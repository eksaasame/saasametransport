/**
 * Autogenerated by Thrift Compiler (0.12.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "physical_packer_service_proxy.h"
#include "thrift/async/TAsyncChannel.h"

namespace saasame { namespace transport {


physical_packer_service_proxy_packer_ping_p_args::~physical_packer_service_proxy_packer_ping_p_args() throw() {
}


uint32_t physical_packer_service_proxy_packer_ping_p_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->addr);
          this->__isset.addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_packer_ping_p_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_packer_ping_p_args");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->addr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_packer_ping_p_pargs::~physical_packer_service_proxy_packer_ping_p_pargs() throw() {
}


uint32_t physical_packer_service_proxy_packer_ping_p_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_packer_ping_p_pargs");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->session_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->addr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_packer_ping_p_result::~physical_packer_service_proxy_packer_ping_p_result() throw() {
}


uint32_t physical_packer_service_proxy_packer_ping_p_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_packer_ping_p_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("physical_packer_service_proxy_packer_ping_p_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_packer_ping_p_presult::~physical_packer_service_proxy_packer_ping_p_presult() throw() {
}


uint32_t physical_packer_service_proxy_packer_ping_p_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_packer_ping_p_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_packer_ping_p_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
  xfer += (*(this->success)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_take_snapshots_p_args::~physical_packer_service_proxy_take_snapshots_p_args() throw() {
}


uint32_t physical_packer_service_proxy_take_snapshots_p_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->addr);
          this->__isset.addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->disks.clear();
            uint32_t _size1466;
            ::apache::thrift::protocol::TType _etype1469;
            xfer += iprot->readSetBegin(_etype1469, _size1466);
            uint32_t _i1470;
            for (_i1470 = 0; _i1470 < _size1466; ++_i1470)
            {
              std::string _elem1471;
              xfer += iprot->readString(_elem1471);
              this->disks.insert(_elem1471);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.disks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_take_snapshots_p_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_take_snapshots_p_args");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->addr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("disks", ::apache::thrift::protocol::T_SET, 3);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->disks.size()));
    std::set<std::string> ::const_iterator _iter1472;
    for (_iter1472 = this->disks.begin(); _iter1472 != this->disks.end(); ++_iter1472)
    {
      xfer += oprot->writeString((*_iter1472));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_take_snapshots_p_pargs::~physical_packer_service_proxy_take_snapshots_p_pargs() throw() {
}


uint32_t physical_packer_service_proxy_take_snapshots_p_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_take_snapshots_p_pargs");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->session_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->addr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("disks", ::apache::thrift::protocol::T_SET, 3);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->disks)).size()));
    std::set<std::string> ::const_iterator _iter1473;
    for (_iter1473 = (*(this->disks)).begin(); _iter1473 != (*(this->disks)).end(); ++_iter1473)
    {
      xfer += oprot->writeString((*_iter1473));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_take_snapshots_p_result::~physical_packer_service_proxy_take_snapshots_p_result() throw() {
}


uint32_t physical_packer_service_proxy_take_snapshots_p_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size1474;
            ::apache::thrift::protocol::TType _etype1477;
            xfer += iprot->readListBegin(_etype1477, _size1474);
            this->success.resize(_size1474);
            uint32_t _i1478;
            for (_i1478 = 0; _i1478 < _size1474; ++_i1478)
            {
              xfer += this->success[_i1478].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_take_snapshots_p_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("physical_packer_service_proxy_take_snapshots_p_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector<snapshot> ::const_iterator _iter1479;
      for (_iter1479 = this->success.begin(); _iter1479 != this->success.end(); ++_iter1479)
      {
        xfer += (*_iter1479).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_take_snapshots_p_presult::~physical_packer_service_proxy_take_snapshots_p_presult() throw() {
}


uint32_t physical_packer_service_proxy_take_snapshots_p_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size1480;
            ::apache::thrift::protocol::TType _etype1483;
            xfer += iprot->readListBegin(_etype1483, _size1480);
            (*(this->success)).resize(_size1480);
            uint32_t _i1484;
            for (_i1484 = 0; _i1484 < _size1480; ++_i1484)
            {
              xfer += (*(this->success))[_i1484].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_take_snapshots_p_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_take_snapshots_p_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->success)).size()));
    std::vector<snapshot> ::const_iterator _iter1485;
    for (_iter1485 = (*(this->success)).begin(); _iter1485 != (*(this->success)).end(); ++_iter1485)
    {
      xfer += (*_iter1485).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_take_snapshots_ex_p_args::~physical_packer_service_proxy_take_snapshots_ex_p_args() throw() {
}


uint32_t physical_packer_service_proxy_take_snapshots_ex_p_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->addr);
          this->__isset.addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->disks.clear();
            uint32_t _size1486;
            ::apache::thrift::protocol::TType _etype1489;
            xfer += iprot->readSetBegin(_etype1489, _size1486);
            uint32_t _i1490;
            for (_i1490 = 0; _i1490 < _size1486; ++_i1490)
            {
              std::string _elem1491;
              xfer += iprot->readString(_elem1491);
              this->disks.insert(_elem1491);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.disks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pre_script);
          this->__isset.pre_script = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->post_script);
          this->__isset.post_script = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_take_snapshots_ex_p_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_take_snapshots_ex_p_args");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->addr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("disks", ::apache::thrift::protocol::T_SET, 3);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->disks.size()));
    std::set<std::string> ::const_iterator _iter1492;
    for (_iter1492 = this->disks.begin(); _iter1492 != this->disks.end(); ++_iter1492)
    {
      xfer += oprot->writeString((*_iter1492));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pre_script", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->pre_script);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("post_script", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->post_script);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_take_snapshots_ex_p_pargs::~physical_packer_service_proxy_take_snapshots_ex_p_pargs() throw() {
}


uint32_t physical_packer_service_proxy_take_snapshots_ex_p_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_take_snapshots_ex_p_pargs");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->session_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->addr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("disks", ::apache::thrift::protocol::T_SET, 3);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->disks)).size()));
    std::set<std::string> ::const_iterator _iter1493;
    for (_iter1493 = (*(this->disks)).begin(); _iter1493 != (*(this->disks)).end(); ++_iter1493)
    {
      xfer += oprot->writeString((*_iter1493));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pre_script", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->pre_script)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("post_script", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString((*(this->post_script)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_take_snapshots_ex_p_result::~physical_packer_service_proxy_take_snapshots_ex_p_result() throw() {
}


uint32_t physical_packer_service_proxy_take_snapshots_ex_p_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size1494;
            ::apache::thrift::protocol::TType _etype1497;
            xfer += iprot->readListBegin(_etype1497, _size1494);
            this->success.resize(_size1494);
            uint32_t _i1498;
            for (_i1498 = 0; _i1498 < _size1494; ++_i1498)
            {
              xfer += this->success[_i1498].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_take_snapshots_ex_p_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("physical_packer_service_proxy_take_snapshots_ex_p_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector<snapshot> ::const_iterator _iter1499;
      for (_iter1499 = this->success.begin(); _iter1499 != this->success.end(); ++_iter1499)
      {
        xfer += (*_iter1499).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_take_snapshots_ex_p_presult::~physical_packer_service_proxy_take_snapshots_ex_p_presult() throw() {
}


uint32_t physical_packer_service_proxy_take_snapshots_ex_p_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size1500;
            ::apache::thrift::protocol::TType _etype1503;
            xfer += iprot->readListBegin(_etype1503, _size1500);
            (*(this->success)).resize(_size1500);
            uint32_t _i1504;
            for (_i1504 = 0; _i1504 < _size1500; ++_i1504)
            {
              xfer += (*(this->success))[_i1504].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_take_snapshots_ex_p_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_take_snapshots_ex_p_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->success)).size()));
    std::vector<snapshot> ::const_iterator _iter1505;
    for (_iter1505 = (*(this->success)).begin(); _iter1505 != (*(this->success)).end(); ++_iter1505)
    {
      xfer += (*_iter1505).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_take_snapshots2_p_args::~physical_packer_service_proxy_take_snapshots2_p_args() throw() {
}


uint32_t physical_packer_service_proxy_take_snapshots2_p_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->addr);
          this->__isset.addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->parameters.read(iprot);
          this->__isset.parameters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_take_snapshots2_p_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_take_snapshots2_p_args");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->addr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parameters", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->parameters.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_take_snapshots2_p_pargs::~physical_packer_service_proxy_take_snapshots2_p_pargs() throw() {
}


uint32_t physical_packer_service_proxy_take_snapshots2_p_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_take_snapshots2_p_pargs");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->session_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->addr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parameters", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->parameters)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_take_snapshots2_p_result::~physical_packer_service_proxy_take_snapshots2_p_result() throw() {
}


uint32_t physical_packer_service_proxy_take_snapshots2_p_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size1506;
            ::apache::thrift::protocol::TType _etype1509;
            xfer += iprot->readListBegin(_etype1509, _size1506);
            this->success.resize(_size1506);
            uint32_t _i1510;
            for (_i1510 = 0; _i1510 < _size1506; ++_i1510)
            {
              xfer += this->success[_i1510].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_take_snapshots2_p_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("physical_packer_service_proxy_take_snapshots2_p_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector<snapshot> ::const_iterator _iter1511;
      for (_iter1511 = this->success.begin(); _iter1511 != this->success.end(); ++_iter1511)
      {
        xfer += (*_iter1511).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_take_snapshots2_p_presult::~physical_packer_service_proxy_take_snapshots2_p_presult() throw() {
}


uint32_t physical_packer_service_proxy_take_snapshots2_p_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size1512;
            ::apache::thrift::protocol::TType _etype1515;
            xfer += iprot->readListBegin(_etype1515, _size1512);
            (*(this->success)).resize(_size1512);
            uint32_t _i1516;
            for (_i1516 = 0; _i1516 < _size1512; ++_i1516)
            {
              xfer += (*(this->success))[_i1516].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_take_snapshots2_p_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_take_snapshots2_p_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->success)).size()));
    std::vector<snapshot> ::const_iterator _iter1517;
    for (_iter1517 = (*(this->success)).begin(); _iter1517 != (*(this->success)).end(); ++_iter1517)
    {
      xfer += (*_iter1517).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_delete_snapshot_p_args::~physical_packer_service_proxy_delete_snapshot_p_args() throw() {
}


uint32_t physical_packer_service_proxy_delete_snapshot_p_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->addr);
          this->__isset.addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->snapshot_id);
          this->__isset.snapshot_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_delete_snapshot_p_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_delete_snapshot_p_args");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->addr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("snapshot_id", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->snapshot_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_delete_snapshot_p_pargs::~physical_packer_service_proxy_delete_snapshot_p_pargs() throw() {
}


uint32_t physical_packer_service_proxy_delete_snapshot_p_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_delete_snapshot_p_pargs");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->session_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->addr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("snapshot_id", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->snapshot_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_delete_snapshot_p_result::~physical_packer_service_proxy_delete_snapshot_p_result() throw() {
}


uint32_t physical_packer_service_proxy_delete_snapshot_p_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_delete_snapshot_p_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("physical_packer_service_proxy_delete_snapshot_p_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_delete_snapshot_p_presult::~physical_packer_service_proxy_delete_snapshot_p_presult() throw() {
}


uint32_t physical_packer_service_proxy_delete_snapshot_p_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_delete_snapshot_p_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_delete_snapshot_p_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
  xfer += (*(this->success)).write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_delete_snapshot_set_p_args::~physical_packer_service_proxy_delete_snapshot_set_p_args() throw() {
}


uint32_t physical_packer_service_proxy_delete_snapshot_set_p_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->addr);
          this->__isset.addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->snapshot_set_id);
          this->__isset.snapshot_set_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_delete_snapshot_set_p_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_delete_snapshot_set_p_args");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->addr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("snapshot_set_id", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->snapshot_set_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_delete_snapshot_set_p_pargs::~physical_packer_service_proxy_delete_snapshot_set_p_pargs() throw() {
}


uint32_t physical_packer_service_proxy_delete_snapshot_set_p_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_delete_snapshot_set_p_pargs");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->session_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->addr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("snapshot_set_id", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->snapshot_set_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_delete_snapshot_set_p_result::~physical_packer_service_proxy_delete_snapshot_set_p_result() throw() {
}


uint32_t physical_packer_service_proxy_delete_snapshot_set_p_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_delete_snapshot_set_p_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("physical_packer_service_proxy_delete_snapshot_set_p_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_delete_snapshot_set_p_presult::~physical_packer_service_proxy_delete_snapshot_set_p_presult() throw() {
}


uint32_t physical_packer_service_proxy_delete_snapshot_set_p_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_delete_snapshot_set_p_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_delete_snapshot_set_p_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
  xfer += (*(this->success)).write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_get_all_snapshots_p_args::~physical_packer_service_proxy_get_all_snapshots_p_args() throw() {
}


uint32_t physical_packer_service_proxy_get_all_snapshots_p_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->addr);
          this->__isset.addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_get_all_snapshots_p_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_get_all_snapshots_p_args");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->addr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_get_all_snapshots_p_pargs::~physical_packer_service_proxy_get_all_snapshots_p_pargs() throw() {
}


uint32_t physical_packer_service_proxy_get_all_snapshots_p_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_get_all_snapshots_p_pargs");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->session_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->addr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_get_all_snapshots_p_result::~physical_packer_service_proxy_get_all_snapshots_p_result() throw() {
}


uint32_t physical_packer_service_proxy_get_all_snapshots_p_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->success.clear();
            uint32_t _size1518;
            ::apache::thrift::protocol::TType _ktype1519;
            ::apache::thrift::protocol::TType _vtype1520;
            xfer += iprot->readMapBegin(_ktype1519, _vtype1520, _size1518);
            uint32_t _i1522;
            for (_i1522 = 0; _i1522 < _size1518; ++_i1522)
            {
              std::string _key1523;
              xfer += iprot->readString(_key1523);
              std::vector<snapshot> & _val1524 = this->success[_key1523];
              {
                _val1524.clear();
                uint32_t _size1525;
                ::apache::thrift::protocol::TType _etype1528;
                xfer += iprot->readListBegin(_etype1528, _size1525);
                _val1524.resize(_size1525);
                uint32_t _i1529;
                for (_i1529 = 0; _i1529 < _size1525; ++_i1529)
                {
                  xfer += _val1524[_i1529].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_get_all_snapshots_p_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("physical_packer_service_proxy_get_all_snapshots_p_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->success.size()));
      std::map<std::string, std::vector<snapshot> > ::const_iterator _iter1530;
      for (_iter1530 = this->success.begin(); _iter1530 != this->success.end(); ++_iter1530)
      {
        xfer += oprot->writeString(_iter1530->first);
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter1530->second.size()));
          std::vector<snapshot> ::const_iterator _iter1531;
          for (_iter1531 = _iter1530->second.begin(); _iter1531 != _iter1530->second.end(); ++_iter1531)
          {
            xfer += (*_iter1531).write(oprot);
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_get_all_snapshots_p_presult::~physical_packer_service_proxy_get_all_snapshots_p_presult() throw() {
}


uint32_t physical_packer_service_proxy_get_all_snapshots_p_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            (*(this->success)).clear();
            uint32_t _size1532;
            ::apache::thrift::protocol::TType _ktype1533;
            ::apache::thrift::protocol::TType _vtype1534;
            xfer += iprot->readMapBegin(_ktype1533, _vtype1534, _size1532);
            uint32_t _i1536;
            for (_i1536 = 0; _i1536 < _size1532; ++_i1536)
            {
              std::string _key1537;
              xfer += iprot->readString(_key1537);
              std::vector<snapshot> & _val1538 = (*(this->success))[_key1537];
              {
                _val1538.clear();
                uint32_t _size1539;
                ::apache::thrift::protocol::TType _etype1542;
                xfer += iprot->readListBegin(_etype1542, _size1539);
                _val1538.resize(_size1539);
                uint32_t _i1543;
                for (_i1543 = 0; _i1543 < _size1539; ++_i1543)
                {
                  xfer += _val1538[_i1543].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_get_all_snapshots_p_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_get_all_snapshots_p_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>((*(this->success)).size()));
    std::map<std::string, std::vector<snapshot> > ::const_iterator _iter1544;
    for (_iter1544 = (*(this->success)).begin(); _iter1544 != (*(this->success)).end(); ++_iter1544)
    {
      xfer += oprot->writeString(_iter1544->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter1544->second.size()));
        std::vector<snapshot> ::const_iterator _iter1545;
        for (_iter1545 = _iter1544->second.begin(); _iter1545 != _iter1544->second.end(); ++_iter1545)
        {
          xfer += (*_iter1545).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_create_packer_job_ex_p_args::~physical_packer_service_proxy_create_packer_job_ex_p_args() throw() {
}


uint32_t physical_packer_service_proxy_create_packer_job_ex_p_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->addr);
          this->__isset.addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->job_id);
          this->__isset.job_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->create_job.read(iprot);
          this->__isset.create_job = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_create_packer_job_ex_p_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_create_packer_job_ex_p_args");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->addr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("job_id", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->job_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("create_job", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->create_job.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_create_packer_job_ex_p_pargs::~physical_packer_service_proxy_create_packer_job_ex_p_pargs() throw() {
}


uint32_t physical_packer_service_proxy_create_packer_job_ex_p_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_create_packer_job_ex_p_pargs");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->session_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->addr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("job_id", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->job_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("create_job", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += (*(this->create_job)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_create_packer_job_ex_p_result::~physical_packer_service_proxy_create_packer_job_ex_p_result() throw() {
}


uint32_t physical_packer_service_proxy_create_packer_job_ex_p_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_create_packer_job_ex_p_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("physical_packer_service_proxy_create_packer_job_ex_p_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_create_packer_job_ex_p_presult::~physical_packer_service_proxy_create_packer_job_ex_p_presult() throw() {
}


uint32_t physical_packer_service_proxy_create_packer_job_ex_p_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_create_packer_job_ex_p_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_create_packer_job_ex_p_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
  xfer += (*(this->success)).write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_get_packer_job_p_args::~physical_packer_service_proxy_get_packer_job_p_args() throw() {
}


uint32_t physical_packer_service_proxy_get_packer_job_p_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->addr);
          this->__isset.addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->job_id);
          this->__isset.job_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->previous_updated_time);
          this->__isset.previous_updated_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_get_packer_job_p_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_get_packer_job_p_args");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->addr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("job_id", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->job_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("previous_updated_time", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->previous_updated_time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_get_packer_job_p_pargs::~physical_packer_service_proxy_get_packer_job_p_pargs() throw() {
}


uint32_t physical_packer_service_proxy_get_packer_job_p_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_get_packer_job_p_pargs");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->session_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->addr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("job_id", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->job_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("previous_updated_time", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->previous_updated_time)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_get_packer_job_p_result::~physical_packer_service_proxy_get_packer_job_p_result() throw() {
}


uint32_t physical_packer_service_proxy_get_packer_job_p_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_get_packer_job_p_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("physical_packer_service_proxy_get_packer_job_p_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_get_packer_job_p_presult::~physical_packer_service_proxy_get_packer_job_p_presult() throw() {
}


uint32_t physical_packer_service_proxy_get_packer_job_p_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_get_packer_job_p_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_get_packer_job_p_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
  xfer += (*(this->success)).write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_interrupt_packer_job_p_args::~physical_packer_service_proxy_interrupt_packer_job_p_args() throw() {
}


uint32_t physical_packer_service_proxy_interrupt_packer_job_p_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->addr);
          this->__isset.addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->job_id);
          this->__isset.job_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_interrupt_packer_job_p_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_interrupt_packer_job_p_args");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->addr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("job_id", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->job_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_interrupt_packer_job_p_pargs::~physical_packer_service_proxy_interrupt_packer_job_p_pargs() throw() {
}


uint32_t physical_packer_service_proxy_interrupt_packer_job_p_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_interrupt_packer_job_p_pargs");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->session_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->addr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("job_id", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->job_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_interrupt_packer_job_p_result::~physical_packer_service_proxy_interrupt_packer_job_p_result() throw() {
}


uint32_t physical_packer_service_proxy_interrupt_packer_job_p_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_interrupt_packer_job_p_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("physical_packer_service_proxy_interrupt_packer_job_p_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_interrupt_packer_job_p_presult::~physical_packer_service_proxy_interrupt_packer_job_p_presult() throw() {
}


uint32_t physical_packer_service_proxy_interrupt_packer_job_p_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_interrupt_packer_job_p_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_interrupt_packer_job_p_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
  xfer += oprot->writeBool((*(this->success)));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_resume_packer_job_p_args::~physical_packer_service_proxy_resume_packer_job_p_args() throw() {
}


uint32_t physical_packer_service_proxy_resume_packer_job_p_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->addr);
          this->__isset.addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->job_id);
          this->__isset.job_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_resume_packer_job_p_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_resume_packer_job_p_args");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->addr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("job_id", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->job_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_resume_packer_job_p_pargs::~physical_packer_service_proxy_resume_packer_job_p_pargs() throw() {
}


uint32_t physical_packer_service_proxy_resume_packer_job_p_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_resume_packer_job_p_pargs");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->session_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->addr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("job_id", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->job_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_resume_packer_job_p_result::~physical_packer_service_proxy_resume_packer_job_p_result() throw() {
}


uint32_t physical_packer_service_proxy_resume_packer_job_p_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_resume_packer_job_p_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("physical_packer_service_proxy_resume_packer_job_p_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_resume_packer_job_p_presult::~physical_packer_service_proxy_resume_packer_job_p_presult() throw() {
}


uint32_t physical_packer_service_proxy_resume_packer_job_p_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_resume_packer_job_p_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_resume_packer_job_p_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
  xfer += oprot->writeBool((*(this->success)));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_remove_packer_job_p_args::~physical_packer_service_proxy_remove_packer_job_p_args() throw() {
}


uint32_t physical_packer_service_proxy_remove_packer_job_p_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->addr);
          this->__isset.addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->job_id);
          this->__isset.job_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_remove_packer_job_p_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_remove_packer_job_p_args");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->addr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("job_id", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->job_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_remove_packer_job_p_pargs::~physical_packer_service_proxy_remove_packer_job_p_pargs() throw() {
}


uint32_t physical_packer_service_proxy_remove_packer_job_p_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_remove_packer_job_p_pargs");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->session_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->addr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("job_id", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->job_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_remove_packer_job_p_result::~physical_packer_service_proxy_remove_packer_job_p_result() throw() {
}


uint32_t physical_packer_service_proxy_remove_packer_job_p_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_remove_packer_job_p_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("physical_packer_service_proxy_remove_packer_job_p_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_remove_packer_job_p_presult::~physical_packer_service_proxy_remove_packer_job_p_presult() throw() {
}


uint32_t physical_packer_service_proxy_remove_packer_job_p_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_remove_packer_job_p_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_remove_packer_job_p_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
  xfer += oprot->writeBool((*(this->success)));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_running_packer_job_p_args::~physical_packer_service_proxy_running_packer_job_p_args() throw() {
}


uint32_t physical_packer_service_proxy_running_packer_job_p_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->addr);
          this->__isset.addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->job_id);
          this->__isset.job_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_running_packer_job_p_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_running_packer_job_p_args");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->addr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("job_id", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->job_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_running_packer_job_p_pargs::~physical_packer_service_proxy_running_packer_job_p_pargs() throw() {
}


uint32_t physical_packer_service_proxy_running_packer_job_p_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_running_packer_job_p_pargs");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->session_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->addr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("job_id", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->job_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_running_packer_job_p_result::~physical_packer_service_proxy_running_packer_job_p_result() throw() {
}


uint32_t physical_packer_service_proxy_running_packer_job_p_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_running_packer_job_p_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("physical_packer_service_proxy_running_packer_job_p_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_running_packer_job_p_presult::~physical_packer_service_proxy_running_packer_job_p_presult() throw() {
}


uint32_t physical_packer_service_proxy_running_packer_job_p_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_running_packer_job_p_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_running_packer_job_p_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
  xfer += oprot->writeBool((*(this->success)));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_enumerate_packer_disks_p_args::~physical_packer_service_proxy_enumerate_packer_disks_p_args() throw() {
}


uint32_t physical_packer_service_proxy_enumerate_packer_disks_p_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->addr);
          this->__isset.addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1546;
          xfer += iprot->readI32(ecast1546);
          this->filter = (enumerate_disk_filter_style::type)ecast1546;
          this->__isset.filter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_enumerate_packer_disks_p_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_enumerate_packer_disks_p_args");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->addr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("filter", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->filter);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_enumerate_packer_disks_p_pargs::~physical_packer_service_proxy_enumerate_packer_disks_p_pargs() throw() {
}


uint32_t physical_packer_service_proxy_enumerate_packer_disks_p_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_enumerate_packer_disks_p_pargs");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->session_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->addr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("filter", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)(*(this->filter)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_enumerate_packer_disks_p_result::~physical_packer_service_proxy_enumerate_packer_disks_p_result() throw() {
}


uint32_t physical_packer_service_proxy_enumerate_packer_disks_p_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->success.clear();
            uint32_t _size1547;
            ::apache::thrift::protocol::TType _etype1550;
            xfer += iprot->readSetBegin(_etype1550, _size1547);
            uint32_t _i1551;
            for (_i1551 = 0; _i1551 < _size1547; ++_i1551)
            {
              disk_info _elem1552;
              xfer += _elem1552.read(iprot);
              this->success.insert(_elem1552);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_enumerate_packer_disks_p_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("physical_packer_service_proxy_enumerate_packer_disks_p_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_SET, 0);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::set<disk_info> ::const_iterator _iter1553;
      for (_iter1553 = this->success.begin(); _iter1553 != this->success.end(); ++_iter1553)
      {
        xfer += (*_iter1553).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_enumerate_packer_disks_p_presult::~physical_packer_service_proxy_enumerate_packer_disks_p_presult() throw() {
}


uint32_t physical_packer_service_proxy_enumerate_packer_disks_p_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            (*(this->success)).clear();
            uint32_t _size1554;
            ::apache::thrift::protocol::TType _etype1557;
            xfer += iprot->readSetBegin(_etype1557, _size1554);
            uint32_t _i1558;
            for (_i1558 = 0; _i1558 < _size1554; ++_i1558)
            {
              disk_info _elem1559;
              xfer += _elem1559.read(iprot);
              (*(this->success)).insert(_elem1559);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_enumerate_packer_disks_p_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_enumerate_packer_disks_p_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_SET, 0);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->success)).size()));
    std::set<disk_info> ::const_iterator _iter1560;
    for (_iter1560 = (*(this->success)).begin(); _iter1560 != (*(this->success)).end(); ++_iter1560)
    {
      xfer += (*_iter1560).write(oprot);
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_verify_packer_carrier_p_args::~physical_packer_service_proxy_verify_packer_carrier_p_args() throw() {
}


uint32_t physical_packer_service_proxy_verify_packer_carrier_p_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->addr);
          this->__isset.addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->carrier);
          this->__isset.carrier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_ssl);
          this->__isset.is_ssl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_verify_packer_carrier_p_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_verify_packer_carrier_p_args");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->addr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("carrier", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->carrier);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_ssl", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->is_ssl);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_verify_packer_carrier_p_pargs::~physical_packer_service_proxy_verify_packer_carrier_p_pargs() throw() {
}


uint32_t physical_packer_service_proxy_verify_packer_carrier_p_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_verify_packer_carrier_p_pargs");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->session_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->addr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("carrier", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->carrier)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_ssl", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool((*(this->is_ssl)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_verify_packer_carrier_p_result::~physical_packer_service_proxy_verify_packer_carrier_p_result() throw() {
}


uint32_t physical_packer_service_proxy_verify_packer_carrier_p_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_verify_packer_carrier_p_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("physical_packer_service_proxy_verify_packer_carrier_p_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_verify_packer_carrier_p_presult::~physical_packer_service_proxy_verify_packer_carrier_p_presult() throw() {
}


uint32_t physical_packer_service_proxy_verify_packer_carrier_p_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_verify_packer_carrier_p_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_verify_packer_carrier_p_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
  xfer += oprot->writeBool((*(this->success)));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_get_packer_host_detail_p_args::~physical_packer_service_proxy_get_packer_host_detail_p_args() throw() {
}


uint32_t physical_packer_service_proxy_get_packer_host_detail_p_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->addr);
          this->__isset.addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1561;
          xfer += iprot->readI32(ecast1561);
          this->filter = (machine_detail_filter::type)ecast1561;
          this->__isset.filter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_get_packer_host_detail_p_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_get_packer_host_detail_p_args");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->addr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("filter", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->filter);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_get_packer_host_detail_p_pargs::~physical_packer_service_proxy_get_packer_host_detail_p_pargs() throw() {
}


uint32_t physical_packer_service_proxy_get_packer_host_detail_p_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_get_packer_host_detail_p_pargs");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->session_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->addr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("filter", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)(*(this->filter)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_get_packer_host_detail_p_result::~physical_packer_service_proxy_get_packer_host_detail_p_result() throw() {
}


uint32_t physical_packer_service_proxy_get_packer_host_detail_p_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_get_packer_host_detail_p_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("physical_packer_service_proxy_get_packer_host_detail_p_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_get_packer_host_detail_p_presult::~physical_packer_service_proxy_get_packer_host_detail_p_presult() throw() {
}


uint32_t physical_packer_service_proxy_get_packer_host_detail_p_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_get_packer_host_detail_p_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_get_packer_host_detail_p_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
  xfer += (*(this->success)).write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void physical_packer_service_proxyClient::packer_ping_p(service_info& _return, const std::string& session_id, const std::string& addr)
{
  send_packer_ping_p(session_id, addr);
  recv_packer_ping_p(_return);
}

void physical_packer_service_proxyClient::send_packer_ping_p(const std::string& session_id, const std::string& addr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("packer_ping_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_packer_ping_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyClient::recv_packer_ping_p(service_info& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("packer_ping_p") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  physical_packer_service_proxy_packer_ping_p_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "packer_ping_p failed: unknown result");
}

void physical_packer_service_proxyClient::take_snapshots_p(std::vector<snapshot> & _return, const std::string& session_id, const std::string& addr, const std::set<std::string> & disks)
{
  send_take_snapshots_p(session_id, addr, disks);
  recv_take_snapshots_p(_return);
}

void physical_packer_service_proxyClient::send_take_snapshots_p(const std::string& session_id, const std::string& addr, const std::set<std::string> & disks)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("take_snapshots_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_take_snapshots_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.disks = &disks;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyClient::recv_take_snapshots_p(std::vector<snapshot> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("take_snapshots_p") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  physical_packer_service_proxy_take_snapshots_p_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.ouch) {
    throw result.ouch;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "take_snapshots_p failed: unknown result");
}

void physical_packer_service_proxyClient::take_snapshots_ex_p(std::vector<snapshot> & _return, const std::string& session_id, const std::string& addr, const std::set<std::string> & disks, const std::string& pre_script, const std::string& post_script)
{
  send_take_snapshots_ex_p(session_id, addr, disks, pre_script, post_script);
  recv_take_snapshots_ex_p(_return);
}

void physical_packer_service_proxyClient::send_take_snapshots_ex_p(const std::string& session_id, const std::string& addr, const std::set<std::string> & disks, const std::string& pre_script, const std::string& post_script)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("take_snapshots_ex_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_take_snapshots_ex_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.disks = &disks;
  args.pre_script = &pre_script;
  args.post_script = &post_script;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyClient::recv_take_snapshots_ex_p(std::vector<snapshot> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("take_snapshots_ex_p") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  physical_packer_service_proxy_take_snapshots_ex_p_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.ouch) {
    throw result.ouch;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "take_snapshots_ex_p failed: unknown result");
}

void physical_packer_service_proxyClient::take_snapshots2_p(std::vector<snapshot> & _return, const std::string& session_id, const std::string& addr, const take_snapshots_parameters& parameters)
{
  send_take_snapshots2_p(session_id, addr, parameters);
  recv_take_snapshots2_p(_return);
}

void physical_packer_service_proxyClient::send_take_snapshots2_p(const std::string& session_id, const std::string& addr, const take_snapshots_parameters& parameters)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("take_snapshots2_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_take_snapshots2_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.parameters = &parameters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyClient::recv_take_snapshots2_p(std::vector<snapshot> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("take_snapshots2_p") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  physical_packer_service_proxy_take_snapshots2_p_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.ouch) {
    throw result.ouch;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "take_snapshots2_p failed: unknown result");
}

void physical_packer_service_proxyClient::delete_snapshot_p(delete_snapshot_result& _return, const std::string& session_id, const std::string& addr, const std::string& snapshot_id)
{
  send_delete_snapshot_p(session_id, addr, snapshot_id);
  recv_delete_snapshot_p(_return);
}

void physical_packer_service_proxyClient::send_delete_snapshot_p(const std::string& session_id, const std::string& addr, const std::string& snapshot_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("delete_snapshot_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_delete_snapshot_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.snapshot_id = &snapshot_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyClient::recv_delete_snapshot_p(delete_snapshot_result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("delete_snapshot_p") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  physical_packer_service_proxy_delete_snapshot_p_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.ouch) {
    throw result.ouch;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "delete_snapshot_p failed: unknown result");
}

void physical_packer_service_proxyClient::delete_snapshot_set_p(delete_snapshot_result& _return, const std::string& session_id, const std::string& addr, const std::string& snapshot_set_id)
{
  send_delete_snapshot_set_p(session_id, addr, snapshot_set_id);
  recv_delete_snapshot_set_p(_return);
}

void physical_packer_service_proxyClient::send_delete_snapshot_set_p(const std::string& session_id, const std::string& addr, const std::string& snapshot_set_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("delete_snapshot_set_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_delete_snapshot_set_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.snapshot_set_id = &snapshot_set_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyClient::recv_delete_snapshot_set_p(delete_snapshot_result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("delete_snapshot_set_p") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  physical_packer_service_proxy_delete_snapshot_set_p_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.ouch) {
    throw result.ouch;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "delete_snapshot_set_p failed: unknown result");
}

void physical_packer_service_proxyClient::get_all_snapshots_p(std::map<std::string, std::vector<snapshot> > & _return, const std::string& session_id, const std::string& addr)
{
  send_get_all_snapshots_p(session_id, addr);
  recv_get_all_snapshots_p(_return);
}

void physical_packer_service_proxyClient::send_get_all_snapshots_p(const std::string& session_id, const std::string& addr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("get_all_snapshots_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_get_all_snapshots_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyClient::recv_get_all_snapshots_p(std::map<std::string, std::vector<snapshot> > & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("get_all_snapshots_p") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  physical_packer_service_proxy_get_all_snapshots_p_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.ouch) {
    throw result.ouch;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_all_snapshots_p failed: unknown result");
}

void physical_packer_service_proxyClient::create_packer_job_ex_p(packer_job_detail& _return, const std::string& session_id, const std::string& addr, const std::string& job_id, const create_packer_job_detail& create_job)
{
  send_create_packer_job_ex_p(session_id, addr, job_id, create_job);
  recv_create_packer_job_ex_p(_return);
}

void physical_packer_service_proxyClient::send_create_packer_job_ex_p(const std::string& session_id, const std::string& addr, const std::string& job_id, const create_packer_job_detail& create_job)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("create_packer_job_ex_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_create_packer_job_ex_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.job_id = &job_id;
  args.create_job = &create_job;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyClient::recv_create_packer_job_ex_p(packer_job_detail& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("create_packer_job_ex_p") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  physical_packer_service_proxy_create_packer_job_ex_p_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.ouch) {
    throw result.ouch;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "create_packer_job_ex_p failed: unknown result");
}

void physical_packer_service_proxyClient::get_packer_job_p(packer_job_detail& _return, const std::string& session_id, const std::string& addr, const std::string& job_id, const std::string& previous_updated_time)
{
  send_get_packer_job_p(session_id, addr, job_id, previous_updated_time);
  recv_get_packer_job_p(_return);
}

void physical_packer_service_proxyClient::send_get_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id, const std::string& previous_updated_time)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("get_packer_job_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_get_packer_job_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.job_id = &job_id;
  args.previous_updated_time = &previous_updated_time;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyClient::recv_get_packer_job_p(packer_job_detail& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("get_packer_job_p") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  physical_packer_service_proxy_get_packer_job_p_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.ouch) {
    throw result.ouch;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_packer_job_p failed: unknown result");
}

bool physical_packer_service_proxyClient::interrupt_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  send_interrupt_packer_job_p(session_id, addr, job_id);
  return recv_interrupt_packer_job_p();
}

void physical_packer_service_proxyClient::send_interrupt_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("interrupt_packer_job_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_interrupt_packer_job_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.job_id = &job_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool physical_packer_service_proxyClient::recv_interrupt_packer_job_p()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("interrupt_packer_job_p") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  physical_packer_service_proxy_interrupt_packer_job_p_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.ouch) {
    throw result.ouch;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "interrupt_packer_job_p failed: unknown result");
}

bool physical_packer_service_proxyClient::resume_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  send_resume_packer_job_p(session_id, addr, job_id);
  return recv_resume_packer_job_p();
}

void physical_packer_service_proxyClient::send_resume_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("resume_packer_job_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_resume_packer_job_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.job_id = &job_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool physical_packer_service_proxyClient::recv_resume_packer_job_p()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("resume_packer_job_p") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  physical_packer_service_proxy_resume_packer_job_p_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.ouch) {
    throw result.ouch;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "resume_packer_job_p failed: unknown result");
}

bool physical_packer_service_proxyClient::remove_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  send_remove_packer_job_p(session_id, addr, job_id);
  return recv_remove_packer_job_p();
}

void physical_packer_service_proxyClient::send_remove_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("remove_packer_job_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_remove_packer_job_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.job_id = &job_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool physical_packer_service_proxyClient::recv_remove_packer_job_p()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("remove_packer_job_p") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  physical_packer_service_proxy_remove_packer_job_p_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.ouch) {
    throw result.ouch;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "remove_packer_job_p failed: unknown result");
}

bool physical_packer_service_proxyClient::running_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  send_running_packer_job_p(session_id, addr, job_id);
  return recv_running_packer_job_p();
}

void physical_packer_service_proxyClient::send_running_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("running_packer_job_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_running_packer_job_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.job_id = &job_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool physical_packer_service_proxyClient::recv_running_packer_job_p()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("running_packer_job_p") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  physical_packer_service_proxy_running_packer_job_p_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.ouch) {
    throw result.ouch;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "running_packer_job_p failed: unknown result");
}

void physical_packer_service_proxyClient::enumerate_packer_disks_p(std::set<disk_info> & _return, const std::string& session_id, const std::string& addr, const enumerate_disk_filter_style::type filter)
{
  send_enumerate_packer_disks_p(session_id, addr, filter);
  recv_enumerate_packer_disks_p(_return);
}

void physical_packer_service_proxyClient::send_enumerate_packer_disks_p(const std::string& session_id, const std::string& addr, const enumerate_disk_filter_style::type filter)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("enumerate_packer_disks_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_enumerate_packer_disks_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.filter = &filter;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyClient::recv_enumerate_packer_disks_p(std::set<disk_info> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("enumerate_packer_disks_p") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  physical_packer_service_proxy_enumerate_packer_disks_p_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.ouch) {
    throw result.ouch;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "enumerate_packer_disks_p failed: unknown result");
}

bool physical_packer_service_proxyClient::verify_packer_carrier_p(const std::string& session_id, const std::string& addr, const std::string& carrier, const bool is_ssl)
{
  send_verify_packer_carrier_p(session_id, addr, carrier, is_ssl);
  return recv_verify_packer_carrier_p();
}

void physical_packer_service_proxyClient::send_verify_packer_carrier_p(const std::string& session_id, const std::string& addr, const std::string& carrier, const bool is_ssl)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("verify_packer_carrier_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_verify_packer_carrier_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.carrier = &carrier;
  args.is_ssl = &is_ssl;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool physical_packer_service_proxyClient::recv_verify_packer_carrier_p()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("verify_packer_carrier_p") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  physical_packer_service_proxy_verify_packer_carrier_p_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.ouch) {
    throw result.ouch;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "verify_packer_carrier_p failed: unknown result");
}

void physical_packer_service_proxyClient::get_packer_host_detail_p(physical_machine_info& _return, const std::string& session_id, const std::string& addr, const machine_detail_filter::type filter)
{
  send_get_packer_host_detail_p(session_id, addr, filter);
  recv_get_packer_host_detail_p(_return);
}

void physical_packer_service_proxyClient::send_get_packer_host_detail_p(const std::string& session_id, const std::string& addr, const machine_detail_filter::type filter)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("get_packer_host_detail_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_get_packer_host_detail_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.filter = &filter;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyClient::recv_get_packer_host_detail_p(physical_machine_info& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("get_packer_host_detail_p") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  physical_packer_service_proxy_get_packer_host_detail_p_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.ouch) {
    throw result.ouch;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_packer_host_detail_p failed: unknown result");
}

bool physical_packer_service_proxyProcessor::dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext) {
  ProcessMap::iterator pfn;
  pfn = processMap_.find(fname);
  if (pfn == processMap_.end()) {
    return common_serviceProcessor::dispatchCall(iprot, oprot, fname, seqid, callContext);
  }
  (this->*(pfn->second))(seqid, iprot, oprot, callContext);
  return true;
}

void physical_packer_service_proxyProcessor::process_packer_ping_p(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.packer_ping_p", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.packer_ping_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.packer_ping_p");
  }

  physical_packer_service_proxy_packer_ping_p_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.packer_ping_p", bytes);
  }

  physical_packer_service_proxy_packer_ping_p_result result;
  try {
    iface_->packer_ping_p(result.success, args.session_id, args.addr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.packer_ping_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("packer_ping_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.packer_ping_p");
  }

  oprot->writeMessageBegin("packer_ping_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.packer_ping_p", bytes);
  }
}

void physical_packer_service_proxyProcessor::process_take_snapshots_p(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.take_snapshots_p", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.take_snapshots_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.take_snapshots_p");
  }

  physical_packer_service_proxy_take_snapshots_p_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.take_snapshots_p", bytes);
  }

  physical_packer_service_proxy_take_snapshots_p_result result;
  try {
    iface_->take_snapshots_p(result.success, args.session_id, args.addr, args.disks);
    result.__isset.success = true;
  } catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.take_snapshots_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("take_snapshots_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.take_snapshots_p");
  }

  oprot->writeMessageBegin("take_snapshots_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.take_snapshots_p", bytes);
  }
}

void physical_packer_service_proxyProcessor::process_take_snapshots_ex_p(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.take_snapshots_ex_p", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.take_snapshots_ex_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.take_snapshots_ex_p");
  }

  physical_packer_service_proxy_take_snapshots_ex_p_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.take_snapshots_ex_p", bytes);
  }

  physical_packer_service_proxy_take_snapshots_ex_p_result result;
  try {
    iface_->take_snapshots_ex_p(result.success, args.session_id, args.addr, args.disks, args.pre_script, args.post_script);
    result.__isset.success = true;
  } catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.take_snapshots_ex_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("take_snapshots_ex_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.take_snapshots_ex_p");
  }

  oprot->writeMessageBegin("take_snapshots_ex_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.take_snapshots_ex_p", bytes);
  }
}

void physical_packer_service_proxyProcessor::process_take_snapshots2_p(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.take_snapshots2_p", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.take_snapshots2_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.take_snapshots2_p");
  }

  physical_packer_service_proxy_take_snapshots2_p_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.take_snapshots2_p", bytes);
  }

  physical_packer_service_proxy_take_snapshots2_p_result result;
  try {
    iface_->take_snapshots2_p(result.success, args.session_id, args.addr, args.parameters);
    result.__isset.success = true;
  } catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.take_snapshots2_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("take_snapshots2_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.take_snapshots2_p");
  }

  oprot->writeMessageBegin("take_snapshots2_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.take_snapshots2_p", bytes);
  }
}

void physical_packer_service_proxyProcessor::process_delete_snapshot_p(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.delete_snapshot_p", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.delete_snapshot_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.delete_snapshot_p");
  }

  physical_packer_service_proxy_delete_snapshot_p_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.delete_snapshot_p", bytes);
  }

  physical_packer_service_proxy_delete_snapshot_p_result result;
  try {
    iface_->delete_snapshot_p(result.success, args.session_id, args.addr, args.snapshot_id);
    result.__isset.success = true;
  } catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.delete_snapshot_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("delete_snapshot_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.delete_snapshot_p");
  }

  oprot->writeMessageBegin("delete_snapshot_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.delete_snapshot_p", bytes);
  }
}

void physical_packer_service_proxyProcessor::process_delete_snapshot_set_p(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.delete_snapshot_set_p", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.delete_snapshot_set_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.delete_snapshot_set_p");
  }

  physical_packer_service_proxy_delete_snapshot_set_p_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.delete_snapshot_set_p", bytes);
  }

  physical_packer_service_proxy_delete_snapshot_set_p_result result;
  try {
    iface_->delete_snapshot_set_p(result.success, args.session_id, args.addr, args.snapshot_set_id);
    result.__isset.success = true;
  } catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.delete_snapshot_set_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("delete_snapshot_set_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.delete_snapshot_set_p");
  }

  oprot->writeMessageBegin("delete_snapshot_set_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.delete_snapshot_set_p", bytes);
  }
}

void physical_packer_service_proxyProcessor::process_get_all_snapshots_p(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.get_all_snapshots_p", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.get_all_snapshots_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.get_all_snapshots_p");
  }

  physical_packer_service_proxy_get_all_snapshots_p_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.get_all_snapshots_p", bytes);
  }

  physical_packer_service_proxy_get_all_snapshots_p_result result;
  try {
    iface_->get_all_snapshots_p(result.success, args.session_id, args.addr);
    result.__isset.success = true;
  } catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.get_all_snapshots_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("get_all_snapshots_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.get_all_snapshots_p");
  }

  oprot->writeMessageBegin("get_all_snapshots_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.get_all_snapshots_p", bytes);
  }
}

void physical_packer_service_proxyProcessor::process_create_packer_job_ex_p(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.create_packer_job_ex_p", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.create_packer_job_ex_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.create_packer_job_ex_p");
  }

  physical_packer_service_proxy_create_packer_job_ex_p_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.create_packer_job_ex_p", bytes);
  }

  physical_packer_service_proxy_create_packer_job_ex_p_result result;
  try {
    iface_->create_packer_job_ex_p(result.success, args.session_id, args.addr, args.job_id, args.create_job);
    result.__isset.success = true;
  } catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.create_packer_job_ex_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("create_packer_job_ex_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.create_packer_job_ex_p");
  }

  oprot->writeMessageBegin("create_packer_job_ex_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.create_packer_job_ex_p", bytes);
  }
}

void physical_packer_service_proxyProcessor::process_get_packer_job_p(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.get_packer_job_p", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.get_packer_job_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.get_packer_job_p");
  }

  physical_packer_service_proxy_get_packer_job_p_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.get_packer_job_p", bytes);
  }

  physical_packer_service_proxy_get_packer_job_p_result result;
  try {
    iface_->get_packer_job_p(result.success, args.session_id, args.addr, args.job_id, args.previous_updated_time);
    result.__isset.success = true;
  } catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.get_packer_job_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("get_packer_job_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.get_packer_job_p");
  }

  oprot->writeMessageBegin("get_packer_job_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.get_packer_job_p", bytes);
  }
}

void physical_packer_service_proxyProcessor::process_interrupt_packer_job_p(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.interrupt_packer_job_p", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.interrupt_packer_job_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.interrupt_packer_job_p");
  }

  physical_packer_service_proxy_interrupt_packer_job_p_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.interrupt_packer_job_p", bytes);
  }

  physical_packer_service_proxy_interrupt_packer_job_p_result result;
  try {
    result.success = iface_->interrupt_packer_job_p(args.session_id, args.addr, args.job_id);
    result.__isset.success = true;
  } catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.interrupt_packer_job_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("interrupt_packer_job_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.interrupt_packer_job_p");
  }

  oprot->writeMessageBegin("interrupt_packer_job_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.interrupt_packer_job_p", bytes);
  }
}

void physical_packer_service_proxyProcessor::process_resume_packer_job_p(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.resume_packer_job_p", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.resume_packer_job_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.resume_packer_job_p");
  }

  physical_packer_service_proxy_resume_packer_job_p_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.resume_packer_job_p", bytes);
  }

  physical_packer_service_proxy_resume_packer_job_p_result result;
  try {
    result.success = iface_->resume_packer_job_p(args.session_id, args.addr, args.job_id);
    result.__isset.success = true;
  } catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.resume_packer_job_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("resume_packer_job_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.resume_packer_job_p");
  }

  oprot->writeMessageBegin("resume_packer_job_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.resume_packer_job_p", bytes);
  }
}

void physical_packer_service_proxyProcessor::process_remove_packer_job_p(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.remove_packer_job_p", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.remove_packer_job_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.remove_packer_job_p");
  }

  physical_packer_service_proxy_remove_packer_job_p_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.remove_packer_job_p", bytes);
  }

  physical_packer_service_proxy_remove_packer_job_p_result result;
  try {
    result.success = iface_->remove_packer_job_p(args.session_id, args.addr, args.job_id);
    result.__isset.success = true;
  } catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.remove_packer_job_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("remove_packer_job_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.remove_packer_job_p");
  }

  oprot->writeMessageBegin("remove_packer_job_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.remove_packer_job_p", bytes);
  }
}

void physical_packer_service_proxyProcessor::process_running_packer_job_p(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.running_packer_job_p", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.running_packer_job_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.running_packer_job_p");
  }

  physical_packer_service_proxy_running_packer_job_p_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.running_packer_job_p", bytes);
  }

  physical_packer_service_proxy_running_packer_job_p_result result;
  try {
    result.success = iface_->running_packer_job_p(args.session_id, args.addr, args.job_id);
    result.__isset.success = true;
  } catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.running_packer_job_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("running_packer_job_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.running_packer_job_p");
  }

  oprot->writeMessageBegin("running_packer_job_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.running_packer_job_p", bytes);
  }
}

void physical_packer_service_proxyProcessor::process_enumerate_packer_disks_p(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.enumerate_packer_disks_p", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.enumerate_packer_disks_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.enumerate_packer_disks_p");
  }

  physical_packer_service_proxy_enumerate_packer_disks_p_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.enumerate_packer_disks_p", bytes);
  }

  physical_packer_service_proxy_enumerate_packer_disks_p_result result;
  try {
    iface_->enumerate_packer_disks_p(result.success, args.session_id, args.addr, args.filter);
    result.__isset.success = true;
  } catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.enumerate_packer_disks_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("enumerate_packer_disks_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.enumerate_packer_disks_p");
  }

  oprot->writeMessageBegin("enumerate_packer_disks_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.enumerate_packer_disks_p", bytes);
  }
}

void physical_packer_service_proxyProcessor::process_verify_packer_carrier_p(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.verify_packer_carrier_p", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.verify_packer_carrier_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.verify_packer_carrier_p");
  }

  physical_packer_service_proxy_verify_packer_carrier_p_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.verify_packer_carrier_p", bytes);
  }

  physical_packer_service_proxy_verify_packer_carrier_p_result result;
  try {
    result.success = iface_->verify_packer_carrier_p(args.session_id, args.addr, args.carrier, args.is_ssl);
    result.__isset.success = true;
  } catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.verify_packer_carrier_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("verify_packer_carrier_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.verify_packer_carrier_p");
  }

  oprot->writeMessageBegin("verify_packer_carrier_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.verify_packer_carrier_p", bytes);
  }
}

void physical_packer_service_proxyProcessor::process_get_packer_host_detail_p(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.get_packer_host_detail_p", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.get_packer_host_detail_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.get_packer_host_detail_p");
  }

  physical_packer_service_proxy_get_packer_host_detail_p_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.get_packer_host_detail_p", bytes);
  }

  physical_packer_service_proxy_get_packer_host_detail_p_result result;
  try {
    iface_->get_packer_host_detail_p(result.success, args.session_id, args.addr, args.filter);
    result.__isset.success = true;
  } catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.get_packer_host_detail_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("get_packer_host_detail_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.get_packer_host_detail_p");
  }

  oprot->writeMessageBegin("get_packer_host_detail_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.get_packer_host_detail_p", bytes);
  }
}

::apache::thrift::stdcxx::shared_ptr< ::apache::thrift::TProcessor > physical_packer_service_proxyProcessorFactory::getProcessor(const ::apache::thrift::TConnectionInfo& connInfo) {
  ::apache::thrift::ReleaseHandler< physical_packer_service_proxyIfFactory > cleanup(handlerFactory_);
  ::apache::thrift::stdcxx::shared_ptr< physical_packer_service_proxyIf > handler(handlerFactory_->getHandler(connInfo), cleanup);
  ::apache::thrift::stdcxx::shared_ptr< ::apache::thrift::TProcessor > processor(new physical_packer_service_proxyProcessor(handler));
  return processor;
}

void physical_packer_service_proxyConcurrentClient::packer_ping_p(service_info& _return, const std::string& session_id, const std::string& addr)
{
  int32_t seqid = send_packer_ping_p(session_id, addr);
  recv_packer_ping_p(_return, seqid);
}

int32_t physical_packer_service_proxyConcurrentClient::send_packer_ping_p(const std::string& session_id, const std::string& addr)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("packer_ping_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_packer_ping_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void physical_packer_service_proxyConcurrentClient::recv_packer_ping_p(service_info& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("packer_ping_p") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      physical_packer_service_proxy_packer_ping_p_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "packer_ping_p failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void physical_packer_service_proxyConcurrentClient::take_snapshots_p(std::vector<snapshot> & _return, const std::string& session_id, const std::string& addr, const std::set<std::string> & disks)
{
  int32_t seqid = send_take_snapshots_p(session_id, addr, disks);
  recv_take_snapshots_p(_return, seqid);
}

int32_t physical_packer_service_proxyConcurrentClient::send_take_snapshots_p(const std::string& session_id, const std::string& addr, const std::set<std::string> & disks)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("take_snapshots_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_take_snapshots_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.disks = &disks;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void physical_packer_service_proxyConcurrentClient::recv_take_snapshots_p(std::vector<snapshot> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("take_snapshots_p") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      physical_packer_service_proxy_take_snapshots_p_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.ouch) {
        sentry.commit();
        throw result.ouch;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "take_snapshots_p failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void physical_packer_service_proxyConcurrentClient::take_snapshots_ex_p(std::vector<snapshot> & _return, const std::string& session_id, const std::string& addr, const std::set<std::string> & disks, const std::string& pre_script, const std::string& post_script)
{
  int32_t seqid = send_take_snapshots_ex_p(session_id, addr, disks, pre_script, post_script);
  recv_take_snapshots_ex_p(_return, seqid);
}

int32_t physical_packer_service_proxyConcurrentClient::send_take_snapshots_ex_p(const std::string& session_id, const std::string& addr, const std::set<std::string> & disks, const std::string& pre_script, const std::string& post_script)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("take_snapshots_ex_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_take_snapshots_ex_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.disks = &disks;
  args.pre_script = &pre_script;
  args.post_script = &post_script;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void physical_packer_service_proxyConcurrentClient::recv_take_snapshots_ex_p(std::vector<snapshot> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("take_snapshots_ex_p") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      physical_packer_service_proxy_take_snapshots_ex_p_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.ouch) {
        sentry.commit();
        throw result.ouch;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "take_snapshots_ex_p failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void physical_packer_service_proxyConcurrentClient::take_snapshots2_p(std::vector<snapshot> & _return, const std::string& session_id, const std::string& addr, const take_snapshots_parameters& parameters)
{
  int32_t seqid = send_take_snapshots2_p(session_id, addr, parameters);
  recv_take_snapshots2_p(_return, seqid);
}

int32_t physical_packer_service_proxyConcurrentClient::send_take_snapshots2_p(const std::string& session_id, const std::string& addr, const take_snapshots_parameters& parameters)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("take_snapshots2_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_take_snapshots2_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.parameters = &parameters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void physical_packer_service_proxyConcurrentClient::recv_take_snapshots2_p(std::vector<snapshot> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("take_snapshots2_p") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      physical_packer_service_proxy_take_snapshots2_p_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.ouch) {
        sentry.commit();
        throw result.ouch;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "take_snapshots2_p failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void physical_packer_service_proxyConcurrentClient::delete_snapshot_p(delete_snapshot_result& _return, const std::string& session_id, const std::string& addr, const std::string& snapshot_id)
{
  int32_t seqid = send_delete_snapshot_p(session_id, addr, snapshot_id);
  recv_delete_snapshot_p(_return, seqid);
}

int32_t physical_packer_service_proxyConcurrentClient::send_delete_snapshot_p(const std::string& session_id, const std::string& addr, const std::string& snapshot_id)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("delete_snapshot_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_delete_snapshot_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.snapshot_id = &snapshot_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void physical_packer_service_proxyConcurrentClient::recv_delete_snapshot_p(delete_snapshot_result& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("delete_snapshot_p") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      physical_packer_service_proxy_delete_snapshot_p_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.ouch) {
        sentry.commit();
        throw result.ouch;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "delete_snapshot_p failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void physical_packer_service_proxyConcurrentClient::delete_snapshot_set_p(delete_snapshot_result& _return, const std::string& session_id, const std::string& addr, const std::string& snapshot_set_id)
{
  int32_t seqid = send_delete_snapshot_set_p(session_id, addr, snapshot_set_id);
  recv_delete_snapshot_set_p(_return, seqid);
}

int32_t physical_packer_service_proxyConcurrentClient::send_delete_snapshot_set_p(const std::string& session_id, const std::string& addr, const std::string& snapshot_set_id)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("delete_snapshot_set_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_delete_snapshot_set_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.snapshot_set_id = &snapshot_set_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void physical_packer_service_proxyConcurrentClient::recv_delete_snapshot_set_p(delete_snapshot_result& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("delete_snapshot_set_p") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      physical_packer_service_proxy_delete_snapshot_set_p_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.ouch) {
        sentry.commit();
        throw result.ouch;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "delete_snapshot_set_p failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void physical_packer_service_proxyConcurrentClient::get_all_snapshots_p(std::map<std::string, std::vector<snapshot> > & _return, const std::string& session_id, const std::string& addr)
{
  int32_t seqid = send_get_all_snapshots_p(session_id, addr);
  recv_get_all_snapshots_p(_return, seqid);
}

int32_t physical_packer_service_proxyConcurrentClient::send_get_all_snapshots_p(const std::string& session_id, const std::string& addr)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("get_all_snapshots_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_get_all_snapshots_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void physical_packer_service_proxyConcurrentClient::recv_get_all_snapshots_p(std::map<std::string, std::vector<snapshot> > & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("get_all_snapshots_p") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      physical_packer_service_proxy_get_all_snapshots_p_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.ouch) {
        sentry.commit();
        throw result.ouch;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_all_snapshots_p failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void physical_packer_service_proxyConcurrentClient::create_packer_job_ex_p(packer_job_detail& _return, const std::string& session_id, const std::string& addr, const std::string& job_id, const create_packer_job_detail& create_job)
{
  int32_t seqid = send_create_packer_job_ex_p(session_id, addr, job_id, create_job);
  recv_create_packer_job_ex_p(_return, seqid);
}

int32_t physical_packer_service_proxyConcurrentClient::send_create_packer_job_ex_p(const std::string& session_id, const std::string& addr, const std::string& job_id, const create_packer_job_detail& create_job)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("create_packer_job_ex_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_create_packer_job_ex_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.job_id = &job_id;
  args.create_job = &create_job;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void physical_packer_service_proxyConcurrentClient::recv_create_packer_job_ex_p(packer_job_detail& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("create_packer_job_ex_p") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      physical_packer_service_proxy_create_packer_job_ex_p_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.ouch) {
        sentry.commit();
        throw result.ouch;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "create_packer_job_ex_p failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void physical_packer_service_proxyConcurrentClient::get_packer_job_p(packer_job_detail& _return, const std::string& session_id, const std::string& addr, const std::string& job_id, const std::string& previous_updated_time)
{
  int32_t seqid = send_get_packer_job_p(session_id, addr, job_id, previous_updated_time);
  recv_get_packer_job_p(_return, seqid);
}

int32_t physical_packer_service_proxyConcurrentClient::send_get_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id, const std::string& previous_updated_time)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("get_packer_job_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_get_packer_job_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.job_id = &job_id;
  args.previous_updated_time = &previous_updated_time;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void physical_packer_service_proxyConcurrentClient::recv_get_packer_job_p(packer_job_detail& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("get_packer_job_p") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      physical_packer_service_proxy_get_packer_job_p_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.ouch) {
        sentry.commit();
        throw result.ouch;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_packer_job_p failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

bool physical_packer_service_proxyConcurrentClient::interrupt_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  int32_t seqid = send_interrupt_packer_job_p(session_id, addr, job_id);
  return recv_interrupt_packer_job_p(seqid);
}

int32_t physical_packer_service_proxyConcurrentClient::send_interrupt_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("interrupt_packer_job_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_interrupt_packer_job_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.job_id = &job_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool physical_packer_service_proxyConcurrentClient::recv_interrupt_packer_job_p(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("interrupt_packer_job_p") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      physical_packer_service_proxy_interrupt_packer_job_p_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      if (result.__isset.ouch) {
        sentry.commit();
        throw result.ouch;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "interrupt_packer_job_p failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

bool physical_packer_service_proxyConcurrentClient::resume_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  int32_t seqid = send_resume_packer_job_p(session_id, addr, job_id);
  return recv_resume_packer_job_p(seqid);
}

int32_t physical_packer_service_proxyConcurrentClient::send_resume_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("resume_packer_job_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_resume_packer_job_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.job_id = &job_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool physical_packer_service_proxyConcurrentClient::recv_resume_packer_job_p(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("resume_packer_job_p") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      physical_packer_service_proxy_resume_packer_job_p_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      if (result.__isset.ouch) {
        sentry.commit();
        throw result.ouch;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "resume_packer_job_p failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

bool physical_packer_service_proxyConcurrentClient::remove_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  int32_t seqid = send_remove_packer_job_p(session_id, addr, job_id);
  return recv_remove_packer_job_p(seqid);
}

int32_t physical_packer_service_proxyConcurrentClient::send_remove_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("remove_packer_job_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_remove_packer_job_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.job_id = &job_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool physical_packer_service_proxyConcurrentClient::recv_remove_packer_job_p(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("remove_packer_job_p") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      physical_packer_service_proxy_remove_packer_job_p_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      if (result.__isset.ouch) {
        sentry.commit();
        throw result.ouch;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "remove_packer_job_p failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

bool physical_packer_service_proxyConcurrentClient::running_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  int32_t seqid = send_running_packer_job_p(session_id, addr, job_id);
  return recv_running_packer_job_p(seqid);
}

int32_t physical_packer_service_proxyConcurrentClient::send_running_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("running_packer_job_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_running_packer_job_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.job_id = &job_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool physical_packer_service_proxyConcurrentClient::recv_running_packer_job_p(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("running_packer_job_p") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      physical_packer_service_proxy_running_packer_job_p_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      if (result.__isset.ouch) {
        sentry.commit();
        throw result.ouch;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "running_packer_job_p failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void physical_packer_service_proxyConcurrentClient::enumerate_packer_disks_p(std::set<disk_info> & _return, const std::string& session_id, const std::string& addr, const enumerate_disk_filter_style::type filter)
{
  int32_t seqid = send_enumerate_packer_disks_p(session_id, addr, filter);
  recv_enumerate_packer_disks_p(_return, seqid);
}

int32_t physical_packer_service_proxyConcurrentClient::send_enumerate_packer_disks_p(const std::string& session_id, const std::string& addr, const enumerate_disk_filter_style::type filter)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("enumerate_packer_disks_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_enumerate_packer_disks_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.filter = &filter;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void physical_packer_service_proxyConcurrentClient::recv_enumerate_packer_disks_p(std::set<disk_info> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("enumerate_packer_disks_p") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      physical_packer_service_proxy_enumerate_packer_disks_p_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.ouch) {
        sentry.commit();
        throw result.ouch;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "enumerate_packer_disks_p failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

bool physical_packer_service_proxyConcurrentClient::verify_packer_carrier_p(const std::string& session_id, const std::string& addr, const std::string& carrier, const bool is_ssl)
{
  int32_t seqid = send_verify_packer_carrier_p(session_id, addr, carrier, is_ssl);
  return recv_verify_packer_carrier_p(seqid);
}

int32_t physical_packer_service_proxyConcurrentClient::send_verify_packer_carrier_p(const std::string& session_id, const std::string& addr, const std::string& carrier, const bool is_ssl)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("verify_packer_carrier_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_verify_packer_carrier_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.carrier = &carrier;
  args.is_ssl = &is_ssl;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool physical_packer_service_proxyConcurrentClient::recv_verify_packer_carrier_p(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("verify_packer_carrier_p") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      physical_packer_service_proxy_verify_packer_carrier_p_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      if (result.__isset.ouch) {
        sentry.commit();
        throw result.ouch;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "verify_packer_carrier_p failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void physical_packer_service_proxyConcurrentClient::get_packer_host_detail_p(physical_machine_info& _return, const std::string& session_id, const std::string& addr, const machine_detail_filter::type filter)
{
  int32_t seqid = send_get_packer_host_detail_p(session_id, addr, filter);
  recv_get_packer_host_detail_p(_return, seqid);
}

int32_t physical_packer_service_proxyConcurrentClient::send_get_packer_host_detail_p(const std::string& session_id, const std::string& addr, const machine_detail_filter::type filter)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("get_packer_host_detail_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_get_packer_host_detail_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.filter = &filter;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void physical_packer_service_proxyConcurrentClient::recv_get_packer_host_detail_p(physical_machine_info& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("get_packer_host_detail_p") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      physical_packer_service_proxy_get_packer_host_detail_p_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.ouch) {
        sentry.commit();
        throw result.ouch;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_packer_host_detail_p failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void physical_packer_service_proxyCobClient::packer_ping_p(::apache::thrift::stdcxx::function<void(physical_packer_service_proxyCobClient* client)> cob, const std::string& session_id, const std::string& addr)
{
  send_packer_ping_p(session_id, addr);
  channel_->sendAndRecvMessage(::apache::thrift::stdcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void physical_packer_service_proxyCobClient::send_packer_ping_p(const std::string& session_id, const std::string& addr)
{
  int32_t cseqid = 0;
  otrans_->resetBuffer();
  oprot_->writeMessageBegin("packer_ping_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_packer_ping_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyCobClient::recv_packer_ping_p(service_info& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("packer_ping_p") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    physical_packer_service_proxy_packer_ping_p_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "packer_ping_p failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void physical_packer_service_proxyCobClient::take_snapshots_p(::apache::thrift::stdcxx::function<void(physical_packer_service_proxyCobClient* client)> cob, const std::string& session_id, const std::string& addr, const std::set<std::string> & disks)
{
  send_take_snapshots_p(session_id, addr, disks);
  channel_->sendAndRecvMessage(::apache::thrift::stdcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void physical_packer_service_proxyCobClient::send_take_snapshots_p(const std::string& session_id, const std::string& addr, const std::set<std::string> & disks)
{
  int32_t cseqid = 0;
  otrans_->resetBuffer();
  oprot_->writeMessageBegin("take_snapshots_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_take_snapshots_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.disks = &disks;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyCobClient::recv_take_snapshots_p(std::vector<snapshot> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("take_snapshots_p") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    physical_packer_service_proxy_take_snapshots_p_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    if (result.__isset.ouch) {
      completed = true;
      completed__(true);
      throw result.ouch;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "take_snapshots_p failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void physical_packer_service_proxyCobClient::take_snapshots_ex_p(::apache::thrift::stdcxx::function<void(physical_packer_service_proxyCobClient* client)> cob, const std::string& session_id, const std::string& addr, const std::set<std::string> & disks, const std::string& pre_script, const std::string& post_script)
{
  send_take_snapshots_ex_p(session_id, addr, disks, pre_script, post_script);
  channel_->sendAndRecvMessage(::apache::thrift::stdcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void physical_packer_service_proxyCobClient::send_take_snapshots_ex_p(const std::string& session_id, const std::string& addr, const std::set<std::string> & disks, const std::string& pre_script, const std::string& post_script)
{
  int32_t cseqid = 0;
  otrans_->resetBuffer();
  oprot_->writeMessageBegin("take_snapshots_ex_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_take_snapshots_ex_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.disks = &disks;
  args.pre_script = &pre_script;
  args.post_script = &post_script;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyCobClient::recv_take_snapshots_ex_p(std::vector<snapshot> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("take_snapshots_ex_p") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    physical_packer_service_proxy_take_snapshots_ex_p_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    if (result.__isset.ouch) {
      completed = true;
      completed__(true);
      throw result.ouch;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "take_snapshots_ex_p failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void physical_packer_service_proxyCobClient::take_snapshots2_p(::apache::thrift::stdcxx::function<void(physical_packer_service_proxyCobClient* client)> cob, const std::string& session_id, const std::string& addr, const take_snapshots_parameters& parameters)
{
  send_take_snapshots2_p(session_id, addr, parameters);
  channel_->sendAndRecvMessage(::apache::thrift::stdcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void physical_packer_service_proxyCobClient::send_take_snapshots2_p(const std::string& session_id, const std::string& addr, const take_snapshots_parameters& parameters)
{
  int32_t cseqid = 0;
  otrans_->resetBuffer();
  oprot_->writeMessageBegin("take_snapshots2_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_take_snapshots2_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.parameters = &parameters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyCobClient::recv_take_snapshots2_p(std::vector<snapshot> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("take_snapshots2_p") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    physical_packer_service_proxy_take_snapshots2_p_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    if (result.__isset.ouch) {
      completed = true;
      completed__(true);
      throw result.ouch;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "take_snapshots2_p failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void physical_packer_service_proxyCobClient::delete_snapshot_p(::apache::thrift::stdcxx::function<void(physical_packer_service_proxyCobClient* client)> cob, const std::string& session_id, const std::string& addr, const std::string& snapshot_id)
{
  send_delete_snapshot_p(session_id, addr, snapshot_id);
  channel_->sendAndRecvMessage(::apache::thrift::stdcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void physical_packer_service_proxyCobClient::send_delete_snapshot_p(const std::string& session_id, const std::string& addr, const std::string& snapshot_id)
{
  int32_t cseqid = 0;
  otrans_->resetBuffer();
  oprot_->writeMessageBegin("delete_snapshot_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_delete_snapshot_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.snapshot_id = &snapshot_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyCobClient::recv_delete_snapshot_p(delete_snapshot_result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("delete_snapshot_p") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    physical_packer_service_proxy_delete_snapshot_p_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    if (result.__isset.ouch) {
      completed = true;
      completed__(true);
      throw result.ouch;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "delete_snapshot_p failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void physical_packer_service_proxyCobClient::delete_snapshot_set_p(::apache::thrift::stdcxx::function<void(physical_packer_service_proxyCobClient* client)> cob, const std::string& session_id, const std::string& addr, const std::string& snapshot_set_id)
{
  send_delete_snapshot_set_p(session_id, addr, snapshot_set_id);
  channel_->sendAndRecvMessage(::apache::thrift::stdcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void physical_packer_service_proxyCobClient::send_delete_snapshot_set_p(const std::string& session_id, const std::string& addr, const std::string& snapshot_set_id)
{
  int32_t cseqid = 0;
  otrans_->resetBuffer();
  oprot_->writeMessageBegin("delete_snapshot_set_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_delete_snapshot_set_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.snapshot_set_id = &snapshot_set_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyCobClient::recv_delete_snapshot_set_p(delete_snapshot_result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("delete_snapshot_set_p") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    physical_packer_service_proxy_delete_snapshot_set_p_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    if (result.__isset.ouch) {
      completed = true;
      completed__(true);
      throw result.ouch;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "delete_snapshot_set_p failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void physical_packer_service_proxyCobClient::get_all_snapshots_p(::apache::thrift::stdcxx::function<void(physical_packer_service_proxyCobClient* client)> cob, const std::string& session_id, const std::string& addr)
{
  send_get_all_snapshots_p(session_id, addr);
  channel_->sendAndRecvMessage(::apache::thrift::stdcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void physical_packer_service_proxyCobClient::send_get_all_snapshots_p(const std::string& session_id, const std::string& addr)
{
  int32_t cseqid = 0;
  otrans_->resetBuffer();
  oprot_->writeMessageBegin("get_all_snapshots_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_get_all_snapshots_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyCobClient::recv_get_all_snapshots_p(std::map<std::string, std::vector<snapshot> > & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("get_all_snapshots_p") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    physical_packer_service_proxy_get_all_snapshots_p_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    if (result.__isset.ouch) {
      completed = true;
      completed__(true);
      throw result.ouch;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_all_snapshots_p failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void physical_packer_service_proxyCobClient::create_packer_job_ex_p(::apache::thrift::stdcxx::function<void(physical_packer_service_proxyCobClient* client)> cob, const std::string& session_id, const std::string& addr, const std::string& job_id, const create_packer_job_detail& create_job)
{
  send_create_packer_job_ex_p(session_id, addr, job_id, create_job);
  channel_->sendAndRecvMessage(::apache::thrift::stdcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void physical_packer_service_proxyCobClient::send_create_packer_job_ex_p(const std::string& session_id, const std::string& addr, const std::string& job_id, const create_packer_job_detail& create_job)
{
  int32_t cseqid = 0;
  otrans_->resetBuffer();
  oprot_->writeMessageBegin("create_packer_job_ex_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_create_packer_job_ex_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.job_id = &job_id;
  args.create_job = &create_job;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyCobClient::recv_create_packer_job_ex_p(packer_job_detail& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("create_packer_job_ex_p") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    physical_packer_service_proxy_create_packer_job_ex_p_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    if (result.__isset.ouch) {
      completed = true;
      completed__(true);
      throw result.ouch;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "create_packer_job_ex_p failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void physical_packer_service_proxyCobClient::get_packer_job_p(::apache::thrift::stdcxx::function<void(physical_packer_service_proxyCobClient* client)> cob, const std::string& session_id, const std::string& addr, const std::string& job_id, const std::string& previous_updated_time)
{
  send_get_packer_job_p(session_id, addr, job_id, previous_updated_time);
  channel_->sendAndRecvMessage(::apache::thrift::stdcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void physical_packer_service_proxyCobClient::send_get_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id, const std::string& previous_updated_time)
{
  int32_t cseqid = 0;
  otrans_->resetBuffer();
  oprot_->writeMessageBegin("get_packer_job_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_get_packer_job_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.job_id = &job_id;
  args.previous_updated_time = &previous_updated_time;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyCobClient::recv_get_packer_job_p(packer_job_detail& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("get_packer_job_p") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    physical_packer_service_proxy_get_packer_job_p_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    if (result.__isset.ouch) {
      completed = true;
      completed__(true);
      throw result.ouch;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_packer_job_p failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void physical_packer_service_proxyCobClient::interrupt_packer_job_p(::apache::thrift::stdcxx::function<void(physical_packer_service_proxyCobClient* client)> cob, const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  send_interrupt_packer_job_p(session_id, addr, job_id);
  channel_->sendAndRecvMessage(::apache::thrift::stdcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void physical_packer_service_proxyCobClient::send_interrupt_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  int32_t cseqid = 0;
  otrans_->resetBuffer();
  oprot_->writeMessageBegin("interrupt_packer_job_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_interrupt_packer_job_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.job_id = &job_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool physical_packer_service_proxyCobClient::recv_interrupt_packer_job_p()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("interrupt_packer_job_p") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    bool _return;
    physical_packer_service_proxy_interrupt_packer_job_p_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      completed = true;
      completed__(true);
      return _return;
    }
    if (result.__isset.ouch) {
      completed = true;
      completed__(true);
      throw result.ouch;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "interrupt_packer_job_p failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void physical_packer_service_proxyCobClient::resume_packer_job_p(::apache::thrift::stdcxx::function<void(physical_packer_service_proxyCobClient* client)> cob, const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  send_resume_packer_job_p(session_id, addr, job_id);
  channel_->sendAndRecvMessage(::apache::thrift::stdcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void physical_packer_service_proxyCobClient::send_resume_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  int32_t cseqid = 0;
  otrans_->resetBuffer();
  oprot_->writeMessageBegin("resume_packer_job_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_resume_packer_job_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.job_id = &job_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool physical_packer_service_proxyCobClient::recv_resume_packer_job_p()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("resume_packer_job_p") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    bool _return;
    physical_packer_service_proxy_resume_packer_job_p_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      completed = true;
      completed__(true);
      return _return;
    }
    if (result.__isset.ouch) {
      completed = true;
      completed__(true);
      throw result.ouch;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "resume_packer_job_p failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void physical_packer_service_proxyCobClient::remove_packer_job_p(::apache::thrift::stdcxx::function<void(physical_packer_service_proxyCobClient* client)> cob, const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  send_remove_packer_job_p(session_id, addr, job_id);
  channel_->sendAndRecvMessage(::apache::thrift::stdcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void physical_packer_service_proxyCobClient::send_remove_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  int32_t cseqid = 0;
  otrans_->resetBuffer();
  oprot_->writeMessageBegin("remove_packer_job_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_remove_packer_job_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.job_id = &job_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool physical_packer_service_proxyCobClient::recv_remove_packer_job_p()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("remove_packer_job_p") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    bool _return;
    physical_packer_service_proxy_remove_packer_job_p_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      completed = true;
      completed__(true);
      return _return;
    }
    if (result.__isset.ouch) {
      completed = true;
      completed__(true);
      throw result.ouch;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "remove_packer_job_p failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void physical_packer_service_proxyCobClient::running_packer_job_p(::apache::thrift::stdcxx::function<void(physical_packer_service_proxyCobClient* client)> cob, const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  send_running_packer_job_p(session_id, addr, job_id);
  channel_->sendAndRecvMessage(::apache::thrift::stdcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void physical_packer_service_proxyCobClient::send_running_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  int32_t cseqid = 0;
  otrans_->resetBuffer();
  oprot_->writeMessageBegin("running_packer_job_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_running_packer_job_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.job_id = &job_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool physical_packer_service_proxyCobClient::recv_running_packer_job_p()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("running_packer_job_p") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    bool _return;
    physical_packer_service_proxy_running_packer_job_p_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      completed = true;
      completed__(true);
      return _return;
    }
    if (result.__isset.ouch) {
      completed = true;
      completed__(true);
      throw result.ouch;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "running_packer_job_p failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void physical_packer_service_proxyCobClient::enumerate_packer_disks_p(::apache::thrift::stdcxx::function<void(physical_packer_service_proxyCobClient* client)> cob, const std::string& session_id, const std::string& addr, const enumerate_disk_filter_style::type filter)
{
  send_enumerate_packer_disks_p(session_id, addr, filter);
  channel_->sendAndRecvMessage(::apache::thrift::stdcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void physical_packer_service_proxyCobClient::send_enumerate_packer_disks_p(const std::string& session_id, const std::string& addr, const enumerate_disk_filter_style::type filter)
{
  int32_t cseqid = 0;
  otrans_->resetBuffer();
  oprot_->writeMessageBegin("enumerate_packer_disks_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_enumerate_packer_disks_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.filter = &filter;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyCobClient::recv_enumerate_packer_disks_p(std::set<disk_info> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("enumerate_packer_disks_p") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    physical_packer_service_proxy_enumerate_packer_disks_p_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    if (result.__isset.ouch) {
      completed = true;
      completed__(true);
      throw result.ouch;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "enumerate_packer_disks_p failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void physical_packer_service_proxyCobClient::verify_packer_carrier_p(::apache::thrift::stdcxx::function<void(physical_packer_service_proxyCobClient* client)> cob, const std::string& session_id, const std::string& addr, const std::string& carrier, const bool is_ssl)
{
  send_verify_packer_carrier_p(session_id, addr, carrier, is_ssl);
  channel_->sendAndRecvMessage(::apache::thrift::stdcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void physical_packer_service_proxyCobClient::send_verify_packer_carrier_p(const std::string& session_id, const std::string& addr, const std::string& carrier, const bool is_ssl)
{
  int32_t cseqid = 0;
  otrans_->resetBuffer();
  oprot_->writeMessageBegin("verify_packer_carrier_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_verify_packer_carrier_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.carrier = &carrier;
  args.is_ssl = &is_ssl;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool physical_packer_service_proxyCobClient::recv_verify_packer_carrier_p()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("verify_packer_carrier_p") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    bool _return;
    physical_packer_service_proxy_verify_packer_carrier_p_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      completed = true;
      completed__(true);
      return _return;
    }
    if (result.__isset.ouch) {
      completed = true;
      completed__(true);
      throw result.ouch;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "verify_packer_carrier_p failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void physical_packer_service_proxyCobClient::get_packer_host_detail_p(::apache::thrift::stdcxx::function<void(physical_packer_service_proxyCobClient* client)> cob, const std::string& session_id, const std::string& addr, const machine_detail_filter::type filter)
{
  send_get_packer_host_detail_p(session_id, addr, filter);
  channel_->sendAndRecvMessage(::apache::thrift::stdcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void physical_packer_service_proxyCobClient::send_get_packer_host_detail_p(const std::string& session_id, const std::string& addr, const machine_detail_filter::type filter)
{
  int32_t cseqid = 0;
  otrans_->resetBuffer();
  oprot_->writeMessageBegin("get_packer_host_detail_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_get_packer_host_detail_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.filter = &filter;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyCobClient::recv_get_packer_host_detail_p(physical_machine_info& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("get_packer_host_detail_p") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    physical_packer_service_proxy_get_packer_host_detail_p_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    if (result.__isset.ouch) {
      completed = true;
      completed__(true);
      throw result.ouch;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_packer_host_detail_p failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void physical_packer_service_proxyAsyncProcessor::dispatchCall(::apache::thrift::stdcxx::function<void(bool ok)> cob, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid) {
  ProcessMap::iterator pfn;
  pfn = processMap_.find(fname);
  if (pfn == processMap_.end()) {
    return common_serviceAsyncProcessor::dispatchCall(cob, iprot, oprot, fname, seqid);
  }
  (this->*(pfn->second))(cob, seqid, iprot, oprot);
  return;
}

void physical_packer_service_proxyAsyncProcessor::process_packer_ping_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  physical_packer_service_proxy_packer_ping_p_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.packer_ping_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.packer_ping_p");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.packer_ping_p");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.packer_ping_p", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.packer_ping_p");
    }
    return cob(false);
  }
  freer.unregister();
  void (physical_packer_service_proxyAsyncProcessor::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const service_info& _return) =
    &physical_packer_service_proxyAsyncProcessor::return_packer_ping_p;
  iface_->packer_ping_p(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.session_id,
      args.addr);
}

void physical_packer_service_proxyAsyncProcessor::return_packer_ping_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const service_info& _return)
{
  physical_packer_service_proxy_packer_ping_p_presult result;
  result.success = const_cast<service_info*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.packer_ping_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.packer_ping_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.packer_ping_p");
  }

  oprot->writeMessageBegin("packer_ping_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.packer_ping_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::process_take_snapshots_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  physical_packer_service_proxy_take_snapshots_p_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.take_snapshots_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.take_snapshots_p");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.take_snapshots_p");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.take_snapshots_p", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.take_snapshots_p");
    }
    return cob(false);
  }
  freer.unregister();
  void (physical_packer_service_proxyAsyncProcessor::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::vector<snapshot> & _return) =
    &physical_packer_service_proxyAsyncProcessor::return_take_snapshots_p;
  void (physical_packer_service_proxyAsyncProcessor::*throw_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &physical_packer_service_proxyAsyncProcessor::throw_take_snapshots_p;
  iface_->take_snapshots_p(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      ::apache::thrift::stdcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.session_id,
      args.addr,
      args.disks);
}

void physical_packer_service_proxyAsyncProcessor::return_take_snapshots_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::vector<snapshot> & _return)
{
  physical_packer_service_proxy_take_snapshots_p_presult result;
  result.success = const_cast<std::vector<snapshot> *>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.take_snapshots_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.take_snapshots_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.take_snapshots_p");
  }

  oprot->writeMessageBegin("take_snapshots_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.take_snapshots_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::throw_take_snapshots_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.take_snapshots_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.take_snapshots_p");

  physical_packer_service_proxy_take_snapshots_p_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.take_snapshots_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("take_snapshots_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.take_snapshots_p");
  }

  oprot->writeMessageBegin("take_snapshots_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.take_snapshots_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::process_take_snapshots_ex_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  physical_packer_service_proxy_take_snapshots_ex_p_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.take_snapshots_ex_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.take_snapshots_ex_p");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.take_snapshots_ex_p");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.take_snapshots_ex_p", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.take_snapshots_ex_p");
    }
    return cob(false);
  }
  freer.unregister();
  void (physical_packer_service_proxyAsyncProcessor::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::vector<snapshot> & _return) =
    &physical_packer_service_proxyAsyncProcessor::return_take_snapshots_ex_p;
  void (physical_packer_service_proxyAsyncProcessor::*throw_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &physical_packer_service_proxyAsyncProcessor::throw_take_snapshots_ex_p;
  iface_->take_snapshots_ex_p(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      ::apache::thrift::stdcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.session_id,
      args.addr,
      args.disks,
      args.pre_script,
      args.post_script);
}

void physical_packer_service_proxyAsyncProcessor::return_take_snapshots_ex_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::vector<snapshot> & _return)
{
  physical_packer_service_proxy_take_snapshots_ex_p_presult result;
  result.success = const_cast<std::vector<snapshot> *>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.take_snapshots_ex_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.take_snapshots_ex_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.take_snapshots_ex_p");
  }

  oprot->writeMessageBegin("take_snapshots_ex_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.take_snapshots_ex_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::throw_take_snapshots_ex_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.take_snapshots_ex_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.take_snapshots_ex_p");

  physical_packer_service_proxy_take_snapshots_ex_p_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.take_snapshots_ex_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("take_snapshots_ex_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.take_snapshots_ex_p");
  }

  oprot->writeMessageBegin("take_snapshots_ex_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.take_snapshots_ex_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::process_take_snapshots2_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  physical_packer_service_proxy_take_snapshots2_p_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.take_snapshots2_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.take_snapshots2_p");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.take_snapshots2_p");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.take_snapshots2_p", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.take_snapshots2_p");
    }
    return cob(false);
  }
  freer.unregister();
  void (physical_packer_service_proxyAsyncProcessor::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::vector<snapshot> & _return) =
    &physical_packer_service_proxyAsyncProcessor::return_take_snapshots2_p;
  void (physical_packer_service_proxyAsyncProcessor::*throw_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &physical_packer_service_proxyAsyncProcessor::throw_take_snapshots2_p;
  iface_->take_snapshots2_p(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      ::apache::thrift::stdcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.session_id,
      args.addr,
      args.parameters);
}

void physical_packer_service_proxyAsyncProcessor::return_take_snapshots2_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::vector<snapshot> & _return)
{
  physical_packer_service_proxy_take_snapshots2_p_presult result;
  result.success = const_cast<std::vector<snapshot> *>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.take_snapshots2_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.take_snapshots2_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.take_snapshots2_p");
  }

  oprot->writeMessageBegin("take_snapshots2_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.take_snapshots2_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::throw_take_snapshots2_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.take_snapshots2_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.take_snapshots2_p");

  physical_packer_service_proxy_take_snapshots2_p_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.take_snapshots2_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("take_snapshots2_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.take_snapshots2_p");
  }

  oprot->writeMessageBegin("take_snapshots2_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.take_snapshots2_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::process_delete_snapshot_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  physical_packer_service_proxy_delete_snapshot_p_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.delete_snapshot_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.delete_snapshot_p");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.delete_snapshot_p");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.delete_snapshot_p", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.delete_snapshot_p");
    }
    return cob(false);
  }
  freer.unregister();
  void (physical_packer_service_proxyAsyncProcessor::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const delete_snapshot_result& _return) =
    &physical_packer_service_proxyAsyncProcessor::return_delete_snapshot_p;
  void (physical_packer_service_proxyAsyncProcessor::*throw_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &physical_packer_service_proxyAsyncProcessor::throw_delete_snapshot_p;
  iface_->delete_snapshot_p(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      ::apache::thrift::stdcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.session_id,
      args.addr,
      args.snapshot_id);
}

void physical_packer_service_proxyAsyncProcessor::return_delete_snapshot_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const delete_snapshot_result& _return)
{
  physical_packer_service_proxy_delete_snapshot_p_presult result;
  result.success = const_cast<delete_snapshot_result*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.delete_snapshot_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.delete_snapshot_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.delete_snapshot_p");
  }

  oprot->writeMessageBegin("delete_snapshot_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.delete_snapshot_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::throw_delete_snapshot_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.delete_snapshot_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.delete_snapshot_p");

  physical_packer_service_proxy_delete_snapshot_p_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.delete_snapshot_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("delete_snapshot_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.delete_snapshot_p");
  }

  oprot->writeMessageBegin("delete_snapshot_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.delete_snapshot_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::process_delete_snapshot_set_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  physical_packer_service_proxy_delete_snapshot_set_p_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.delete_snapshot_set_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.delete_snapshot_set_p");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.delete_snapshot_set_p");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.delete_snapshot_set_p", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.delete_snapshot_set_p");
    }
    return cob(false);
  }
  freer.unregister();
  void (physical_packer_service_proxyAsyncProcessor::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const delete_snapshot_result& _return) =
    &physical_packer_service_proxyAsyncProcessor::return_delete_snapshot_set_p;
  void (physical_packer_service_proxyAsyncProcessor::*throw_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &physical_packer_service_proxyAsyncProcessor::throw_delete_snapshot_set_p;
  iface_->delete_snapshot_set_p(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      ::apache::thrift::stdcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.session_id,
      args.addr,
      args.snapshot_set_id);
}

void physical_packer_service_proxyAsyncProcessor::return_delete_snapshot_set_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const delete_snapshot_result& _return)
{
  physical_packer_service_proxy_delete_snapshot_set_p_presult result;
  result.success = const_cast<delete_snapshot_result*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.delete_snapshot_set_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.delete_snapshot_set_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.delete_snapshot_set_p");
  }

  oprot->writeMessageBegin("delete_snapshot_set_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.delete_snapshot_set_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::throw_delete_snapshot_set_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.delete_snapshot_set_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.delete_snapshot_set_p");

  physical_packer_service_proxy_delete_snapshot_set_p_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.delete_snapshot_set_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("delete_snapshot_set_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.delete_snapshot_set_p");
  }

  oprot->writeMessageBegin("delete_snapshot_set_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.delete_snapshot_set_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::process_get_all_snapshots_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  physical_packer_service_proxy_get_all_snapshots_p_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.get_all_snapshots_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.get_all_snapshots_p");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.get_all_snapshots_p");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.get_all_snapshots_p", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.get_all_snapshots_p");
    }
    return cob(false);
  }
  freer.unregister();
  void (physical_packer_service_proxyAsyncProcessor::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::map<std::string, std::vector<snapshot> > & _return) =
    &physical_packer_service_proxyAsyncProcessor::return_get_all_snapshots_p;
  void (physical_packer_service_proxyAsyncProcessor::*throw_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &physical_packer_service_proxyAsyncProcessor::throw_get_all_snapshots_p;
  iface_->get_all_snapshots_p(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      ::apache::thrift::stdcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.session_id,
      args.addr);
}

void physical_packer_service_proxyAsyncProcessor::return_get_all_snapshots_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::map<std::string, std::vector<snapshot> > & _return)
{
  physical_packer_service_proxy_get_all_snapshots_p_presult result;
  result.success = const_cast<std::map<std::string, std::vector<snapshot> > *>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.get_all_snapshots_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.get_all_snapshots_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.get_all_snapshots_p");
  }

  oprot->writeMessageBegin("get_all_snapshots_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.get_all_snapshots_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::throw_get_all_snapshots_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.get_all_snapshots_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.get_all_snapshots_p");

  physical_packer_service_proxy_get_all_snapshots_p_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.get_all_snapshots_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("get_all_snapshots_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.get_all_snapshots_p");
  }

  oprot->writeMessageBegin("get_all_snapshots_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.get_all_snapshots_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::process_create_packer_job_ex_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  physical_packer_service_proxy_create_packer_job_ex_p_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.create_packer_job_ex_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.create_packer_job_ex_p");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.create_packer_job_ex_p");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.create_packer_job_ex_p", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.create_packer_job_ex_p");
    }
    return cob(false);
  }
  freer.unregister();
  void (physical_packer_service_proxyAsyncProcessor::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const packer_job_detail& _return) =
    &physical_packer_service_proxyAsyncProcessor::return_create_packer_job_ex_p;
  void (physical_packer_service_proxyAsyncProcessor::*throw_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &physical_packer_service_proxyAsyncProcessor::throw_create_packer_job_ex_p;
  iface_->create_packer_job_ex_p(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      ::apache::thrift::stdcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.session_id,
      args.addr,
      args.job_id,
      args.create_job);
}

void physical_packer_service_proxyAsyncProcessor::return_create_packer_job_ex_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const packer_job_detail& _return)
{
  physical_packer_service_proxy_create_packer_job_ex_p_presult result;
  result.success = const_cast<packer_job_detail*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.create_packer_job_ex_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.create_packer_job_ex_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.create_packer_job_ex_p");
  }

  oprot->writeMessageBegin("create_packer_job_ex_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.create_packer_job_ex_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::throw_create_packer_job_ex_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.create_packer_job_ex_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.create_packer_job_ex_p");

  physical_packer_service_proxy_create_packer_job_ex_p_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.create_packer_job_ex_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("create_packer_job_ex_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.create_packer_job_ex_p");
  }

  oprot->writeMessageBegin("create_packer_job_ex_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.create_packer_job_ex_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::process_get_packer_job_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  physical_packer_service_proxy_get_packer_job_p_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.get_packer_job_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.get_packer_job_p");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.get_packer_job_p");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.get_packer_job_p", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.get_packer_job_p");
    }
    return cob(false);
  }
  freer.unregister();
  void (physical_packer_service_proxyAsyncProcessor::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const packer_job_detail& _return) =
    &physical_packer_service_proxyAsyncProcessor::return_get_packer_job_p;
  void (physical_packer_service_proxyAsyncProcessor::*throw_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &physical_packer_service_proxyAsyncProcessor::throw_get_packer_job_p;
  iface_->get_packer_job_p(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      ::apache::thrift::stdcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.session_id,
      args.addr,
      args.job_id,
      args.previous_updated_time);
}

void physical_packer_service_proxyAsyncProcessor::return_get_packer_job_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const packer_job_detail& _return)
{
  physical_packer_service_proxy_get_packer_job_p_presult result;
  result.success = const_cast<packer_job_detail*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.get_packer_job_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.get_packer_job_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.get_packer_job_p");
  }

  oprot->writeMessageBegin("get_packer_job_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.get_packer_job_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::throw_get_packer_job_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.get_packer_job_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.get_packer_job_p");

  physical_packer_service_proxy_get_packer_job_p_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.get_packer_job_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("get_packer_job_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.get_packer_job_p");
  }

  oprot->writeMessageBegin("get_packer_job_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.get_packer_job_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::process_interrupt_packer_job_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  physical_packer_service_proxy_interrupt_packer_job_p_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.interrupt_packer_job_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.interrupt_packer_job_p");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.interrupt_packer_job_p");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.interrupt_packer_job_p", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.interrupt_packer_job_p");
    }
    return cob(false);
  }
  freer.unregister();
  void (physical_packer_service_proxyAsyncProcessor::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const bool& _return) =
    &physical_packer_service_proxyAsyncProcessor::return_interrupt_packer_job_p;
  void (physical_packer_service_proxyAsyncProcessor::*throw_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &physical_packer_service_proxyAsyncProcessor::throw_interrupt_packer_job_p;
  iface_->interrupt_packer_job_p(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      ::apache::thrift::stdcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.session_id,
      args.addr,
      args.job_id);
}

void physical_packer_service_proxyAsyncProcessor::return_interrupt_packer_job_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const bool& _return)
{
  physical_packer_service_proxy_interrupt_packer_job_p_presult result;
  result.success = const_cast<bool*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.interrupt_packer_job_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.interrupt_packer_job_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.interrupt_packer_job_p");
  }

  oprot->writeMessageBegin("interrupt_packer_job_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.interrupt_packer_job_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::throw_interrupt_packer_job_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.interrupt_packer_job_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.interrupt_packer_job_p");

  physical_packer_service_proxy_interrupt_packer_job_p_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.interrupt_packer_job_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("interrupt_packer_job_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.interrupt_packer_job_p");
  }

  oprot->writeMessageBegin("interrupt_packer_job_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.interrupt_packer_job_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::process_resume_packer_job_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  physical_packer_service_proxy_resume_packer_job_p_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.resume_packer_job_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.resume_packer_job_p");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.resume_packer_job_p");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.resume_packer_job_p", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.resume_packer_job_p");
    }
    return cob(false);
  }
  freer.unregister();
  void (physical_packer_service_proxyAsyncProcessor::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const bool& _return) =
    &physical_packer_service_proxyAsyncProcessor::return_resume_packer_job_p;
  void (physical_packer_service_proxyAsyncProcessor::*throw_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &physical_packer_service_proxyAsyncProcessor::throw_resume_packer_job_p;
  iface_->resume_packer_job_p(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      ::apache::thrift::stdcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.session_id,
      args.addr,
      args.job_id);
}

void physical_packer_service_proxyAsyncProcessor::return_resume_packer_job_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const bool& _return)
{
  physical_packer_service_proxy_resume_packer_job_p_presult result;
  result.success = const_cast<bool*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.resume_packer_job_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.resume_packer_job_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.resume_packer_job_p");
  }

  oprot->writeMessageBegin("resume_packer_job_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.resume_packer_job_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::throw_resume_packer_job_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.resume_packer_job_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.resume_packer_job_p");

  physical_packer_service_proxy_resume_packer_job_p_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.resume_packer_job_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("resume_packer_job_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.resume_packer_job_p");
  }

  oprot->writeMessageBegin("resume_packer_job_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.resume_packer_job_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::process_remove_packer_job_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  physical_packer_service_proxy_remove_packer_job_p_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.remove_packer_job_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.remove_packer_job_p");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.remove_packer_job_p");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.remove_packer_job_p", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.remove_packer_job_p");
    }
    return cob(false);
  }
  freer.unregister();
  void (physical_packer_service_proxyAsyncProcessor::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const bool& _return) =
    &physical_packer_service_proxyAsyncProcessor::return_remove_packer_job_p;
  void (physical_packer_service_proxyAsyncProcessor::*throw_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &physical_packer_service_proxyAsyncProcessor::throw_remove_packer_job_p;
  iface_->remove_packer_job_p(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      ::apache::thrift::stdcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.session_id,
      args.addr,
      args.job_id);
}

void physical_packer_service_proxyAsyncProcessor::return_remove_packer_job_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const bool& _return)
{
  physical_packer_service_proxy_remove_packer_job_p_presult result;
  result.success = const_cast<bool*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.remove_packer_job_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.remove_packer_job_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.remove_packer_job_p");
  }

  oprot->writeMessageBegin("remove_packer_job_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.remove_packer_job_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::throw_remove_packer_job_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.remove_packer_job_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.remove_packer_job_p");

  physical_packer_service_proxy_remove_packer_job_p_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.remove_packer_job_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("remove_packer_job_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.remove_packer_job_p");
  }

  oprot->writeMessageBegin("remove_packer_job_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.remove_packer_job_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::process_running_packer_job_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  physical_packer_service_proxy_running_packer_job_p_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.running_packer_job_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.running_packer_job_p");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.running_packer_job_p");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.running_packer_job_p", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.running_packer_job_p");
    }
    return cob(false);
  }
  freer.unregister();
  void (physical_packer_service_proxyAsyncProcessor::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const bool& _return) =
    &physical_packer_service_proxyAsyncProcessor::return_running_packer_job_p;
  void (physical_packer_service_proxyAsyncProcessor::*throw_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &physical_packer_service_proxyAsyncProcessor::throw_running_packer_job_p;
  iface_->running_packer_job_p(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      ::apache::thrift::stdcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.session_id,
      args.addr,
      args.job_id);
}

void physical_packer_service_proxyAsyncProcessor::return_running_packer_job_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const bool& _return)
{
  physical_packer_service_proxy_running_packer_job_p_presult result;
  result.success = const_cast<bool*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.running_packer_job_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.running_packer_job_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.running_packer_job_p");
  }

  oprot->writeMessageBegin("running_packer_job_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.running_packer_job_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::throw_running_packer_job_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.running_packer_job_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.running_packer_job_p");

  physical_packer_service_proxy_running_packer_job_p_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.running_packer_job_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("running_packer_job_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.running_packer_job_p");
  }

  oprot->writeMessageBegin("running_packer_job_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.running_packer_job_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::process_enumerate_packer_disks_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  physical_packer_service_proxy_enumerate_packer_disks_p_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.enumerate_packer_disks_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.enumerate_packer_disks_p");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.enumerate_packer_disks_p");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.enumerate_packer_disks_p", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.enumerate_packer_disks_p");
    }
    return cob(false);
  }
  freer.unregister();
  void (physical_packer_service_proxyAsyncProcessor::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::set<disk_info> & _return) =
    &physical_packer_service_proxyAsyncProcessor::return_enumerate_packer_disks_p;
  void (physical_packer_service_proxyAsyncProcessor::*throw_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &physical_packer_service_proxyAsyncProcessor::throw_enumerate_packer_disks_p;
  iface_->enumerate_packer_disks_p(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      ::apache::thrift::stdcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.session_id,
      args.addr,
      args.filter);
}

void physical_packer_service_proxyAsyncProcessor::return_enumerate_packer_disks_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::set<disk_info> & _return)
{
  physical_packer_service_proxy_enumerate_packer_disks_p_presult result;
  result.success = const_cast<std::set<disk_info> *>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.enumerate_packer_disks_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.enumerate_packer_disks_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.enumerate_packer_disks_p");
  }

  oprot->writeMessageBegin("enumerate_packer_disks_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.enumerate_packer_disks_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::throw_enumerate_packer_disks_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.enumerate_packer_disks_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.enumerate_packer_disks_p");

  physical_packer_service_proxy_enumerate_packer_disks_p_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.enumerate_packer_disks_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("enumerate_packer_disks_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.enumerate_packer_disks_p");
  }

  oprot->writeMessageBegin("enumerate_packer_disks_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.enumerate_packer_disks_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::process_verify_packer_carrier_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  physical_packer_service_proxy_verify_packer_carrier_p_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.verify_packer_carrier_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.verify_packer_carrier_p");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.verify_packer_carrier_p");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.verify_packer_carrier_p", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.verify_packer_carrier_p");
    }
    return cob(false);
  }
  freer.unregister();
  void (physical_packer_service_proxyAsyncProcessor::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const bool& _return) =
    &physical_packer_service_proxyAsyncProcessor::return_verify_packer_carrier_p;
  void (physical_packer_service_proxyAsyncProcessor::*throw_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &physical_packer_service_proxyAsyncProcessor::throw_verify_packer_carrier_p;
  iface_->verify_packer_carrier_p(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      ::apache::thrift::stdcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.session_id,
      args.addr,
      args.carrier,
      args.is_ssl);
}

void physical_packer_service_proxyAsyncProcessor::return_verify_packer_carrier_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const bool& _return)
{
  physical_packer_service_proxy_verify_packer_carrier_p_presult result;
  result.success = const_cast<bool*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.verify_packer_carrier_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.verify_packer_carrier_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.verify_packer_carrier_p");
  }

  oprot->writeMessageBegin("verify_packer_carrier_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.verify_packer_carrier_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::throw_verify_packer_carrier_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.verify_packer_carrier_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.verify_packer_carrier_p");

  physical_packer_service_proxy_verify_packer_carrier_p_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.verify_packer_carrier_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("verify_packer_carrier_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.verify_packer_carrier_p");
  }

  oprot->writeMessageBegin("verify_packer_carrier_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.verify_packer_carrier_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::process_get_packer_host_detail_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  physical_packer_service_proxy_get_packer_host_detail_p_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.get_packer_host_detail_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.get_packer_host_detail_p");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.get_packer_host_detail_p");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.get_packer_host_detail_p", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.get_packer_host_detail_p");
    }
    return cob(false);
  }
  freer.unregister();
  void (physical_packer_service_proxyAsyncProcessor::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const physical_machine_info& _return) =
    &physical_packer_service_proxyAsyncProcessor::return_get_packer_host_detail_p;
  void (physical_packer_service_proxyAsyncProcessor::*throw_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &physical_packer_service_proxyAsyncProcessor::throw_get_packer_host_detail_p;
  iface_->get_packer_host_detail_p(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      ::apache::thrift::stdcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.session_id,
      args.addr,
      args.filter);
}

void physical_packer_service_proxyAsyncProcessor::return_get_packer_host_detail_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const physical_machine_info& _return)
{
  physical_packer_service_proxy_get_packer_host_detail_p_presult result;
  result.success = const_cast<physical_machine_info*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.get_packer_host_detail_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.get_packer_host_detail_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.get_packer_host_detail_p");
  }

  oprot->writeMessageBegin("get_packer_host_detail_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.get_packer_host_detail_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::throw_get_packer_host_detail_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.get_packer_host_detail_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.get_packer_host_detail_p");

  physical_packer_service_proxy_get_packer_host_detail_p_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.get_packer_host_detail_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("get_packer_host_detail_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.get_packer_host_detail_p");
  }

  oprot->writeMessageBegin("get_packer_host_detail_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.get_packer_host_detail_p", bytes);
  }
  return cob(true);
}

::apache::thrift::stdcxx::shared_ptr< ::apache::thrift::async::TAsyncProcessor > physical_packer_service_proxyAsyncProcessorFactory::getProcessor(const ::apache::thrift::TConnectionInfo& connInfo) {
  ::apache::thrift::ReleaseHandler< physical_packer_service_proxyCobSvIfFactory > cleanup(handlerFactory_);
  ::apache::thrift::stdcxx::shared_ptr< physical_packer_service_proxyCobSvIf > handler(handlerFactory_->getHandler(connInfo), cleanup);
  ::apache::thrift::stdcxx::shared_ptr< ::apache::thrift::async::TAsyncProcessor > processor(new physical_packer_service_proxyAsyncProcessor(handler));
  return processor;
}

}} // namespace

