/**
 * Autogenerated by Thrift Compiler (0.12.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "saasame_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace saasame { namespace transport {

int _kenumerate_disk_filter_styleValues[] = {
  enumerate_disk_filter_style::ALL_DISK,
  enumerate_disk_filter_style::UNINITIALIZED_DISK
};
const char* _kenumerate_disk_filter_styleNames[] = {
  "ALL_DISK",
  "UNINITIALIZED_DISK"
};
const std::map<int, const char*> _enumerate_disk_filter_style_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kenumerate_disk_filter_styleValues, _kenumerate_disk_filter_styleNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const enumerate_disk_filter_style::type& val) {
  std::map<int, const char*>::const_iterator it = _enumerate_disk_filter_style_VALUES_TO_NAMES.find(val);
  if (it != _enumerate_disk_filter_style_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kmachine_detail_filterValues[] = {
  machine_detail_filter::FULL,
  machine_detail_filter::SIMPLE
};
const char* _kmachine_detail_filterNames[] = {
  "FULL",
  "SIMPLE"
};
const std::map<int, const char*> _machine_detail_filter_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kmachine_detail_filterValues, _kmachine_detail_filterNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const machine_detail_filter::type& val) {
  std::map<int, const char*>::const_iterator it = _machine_detail_filter_VALUES_TO_NAMES.find(val);
  if (it != _machine_detail_filter_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kpartition_styleValues[] = {
  partition_style::PARTITION_UNKNOWN,
  partition_style::PARTITION_MBR,
  partition_style::PARTITION_GPT
};
const char* _kpartition_styleNames[] = {
  "PARTITION_UNKNOWN",
  "PARTITION_MBR",
  "PARTITION_GPT"
};
const std::map<int, const char*> _partition_style_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kpartition_styleValues, _kpartition_styleNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const partition_style::type& val) {
  std::map<int, const char*>::const_iterator it = _partition_style_VALUES_TO_NAMES.find(val);
  if (it != _partition_style_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kdrive_typeValues[] = {
  drive_type::DT_UNKNOWN,
  drive_type::DT_NO_ROOT_PATH,
  drive_type::DT_REMOVABLE,
  drive_type::DT_FIXED,
  drive_type::DT_REMOTE,
  drive_type::DT_CDROM,
  drive_type::DT_RAMDISK
};
const char* _kdrive_typeNames[] = {
  "DT_UNKNOWN",
  "DT_NO_ROOT_PATH",
  "DT_REMOVABLE",
  "DT_FIXED",
  "DT_REMOTE",
  "DT_CDROM",
  "DT_RAMDISK"
};
const std::map<int, const char*> _drive_type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kdrive_typeValues, _kdrive_typeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const drive_type::type& val) {
  std::map<int, const char*>::const_iterator it = _drive_type_VALUES_TO_NAMES.find(val);
  if (it != _drive_type_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kbus_typeValues[] = {
  bus_type::Unknown,
  bus_type::SCSI,
  bus_type::ATAPI,
  bus_type::ATA,
  bus_type::IEEE_1394,
  bus_type::SSA,
  bus_type::Fibre_Channel,
  bus_type::USB,
  bus_type::RAID,
  bus_type::iSCSI,
  bus_type::SAS,
  bus_type::SATA,
  bus_type::SD,
  bus_type::MMC,
  bus_type::Virtual,
  bus_type::File_Backed_Virtual,
  bus_type::Storage_Spaces,
  bus_type::NVMe
};
const char* _kbus_typeNames[] = {
  "Unknown",
  "SCSI",
  "ATAPI",
  "ATA",
  "IEEE_1394",
  "SSA",
  "Fibre_Channel",
  "USB",
  "RAID",
  "iSCSI",
  "SAS",
  "SATA",
  "SD",
  "MMC",
  "Virtual",
  "File_Backed_Virtual",
  "Storage_Spaces",
  "NVMe"
};
const std::map<int, const char*> _bus_type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(18, _kbus_typeValues, _kbus_typeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const bus_type::type& val) {
  std::map<int, const char*>::const_iterator it = _bus_type_VALUES_TO_NAMES.find(val);
  if (it != _bus_type_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _khv_vm_tools_statusValues[] = {
  hv_vm_tools_status::HV_VMTOOLS_UNKNOWN,
  hv_vm_tools_status::HV_VMTOOLS_OK,
  hv_vm_tools_status::HV_VMTOOLS_NOTINSTALLED,
  hv_vm_tools_status::HV_VMTOOLS_OLD,
  hv_vm_tools_status::HV_VMTOOLS_NOTRUNNING,
  hv_vm_tools_status::HV_VMTOOLS_NEEDUPGRADE,
  hv_vm_tools_status::HV_VMTOOLS_UNMANAGED,
  hv_vm_tools_status::HV_VMTOOLS_NEW,
  hv_vm_tools_status::HV_VMTOOLS_BLACKLISTED
};
const char* _khv_vm_tools_statusNames[] = {
  "HV_VMTOOLS_UNKNOWN",
  "HV_VMTOOLS_OK",
  "HV_VMTOOLS_NOTINSTALLED",
  "HV_VMTOOLS_OLD",
  "HV_VMTOOLS_NOTRUNNING",
  "HV_VMTOOLS_NEEDUPGRADE",
  "HV_VMTOOLS_UNMANAGED",
  "HV_VMTOOLS_NEW",
  "HV_VMTOOLS_BLACKLISTED"
};
const std::map<int, const char*> _hv_vm_tools_status_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(9, _khv_vm_tools_statusValues, _khv_vm_tools_statusNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const hv_vm_tools_status::type& val) {
  std::map<int, const char*>::const_iterator it = _hv_vm_tools_status_VALUES_TO_NAMES.find(val);
  if (it != _hv_vm_tools_status_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _khv_vm_power_stateValues[] = {
  hv_vm_power_state::HV_VMPOWER_UNKNOWN,
  hv_vm_power_state::HV_VMPOWER_ON,
  hv_vm_power_state::HV_VMPOWER_OFF,
  hv_vm_power_state::HV_VMPOWER_SUSPENDED
};
const char* _khv_vm_power_stateNames[] = {
  "HV_VMPOWER_UNKNOWN",
  "HV_VMPOWER_ON",
  "HV_VMPOWER_OFF",
  "HV_VMPOWER_SUSPENDED"
};
const std::map<int, const char*> _hv_vm_power_state_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _khv_vm_power_stateValues, _khv_vm_power_stateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const hv_vm_power_state::type& val) {
  std::map<int, const char*>::const_iterator it = _hv_vm_power_state_VALUES_TO_NAMES.find(val);
  if (it != _hv_vm_power_state_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _khv_vm_connection_stateValues[] = {
  hv_vm_connection_state::HV_VMCONNECT_UNKNOWN,
  hv_vm_connection_state::HV_VMCONNECT_CONNECTED,
  hv_vm_connection_state::HV_VMCONNECT_DISCONNECTED,
  hv_vm_connection_state::HV_VMCONNECT_INACCESSIBLE,
  hv_vm_connection_state::HV_VMCONNECT_INVALID,
  hv_vm_connection_state::HV_VMCONNECT_ORPHANED
};
const char* _khv_vm_connection_stateNames[] = {
  "HV_VMCONNECT_UNKNOWN",
  "HV_VMCONNECT_CONNECTED",
  "HV_VMCONNECT_DISCONNECTED",
  "HV_VMCONNECT_INACCESSIBLE",
  "HV_VMCONNECT_INVALID",
  "HV_VMCONNECT_ORPHANED"
};
const std::map<int, const char*> _hv_vm_connection_state_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _khv_vm_connection_stateValues, _khv_vm_connection_stateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const hv_vm_connection_state::type& val) {
  std::map<int, const char*>::const_iterator it = _hv_vm_connection_state_VALUES_TO_NAMES.find(val);
  if (it != _hv_vm_connection_state_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _khv_host_power_stateValues[] = {
  hv_host_power_state::HV_HOSTPOWER_UNKNOWN,
  hv_host_power_state::HV_HOSTPOWER_ON,
  hv_host_power_state::HV_HOSTPOWER_OFF,
  hv_host_power_state::HV_HOSTPOWER_STANDBY
};
const char* _khv_host_power_stateNames[] = {
  "HV_HOSTPOWER_UNKNOWN",
  "HV_HOSTPOWER_ON",
  "HV_HOSTPOWER_OFF",
  "HV_HOSTPOWER_STANDBY"
};
const std::map<int, const char*> _hv_host_power_state_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _khv_host_power_stateValues, _khv_host_power_stateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const hv_host_power_state::type& val) {
  std::map<int, const char*>::const_iterator it = _hv_host_power_state_VALUES_TO_NAMES.find(val);
  if (it != _hv_host_power_state_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _khv_connection_typeValues[] = {
  hv_connection_type::HV_CONNECTION_TYPE_UNKNOWN,
  hv_connection_type::HV_CONNECTION_TYPE_VCENTER,
  hv_connection_type::HV_CONNECTION_TYPE_HOST
};
const char* _khv_connection_typeNames[] = {
  "HV_CONNECTION_TYPE_UNKNOWN",
  "HV_CONNECTION_TYPE_VCENTER",
  "HV_CONNECTION_TYPE_HOST"
};
const std::map<int, const char*> _hv_connection_type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _khv_connection_typeValues, _khv_connection_typeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const hv_connection_type::type& val) {
  std::map<int, const char*>::const_iterator it = _hv_connection_type_VALUES_TO_NAMES.find(val);
  if (it != _hv_connection_type_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _khv_guest_os_typeValues[] = {
  hv_guest_os_type::HV_OS_UNKNOWN,
  hv_guest_os_type::HV_OS_WINDOWS,
  hv_guest_os_type::HV_OS_LINUX
};
const char* _khv_guest_os_typeNames[] = {
  "HV_OS_UNKNOWN",
  "HV_OS_WINDOWS",
  "HV_OS_LINUX"
};
const std::map<int, const char*> _hv_guest_os_type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _khv_guest_os_typeValues, _khv_guest_os_typeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const hv_guest_os_type::type& val) {
  std::map<int, const char*>::const_iterator it = _hv_guest_os_type_VALUES_TO_NAMES.find(val);
  if (it != _hv_guest_os_type_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _khv_controller_typeValues[] = {
  hv_controller_type::HV_CTRL_ANY,
  hv_controller_type::HV_CTRL_IDE,
  hv_controller_type::HV_CTRL_PARA_VIRT_SCSI,
  hv_controller_type::HV_CTRL_BUS_LOGIC,
  hv_controller_type::HV_CTRL_LSI_LOGIC,
  hv_controller_type::HV_CTRL_LSI_LOGIC_SAS
};
const char* _khv_controller_typeNames[] = {
  "HV_CTRL_ANY",
  "HV_CTRL_IDE",
  "HV_CTRL_PARA_VIRT_SCSI",
  "HV_CTRL_BUS_LOGIC",
  "HV_CTRL_LSI_LOGIC",
  "HV_CTRL_LSI_LOGIC_SAS"
};
const std::map<int, const char*> _hv_controller_type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _khv_controller_typeValues, _khv_controller_typeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const hv_controller_type::type& val) {
  std::map<int, const char*>::const_iterator it = _hv_controller_type_VALUES_TO_NAMES.find(val);
  if (it != _hv_controller_type_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _khv_vm_firmwareValues[] = {
  hv_vm_firmware::HV_VM_FIRMWARE_BIOS,
  hv_vm_firmware::HV_VM_FIRMWARE_EFI
};
const char* _khv_vm_firmwareNames[] = {
  "HV_VM_FIRMWARE_BIOS",
  "HV_VM_FIRMWARE_EFI"
};
const std::map<int, const char*> _hv_vm_firmware_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _khv_vm_firmwareValues, _khv_vm_firmwareNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const hv_vm_firmware::type& val) {
  std::map<int, const char*>::const_iterator it = _hv_vm_firmware_VALUES_TO_NAMES.find(val);
  if (it != _hv_vm_firmware_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kjob_typeValues[] = {
  job_type::physical_packer_job_type,
  job_type::virtual_packer_job_type,
  job_type::physical_transport_type,
  job_type::virtual_transport_type,
  job_type::loader_job_type,
  job_type::launcher_job_type,
  job_type::winpe_packer_job_type,
  job_type::winpe_transport_job_type
};
const char* _kjob_typeNames[] = {
  "physical_packer_job_type",
  "virtual_packer_job_type",
  "physical_transport_type",
  "virtual_transport_type",
  "loader_job_type",
  "launcher_job_type",
  "winpe_packer_job_type",
  "winpe_transport_job_type"
};
const std::map<int, const char*> _job_type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(8, _kjob_typeValues, _kjob_typeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const job_type::type& val) {
  std::map<int, const char*>::const_iterator it = _job_type_VALUES_TO_NAMES.find(val);
  if (it != _job_type_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kjob_trigger_typeValues[] = {
  job_trigger_type::runonce_trigger,
  job_trigger_type::interval_trigger
};
const char* _kjob_trigger_typeNames[] = {
  "runonce_trigger",
  "interval_trigger"
};
const std::map<int, const char*> _job_trigger_type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kjob_trigger_typeValues, _kjob_trigger_typeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const job_trigger_type::type& val) {
  std::map<int, const char*>::const_iterator it = _job_trigger_type_VALUES_TO_NAMES.find(val);
  if (it != _job_trigger_type_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kjob_stateValues[] = {
  job_state::job_state_none,
  job_state::job_state_initialed,
  job_state::job_state_replicating,
  job_state::job_state_replicated,
  job_state::job_state_converting,
  job_state::job_state_finished,
  job_state::job_state_sche_completed,
  job_state::job_state_recover,
  job_state::job_state_resizing,
  job_state::job_state_uploading,
  job_state::job_state_upload_completed,
  job_state::job_state_discard
};
const char* _kjob_stateNames[] = {
  "job_state_none",
  "job_state_initialed",
  "job_state_replicating",
  "job_state_replicated",
  "job_state_converting",
  "job_state_finished",
  "job_state_sche_completed",
  "job_state_recover",
  "job_state_resizing",
  "job_state_uploading",
  "job_state_upload_completed",
  "job_state_discard"
};
const std::map<int, const char*> _job_state_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(12, _kjob_stateValues, _kjob_stateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const job_state::type& val) {
  std::map<int, const char*>::const_iterator it = _job_state_VALUES_TO_NAMES.find(val);
  if (it != _job_state_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kerror_codesValues[] = {
  error_codes::SAASAME_S_OK,
  error_codes::SAASAME_NOERROR,
  error_codes::SAASAME_E_FAIL,
  error_codes::SAASAME_E_INITIAL_FAIL,
  error_codes::SAASAME_E_DISK_FULL,
  error_codes::SAASAME_E_INVALID_ARG,
  error_codes::SAASAME_E_INVALID_AUTHENTICATION,
  error_codes::SAASAME_E_INTERNAL_FAIL,
  error_codes::SAASAME_E_CANNOT_CONNECT_TO_HOST,
  error_codes::SAASAME_E_QUEUE_FULL,
  error_codes::SAASAME_E_INVALID_LICENSE_KEY,
  error_codes::SAASAME_E_INVALID_LICENSE,
  error_codes::SAASAME_E_JOB_CREATE_FAIL,
  error_codes::SAASAME_E_JOB_REMOVE_FAIL,
  error_codes::SAASAME_E_JOB_NOTFOUND,
  error_codes::SAASAME_E_JOB_CONFIG_NOTFOUND,
  error_codes::SAASAME_E_JOB_STATUS_NOTFOUND,
  error_codes::SAASAME_E_JOB_CANCELLED,
  error_codes::SAASAME_E_JOB_CONVERT_FAIL,
  error_codes::SAASAME_E_JOB_REPLICATE_FAIL,
  error_codes::SAASAME_E_JOB_ID_DUPLICATED,
  error_codes::SAASAME_E_JOB_INTERRUPTED,
  error_codes::SAASAME_E_JOB_RUNNING,
  error_codes::SAASAME_E_JOB_RESPONSE,
  error_codes::SAASAME_E_PHYSICAL_CONFIG_FAILED,
  error_codes::SAASAME_E_VIRTUAL_VM_NOTFOUND,
  error_codes::SAASAME_E_IMAGE_NOTFOUND,
  error_codes::SAASAME_E_IMAGE_CREATE_FAIL,
  error_codes::SAASAME_E_IMAGE_OPEN_FAIL,
  error_codes::SAASAME_E_IMAGE_READ,
  error_codes::SAASAME_E_IMAGE_WRITE,
  error_codes::SAASAME_E_IMAGE_OUTOFRANGE,
  error_codes::SAASAME_E_IMAGE_ATTACH_FAIL,
  error_codes::SAASAME_E_IMAGE_DETACH_FAIL,
  error_codes::SAASAME_E_IMAGE_PROPERTY_FAIL,
  error_codes::SAASAME_E_SNAPSHOT_CREATE_FAIL,
  error_codes::SAASAME_E_SNAPSHOT_REMOVE_FAIL,
  error_codes::SAASAME_E_SNAPSHOT_NOTFOUND,
  error_codes::SAASAME_E_SNAPSHOT_INVALID
};
const char* _kerror_codesNames[] = {
  "SAASAME_S_OK",
  "SAASAME_NOERROR",
  "SAASAME_E_FAIL",
  "SAASAME_E_INITIAL_FAIL",
  "SAASAME_E_DISK_FULL",
  "SAASAME_E_INVALID_ARG",
  "SAASAME_E_INVALID_AUTHENTICATION",
  "SAASAME_E_INTERNAL_FAIL",
  "SAASAME_E_CANNOT_CONNECT_TO_HOST",
  "SAASAME_E_QUEUE_FULL",
  "SAASAME_E_INVALID_LICENSE_KEY",
  "SAASAME_E_INVALID_LICENSE",
  "SAASAME_E_JOB_CREATE_FAIL",
  "SAASAME_E_JOB_REMOVE_FAIL",
  "SAASAME_E_JOB_NOTFOUND",
  "SAASAME_E_JOB_CONFIG_NOTFOUND",
  "SAASAME_E_JOB_STATUS_NOTFOUND",
  "SAASAME_E_JOB_CANCELLED",
  "SAASAME_E_JOB_CONVERT_FAIL",
  "SAASAME_E_JOB_REPLICATE_FAIL",
  "SAASAME_E_JOB_ID_DUPLICATED",
  "SAASAME_E_JOB_INTERRUPTED",
  "SAASAME_E_JOB_RUNNING",
  "SAASAME_E_JOB_RESPONSE",
  "SAASAME_E_PHYSICAL_CONFIG_FAILED",
  "SAASAME_E_VIRTUAL_VM_NOTFOUND",
  "SAASAME_E_IMAGE_NOTFOUND",
  "SAASAME_E_IMAGE_CREATE_FAIL",
  "SAASAME_E_IMAGE_OPEN_FAIL",
  "SAASAME_E_IMAGE_READ",
  "SAASAME_E_IMAGE_WRITE",
  "SAASAME_E_IMAGE_OUTOFRANGE",
  "SAASAME_E_IMAGE_ATTACH_FAIL",
  "SAASAME_E_IMAGE_DETACH_FAIL",
  "SAASAME_E_IMAGE_PROPERTY_FAIL",
  "SAASAME_E_SNAPSHOT_CREATE_FAIL",
  "SAASAME_E_SNAPSHOT_REMOVE_FAIL",
  "SAASAME_E_SNAPSHOT_NOTFOUND",
  "SAASAME_E_SNAPSHOT_INVALID"
};
const std::map<int, const char*> _error_codes_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(39, _kerror_codesValues, _kerror_codesNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const error_codes::type& val) {
  std::map<int, const char*>::const_iterator it = _error_codes_VALUES_TO_NAMES.find(val);
  if (it != _error_codes_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kconnection_typeValues[] = {
  connection_type::LOCAL_FOLDER,
  connection_type::NFS_FOLDER,
  connection_type::CIFS_FOLDER,
  connection_type::WEBDAV,
  connection_type::S3_BUCKET,
  connection_type::WEBDAV_WITH_SSL,
  connection_type::WEBDAV_EX,
  connection_type::S3_BUCKET_EX,
  connection_type::LOCAL_FOLDER_EX
};
const char* _kconnection_typeNames[] = {
  "LOCAL_FOLDER",
  "NFS_FOLDER",
  "CIFS_FOLDER",
  "WEBDAV",
  "S3_BUCKET",
  "WEBDAV_WITH_SSL",
  "WEBDAV_EX",
  "S3_BUCKET_EX",
  "LOCAL_FOLDER_EX"
};
const std::map<int, const char*> _connection_type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(9, _kconnection_typeValues, _kconnection_typeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const connection_type::type& val) {
  std::map<int, const char*>::const_iterator it = _connection_type_VALUES_TO_NAMES.find(val);
  if (it != _connection_type_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kaws_regionValues[] = {
  aws_region::US_EAST_1,
  aws_region::US_WEST_1,
  aws_region::US_WEST_2,
  aws_region::EU_WEST_1,
  aws_region::EU_CENTRAL_1,
  aws_region::AP_SOUTHEAST_1,
  aws_region::AP_SOUTHEAST_2,
  aws_region::AP_NORTHEAST_1,
  aws_region::AP_NORTHEAST_2,
  aws_region::SA_EAST_1
};
const char* _kaws_regionNames[] = {
  "US_EAST_1",
  "US_WEST_1",
  "US_WEST_2",
  "EU_WEST_1",
  "EU_CENTRAL_1",
  "AP_SOUTHEAST_1",
  "AP_SOUTHEAST_2",
  "AP_NORTHEAST_1",
  "AP_NORTHEAST_2",
  "SA_EAST_1"
};
const std::map<int, const char*> _aws_region_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(10, _kaws_regionValues, _kaws_regionNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const aws_region::type& val) {
  std::map<int, const char*>::const_iterator it = _aws_region_VALUES_TO_NAMES.find(val);
  if (it != _aws_region_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kcreate_image_optionValues[] = {
  create_image_option::VERSION_1,
  create_image_option::VERSION_2
};
const char* _kcreate_image_optionNames[] = {
  "VERSION_1",
  "VERSION_2"
};
const std::map<int, const char*> _create_image_option_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kcreate_image_optionValues, _kcreate_image_optionNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const create_image_option::type& val) {
  std::map<int, const char*>::const_iterator it = _create_image_option_VALUES_TO_NAMES.find(val);
  if (it != _create_image_option_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kdisk_detect_typeValues[] = {
  disk_detect_type::SCSI_ADDRESS,
  disk_detect_type::LINUX_DEVICE_PATH,
  disk_detect_type::SERIAL_NUMBER,
  disk_detect_type::EXPORT_IMAGE,
  disk_detect_type::UNIQUE_ID,
  disk_detect_type::CUSTOMIZED_ID,
  disk_detect_type::AZURE_BLOB,
  disk_detect_type::VMWARE_VADP
};
const char* _kdisk_detect_typeNames[] = {
  "SCSI_ADDRESS",
  "LINUX_DEVICE_PATH",
  "SERIAL_NUMBER",
  "EXPORT_IMAGE",
  "UNIQUE_ID",
  "CUSTOMIZED_ID",
  "AZURE_BLOB",
  "VMWARE_VADP"
};
const std::map<int, const char*> _disk_detect_type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(8, _kdisk_detect_typeValues, _kdisk_detect_typeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const disk_detect_type::type& val) {
  std::map<int, const char*>::const_iterator it = _disk_detect_type_VALUES_TO_NAMES.find(val);
  if (it != _disk_detect_type_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kvirtual_disk_typeValues[] = {
  virtual_disk_type::VHD,
  virtual_disk_type::VHDX
};
const char* _kvirtual_disk_typeNames[] = {
  "VHD",
  "VHDX"
};
const std::map<int, const char*> _virtual_disk_type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kvirtual_disk_typeValues, _kvirtual_disk_typeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const virtual_disk_type::type& val) {
  std::map<int, const char*>::const_iterator it = _virtual_disk_type_VALUES_TO_NAMES.find(val);
  if (it != _virtual_disk_type_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kconversion_typeValues[] = {
  conversion_type::ANY_TO_ANY,
  conversion_type::OPENSTACK,
  conversion_type::XEN,
  conversion_type::VMWARE,
  conversion_type::HYPERV,
  conversion_type::AUTO
};
const char* _kconversion_typeNames[] = {
  "ANY_TO_ANY",
  "OPENSTACK",
  "XEN",
  "VMWARE",
  "HYPERV",
  "AUTO"
};
const std::map<int, const char*> _conversion_type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kconversion_typeValues, _kconversion_typeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const conversion_type::type& val) {
  std::map<int, const char*>::const_iterator it = _conversion_type_VALUES_TO_NAMES.find(val);
  if (it != _conversion_type_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _krecovery_typeValues[] = {
  recovery_type::TEST_RECOVERY,
  recovery_type::DISASTER_RECOVERY,
  recovery_type::MIGRATION_RECOVERY
};
const char* _krecovery_typeNames[] = {
  "TEST_RECOVERY",
  "DISASTER_RECOVERY",
  "MIGRATION_RECOVERY"
};
const std::map<int, const char*> _recovery_type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _krecovery_typeValues, _krecovery_typeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const recovery_type::type& val) {
  std::map<int, const char*>::const_iterator it = _recovery_type_VALUES_TO_NAMES.find(val);
  if (it != _recovery_type_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kextra_options_typeValues[] = {
  extra_options_type::UNKNOWN,
  extra_options_type::ALIYUN,
  extra_options_type::TENCENT
};
const char* _kextra_options_typeNames[] = {
  "UNKNOWN",
  "ALIYUN",
  "TENCENT"
};
const std::map<int, const char*> _extra_options_type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kextra_options_typeValues, _kextra_options_typeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const extra_options_type::type& val) {
  std::map<int, const char*>::const_iterator it = _extra_options_type_VALUES_TO_NAMES.find(val);
  if (it != _extra_options_type_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}


disk_info::~disk_info() throw() {
}


void disk_info::__set_boot_from_disk(const bool val) {
  this->boot_from_disk = val;
__isset.boot_from_disk = true;
}

void disk_info::__set_bus_type(const bus_type::type val) {
  this->bus_type = val;
__isset.bus_type = true;
}

void disk_info::__set_cluster_owner(const std::string& val) {
  this->cluster_owner = val;
__isset.cluster_owner = true;
}

void disk_info::__set_cylinders(const int64_t val) {
  this->cylinders = val;
__isset.cylinders = true;
}

void disk_info::__set_friendly_name(const std::string& val) {
  this->friendly_name = val;
__isset.friendly_name = true;
}

void disk_info::__set_guid(const std::string& val) {
  this->guid = val;
__isset.guid = true;
}

void disk_info::__set_tracks_per_cylinder(const int32_t val) {
  this->tracks_per_cylinder = val;
__isset.tracks_per_cylinder = true;
}

void disk_info::__set_is_boot(const bool val) {
  this->is_boot = val;
__isset.is_boot = true;
}

void disk_info::__set_is_clustered(const bool val) {
  this->is_clustered = val;
__isset.is_clustered = true;
}

void disk_info::__set_is_offline(const bool val) {
  this->is_offline = val;
__isset.is_offline = true;
}

void disk_info::__set_is_readonly(const bool val) {
  this->is_readonly = val;
__isset.is_readonly = true;
}

void disk_info::__set_is_snapshot(const bool val) {
  this->is_snapshot = val;
__isset.is_snapshot = true;
}

void disk_info::__set_is_system(const bool val) {
  this->is_system = val;
__isset.is_system = true;
}

void disk_info::__set_location(const std::string& val) {
  this->location = val;
__isset.location = true;
}

void disk_info::__set_logical_sector_size(const int32_t val) {
  this->logical_sector_size = val;
__isset.logical_sector_size = true;
}

void disk_info::__set_manufacturer(const std::string& val) {
  this->manufacturer = val;
__isset.manufacturer = true;
}

void disk_info::__set_model(const std::string& val) {
  this->model = val;
__isset.model = true;
}

void disk_info::__set_number(const int32_t val) {
  this->number = val;
__isset.number = true;
}

void disk_info::__set_number_of_partitions(const int32_t val) {
  this->number_of_partitions = val;
__isset.number_of_partitions = true;
}

void disk_info::__set_offline_reason(const int16_t val) {
  this->offline_reason = val;
__isset.offline_reason = true;
}

void disk_info::__set_partition_style(const partition_style::type val) {
  this->partition_style = val;
__isset.partition_style = true;
}

void disk_info::__set_path(const std::string& val) {
  this->path = val;
__isset.path = true;
}

void disk_info::__set_physical_sector_size(const int32_t val) {
  this->physical_sector_size = val;
__isset.physical_sector_size = true;
}

void disk_info::__set_sectors_per_track(const int32_t val) {
  this->sectors_per_track = val;
__isset.sectors_per_track = true;
}

void disk_info::__set_serial_number(const std::string& val) {
  this->serial_number = val;
__isset.serial_number = true;
}

void disk_info::__set_signature(const int32_t val) {
  this->signature = val;
__isset.signature = true;
}

void disk_info::__set_size(const int64_t val) {
  this->size = val;
__isset.size = true;
}

void disk_info::__set_uri(const std::string& val) {
  this->uri = val;
__isset.uri = true;
}

void disk_info::__set_scsi_bus(const int32_t val) {
  this->scsi_bus = val;
__isset.scsi_bus = true;
}

void disk_info::__set_scsi_logical_unit(const int16_t val) {
  this->scsi_logical_unit = val;
__isset.scsi_logical_unit = true;
}

void disk_info::__set_scsi_port(const int16_t val) {
  this->scsi_port = val;
__isset.scsi_port = true;
}

void disk_info::__set_scsi_target_id(const int16_t val) {
  this->scsi_target_id = val;
__isset.scsi_target_id = true;
}

void disk_info::__set_unique_id(const std::string& val) {
  this->unique_id = val;
__isset.unique_id = true;
}

void disk_info::__set_unique_id_format(const int16_t val) {
  this->unique_id_format = val;
__isset.unique_id_format = true;
}

void disk_info::__set_customized_id(const std::string& val) {
  this->customized_id = val;
__isset.customized_id = true;
}
std::ostream& operator<<(std::ostream& out, const disk_info& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t disk_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->boot_from_disk);
          this->__isset.boot_from_disk = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->bus_type = (bus_type::type)ecast0;
          this->__isset.bus_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cluster_owner);
          this->__isset.cluster_owner = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cylinders);
          this->__isset.cylinders = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->friendly_name);
          this->__isset.friendly_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guid);
          this->__isset.guid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->tracks_per_cylinder);
          this->__isset.tracks_per_cylinder = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_boot);
          this->__isset.is_boot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_clustered);
          this->__isset.is_clustered = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_offline);
          this->__isset.is_offline = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_readonly);
          this->__isset.is_readonly = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_snapshot);
          this->__isset.is_snapshot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_system);
          this->__isset.is_system = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->location);
          this->__isset.location = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->logical_sector_size);
          this->__isset.logical_sector_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->manufacturer);
          this->__isset.manufacturer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->model);
          this->__isset.model = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->number);
          this->__isset.number = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->number_of_partitions);
          this->__isset.number_of_partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->offline_reason);
          this->__isset.offline_reason = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1;
          xfer += iprot->readI32(ecast1);
          this->partition_style = (partition_style::type)ecast1;
          this->__isset.partition_style = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->path);
          this->__isset.path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->physical_sector_size);
          this->__isset.physical_sector_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sectors_per_track);
          this->__isset.sectors_per_track = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->serial_number);
          this->__isset.serial_number = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 26:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->signature);
          this->__isset.signature = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 27:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->size);
          this->__isset.size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 28:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->uri);
          this->__isset.uri = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 29:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->scsi_bus);
          this->__isset.scsi_bus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->scsi_logical_unit);
          this->__isset.scsi_logical_unit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 31:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->scsi_port);
          this->__isset.scsi_port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 32:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->scsi_target_id);
          this->__isset.scsi_target_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 33:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->unique_id);
          this->__isset.unique_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 34:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->unique_id_format);
          this->__isset.unique_id_format = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 35:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->customized_id);
          this->__isset.customized_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t disk_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("disk_info");

  if (this->__isset.boot_from_disk) {
    xfer += oprot->writeFieldBegin("boot_from_disk", ::apache::thrift::protocol::T_BOOL, 1);
    xfer += oprot->writeBool(this->boot_from_disk);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.bus_type) {
    xfer += oprot->writeFieldBegin("bus_type", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32((int32_t)this->bus_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_owner) {
    xfer += oprot->writeFieldBegin("cluster_owner", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->cluster_owner);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cylinders) {
    xfer += oprot->writeFieldBegin("cylinders", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->cylinders);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.friendly_name) {
    xfer += oprot->writeFieldBegin("friendly_name", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->friendly_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.guid) {
    xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->guid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tracks_per_cylinder) {
    xfer += oprot->writeFieldBegin("tracks_per_cylinder", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32(this->tracks_per_cylinder);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_boot) {
    xfer += oprot->writeFieldBegin("is_boot", ::apache::thrift::protocol::T_BOOL, 8);
    xfer += oprot->writeBool(this->is_boot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_clustered) {
    xfer += oprot->writeFieldBegin("is_clustered", ::apache::thrift::protocol::T_BOOL, 9);
    xfer += oprot->writeBool(this->is_clustered);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_offline) {
    xfer += oprot->writeFieldBegin("is_offline", ::apache::thrift::protocol::T_BOOL, 10);
    xfer += oprot->writeBool(this->is_offline);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_readonly) {
    xfer += oprot->writeFieldBegin("is_readonly", ::apache::thrift::protocol::T_BOOL, 11);
    xfer += oprot->writeBool(this->is_readonly);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_snapshot) {
    xfer += oprot->writeFieldBegin("is_snapshot", ::apache::thrift::protocol::T_BOOL, 12);
    xfer += oprot->writeBool(this->is_snapshot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_system) {
    xfer += oprot->writeFieldBegin("is_system", ::apache::thrift::protocol::T_BOOL, 13);
    xfer += oprot->writeBool(this->is_system);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.location) {
    xfer += oprot->writeFieldBegin("location", ::apache::thrift::protocol::T_STRING, 14);
    xfer += oprot->writeString(this->location);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.logical_sector_size) {
    xfer += oprot->writeFieldBegin("logical_sector_size", ::apache::thrift::protocol::T_I32, 15);
    xfer += oprot->writeI32(this->logical_sector_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.manufacturer) {
    xfer += oprot->writeFieldBegin("manufacturer", ::apache::thrift::protocol::T_STRING, 16);
    xfer += oprot->writeString(this->manufacturer);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.model) {
    xfer += oprot->writeFieldBegin("model", ::apache::thrift::protocol::T_STRING, 17);
    xfer += oprot->writeString(this->model);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.number) {
    xfer += oprot->writeFieldBegin("number", ::apache::thrift::protocol::T_I32, 18);
    xfer += oprot->writeI32(this->number);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.number_of_partitions) {
    xfer += oprot->writeFieldBegin("number_of_partitions", ::apache::thrift::protocol::T_I32, 19);
    xfer += oprot->writeI32(this->number_of_partitions);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.offline_reason) {
    xfer += oprot->writeFieldBegin("offline_reason", ::apache::thrift::protocol::T_I16, 20);
    xfer += oprot->writeI16(this->offline_reason);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partition_style) {
    xfer += oprot->writeFieldBegin("partition_style", ::apache::thrift::protocol::T_I32, 21);
    xfer += oprot->writeI32((int32_t)this->partition_style);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.path) {
    xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_STRING, 22);
    xfer += oprot->writeString(this->path);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.physical_sector_size) {
    xfer += oprot->writeFieldBegin("physical_sector_size", ::apache::thrift::protocol::T_I32, 23);
    xfer += oprot->writeI32(this->physical_sector_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sectors_per_track) {
    xfer += oprot->writeFieldBegin("sectors_per_track", ::apache::thrift::protocol::T_I32, 24);
    xfer += oprot->writeI32(this->sectors_per_track);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.serial_number) {
    xfer += oprot->writeFieldBegin("serial_number", ::apache::thrift::protocol::T_STRING, 25);
    xfer += oprot->writeString(this->serial_number);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.signature) {
    xfer += oprot->writeFieldBegin("signature", ::apache::thrift::protocol::T_I32, 26);
    xfer += oprot->writeI32(this->signature);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.size) {
    xfer += oprot->writeFieldBegin("size", ::apache::thrift::protocol::T_I64, 27);
    xfer += oprot->writeI64(this->size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.uri) {
    xfer += oprot->writeFieldBegin("uri", ::apache::thrift::protocol::T_STRING, 28);
    xfer += oprot->writeString(this->uri);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.scsi_bus) {
    xfer += oprot->writeFieldBegin("scsi_bus", ::apache::thrift::protocol::T_I32, 29);
    xfer += oprot->writeI32(this->scsi_bus);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.scsi_logical_unit) {
    xfer += oprot->writeFieldBegin("scsi_logical_unit", ::apache::thrift::protocol::T_I16, 30);
    xfer += oprot->writeI16(this->scsi_logical_unit);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.scsi_port) {
    xfer += oprot->writeFieldBegin("scsi_port", ::apache::thrift::protocol::T_I16, 31);
    xfer += oprot->writeI16(this->scsi_port);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.scsi_target_id) {
    xfer += oprot->writeFieldBegin("scsi_target_id", ::apache::thrift::protocol::T_I16, 32);
    xfer += oprot->writeI16(this->scsi_target_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.unique_id) {
    xfer += oprot->writeFieldBegin("unique_id", ::apache::thrift::protocol::T_STRING, 33);
    xfer += oprot->writeString(this->unique_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.unique_id_format) {
    xfer += oprot->writeFieldBegin("unique_id_format", ::apache::thrift::protocol::T_I16, 34);
    xfer += oprot->writeI16(this->unique_id_format);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.customized_id) {
    xfer += oprot->writeFieldBegin("customized_id", ::apache::thrift::protocol::T_STRING, 35);
    xfer += oprot->writeString(this->customized_id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(disk_info &a, disk_info &b) {
  using ::std::swap;
  swap(a.boot_from_disk, b.boot_from_disk);
  swap(a.bus_type, b.bus_type);
  swap(a.cluster_owner, b.cluster_owner);
  swap(a.cylinders, b.cylinders);
  swap(a.friendly_name, b.friendly_name);
  swap(a.guid, b.guid);
  swap(a.tracks_per_cylinder, b.tracks_per_cylinder);
  swap(a.is_boot, b.is_boot);
  swap(a.is_clustered, b.is_clustered);
  swap(a.is_offline, b.is_offline);
  swap(a.is_readonly, b.is_readonly);
  swap(a.is_snapshot, b.is_snapshot);
  swap(a.is_system, b.is_system);
  swap(a.location, b.location);
  swap(a.logical_sector_size, b.logical_sector_size);
  swap(a.manufacturer, b.manufacturer);
  swap(a.model, b.model);
  swap(a.number, b.number);
  swap(a.number_of_partitions, b.number_of_partitions);
  swap(a.offline_reason, b.offline_reason);
  swap(a.partition_style, b.partition_style);
  swap(a.path, b.path);
  swap(a.physical_sector_size, b.physical_sector_size);
  swap(a.sectors_per_track, b.sectors_per_track);
  swap(a.serial_number, b.serial_number);
  swap(a.signature, b.signature);
  swap(a.size, b.size);
  swap(a.uri, b.uri);
  swap(a.scsi_bus, b.scsi_bus);
  swap(a.scsi_logical_unit, b.scsi_logical_unit);
  swap(a.scsi_port, b.scsi_port);
  swap(a.scsi_target_id, b.scsi_target_id);
  swap(a.unique_id, b.unique_id);
  swap(a.unique_id_format, b.unique_id_format);
  swap(a.customized_id, b.customized_id);
  swap(a.__isset, b.__isset);
}

disk_info::disk_info(const disk_info& other2) {
  boot_from_disk = other2.boot_from_disk;
  bus_type = other2.bus_type;
  cluster_owner = other2.cluster_owner;
  cylinders = other2.cylinders;
  friendly_name = other2.friendly_name;
  guid = other2.guid;
  tracks_per_cylinder = other2.tracks_per_cylinder;
  is_boot = other2.is_boot;
  is_clustered = other2.is_clustered;
  is_offline = other2.is_offline;
  is_readonly = other2.is_readonly;
  is_snapshot = other2.is_snapshot;
  is_system = other2.is_system;
  location = other2.location;
  logical_sector_size = other2.logical_sector_size;
  manufacturer = other2.manufacturer;
  model = other2.model;
  number = other2.number;
  number_of_partitions = other2.number_of_partitions;
  offline_reason = other2.offline_reason;
  partition_style = other2.partition_style;
  path = other2.path;
  physical_sector_size = other2.physical_sector_size;
  sectors_per_track = other2.sectors_per_track;
  serial_number = other2.serial_number;
  signature = other2.signature;
  size = other2.size;
  uri = other2.uri;
  scsi_bus = other2.scsi_bus;
  scsi_logical_unit = other2.scsi_logical_unit;
  scsi_port = other2.scsi_port;
  scsi_target_id = other2.scsi_target_id;
  unique_id = other2.unique_id;
  unique_id_format = other2.unique_id_format;
  customized_id = other2.customized_id;
  __isset = other2.__isset;
}
disk_info& disk_info::operator=(const disk_info& other3) {
  boot_from_disk = other3.boot_from_disk;
  bus_type = other3.bus_type;
  cluster_owner = other3.cluster_owner;
  cylinders = other3.cylinders;
  friendly_name = other3.friendly_name;
  guid = other3.guid;
  tracks_per_cylinder = other3.tracks_per_cylinder;
  is_boot = other3.is_boot;
  is_clustered = other3.is_clustered;
  is_offline = other3.is_offline;
  is_readonly = other3.is_readonly;
  is_snapshot = other3.is_snapshot;
  is_system = other3.is_system;
  location = other3.location;
  logical_sector_size = other3.logical_sector_size;
  manufacturer = other3.manufacturer;
  model = other3.model;
  number = other3.number;
  number_of_partitions = other3.number_of_partitions;
  offline_reason = other3.offline_reason;
  partition_style = other3.partition_style;
  path = other3.path;
  physical_sector_size = other3.physical_sector_size;
  sectors_per_track = other3.sectors_per_track;
  serial_number = other3.serial_number;
  signature = other3.signature;
  size = other3.size;
  uri = other3.uri;
  scsi_bus = other3.scsi_bus;
  scsi_logical_unit = other3.scsi_logical_unit;
  scsi_port = other3.scsi_port;
  scsi_target_id = other3.scsi_target_id;
  unique_id = other3.unique_id;
  unique_id_format = other3.unique_id_format;
  customized_id = other3.customized_id;
  __isset = other3.__isset;
  return *this;
}
void disk_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "disk_info(";
  out << "boot_from_disk="; (__isset.boot_from_disk ? (out << to_string(boot_from_disk)) : (out << "<null>"));
  out << ", " << "bus_type="; (__isset.bus_type ? (out << to_string(bus_type)) : (out << "<null>"));
  out << ", " << "cluster_owner="; (__isset.cluster_owner ? (out << to_string(cluster_owner)) : (out << "<null>"));
  out << ", " << "cylinders="; (__isset.cylinders ? (out << to_string(cylinders)) : (out << "<null>"));
  out << ", " << "friendly_name="; (__isset.friendly_name ? (out << to_string(friendly_name)) : (out << "<null>"));
  out << ", " << "guid="; (__isset.guid ? (out << to_string(guid)) : (out << "<null>"));
  out << ", " << "tracks_per_cylinder="; (__isset.tracks_per_cylinder ? (out << to_string(tracks_per_cylinder)) : (out << "<null>"));
  out << ", " << "is_boot="; (__isset.is_boot ? (out << to_string(is_boot)) : (out << "<null>"));
  out << ", " << "is_clustered="; (__isset.is_clustered ? (out << to_string(is_clustered)) : (out << "<null>"));
  out << ", " << "is_offline="; (__isset.is_offline ? (out << to_string(is_offline)) : (out << "<null>"));
  out << ", " << "is_readonly="; (__isset.is_readonly ? (out << to_string(is_readonly)) : (out << "<null>"));
  out << ", " << "is_snapshot="; (__isset.is_snapshot ? (out << to_string(is_snapshot)) : (out << "<null>"));
  out << ", " << "is_system="; (__isset.is_system ? (out << to_string(is_system)) : (out << "<null>"));
  out << ", " << "location="; (__isset.location ? (out << to_string(location)) : (out << "<null>"));
  out << ", " << "logical_sector_size="; (__isset.logical_sector_size ? (out << to_string(logical_sector_size)) : (out << "<null>"));
  out << ", " << "manufacturer="; (__isset.manufacturer ? (out << to_string(manufacturer)) : (out << "<null>"));
  out << ", " << "model="; (__isset.model ? (out << to_string(model)) : (out << "<null>"));
  out << ", " << "number="; (__isset.number ? (out << to_string(number)) : (out << "<null>"));
  out << ", " << "number_of_partitions="; (__isset.number_of_partitions ? (out << to_string(number_of_partitions)) : (out << "<null>"));
  out << ", " << "offline_reason="; (__isset.offline_reason ? (out << to_string(offline_reason)) : (out << "<null>"));
  out << ", " << "partition_style="; (__isset.partition_style ? (out << to_string(partition_style)) : (out << "<null>"));
  out << ", " << "path="; (__isset.path ? (out << to_string(path)) : (out << "<null>"));
  out << ", " << "physical_sector_size="; (__isset.physical_sector_size ? (out << to_string(physical_sector_size)) : (out << "<null>"));
  out << ", " << "sectors_per_track="; (__isset.sectors_per_track ? (out << to_string(sectors_per_track)) : (out << "<null>"));
  out << ", " << "serial_number="; (__isset.serial_number ? (out << to_string(serial_number)) : (out << "<null>"));
  out << ", " << "signature="; (__isset.signature ? (out << to_string(signature)) : (out << "<null>"));
  out << ", " << "size="; (__isset.size ? (out << to_string(size)) : (out << "<null>"));
  out << ", " << "uri="; (__isset.uri ? (out << to_string(uri)) : (out << "<null>"));
  out << ", " << "scsi_bus="; (__isset.scsi_bus ? (out << to_string(scsi_bus)) : (out << "<null>"));
  out << ", " << "scsi_logical_unit="; (__isset.scsi_logical_unit ? (out << to_string(scsi_logical_unit)) : (out << "<null>"));
  out << ", " << "scsi_port="; (__isset.scsi_port ? (out << to_string(scsi_port)) : (out << "<null>"));
  out << ", " << "scsi_target_id="; (__isset.scsi_target_id ? (out << to_string(scsi_target_id)) : (out << "<null>"));
  out << ", " << "unique_id="; (__isset.unique_id ? (out << to_string(unique_id)) : (out << "<null>"));
  out << ", " << "unique_id_format="; (__isset.unique_id_format ? (out << to_string(unique_id_format)) : (out << "<null>"));
  out << ", " << "customized_id="; (__isset.customized_id ? (out << to_string(customized_id)) : (out << "<null>"));
  out << ")";
}


partition_info::~partition_info() throw() {
}


void partition_info::__set_access_paths(const std::set<std::string> & val) {
  this->access_paths = val;
__isset.access_paths = true;
}

void partition_info::__set_disk_number(const int32_t val) {
  this->disk_number = val;
__isset.disk_number = true;
}

void partition_info::__set_drive_letter(const std::string& val) {
  this->drive_letter = val;
__isset.drive_letter = true;
}

void partition_info::__set_gpt_type(const std::string& val) {
  this->gpt_type = val;
__isset.gpt_type = true;
}

void partition_info::__set_guid(const std::string& val) {
  this->guid = val;
__isset.guid = true;
}

void partition_info::__set_is_active(const bool val) {
  this->is_active = val;
__isset.is_active = true;
}

void partition_info::__set_is_boot(const bool val) {
  this->is_boot = val;
__isset.is_boot = true;
}

void partition_info::__set_is_hidden(const bool val) {
  this->is_hidden = val;
__isset.is_hidden = true;
}

void partition_info::__set_is_offline(const bool val) {
  this->is_offline = val;
__isset.is_offline = true;
}

void partition_info::__set_is_readonly(const bool val) {
  this->is_readonly = val;
__isset.is_readonly = true;
}

void partition_info::__set_is_shadowcopy(const bool val) {
  this->is_shadowcopy = val;
__isset.is_shadowcopy = true;
}

void partition_info::__set_is_system(const bool val) {
  this->is_system = val;
__isset.is_system = true;
}

void partition_info::__set_mbr_type(const int16_t val) {
  this->mbr_type = val;
__isset.mbr_type = true;
}

void partition_info::__set_offset(const int64_t val) {
  this->offset = val;
__isset.offset = true;
}

void partition_info::__set_partition_number(const int32_t val) {
  this->partition_number = val;
__isset.partition_number = true;
}

void partition_info::__set_size(const int64_t val) {
  this->size = val;
__isset.size = true;
}
std::ostream& operator<<(std::ostream& out, const partition_info& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t partition_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->access_paths.clear();
            uint32_t _size4;
            ::apache::thrift::protocol::TType _etype7;
            xfer += iprot->readSetBegin(_etype7, _size4);
            uint32_t _i8;
            for (_i8 = 0; _i8 < _size4; ++_i8)
            {
              std::string _elem9;
              xfer += iprot->readString(_elem9);
              this->access_paths.insert(_elem9);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.access_paths = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->disk_number);
          this->__isset.disk_number = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->drive_letter);
          this->__isset.drive_letter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->gpt_type);
          this->__isset.gpt_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guid);
          this->__isset.guid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_active);
          this->__isset.is_active = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_boot);
          this->__isset.is_boot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_hidden);
          this->__isset.is_hidden = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_offline);
          this->__isset.is_offline = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_readonly);
          this->__isset.is_readonly = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_shadowcopy);
          this->__isset.is_shadowcopy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_system);
          this->__isset.is_system = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->mbr_type);
          this->__isset.mbr_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->offset);
          this->__isset.offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->partition_number);
          this->__isset.partition_number = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->size);
          this->__isset.size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t partition_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("partition_info");

  if (this->__isset.access_paths) {
    xfer += oprot->writeFieldBegin("access_paths", ::apache::thrift::protocol::T_SET, 1);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->access_paths.size()));
      std::set<std::string> ::const_iterator _iter10;
      for (_iter10 = this->access_paths.begin(); _iter10 != this->access_paths.end(); ++_iter10)
      {
        xfer += oprot->writeString((*_iter10));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.disk_number) {
    xfer += oprot->writeFieldBegin("disk_number", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->disk_number);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.drive_letter) {
    xfer += oprot->writeFieldBegin("drive_letter", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->drive_letter);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.gpt_type) {
    xfer += oprot->writeFieldBegin("gpt_type", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->gpt_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.guid) {
    xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->guid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_active) {
    xfer += oprot->writeFieldBegin("is_active", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->is_active);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_boot) {
    xfer += oprot->writeFieldBegin("is_boot", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->is_boot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_hidden) {
    xfer += oprot->writeFieldBegin("is_hidden", ::apache::thrift::protocol::T_BOOL, 8);
    xfer += oprot->writeBool(this->is_hidden);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_offline) {
    xfer += oprot->writeFieldBegin("is_offline", ::apache::thrift::protocol::T_BOOL, 9);
    xfer += oprot->writeBool(this->is_offline);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_readonly) {
    xfer += oprot->writeFieldBegin("is_readonly", ::apache::thrift::protocol::T_BOOL, 10);
    xfer += oprot->writeBool(this->is_readonly);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_shadowcopy) {
    xfer += oprot->writeFieldBegin("is_shadowcopy", ::apache::thrift::protocol::T_BOOL, 11);
    xfer += oprot->writeBool(this->is_shadowcopy);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_system) {
    xfer += oprot->writeFieldBegin("is_system", ::apache::thrift::protocol::T_BOOL, 12);
    xfer += oprot->writeBool(this->is_system);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mbr_type) {
    xfer += oprot->writeFieldBegin("mbr_type", ::apache::thrift::protocol::T_I16, 13);
    xfer += oprot->writeI16(this->mbr_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.offset) {
    xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I64, 14);
    xfer += oprot->writeI64(this->offset);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partition_number) {
    xfer += oprot->writeFieldBegin("partition_number", ::apache::thrift::protocol::T_I32, 15);
    xfer += oprot->writeI32(this->partition_number);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.size) {
    xfer += oprot->writeFieldBegin("size", ::apache::thrift::protocol::T_I64, 16);
    xfer += oprot->writeI64(this->size);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(partition_info &a, partition_info &b) {
  using ::std::swap;
  swap(a.access_paths, b.access_paths);
  swap(a.disk_number, b.disk_number);
  swap(a.drive_letter, b.drive_letter);
  swap(a.gpt_type, b.gpt_type);
  swap(a.guid, b.guid);
  swap(a.is_active, b.is_active);
  swap(a.is_boot, b.is_boot);
  swap(a.is_hidden, b.is_hidden);
  swap(a.is_offline, b.is_offline);
  swap(a.is_readonly, b.is_readonly);
  swap(a.is_shadowcopy, b.is_shadowcopy);
  swap(a.is_system, b.is_system);
  swap(a.mbr_type, b.mbr_type);
  swap(a.offset, b.offset);
  swap(a.partition_number, b.partition_number);
  swap(a.size, b.size);
  swap(a.__isset, b.__isset);
}

partition_info::partition_info(const partition_info& other11) {
  access_paths = other11.access_paths;
  disk_number = other11.disk_number;
  drive_letter = other11.drive_letter;
  gpt_type = other11.gpt_type;
  guid = other11.guid;
  is_active = other11.is_active;
  is_boot = other11.is_boot;
  is_hidden = other11.is_hidden;
  is_offline = other11.is_offline;
  is_readonly = other11.is_readonly;
  is_shadowcopy = other11.is_shadowcopy;
  is_system = other11.is_system;
  mbr_type = other11.mbr_type;
  offset = other11.offset;
  partition_number = other11.partition_number;
  size = other11.size;
  __isset = other11.__isset;
}
partition_info& partition_info::operator=(const partition_info& other12) {
  access_paths = other12.access_paths;
  disk_number = other12.disk_number;
  drive_letter = other12.drive_letter;
  gpt_type = other12.gpt_type;
  guid = other12.guid;
  is_active = other12.is_active;
  is_boot = other12.is_boot;
  is_hidden = other12.is_hidden;
  is_offline = other12.is_offline;
  is_readonly = other12.is_readonly;
  is_shadowcopy = other12.is_shadowcopy;
  is_system = other12.is_system;
  mbr_type = other12.mbr_type;
  offset = other12.offset;
  partition_number = other12.partition_number;
  size = other12.size;
  __isset = other12.__isset;
  return *this;
}
void partition_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "partition_info(";
  out << "access_paths="; (__isset.access_paths ? (out << to_string(access_paths)) : (out << "<null>"));
  out << ", " << "disk_number="; (__isset.disk_number ? (out << to_string(disk_number)) : (out << "<null>"));
  out << ", " << "drive_letter="; (__isset.drive_letter ? (out << to_string(drive_letter)) : (out << "<null>"));
  out << ", " << "gpt_type="; (__isset.gpt_type ? (out << to_string(gpt_type)) : (out << "<null>"));
  out << ", " << "guid="; (__isset.guid ? (out << to_string(guid)) : (out << "<null>"));
  out << ", " << "is_active="; (__isset.is_active ? (out << to_string(is_active)) : (out << "<null>"));
  out << ", " << "is_boot="; (__isset.is_boot ? (out << to_string(is_boot)) : (out << "<null>"));
  out << ", " << "is_hidden="; (__isset.is_hidden ? (out << to_string(is_hidden)) : (out << "<null>"));
  out << ", " << "is_offline="; (__isset.is_offline ? (out << to_string(is_offline)) : (out << "<null>"));
  out << ", " << "is_readonly="; (__isset.is_readonly ? (out << to_string(is_readonly)) : (out << "<null>"));
  out << ", " << "is_shadowcopy="; (__isset.is_shadowcopy ? (out << to_string(is_shadowcopy)) : (out << "<null>"));
  out << ", " << "is_system="; (__isset.is_system ? (out << to_string(is_system)) : (out << "<null>"));
  out << ", " << "mbr_type="; (__isset.mbr_type ? (out << to_string(mbr_type)) : (out << "<null>"));
  out << ", " << "offset="; (__isset.offset ? (out << to_string(offset)) : (out << "<null>"));
  out << ", " << "partition_number="; (__isset.partition_number ? (out << to_string(partition_number)) : (out << "<null>"));
  out << ", " << "size="; (__isset.size ? (out << to_string(size)) : (out << "<null>"));
  out << ")";
}


volume_info::~volume_info() throw() {
}


void volume_info::__set_access_paths(const std::set<std::string> & val) {
  this->access_paths = val;
__isset.access_paths = true;
}

void volume_info::__set_cluster_access_path(const std::string& val) {
  this->cluster_access_path = val;
__isset.cluster_access_path = true;
}

void volume_info::__set_drive_letter(const std::string& val) {
  this->drive_letter = val;
__isset.drive_letter = true;
}

void volume_info::__set_drive_type(const drive_type::type val) {
  this->drive_type = val;
__isset.drive_type = true;
}

void volume_info::__set_file_system(const std::string& val) {
  this->file_system = val;
__isset.file_system = true;
}

void volume_info::__set_file_system_catalogid(const std::string& val) {
  this->file_system_catalogid = val;
__isset.file_system_catalogid = true;
}

void volume_info::__set_file_system_label(const std::string& val) {
  this->file_system_label = val;
__isset.file_system_label = true;
}

void volume_info::__set_object_id(const std::string& val) {
  this->object_id = val;
__isset.object_id = true;
}

void volume_info::__set_path(const std::string& val) {
  this->path = val;
__isset.path = true;
}

void volume_info::__set_size(const int64_t val) {
  this->size = val;
__isset.size = true;
}

void volume_info::__set_size_remaining(const int64_t val) {
  this->size_remaining = val;
__isset.size_remaining = true;
}
std::ostream& operator<<(std::ostream& out, const volume_info& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t volume_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->access_paths.clear();
            uint32_t _size13;
            ::apache::thrift::protocol::TType _etype16;
            xfer += iprot->readSetBegin(_etype16, _size13);
            uint32_t _i17;
            for (_i17 = 0; _i17 < _size13; ++_i17)
            {
              std::string _elem18;
              xfer += iprot->readString(_elem18);
              this->access_paths.insert(_elem18);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.access_paths = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cluster_access_path);
          this->__isset.cluster_access_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->drive_letter);
          this->__isset.drive_letter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast19;
          xfer += iprot->readI32(ecast19);
          this->drive_type = (drive_type::type)ecast19;
          this->__isset.drive_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->file_system);
          this->__isset.file_system = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->file_system_catalogid);
          this->__isset.file_system_catalogid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->file_system_label);
          this->__isset.file_system_label = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->object_id);
          this->__isset.object_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->path);
          this->__isset.path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->size);
          this->__isset.size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->size_remaining);
          this->__isset.size_remaining = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t volume_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("volume_info");

  if (this->__isset.access_paths) {
    xfer += oprot->writeFieldBegin("access_paths", ::apache::thrift::protocol::T_SET, 1);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->access_paths.size()));
      std::set<std::string> ::const_iterator _iter20;
      for (_iter20 = this->access_paths.begin(); _iter20 != this->access_paths.end(); ++_iter20)
      {
        xfer += oprot->writeString((*_iter20));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_access_path) {
    xfer += oprot->writeFieldBegin("cluster_access_path", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->cluster_access_path);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.drive_letter) {
    xfer += oprot->writeFieldBegin("drive_letter", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->drive_letter);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.drive_type) {
    xfer += oprot->writeFieldBegin("drive_type", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32((int32_t)this->drive_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.file_system) {
    xfer += oprot->writeFieldBegin("file_system", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->file_system);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.file_system_catalogid) {
    xfer += oprot->writeFieldBegin("file_system_catalogid", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->file_system_catalogid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.file_system_label) {
    xfer += oprot->writeFieldBegin("file_system_label", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->file_system_label);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.object_id) {
    xfer += oprot->writeFieldBegin("object_id", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->object_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.path) {
    xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->path);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.size) {
    xfer += oprot->writeFieldBegin("size", ::apache::thrift::protocol::T_I64, 10);
    xfer += oprot->writeI64(this->size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.size_remaining) {
    xfer += oprot->writeFieldBegin("size_remaining", ::apache::thrift::protocol::T_I64, 11);
    xfer += oprot->writeI64(this->size_remaining);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(volume_info &a, volume_info &b) {
  using ::std::swap;
  swap(a.access_paths, b.access_paths);
  swap(a.cluster_access_path, b.cluster_access_path);
  swap(a.drive_letter, b.drive_letter);
  swap(a.drive_type, b.drive_type);
  swap(a.file_system, b.file_system);
  swap(a.file_system_catalogid, b.file_system_catalogid);
  swap(a.file_system_label, b.file_system_label);
  swap(a.object_id, b.object_id);
  swap(a.path, b.path);
  swap(a.size, b.size);
  swap(a.size_remaining, b.size_remaining);
  swap(a.__isset, b.__isset);
}

volume_info::volume_info(const volume_info& other21) {
  access_paths = other21.access_paths;
  cluster_access_path = other21.cluster_access_path;
  drive_letter = other21.drive_letter;
  drive_type = other21.drive_type;
  file_system = other21.file_system;
  file_system_catalogid = other21.file_system_catalogid;
  file_system_label = other21.file_system_label;
  object_id = other21.object_id;
  path = other21.path;
  size = other21.size;
  size_remaining = other21.size_remaining;
  __isset = other21.__isset;
}
volume_info& volume_info::operator=(const volume_info& other22) {
  access_paths = other22.access_paths;
  cluster_access_path = other22.cluster_access_path;
  drive_letter = other22.drive_letter;
  drive_type = other22.drive_type;
  file_system = other22.file_system;
  file_system_catalogid = other22.file_system_catalogid;
  file_system_label = other22.file_system_label;
  object_id = other22.object_id;
  path = other22.path;
  size = other22.size;
  size_remaining = other22.size_remaining;
  __isset = other22.__isset;
  return *this;
}
void volume_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "volume_info(";
  out << "access_paths="; (__isset.access_paths ? (out << to_string(access_paths)) : (out << "<null>"));
  out << ", " << "cluster_access_path="; (__isset.cluster_access_path ? (out << to_string(cluster_access_path)) : (out << "<null>"));
  out << ", " << "drive_letter="; (__isset.drive_letter ? (out << to_string(drive_letter)) : (out << "<null>"));
  out << ", " << "drive_type="; (__isset.drive_type ? (out << to_string(drive_type)) : (out << "<null>"));
  out << ", " << "file_system="; (__isset.file_system ? (out << to_string(file_system)) : (out << "<null>"));
  out << ", " << "file_system_catalogid="; (__isset.file_system_catalogid ? (out << to_string(file_system_catalogid)) : (out << "<null>"));
  out << ", " << "file_system_label="; (__isset.file_system_label ? (out << to_string(file_system_label)) : (out << "<null>"));
  out << ", " << "object_id="; (__isset.object_id ? (out << to_string(object_id)) : (out << "<null>"));
  out << ", " << "path="; (__isset.path ? (out << to_string(path)) : (out << "<null>"));
  out << ", " << "size="; (__isset.size ? (out << to_string(size)) : (out << "<null>"));
  out << ", " << "size_remaining="; (__isset.size_remaining ? (out << to_string(size_remaining)) : (out << "<null>"));
  out << ")";
}


network_info::~network_info() throw() {
}


void network_info::__set_adapter_name(const std::string& val) {
  this->adapter_name = val;
__isset.adapter_name = true;
}

void network_info::__set_description(const std::string& val) {
  this->description = val;
__isset.description = true;
}

void network_info::__set_dnss(const std::vector<std::string> & val) {
  this->dnss = val;
__isset.dnss = true;
}

void network_info::__set_gateways(const std::vector<std::string> & val) {
  this->gateways = val;
__isset.gateways = true;
}

void network_info::__set_ip_addresses(const std::vector<std::string> & val) {
  this->ip_addresses = val;
__isset.ip_addresses = true;
}

void network_info::__set_is_dhcp_v4(const bool val) {
  this->is_dhcp_v4 = val;
__isset.is_dhcp_v4 = true;
}

void network_info::__set_is_dhcp_v6(const bool val) {
  this->is_dhcp_v6 = val;
__isset.is_dhcp_v6 = true;
}

void network_info::__set_mac_address(const std::string& val) {
  this->mac_address = val;
__isset.mac_address = true;
}

void network_info::__set_subnet_masks(const std::vector<std::string> & val) {
  this->subnet_masks = val;
__isset.subnet_masks = true;
}
std::ostream& operator<<(std::ostream& out, const network_info& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t network_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->adapter_name);
          this->__isset.adapter_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->description);
          this->__isset.description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->dnss.clear();
            uint32_t _size23;
            ::apache::thrift::protocol::TType _etype26;
            xfer += iprot->readListBegin(_etype26, _size23);
            this->dnss.resize(_size23);
            uint32_t _i27;
            for (_i27 = 0; _i27 < _size23; ++_i27)
            {
              xfer += iprot->readString(this->dnss[_i27]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.dnss = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->gateways.clear();
            uint32_t _size28;
            ::apache::thrift::protocol::TType _etype31;
            xfer += iprot->readListBegin(_etype31, _size28);
            this->gateways.resize(_size28);
            uint32_t _i32;
            for (_i32 = 0; _i32 < _size28; ++_i32)
            {
              xfer += iprot->readString(this->gateways[_i32]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.gateways = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->ip_addresses.clear();
            uint32_t _size33;
            ::apache::thrift::protocol::TType _etype36;
            xfer += iprot->readListBegin(_etype36, _size33);
            this->ip_addresses.resize(_size33);
            uint32_t _i37;
            for (_i37 = 0; _i37 < _size33; ++_i37)
            {
              xfer += iprot->readString(this->ip_addresses[_i37]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.ip_addresses = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_dhcp_v4);
          this->__isset.is_dhcp_v4 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_dhcp_v6);
          this->__isset.is_dhcp_v6 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->mac_address);
          this->__isset.mac_address = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->subnet_masks.clear();
            uint32_t _size38;
            ::apache::thrift::protocol::TType _etype41;
            xfer += iprot->readListBegin(_etype41, _size38);
            this->subnet_masks.resize(_size38);
            uint32_t _i42;
            for (_i42 = 0; _i42 < _size38; ++_i42)
            {
              xfer += iprot->readString(this->subnet_masks[_i42]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.subnet_masks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t network_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("network_info");

  if (this->__isset.adapter_name) {
    xfer += oprot->writeFieldBegin("adapter_name", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->adapter_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.description) {
    xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->description);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dnss) {
    xfer += oprot->writeFieldBegin("dnss", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->dnss.size()));
      std::vector<std::string> ::const_iterator _iter43;
      for (_iter43 = this->dnss.begin(); _iter43 != this->dnss.end(); ++_iter43)
      {
        xfer += oprot->writeString((*_iter43));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.gateways) {
    xfer += oprot->writeFieldBegin("gateways", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->gateways.size()));
      std::vector<std::string> ::const_iterator _iter44;
      for (_iter44 = this->gateways.begin(); _iter44 != this->gateways.end(); ++_iter44)
      {
        xfer += oprot->writeString((*_iter44));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ip_addresses) {
    xfer += oprot->writeFieldBegin("ip_addresses", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->ip_addresses.size()));
      std::vector<std::string> ::const_iterator _iter45;
      for (_iter45 = this->ip_addresses.begin(); _iter45 != this->ip_addresses.end(); ++_iter45)
      {
        xfer += oprot->writeString((*_iter45));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_dhcp_v4) {
    xfer += oprot->writeFieldBegin("is_dhcp_v4", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->is_dhcp_v4);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_dhcp_v6) {
    xfer += oprot->writeFieldBegin("is_dhcp_v6", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->is_dhcp_v6);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mac_address) {
    xfer += oprot->writeFieldBegin("mac_address", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->mac_address);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.subnet_masks) {
    xfer += oprot->writeFieldBegin("subnet_masks", ::apache::thrift::protocol::T_LIST, 9);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->subnet_masks.size()));
      std::vector<std::string> ::const_iterator _iter46;
      for (_iter46 = this->subnet_masks.begin(); _iter46 != this->subnet_masks.end(); ++_iter46)
      {
        xfer += oprot->writeString((*_iter46));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(network_info &a, network_info &b) {
  using ::std::swap;
  swap(a.adapter_name, b.adapter_name);
  swap(a.description, b.description);
  swap(a.dnss, b.dnss);
  swap(a.gateways, b.gateways);
  swap(a.ip_addresses, b.ip_addresses);
  swap(a.is_dhcp_v4, b.is_dhcp_v4);
  swap(a.is_dhcp_v6, b.is_dhcp_v6);
  swap(a.mac_address, b.mac_address);
  swap(a.subnet_masks, b.subnet_masks);
  swap(a.__isset, b.__isset);
}

network_info::network_info(const network_info& other47) {
  adapter_name = other47.adapter_name;
  description = other47.description;
  dnss = other47.dnss;
  gateways = other47.gateways;
  ip_addresses = other47.ip_addresses;
  is_dhcp_v4 = other47.is_dhcp_v4;
  is_dhcp_v6 = other47.is_dhcp_v6;
  mac_address = other47.mac_address;
  subnet_masks = other47.subnet_masks;
  __isset = other47.__isset;
}
network_info& network_info::operator=(const network_info& other48) {
  adapter_name = other48.adapter_name;
  description = other48.description;
  dnss = other48.dnss;
  gateways = other48.gateways;
  ip_addresses = other48.ip_addresses;
  is_dhcp_v4 = other48.is_dhcp_v4;
  is_dhcp_v6 = other48.is_dhcp_v6;
  mac_address = other48.mac_address;
  subnet_masks = other48.subnet_masks;
  __isset = other48.__isset;
  return *this;
}
void network_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "network_info(";
  out << "adapter_name="; (__isset.adapter_name ? (out << to_string(adapter_name)) : (out << "<null>"));
  out << ", " << "description="; (__isset.description ? (out << to_string(description)) : (out << "<null>"));
  out << ", " << "dnss="; (__isset.dnss ? (out << to_string(dnss)) : (out << "<null>"));
  out << ", " << "gateways="; (__isset.gateways ? (out << to_string(gateways)) : (out << "<null>"));
  out << ", " << "ip_addresses="; (__isset.ip_addresses ? (out << to_string(ip_addresses)) : (out << "<null>"));
  out << ", " << "is_dhcp_v4="; (__isset.is_dhcp_v4 ? (out << to_string(is_dhcp_v4)) : (out << "<null>"));
  out << ", " << "is_dhcp_v6="; (__isset.is_dhcp_v6 ? (out << to_string(is_dhcp_v6)) : (out << "<null>"));
  out << ", " << "mac_address="; (__isset.mac_address ? (out << to_string(mac_address)) : (out << "<null>"));
  out << ", " << "subnet_masks="; (__isset.subnet_masks ? (out << to_string(subnet_masks)) : (out << "<null>"));
  out << ")";
}


cluster_network::~cluster_network() throw() {
}


void cluster_network::__set_cluster_network_name(const std::string& val) {
  this->cluster_network_name = val;
__isset.cluster_network_name = true;
}

void cluster_network::__set_cluster_network_id(const std::string& val) {
  this->cluster_network_id = val;
__isset.cluster_network_id = true;
}

void cluster_network::__set_cluster_network_address(const std::string& val) {
  this->cluster_network_address = val;
__isset.cluster_network_address = true;
}

void cluster_network::__set_cluster_network_address_mask(const std::string& val) {
  this->cluster_network_address_mask = val;
__isset.cluster_network_address_mask = true;
}

void cluster_network::__set_network_infos(const std::set<network_info> & val) {
  this->network_infos = val;
__isset.network_infos = true;
}
std::ostream& operator<<(std::ostream& out, const cluster_network& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t cluster_network::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cluster_network_name);
          this->__isset.cluster_network_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cluster_network_id);
          this->__isset.cluster_network_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cluster_network_address);
          this->__isset.cluster_network_address = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cluster_network_address_mask);
          this->__isset.cluster_network_address_mask = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->network_infos.clear();
            uint32_t _size49;
            ::apache::thrift::protocol::TType _etype52;
            xfer += iprot->readSetBegin(_etype52, _size49);
            uint32_t _i53;
            for (_i53 = 0; _i53 < _size49; ++_i53)
            {
              network_info _elem54;
              xfer += _elem54.read(iprot);
              this->network_infos.insert(_elem54);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.network_infos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t cluster_network::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("cluster_network");

  if (this->__isset.cluster_network_name) {
    xfer += oprot->writeFieldBegin("cluster_network_name", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->cluster_network_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_network_id) {
    xfer += oprot->writeFieldBegin("cluster_network_id", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->cluster_network_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_network_address) {
    xfer += oprot->writeFieldBegin("cluster_network_address", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->cluster_network_address);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_network_address_mask) {
    xfer += oprot->writeFieldBegin("cluster_network_address_mask", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->cluster_network_address_mask);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.network_infos) {
    xfer += oprot->writeFieldBegin("network_infos", ::apache::thrift::protocol::T_SET, 5);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->network_infos.size()));
      std::set<network_info> ::const_iterator _iter55;
      for (_iter55 = this->network_infos.begin(); _iter55 != this->network_infos.end(); ++_iter55)
      {
        xfer += (*_iter55).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(cluster_network &a, cluster_network &b) {
  using ::std::swap;
  swap(a.cluster_network_name, b.cluster_network_name);
  swap(a.cluster_network_id, b.cluster_network_id);
  swap(a.cluster_network_address, b.cluster_network_address);
  swap(a.cluster_network_address_mask, b.cluster_network_address_mask);
  swap(a.network_infos, b.network_infos);
  swap(a.__isset, b.__isset);
}

cluster_network::cluster_network(const cluster_network& other56) {
  cluster_network_name = other56.cluster_network_name;
  cluster_network_id = other56.cluster_network_id;
  cluster_network_address = other56.cluster_network_address;
  cluster_network_address_mask = other56.cluster_network_address_mask;
  network_infos = other56.network_infos;
  __isset = other56.__isset;
}
cluster_network& cluster_network::operator=(const cluster_network& other57) {
  cluster_network_name = other57.cluster_network_name;
  cluster_network_id = other57.cluster_network_id;
  cluster_network_address = other57.cluster_network_address;
  cluster_network_address_mask = other57.cluster_network_address_mask;
  network_infos = other57.network_infos;
  __isset = other57.__isset;
  return *this;
}
void cluster_network::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "cluster_network(";
  out << "cluster_network_name="; (__isset.cluster_network_name ? (out << to_string(cluster_network_name)) : (out << "<null>"));
  out << ", " << "cluster_network_id="; (__isset.cluster_network_id ? (out << to_string(cluster_network_id)) : (out << "<null>"));
  out << ", " << "cluster_network_address="; (__isset.cluster_network_address ? (out << to_string(cluster_network_address)) : (out << "<null>"));
  out << ", " << "cluster_network_address_mask="; (__isset.cluster_network_address_mask ? (out << to_string(cluster_network_address_mask)) : (out << "<null>"));
  out << ", " << "network_infos="; (__isset.network_infos ? (out << to_string(network_infos)) : (out << "<null>"));
  out << ")";
}


cluster_group::~cluster_group() throw() {
}


void cluster_group::__set_group_id(const std::string& val) {
  this->group_id = val;
__isset.group_id = true;
}

void cluster_group::__set_group_name(const std::string& val) {
  this->group_name = val;
__isset.group_name = true;
}

void cluster_group::__set_group_owner(const std::string& val) {
  this->group_owner = val;
__isset.group_owner = true;
}

void cluster_group::__set_cluster_disks(const std::set<disk_info> & val) {
  this->cluster_disks = val;
__isset.cluster_disks = true;
}

void cluster_group::__set_cluster_partitions(const std::set<volume_info> & val) {
  this->cluster_partitions = val;
__isset.cluster_partitions = true;
}

void cluster_group::__set_cluster_network_infos(const std::set<cluster_network> & val) {
  this->cluster_network_infos = val;
__isset.cluster_network_infos = true;
}
std::ostream& operator<<(std::ostream& out, const cluster_group& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t cluster_group::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->group_id);
          this->__isset.group_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->group_name);
          this->__isset.group_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->group_owner);
          this->__isset.group_owner = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->cluster_disks.clear();
            uint32_t _size58;
            ::apache::thrift::protocol::TType _etype61;
            xfer += iprot->readSetBegin(_etype61, _size58);
            uint32_t _i62;
            for (_i62 = 0; _i62 < _size58; ++_i62)
            {
              disk_info _elem63;
              xfer += _elem63.read(iprot);
              this->cluster_disks.insert(_elem63);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.cluster_disks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->cluster_partitions.clear();
            uint32_t _size64;
            ::apache::thrift::protocol::TType _etype67;
            xfer += iprot->readSetBegin(_etype67, _size64);
            uint32_t _i68;
            for (_i68 = 0; _i68 < _size64; ++_i68)
            {
              volume_info _elem69;
              xfer += _elem69.read(iprot);
              this->cluster_partitions.insert(_elem69);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.cluster_partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->cluster_network_infos.clear();
            uint32_t _size70;
            ::apache::thrift::protocol::TType _etype73;
            xfer += iprot->readSetBegin(_etype73, _size70);
            uint32_t _i74;
            for (_i74 = 0; _i74 < _size70; ++_i74)
            {
              cluster_network _elem75;
              xfer += _elem75.read(iprot);
              this->cluster_network_infos.insert(_elem75);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.cluster_network_infos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t cluster_group::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("cluster_group");

  if (this->__isset.group_id) {
    xfer += oprot->writeFieldBegin("group_id", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->group_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.group_name) {
    xfer += oprot->writeFieldBegin("group_name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->group_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.group_owner) {
    xfer += oprot->writeFieldBegin("group_owner", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->group_owner);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_disks) {
    xfer += oprot->writeFieldBegin("cluster_disks", ::apache::thrift::protocol::T_SET, 4);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cluster_disks.size()));
      std::set<disk_info> ::const_iterator _iter76;
      for (_iter76 = this->cluster_disks.begin(); _iter76 != this->cluster_disks.end(); ++_iter76)
      {
        xfer += (*_iter76).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_partitions) {
    xfer += oprot->writeFieldBegin("cluster_partitions", ::apache::thrift::protocol::T_SET, 5);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cluster_partitions.size()));
      std::set<volume_info> ::const_iterator _iter77;
      for (_iter77 = this->cluster_partitions.begin(); _iter77 != this->cluster_partitions.end(); ++_iter77)
      {
        xfer += (*_iter77).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_network_infos) {
    xfer += oprot->writeFieldBegin("cluster_network_infos", ::apache::thrift::protocol::T_SET, 6);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cluster_network_infos.size()));
      std::set<cluster_network> ::const_iterator _iter78;
      for (_iter78 = this->cluster_network_infos.begin(); _iter78 != this->cluster_network_infos.end(); ++_iter78)
      {
        xfer += (*_iter78).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(cluster_group &a, cluster_group &b) {
  using ::std::swap;
  swap(a.group_id, b.group_id);
  swap(a.group_name, b.group_name);
  swap(a.group_owner, b.group_owner);
  swap(a.cluster_disks, b.cluster_disks);
  swap(a.cluster_partitions, b.cluster_partitions);
  swap(a.cluster_network_infos, b.cluster_network_infos);
  swap(a.__isset, b.__isset);
}

cluster_group::cluster_group(const cluster_group& other79) {
  group_id = other79.group_id;
  group_name = other79.group_name;
  group_owner = other79.group_owner;
  cluster_disks = other79.cluster_disks;
  cluster_partitions = other79.cluster_partitions;
  cluster_network_infos = other79.cluster_network_infos;
  __isset = other79.__isset;
}
cluster_group& cluster_group::operator=(const cluster_group& other80) {
  group_id = other80.group_id;
  group_name = other80.group_name;
  group_owner = other80.group_owner;
  cluster_disks = other80.cluster_disks;
  cluster_partitions = other80.cluster_partitions;
  cluster_network_infos = other80.cluster_network_infos;
  __isset = other80.__isset;
  return *this;
}
void cluster_group::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "cluster_group(";
  out << "group_id="; (__isset.group_id ? (out << to_string(group_id)) : (out << "<null>"));
  out << ", " << "group_name="; (__isset.group_name ? (out << to_string(group_name)) : (out << "<null>"));
  out << ", " << "group_owner="; (__isset.group_owner ? (out << to_string(group_owner)) : (out << "<null>"));
  out << ", " << "cluster_disks="; (__isset.cluster_disks ? (out << to_string(cluster_disks)) : (out << "<null>"));
  out << ", " << "cluster_partitions="; (__isset.cluster_partitions ? (out << to_string(cluster_partitions)) : (out << "<null>"));
  out << ", " << "cluster_network_infos="; (__isset.cluster_network_infos ? (out << to_string(cluster_network_infos)) : (out << "<null>"));
  out << ")";
}


cluster_info::~cluster_info() throw() {
}


void cluster_info::__set_cluster_name(const std::string& val) {
  this->cluster_name = val;
__isset.cluster_name = true;
}

void cluster_info::__set_quorum_disk(const disk_info& val) {
  this->quorum_disk = val;
__isset.quorum_disk = true;
}

void cluster_info::__set_cluster_nodes(const std::set<std::string> & val) {
  this->cluster_nodes = val;
__isset.cluster_nodes = true;
}

void cluster_info::__set_client_ids(const std::set<std::string> & val) {
  this->client_ids = val;
__isset.client_ids = true;
}

void cluster_info::__set_machine_ids(const std::set<std::string> & val) {
  this->machine_ids = val;
__isset.machine_ids = true;
}

void cluster_info::__set_cluster_network_infos(const std::set<cluster_network> & val) {
  this->cluster_network_infos = val;
__isset.cluster_network_infos = true;
}

void cluster_info::__set_cluster_groups(const std::set<cluster_group> & val) {
  this->cluster_groups = val;
__isset.cluster_groups = true;
}
std::ostream& operator<<(std::ostream& out, const cluster_info& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t cluster_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cluster_name);
          this->__isset.cluster_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->quorum_disk.read(iprot);
          this->__isset.quorum_disk = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->cluster_nodes.clear();
            uint32_t _size81;
            ::apache::thrift::protocol::TType _etype84;
            xfer += iprot->readSetBegin(_etype84, _size81);
            uint32_t _i85;
            for (_i85 = 0; _i85 < _size81; ++_i85)
            {
              std::string _elem86;
              xfer += iprot->readString(_elem86);
              this->cluster_nodes.insert(_elem86);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.cluster_nodes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->client_ids.clear();
            uint32_t _size87;
            ::apache::thrift::protocol::TType _etype90;
            xfer += iprot->readSetBegin(_etype90, _size87);
            uint32_t _i91;
            for (_i91 = 0; _i91 < _size87; ++_i91)
            {
              std::string _elem92;
              xfer += iprot->readString(_elem92);
              this->client_ids.insert(_elem92);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.client_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->machine_ids.clear();
            uint32_t _size93;
            ::apache::thrift::protocol::TType _etype96;
            xfer += iprot->readSetBegin(_etype96, _size93);
            uint32_t _i97;
            for (_i97 = 0; _i97 < _size93; ++_i97)
            {
              std::string _elem98;
              xfer += iprot->readString(_elem98);
              this->machine_ids.insert(_elem98);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.machine_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->cluster_network_infos.clear();
            uint32_t _size99;
            ::apache::thrift::protocol::TType _etype102;
            xfer += iprot->readSetBegin(_etype102, _size99);
            uint32_t _i103;
            for (_i103 = 0; _i103 < _size99; ++_i103)
            {
              cluster_network _elem104;
              xfer += _elem104.read(iprot);
              this->cluster_network_infos.insert(_elem104);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.cluster_network_infos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->cluster_groups.clear();
            uint32_t _size105;
            ::apache::thrift::protocol::TType _etype108;
            xfer += iprot->readSetBegin(_etype108, _size105);
            uint32_t _i109;
            for (_i109 = 0; _i109 < _size105; ++_i109)
            {
              cluster_group _elem110;
              xfer += _elem110.read(iprot);
              this->cluster_groups.insert(_elem110);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.cluster_groups = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t cluster_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("cluster_info");

  if (this->__isset.cluster_name) {
    xfer += oprot->writeFieldBegin("cluster_name", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->cluster_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.quorum_disk) {
    xfer += oprot->writeFieldBegin("quorum_disk", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->quorum_disk.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_nodes) {
    xfer += oprot->writeFieldBegin("cluster_nodes", ::apache::thrift::protocol::T_SET, 3);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->cluster_nodes.size()));
      std::set<std::string> ::const_iterator _iter111;
      for (_iter111 = this->cluster_nodes.begin(); _iter111 != this->cluster_nodes.end(); ++_iter111)
      {
        xfer += oprot->writeString((*_iter111));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.client_ids) {
    xfer += oprot->writeFieldBegin("client_ids", ::apache::thrift::protocol::T_SET, 4);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->client_ids.size()));
      std::set<std::string> ::const_iterator _iter112;
      for (_iter112 = this->client_ids.begin(); _iter112 != this->client_ids.end(); ++_iter112)
      {
        xfer += oprot->writeString((*_iter112));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.machine_ids) {
    xfer += oprot->writeFieldBegin("machine_ids", ::apache::thrift::protocol::T_SET, 5);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->machine_ids.size()));
      std::set<std::string> ::const_iterator _iter113;
      for (_iter113 = this->machine_ids.begin(); _iter113 != this->machine_ids.end(); ++_iter113)
      {
        xfer += oprot->writeString((*_iter113));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_network_infos) {
    xfer += oprot->writeFieldBegin("cluster_network_infos", ::apache::thrift::protocol::T_SET, 6);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cluster_network_infos.size()));
      std::set<cluster_network> ::const_iterator _iter114;
      for (_iter114 = this->cluster_network_infos.begin(); _iter114 != this->cluster_network_infos.end(); ++_iter114)
      {
        xfer += (*_iter114).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_groups) {
    xfer += oprot->writeFieldBegin("cluster_groups", ::apache::thrift::protocol::T_SET, 7);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cluster_groups.size()));
      std::set<cluster_group> ::const_iterator _iter115;
      for (_iter115 = this->cluster_groups.begin(); _iter115 != this->cluster_groups.end(); ++_iter115)
      {
        xfer += (*_iter115).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(cluster_info &a, cluster_info &b) {
  using ::std::swap;
  swap(a.cluster_name, b.cluster_name);
  swap(a.quorum_disk, b.quorum_disk);
  swap(a.cluster_nodes, b.cluster_nodes);
  swap(a.client_ids, b.client_ids);
  swap(a.machine_ids, b.machine_ids);
  swap(a.cluster_network_infos, b.cluster_network_infos);
  swap(a.cluster_groups, b.cluster_groups);
  swap(a.__isset, b.__isset);
}

cluster_info::cluster_info(const cluster_info& other116) {
  cluster_name = other116.cluster_name;
  quorum_disk = other116.quorum_disk;
  cluster_nodes = other116.cluster_nodes;
  client_ids = other116.client_ids;
  machine_ids = other116.machine_ids;
  cluster_network_infos = other116.cluster_network_infos;
  cluster_groups = other116.cluster_groups;
  __isset = other116.__isset;
}
cluster_info& cluster_info::operator=(const cluster_info& other117) {
  cluster_name = other117.cluster_name;
  quorum_disk = other117.quorum_disk;
  cluster_nodes = other117.cluster_nodes;
  client_ids = other117.client_ids;
  machine_ids = other117.machine_ids;
  cluster_network_infos = other117.cluster_network_infos;
  cluster_groups = other117.cluster_groups;
  __isset = other117.__isset;
  return *this;
}
void cluster_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "cluster_info(";
  out << "cluster_name="; (__isset.cluster_name ? (out << to_string(cluster_name)) : (out << "<null>"));
  out << ", " << "quorum_disk="; (__isset.quorum_disk ? (out << to_string(quorum_disk)) : (out << "<null>"));
  out << ", " << "cluster_nodes="; (__isset.cluster_nodes ? (out << to_string(cluster_nodes)) : (out << "<null>"));
  out << ", " << "client_ids="; (__isset.client_ids ? (out << to_string(client_ids)) : (out << "<null>"));
  out << ", " << "machine_ids="; (__isset.machine_ids ? (out << to_string(machine_ids)) : (out << "<null>"));
  out << ", " << "cluster_network_infos="; (__isset.cluster_network_infos ? (out << to_string(cluster_network_infos)) : (out << "<null>"));
  out << ", " << "cluster_groups="; (__isset.cluster_groups ? (out << to_string(cluster_groups)) : (out << "<null>"));
  out << ")";
}


os_version_info::~os_version_info() throw() {
}


void os_version_info::__set_csd_version(const std::string& val) {
  this->csd_version = val;
__isset.csd_version = true;
}

void os_version_info::__set_build_number(const int32_t val) {
  this->build_number = val;
__isset.build_number = true;
}

void os_version_info::__set_major_version(const int32_t val) {
  this->major_version = val;
__isset.major_version = true;
}

void os_version_info::__set_minor_version(const int32_t val) {
  this->minor_version = val;
__isset.minor_version = true;
}

void os_version_info::__set_platform_id(const int32_t val) {
  this->platform_id = val;
__isset.platform_id = true;
}

void os_version_info::__set_product_type(const int16_t val) {
  this->product_type = val;
__isset.product_type = true;
}

void os_version_info::__set_servicepack_major(const int32_t val) {
  this->servicepack_major = val;
__isset.servicepack_major = true;
}

void os_version_info::__set_servicepack_minor(const int32_t val) {
  this->servicepack_minor = val;
__isset.servicepack_minor = true;
}

void os_version_info::__set_suite_mask(const int32_t val) {
  this->suite_mask = val;
__isset.suite_mask = true;
}
std::ostream& operator<<(std::ostream& out, const os_version_info& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t os_version_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->csd_version);
          this->__isset.csd_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->build_number);
          this->__isset.build_number = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->major_version);
          this->__isset.major_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->minor_version);
          this->__isset.minor_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->platform_id);
          this->__isset.platform_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->product_type);
          this->__isset.product_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->servicepack_major);
          this->__isset.servicepack_major = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->servicepack_minor);
          this->__isset.servicepack_minor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->suite_mask);
          this->__isset.suite_mask = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t os_version_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("os_version_info");

  if (this->__isset.csd_version) {
    xfer += oprot->writeFieldBegin("csd_version", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->csd_version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.build_number) {
    xfer += oprot->writeFieldBegin("build_number", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->build_number);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.major_version) {
    xfer += oprot->writeFieldBegin("major_version", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->major_version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.minor_version) {
    xfer += oprot->writeFieldBegin("minor_version", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->minor_version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.platform_id) {
    xfer += oprot->writeFieldBegin("platform_id", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->platform_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.product_type) {
    xfer += oprot->writeFieldBegin("product_type", ::apache::thrift::protocol::T_I16, 6);
    xfer += oprot->writeI16(this->product_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.servicepack_major) {
    xfer += oprot->writeFieldBegin("servicepack_major", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32(this->servicepack_major);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.servicepack_minor) {
    xfer += oprot->writeFieldBegin("servicepack_minor", ::apache::thrift::protocol::T_I32, 8);
    xfer += oprot->writeI32(this->servicepack_minor);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.suite_mask) {
    xfer += oprot->writeFieldBegin("suite_mask", ::apache::thrift::protocol::T_I32, 9);
    xfer += oprot->writeI32(this->suite_mask);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(os_version_info &a, os_version_info &b) {
  using ::std::swap;
  swap(a.csd_version, b.csd_version);
  swap(a.build_number, b.build_number);
  swap(a.major_version, b.major_version);
  swap(a.minor_version, b.minor_version);
  swap(a.platform_id, b.platform_id);
  swap(a.product_type, b.product_type);
  swap(a.servicepack_major, b.servicepack_major);
  swap(a.servicepack_minor, b.servicepack_minor);
  swap(a.suite_mask, b.suite_mask);
  swap(a.__isset, b.__isset);
}

os_version_info::os_version_info(const os_version_info& other118) {
  csd_version = other118.csd_version;
  build_number = other118.build_number;
  major_version = other118.major_version;
  minor_version = other118.minor_version;
  platform_id = other118.platform_id;
  product_type = other118.product_type;
  servicepack_major = other118.servicepack_major;
  servicepack_minor = other118.servicepack_minor;
  suite_mask = other118.suite_mask;
  __isset = other118.__isset;
}
os_version_info& os_version_info::operator=(const os_version_info& other119) {
  csd_version = other119.csd_version;
  build_number = other119.build_number;
  major_version = other119.major_version;
  minor_version = other119.minor_version;
  platform_id = other119.platform_id;
  product_type = other119.product_type;
  servicepack_major = other119.servicepack_major;
  servicepack_minor = other119.servicepack_minor;
  suite_mask = other119.suite_mask;
  __isset = other119.__isset;
  return *this;
}
void os_version_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "os_version_info(";
  out << "csd_version="; (__isset.csd_version ? (out << to_string(csd_version)) : (out << "<null>"));
  out << ", " << "build_number="; (__isset.build_number ? (out << to_string(build_number)) : (out << "<null>"));
  out << ", " << "major_version="; (__isset.major_version ? (out << to_string(major_version)) : (out << "<null>"));
  out << ", " << "minor_version="; (__isset.minor_version ? (out << to_string(minor_version)) : (out << "<null>"));
  out << ", " << "platform_id="; (__isset.platform_id ? (out << to_string(platform_id)) : (out << "<null>"));
  out << ", " << "product_type="; (__isset.product_type ? (out << to_string(product_type)) : (out << "<null>"));
  out << ", " << "servicepack_major="; (__isset.servicepack_major ? (out << to_string(servicepack_major)) : (out << "<null>"));
  out << ", " << "servicepack_minor="; (__isset.servicepack_minor ? (out << to_string(servicepack_minor)) : (out << "<null>"));
  out << ", " << "suite_mask="; (__isset.suite_mask ? (out << to_string(suite_mask)) : (out << "<null>"));
  out << ")";
}


snapshot::~snapshot() throw() {
}


void snapshot::__set_snapshot_set_id(const std::string& val) {
  this->snapshot_set_id = val;
__isset.snapshot_set_id = true;
}

void snapshot::__set_snapshot_id(const std::string& val) {
  this->snapshot_id = val;
__isset.snapshot_id = true;
}

void snapshot::__set_original_volume_name(const std::string& val) {
  this->original_volume_name = val;
__isset.original_volume_name = true;
}

void snapshot::__set_snapshot_device_object(const std::string& val) {
  this->snapshot_device_object = val;
__isset.snapshot_device_object = true;
}

void snapshot::__set_creation_time_stamp(const std::string& val) {
  this->creation_time_stamp = val;
__isset.creation_time_stamp = true;
}

void snapshot::__set_snapshots_count(const int32_t val) {
  this->snapshots_count = val;
__isset.snapshots_count = true;
}
std::ostream& operator<<(std::ostream& out, const snapshot& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t snapshot::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->snapshot_set_id);
          this->__isset.snapshot_set_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->snapshot_id);
          this->__isset.snapshot_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->original_volume_name);
          this->__isset.original_volume_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->snapshot_device_object);
          this->__isset.snapshot_device_object = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->creation_time_stamp);
          this->__isset.creation_time_stamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->snapshots_count);
          this->__isset.snapshots_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t snapshot::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("snapshot");

  if (this->__isset.snapshot_set_id) {
    xfer += oprot->writeFieldBegin("snapshot_set_id", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->snapshot_set_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.snapshot_id) {
    xfer += oprot->writeFieldBegin("snapshot_id", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->snapshot_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.original_volume_name) {
    xfer += oprot->writeFieldBegin("original_volume_name", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->original_volume_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.snapshot_device_object) {
    xfer += oprot->writeFieldBegin("snapshot_device_object", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->snapshot_device_object);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.creation_time_stamp) {
    xfer += oprot->writeFieldBegin("creation_time_stamp", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->creation_time_stamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.snapshots_count) {
    xfer += oprot->writeFieldBegin("snapshots_count", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(this->snapshots_count);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(snapshot &a, snapshot &b) {
  using ::std::swap;
  swap(a.snapshot_set_id, b.snapshot_set_id);
  swap(a.snapshot_id, b.snapshot_id);
  swap(a.original_volume_name, b.original_volume_name);
  swap(a.snapshot_device_object, b.snapshot_device_object);
  swap(a.creation_time_stamp, b.creation_time_stamp);
  swap(a.snapshots_count, b.snapshots_count);
  swap(a.__isset, b.__isset);
}

snapshot::snapshot(const snapshot& other120) {
  snapshot_set_id = other120.snapshot_set_id;
  snapshot_id = other120.snapshot_id;
  original_volume_name = other120.original_volume_name;
  snapshot_device_object = other120.snapshot_device_object;
  creation_time_stamp = other120.creation_time_stamp;
  snapshots_count = other120.snapshots_count;
  __isset = other120.__isset;
}
snapshot& snapshot::operator=(const snapshot& other121) {
  snapshot_set_id = other121.snapshot_set_id;
  snapshot_id = other121.snapshot_id;
  original_volume_name = other121.original_volume_name;
  snapshot_device_object = other121.snapshot_device_object;
  creation_time_stamp = other121.creation_time_stamp;
  snapshots_count = other121.snapshots_count;
  __isset = other121.__isset;
  return *this;
}
void snapshot::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "snapshot(";
  out << "snapshot_set_id="; (__isset.snapshot_set_id ? (out << to_string(snapshot_set_id)) : (out << "<null>"));
  out << ", " << "snapshot_id="; (__isset.snapshot_id ? (out << to_string(snapshot_id)) : (out << "<null>"));
  out << ", " << "original_volume_name="; (__isset.original_volume_name ? (out << to_string(original_volume_name)) : (out << "<null>"));
  out << ", " << "snapshot_device_object="; (__isset.snapshot_device_object ? (out << to_string(snapshot_device_object)) : (out << "<null>"));
  out << ", " << "creation_time_stamp="; (__isset.creation_time_stamp ? (out << to_string(creation_time_stamp)) : (out << "<null>"));
  out << ", " << "snapshots_count="; (__isset.snapshots_count ? (out << to_string(snapshots_count)) : (out << "<null>"));
  out << ")";
}


snapshot_result::~snapshot_result() throw() {
}


void snapshot_result::__set_snapshots(const std::vector<snapshot> & val) {
  this->snapshots = val;
}
std::ostream& operator<<(std::ostream& out, const snapshot_result& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t snapshot_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->snapshots.clear();
            uint32_t _size122;
            ::apache::thrift::protocol::TType _etype125;
            xfer += iprot->readListBegin(_etype125, _size122);
            this->snapshots.resize(_size122);
            uint32_t _i126;
            for (_i126 = 0; _i126 < _size122; ++_i126)
            {
              xfer += this->snapshots[_i126].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.snapshots = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t snapshot_result::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("snapshot_result");

  xfer += oprot->writeFieldBegin("snapshots", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->snapshots.size()));
    std::vector<snapshot> ::const_iterator _iter127;
    for (_iter127 = this->snapshots.begin(); _iter127 != this->snapshots.end(); ++_iter127)
    {
      xfer += (*_iter127).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(snapshot_result &a, snapshot_result &b) {
  using ::std::swap;
  swap(a.snapshots, b.snapshots);
  swap(a.__isset, b.__isset);
}

snapshot_result::snapshot_result(const snapshot_result& other128) {
  snapshots = other128.snapshots;
  __isset = other128.__isset;
}
snapshot_result& snapshot_result::operator=(const snapshot_result& other129) {
  snapshots = other129.snapshots;
  __isset = other129.__isset;
  return *this;
}
void snapshot_result::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "snapshot_result(";
  out << "snapshots=" << to_string(snapshots);
  out << ")";
}


volume_bit_map::~volume_bit_map() throw() {
}


void volume_bit_map::__set_cluster_size(const int32_t val) {
  this->cluster_size = val;
__isset.cluster_size = true;
}

void volume_bit_map::__set_starting_lcn(const int64_t val) {
  this->starting_lcn = val;
__isset.starting_lcn = true;
}

void volume_bit_map::__set_total_number_of_clusters(const int64_t val) {
  this->total_number_of_clusters = val;
__isset.total_number_of_clusters = true;
}

void volume_bit_map::__set_bit_map(const std::string& val) {
  this->bit_map = val;
__isset.bit_map = true;
}

void volume_bit_map::__set_compressed(const bool val) {
  this->compressed = val;
__isset.compressed = true;
}
std::ostream& operator<<(std::ostream& out, const volume_bit_map& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t volume_bit_map::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cluster_size);
          this->__isset.cluster_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->starting_lcn);
          this->__isset.starting_lcn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->total_number_of_clusters);
          this->__isset.total_number_of_clusters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->bit_map);
          this->__isset.bit_map = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->compressed);
          this->__isset.compressed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t volume_bit_map::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("volume_bit_map");

  if (this->__isset.cluster_size) {
    xfer += oprot->writeFieldBegin("cluster_size", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->cluster_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.starting_lcn) {
    xfer += oprot->writeFieldBegin("starting_lcn", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->starting_lcn);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.total_number_of_clusters) {
    xfer += oprot->writeFieldBegin("total_number_of_clusters", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->total_number_of_clusters);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.bit_map) {
    xfer += oprot->writeFieldBegin("bit_map", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeBinary(this->bit_map);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.compressed) {
    xfer += oprot->writeFieldBegin("compressed", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->compressed);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(volume_bit_map &a, volume_bit_map &b) {
  using ::std::swap;
  swap(a.cluster_size, b.cluster_size);
  swap(a.starting_lcn, b.starting_lcn);
  swap(a.total_number_of_clusters, b.total_number_of_clusters);
  swap(a.bit_map, b.bit_map);
  swap(a.compressed, b.compressed);
  swap(a.__isset, b.__isset);
}

volume_bit_map::volume_bit_map(const volume_bit_map& other130) {
  cluster_size = other130.cluster_size;
  starting_lcn = other130.starting_lcn;
  total_number_of_clusters = other130.total_number_of_clusters;
  bit_map = other130.bit_map;
  compressed = other130.compressed;
  __isset = other130.__isset;
}
volume_bit_map& volume_bit_map::operator=(const volume_bit_map& other131) {
  cluster_size = other131.cluster_size;
  starting_lcn = other131.starting_lcn;
  total_number_of_clusters = other131.total_number_of_clusters;
  bit_map = other131.bit_map;
  compressed = other131.compressed;
  __isset = other131.__isset;
  return *this;
}
void volume_bit_map::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "volume_bit_map(";
  out << "cluster_size="; (__isset.cluster_size ? (out << to_string(cluster_size)) : (out << "<null>"));
  out << ", " << "starting_lcn="; (__isset.starting_lcn ? (out << to_string(starting_lcn)) : (out << "<null>"));
  out << ", " << "total_number_of_clusters="; (__isset.total_number_of_clusters ? (out << to_string(total_number_of_clusters)) : (out << "<null>"));
  out << ", " << "bit_map="; (__isset.bit_map ? (out << to_string(bit_map)) : (out << "<null>"));
  out << ", " << "compressed="; (__isset.compressed ? (out << to_string(compressed)) : (out << "<null>"));
  out << ")";
}


replication_result::~replication_result() throw() {
}


void replication_result::__set_result(const std::string& val) {
  this->result = val;
__isset.result = true;
}

void replication_result::__set_compressed(const bool val) {
  this->compressed = val;
__isset.compressed = true;
}
std::ostream& operator<<(std::ostream& out, const replication_result& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t replication_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->compressed);
          this->__isset.compressed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t replication_result::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("replication_result");

  if (this->__isset.result) {
    xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeBinary(this->result);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.compressed) {
    xfer += oprot->writeFieldBegin("compressed", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->compressed);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(replication_result &a, replication_result &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.compressed, b.compressed);
  swap(a.__isset, b.__isset);
}

replication_result::replication_result(const replication_result& other132) {
  result = other132.result;
  compressed = other132.compressed;
  __isset = other132.__isset;
}
replication_result& replication_result::operator=(const replication_result& other133) {
  result = other133.result;
  compressed = other133.compressed;
  __isset = other133.__isset;
  return *this;
}
void replication_result::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "replication_result(";
  out << "result="; (__isset.result ? (out << to_string(result)) : (out << "<null>"));
  out << ", " << "compressed="; (__isset.compressed ? (out << to_string(compressed)) : (out << "<null>"));
  out << ")";
}


delete_snapshot_result::~delete_snapshot_result() throw() {
}


void delete_snapshot_result::__set_code(const int32_t val) {
  this->code = val;
__isset.code = true;
}

void delete_snapshot_result::__set_deleted_snapshots(const int32_t val) {
  this->deleted_snapshots = val;
__isset.deleted_snapshots = true;
}

void delete_snapshot_result::__set_non_deleted_snapshot_id(const std::string& val) {
  this->non_deleted_snapshot_id = val;
__isset.non_deleted_snapshot_id = true;
}
std::ostream& operator<<(std::ostream& out, const delete_snapshot_result& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t delete_snapshot_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->code);
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->deleted_snapshots);
          this->__isset.deleted_snapshots = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->non_deleted_snapshot_id);
          this->__isset.non_deleted_snapshot_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t delete_snapshot_result::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("delete_snapshot_result");

  if (this->__isset.code) {
    xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->code);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.deleted_snapshots) {
    xfer += oprot->writeFieldBegin("deleted_snapshots", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->deleted_snapshots);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.non_deleted_snapshot_id) {
    xfer += oprot->writeFieldBegin("non_deleted_snapshot_id", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->non_deleted_snapshot_id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(delete_snapshot_result &a, delete_snapshot_result &b) {
  using ::std::swap;
  swap(a.code, b.code);
  swap(a.deleted_snapshots, b.deleted_snapshots);
  swap(a.non_deleted_snapshot_id, b.non_deleted_snapshot_id);
  swap(a.__isset, b.__isset);
}

delete_snapshot_result::delete_snapshot_result(const delete_snapshot_result& other134) {
  code = other134.code;
  deleted_snapshots = other134.deleted_snapshots;
  non_deleted_snapshot_id = other134.non_deleted_snapshot_id;
  __isset = other134.__isset;
}
delete_snapshot_result& delete_snapshot_result::operator=(const delete_snapshot_result& other135) {
  code = other135.code;
  deleted_snapshots = other135.deleted_snapshots;
  non_deleted_snapshot_id = other135.non_deleted_snapshot_id;
  __isset = other135.__isset;
  return *this;
}
void delete_snapshot_result::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "delete_snapshot_result(";
  out << "code="; (__isset.code ? (out << to_string(code)) : (out << "<null>"));
  out << ", " << "deleted_snapshots="; (__isset.deleted_snapshots ? (out << to_string(deleted_snapshots)) : (out << "<null>"));
  out << ", " << "non_deleted_snapshot_id="; (__isset.non_deleted_snapshot_id ? (out << to_string(non_deleted_snapshot_id)) : (out << "<null>"));
  out << ")";
}


physical_machine_info::~physical_machine_info() throw() {
}


void physical_machine_info::__set_architecture(const std::string& val) {
  this->architecture = val;
__isset.architecture = true;
}

void physical_machine_info::__set_client_id(const std::string& val) {
  this->client_id = val;
__isset.client_id = true;
}

void physical_machine_info::__set_client_name(const std::string& val) {
  this->client_name = val;
__isset.client_name = true;
}

void physical_machine_info::__set_domain(const std::string& val) {
  this->domain = val;
__isset.domain = true;
}

void physical_machine_info::__set_hal(const std::string& val) {
  this->hal = val;
__isset.hal = true;
}

void physical_machine_info::__set_initiator_name(const std::string& val) {
  this->initiator_name = val;
__isset.initiator_name = true;
}

void physical_machine_info::__set_is_oem(const bool val) {
  this->is_oem = val;
__isset.is_oem = true;
}

void physical_machine_info::__set_logical_processors(const int16_t val) {
  this->logical_processors = val;
__isset.logical_processors = true;
}

void physical_machine_info::__set_machine_id(const std::string& val) {
  this->machine_id = val;
__isset.machine_id = true;
}

void physical_machine_info::__set_manufacturer(const std::string& val) {
  this->manufacturer = val;
__isset.manufacturer = true;
}

void physical_machine_info::__set_os_name(const std::string& val) {
  this->os_name = val;
__isset.os_name = true;
}

void physical_machine_info::__set_os_type(const int32_t val) {
  this->os_type = val;
__isset.os_type = true;
}

void physical_machine_info::__set_os_system_info(const std::string& val) {
  this->os_system_info = val;
__isset.os_system_info = true;
}

void physical_machine_info::__set_physical_memory(const int64_t val) {
  this->physical_memory = val;
__isset.physical_memory = true;
}

void physical_machine_info::__set_processors(const int16_t val) {
  this->processors = val;
__isset.processors = true;
}

void physical_machine_info::__set_role(const int32_t val) {
  this->role = val;
__isset.role = true;
}

void physical_machine_info::__set_system_model(const std::string& val) {
  this->system_model = val;
__isset.system_model = true;
}

void physical_machine_info::__set_system_root(const std::string& val) {
  this->system_root = val;
__isset.system_root = true;
}

void physical_machine_info::__set_workgroup(const std::string& val) {
  this->workgroup = val;
__isset.workgroup = true;
}

void physical_machine_info::__set_os_version(const os_version_info& val) {
  this->os_version = val;
__isset.os_version = true;
}

void physical_machine_info::__set_cluster_infos(const std::set<cluster_info> & val) {
  this->cluster_infos = val;
__isset.cluster_infos = true;
}

void physical_machine_info::__set_disk_infos(const std::set<disk_info> & val) {
  this->disk_infos = val;
__isset.disk_infos = true;
}

void physical_machine_info::__set_network_infos(const std::set<network_info> & val) {
  this->network_infos = val;
__isset.network_infos = true;
}

void physical_machine_info::__set_partition_infos(const std::set<partition_info> & val) {
  this->partition_infos = val;
__isset.partition_infos = true;
}

void physical_machine_info::__set_volume_infos(const std::set<volume_info> & val) {
  this->volume_infos = val;
__isset.volume_infos = true;
}

void physical_machine_info::__set_is_vcbt_driver_installed(const bool val) {
  this->is_vcbt_driver_installed = val;
__isset.is_vcbt_driver_installed = true;
}

void physical_machine_info::__set_is_vcbt_enabled(const bool val) {
  this->is_vcbt_enabled = val;
__isset.is_vcbt_enabled = true;
}

void physical_machine_info::__set_current_vcbt_version(const std::string& val) {
  this->current_vcbt_version = val;
__isset.current_vcbt_version = true;
}

void physical_machine_info::__set_installed_vcbt_version(const std::string& val) {
  this->installed_vcbt_version = val;
__isset.installed_vcbt_version = true;
}

void physical_machine_info::__set_is_winpe(const bool val) {
  this->is_winpe = val;
__isset.is_winpe = true;
}

void physical_machine_info::__set_system_default_ui_language(const int16_t val) {
  this->system_default_ui_language = val;
__isset.system_default_ui_language = true;
}
std::ostream& operator<<(std::ostream& out, const physical_machine_info& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t physical_machine_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->architecture);
          this->__isset.architecture = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->client_id);
          this->__isset.client_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->client_name);
          this->__isset.client_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->domain);
          this->__isset.domain = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hal);
          this->__isset.hal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->initiator_name);
          this->__isset.initiator_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_oem);
          this->__isset.is_oem = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->logical_processors);
          this->__isset.logical_processors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->machine_id);
          this->__isset.machine_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->manufacturer);
          this->__isset.manufacturer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->os_name);
          this->__isset.os_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->os_type);
          this->__isset.os_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->os_system_info);
          this->__isset.os_system_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->physical_memory);
          this->__isset.physical_memory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->processors);
          this->__isset.processors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->role);
          this->__isset.role = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->system_model);
          this->__isset.system_model = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->system_root);
          this->__isset.system_root = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->workgroup);
          this->__isset.workgroup = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->os_version.read(iprot);
          this->__isset.os_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->cluster_infos.clear();
            uint32_t _size136;
            ::apache::thrift::protocol::TType _etype139;
            xfer += iprot->readSetBegin(_etype139, _size136);
            uint32_t _i140;
            for (_i140 = 0; _i140 < _size136; ++_i140)
            {
              cluster_info _elem141;
              xfer += _elem141.read(iprot);
              this->cluster_infos.insert(_elem141);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.cluster_infos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->disk_infos.clear();
            uint32_t _size142;
            ::apache::thrift::protocol::TType _etype145;
            xfer += iprot->readSetBegin(_etype145, _size142);
            uint32_t _i146;
            for (_i146 = 0; _i146 < _size142; ++_i146)
            {
              disk_info _elem147;
              xfer += _elem147.read(iprot);
              this->disk_infos.insert(_elem147);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.disk_infos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->network_infos.clear();
            uint32_t _size148;
            ::apache::thrift::protocol::TType _etype151;
            xfer += iprot->readSetBegin(_etype151, _size148);
            uint32_t _i152;
            for (_i152 = 0; _i152 < _size148; ++_i152)
            {
              network_info _elem153;
              xfer += _elem153.read(iprot);
              this->network_infos.insert(_elem153);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.network_infos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->partition_infos.clear();
            uint32_t _size154;
            ::apache::thrift::protocol::TType _etype157;
            xfer += iprot->readSetBegin(_etype157, _size154);
            uint32_t _i158;
            for (_i158 = 0; _i158 < _size154; ++_i158)
            {
              partition_info _elem159;
              xfer += _elem159.read(iprot);
              this->partition_infos.insert(_elem159);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.partition_infos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->volume_infos.clear();
            uint32_t _size160;
            ::apache::thrift::protocol::TType _etype163;
            xfer += iprot->readSetBegin(_etype163, _size160);
            uint32_t _i164;
            for (_i164 = 0; _i164 < _size160; ++_i164)
            {
              volume_info _elem165;
              xfer += _elem165.read(iprot);
              this->volume_infos.insert(_elem165);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.volume_infos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 26:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_vcbt_driver_installed);
          this->__isset.is_vcbt_driver_installed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 27:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_vcbt_enabled);
          this->__isset.is_vcbt_enabled = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 28:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->current_vcbt_version);
          this->__isset.current_vcbt_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 29:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->installed_vcbt_version);
          this->__isset.installed_vcbt_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_winpe);
          this->__isset.is_winpe = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 31:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->system_default_ui_language);
          this->__isset.system_default_ui_language = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_machine_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_machine_info");

  if (this->__isset.architecture) {
    xfer += oprot->writeFieldBegin("architecture", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->architecture);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.client_id) {
    xfer += oprot->writeFieldBegin("client_id", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->client_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.client_name) {
    xfer += oprot->writeFieldBegin("client_name", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->client_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.domain) {
    xfer += oprot->writeFieldBegin("domain", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->domain);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.hal) {
    xfer += oprot->writeFieldBegin("hal", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->hal);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.initiator_name) {
    xfer += oprot->writeFieldBegin("initiator_name", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->initiator_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_oem) {
    xfer += oprot->writeFieldBegin("is_oem", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->is_oem);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.logical_processors) {
    xfer += oprot->writeFieldBegin("logical_processors", ::apache::thrift::protocol::T_I16, 8);
    xfer += oprot->writeI16(this->logical_processors);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.machine_id) {
    xfer += oprot->writeFieldBegin("machine_id", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->machine_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.manufacturer) {
    xfer += oprot->writeFieldBegin("manufacturer", ::apache::thrift::protocol::T_STRING, 10);
    xfer += oprot->writeString(this->manufacturer);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.os_name) {
    xfer += oprot->writeFieldBegin("os_name", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeString(this->os_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.os_type) {
    xfer += oprot->writeFieldBegin("os_type", ::apache::thrift::protocol::T_I32, 12);
    xfer += oprot->writeI32(this->os_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.os_system_info) {
    xfer += oprot->writeFieldBegin("os_system_info", ::apache::thrift::protocol::T_STRING, 13);
    xfer += oprot->writeString(this->os_system_info);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.physical_memory) {
    xfer += oprot->writeFieldBegin("physical_memory", ::apache::thrift::protocol::T_I64, 14);
    xfer += oprot->writeI64(this->physical_memory);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.processors) {
    xfer += oprot->writeFieldBegin("processors", ::apache::thrift::protocol::T_I16, 15);
    xfer += oprot->writeI16(this->processors);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.role) {
    xfer += oprot->writeFieldBegin("role", ::apache::thrift::protocol::T_I32, 16);
    xfer += oprot->writeI32(this->role);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.system_model) {
    xfer += oprot->writeFieldBegin("system_model", ::apache::thrift::protocol::T_STRING, 17);
    xfer += oprot->writeString(this->system_model);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.system_root) {
    xfer += oprot->writeFieldBegin("system_root", ::apache::thrift::protocol::T_STRING, 18);
    xfer += oprot->writeString(this->system_root);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.workgroup) {
    xfer += oprot->writeFieldBegin("workgroup", ::apache::thrift::protocol::T_STRING, 19);
    xfer += oprot->writeString(this->workgroup);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.os_version) {
    xfer += oprot->writeFieldBegin("os_version", ::apache::thrift::protocol::T_STRUCT, 20);
    xfer += this->os_version.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_infos) {
    xfer += oprot->writeFieldBegin("cluster_infos", ::apache::thrift::protocol::T_SET, 21);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cluster_infos.size()));
      std::set<cluster_info> ::const_iterator _iter166;
      for (_iter166 = this->cluster_infos.begin(); _iter166 != this->cluster_infos.end(); ++_iter166)
      {
        xfer += (*_iter166).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.disk_infos) {
    xfer += oprot->writeFieldBegin("disk_infos", ::apache::thrift::protocol::T_SET, 22);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->disk_infos.size()));
      std::set<disk_info> ::const_iterator _iter167;
      for (_iter167 = this->disk_infos.begin(); _iter167 != this->disk_infos.end(); ++_iter167)
      {
        xfer += (*_iter167).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.network_infos) {
    xfer += oprot->writeFieldBegin("network_infos", ::apache::thrift::protocol::T_SET, 23);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->network_infos.size()));
      std::set<network_info> ::const_iterator _iter168;
      for (_iter168 = this->network_infos.begin(); _iter168 != this->network_infos.end(); ++_iter168)
      {
        xfer += (*_iter168).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partition_infos) {
    xfer += oprot->writeFieldBegin("partition_infos", ::apache::thrift::protocol::T_SET, 24);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partition_infos.size()));
      std::set<partition_info> ::const_iterator _iter169;
      for (_iter169 = this->partition_infos.begin(); _iter169 != this->partition_infos.end(); ++_iter169)
      {
        xfer += (*_iter169).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.volume_infos) {
    xfer += oprot->writeFieldBegin("volume_infos", ::apache::thrift::protocol::T_SET, 25);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->volume_infos.size()));
      std::set<volume_info> ::const_iterator _iter170;
      for (_iter170 = this->volume_infos.begin(); _iter170 != this->volume_infos.end(); ++_iter170)
      {
        xfer += (*_iter170).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_vcbt_driver_installed) {
    xfer += oprot->writeFieldBegin("is_vcbt_driver_installed", ::apache::thrift::protocol::T_BOOL, 26);
    xfer += oprot->writeBool(this->is_vcbt_driver_installed);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_vcbt_enabled) {
    xfer += oprot->writeFieldBegin("is_vcbt_enabled", ::apache::thrift::protocol::T_BOOL, 27);
    xfer += oprot->writeBool(this->is_vcbt_enabled);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.current_vcbt_version) {
    xfer += oprot->writeFieldBegin("current_vcbt_version", ::apache::thrift::protocol::T_STRING, 28);
    xfer += oprot->writeString(this->current_vcbt_version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.installed_vcbt_version) {
    xfer += oprot->writeFieldBegin("installed_vcbt_version", ::apache::thrift::protocol::T_STRING, 29);
    xfer += oprot->writeString(this->installed_vcbt_version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_winpe) {
    xfer += oprot->writeFieldBegin("is_winpe", ::apache::thrift::protocol::T_BOOL, 30);
    xfer += oprot->writeBool(this->is_winpe);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.system_default_ui_language) {
    xfer += oprot->writeFieldBegin("system_default_ui_language", ::apache::thrift::protocol::T_I16, 31);
    xfer += oprot->writeI16(this->system_default_ui_language);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(physical_machine_info &a, physical_machine_info &b) {
  using ::std::swap;
  swap(a.architecture, b.architecture);
  swap(a.client_id, b.client_id);
  swap(a.client_name, b.client_name);
  swap(a.domain, b.domain);
  swap(a.hal, b.hal);
  swap(a.initiator_name, b.initiator_name);
  swap(a.is_oem, b.is_oem);
  swap(a.logical_processors, b.logical_processors);
  swap(a.machine_id, b.machine_id);
  swap(a.manufacturer, b.manufacturer);
  swap(a.os_name, b.os_name);
  swap(a.os_type, b.os_type);
  swap(a.os_system_info, b.os_system_info);
  swap(a.physical_memory, b.physical_memory);
  swap(a.processors, b.processors);
  swap(a.role, b.role);
  swap(a.system_model, b.system_model);
  swap(a.system_root, b.system_root);
  swap(a.workgroup, b.workgroup);
  swap(a.os_version, b.os_version);
  swap(a.cluster_infos, b.cluster_infos);
  swap(a.disk_infos, b.disk_infos);
  swap(a.network_infos, b.network_infos);
  swap(a.partition_infos, b.partition_infos);
  swap(a.volume_infos, b.volume_infos);
  swap(a.is_vcbt_driver_installed, b.is_vcbt_driver_installed);
  swap(a.is_vcbt_enabled, b.is_vcbt_enabled);
  swap(a.current_vcbt_version, b.current_vcbt_version);
  swap(a.installed_vcbt_version, b.installed_vcbt_version);
  swap(a.is_winpe, b.is_winpe);
  swap(a.system_default_ui_language, b.system_default_ui_language);
  swap(a.__isset, b.__isset);
}

physical_machine_info::physical_machine_info(const physical_machine_info& other171) {
  architecture = other171.architecture;
  client_id = other171.client_id;
  client_name = other171.client_name;
  domain = other171.domain;
  hal = other171.hal;
  initiator_name = other171.initiator_name;
  is_oem = other171.is_oem;
  logical_processors = other171.logical_processors;
  machine_id = other171.machine_id;
  manufacturer = other171.manufacturer;
  os_name = other171.os_name;
  os_type = other171.os_type;
  os_system_info = other171.os_system_info;
  physical_memory = other171.physical_memory;
  processors = other171.processors;
  role = other171.role;
  system_model = other171.system_model;
  system_root = other171.system_root;
  workgroup = other171.workgroup;
  os_version = other171.os_version;
  cluster_infos = other171.cluster_infos;
  disk_infos = other171.disk_infos;
  network_infos = other171.network_infos;
  partition_infos = other171.partition_infos;
  volume_infos = other171.volume_infos;
  is_vcbt_driver_installed = other171.is_vcbt_driver_installed;
  is_vcbt_enabled = other171.is_vcbt_enabled;
  current_vcbt_version = other171.current_vcbt_version;
  installed_vcbt_version = other171.installed_vcbt_version;
  is_winpe = other171.is_winpe;
  system_default_ui_language = other171.system_default_ui_language;
  __isset = other171.__isset;
}
physical_machine_info& physical_machine_info::operator=(const physical_machine_info& other172) {
  architecture = other172.architecture;
  client_id = other172.client_id;
  client_name = other172.client_name;
  domain = other172.domain;
  hal = other172.hal;
  initiator_name = other172.initiator_name;
  is_oem = other172.is_oem;
  logical_processors = other172.logical_processors;
  machine_id = other172.machine_id;
  manufacturer = other172.manufacturer;
  os_name = other172.os_name;
  os_type = other172.os_type;
  os_system_info = other172.os_system_info;
  physical_memory = other172.physical_memory;
  processors = other172.processors;
  role = other172.role;
  system_model = other172.system_model;
  system_root = other172.system_root;
  workgroup = other172.workgroup;
  os_version = other172.os_version;
  cluster_infos = other172.cluster_infos;
  disk_infos = other172.disk_infos;
  network_infos = other172.network_infos;
  partition_infos = other172.partition_infos;
  volume_infos = other172.volume_infos;
  is_vcbt_driver_installed = other172.is_vcbt_driver_installed;
  is_vcbt_enabled = other172.is_vcbt_enabled;
  current_vcbt_version = other172.current_vcbt_version;
  installed_vcbt_version = other172.installed_vcbt_version;
  is_winpe = other172.is_winpe;
  system_default_ui_language = other172.system_default_ui_language;
  __isset = other172.__isset;
  return *this;
}
void physical_machine_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "physical_machine_info(";
  out << "architecture="; (__isset.architecture ? (out << to_string(architecture)) : (out << "<null>"));
  out << ", " << "client_id="; (__isset.client_id ? (out << to_string(client_id)) : (out << "<null>"));
  out << ", " << "client_name="; (__isset.client_name ? (out << to_string(client_name)) : (out << "<null>"));
  out << ", " << "domain="; (__isset.domain ? (out << to_string(domain)) : (out << "<null>"));
  out << ", " << "hal="; (__isset.hal ? (out << to_string(hal)) : (out << "<null>"));
  out << ", " << "initiator_name="; (__isset.initiator_name ? (out << to_string(initiator_name)) : (out << "<null>"));
  out << ", " << "is_oem="; (__isset.is_oem ? (out << to_string(is_oem)) : (out << "<null>"));
  out << ", " << "logical_processors="; (__isset.logical_processors ? (out << to_string(logical_processors)) : (out << "<null>"));
  out << ", " << "machine_id="; (__isset.machine_id ? (out << to_string(machine_id)) : (out << "<null>"));
  out << ", " << "manufacturer="; (__isset.manufacturer ? (out << to_string(manufacturer)) : (out << "<null>"));
  out << ", " << "os_name="; (__isset.os_name ? (out << to_string(os_name)) : (out << "<null>"));
  out << ", " << "os_type="; (__isset.os_type ? (out << to_string(os_type)) : (out << "<null>"));
  out << ", " << "os_system_info="; (__isset.os_system_info ? (out << to_string(os_system_info)) : (out << "<null>"));
  out << ", " << "physical_memory="; (__isset.physical_memory ? (out << to_string(physical_memory)) : (out << "<null>"));
  out << ", " << "processors="; (__isset.processors ? (out << to_string(processors)) : (out << "<null>"));
  out << ", " << "role="; (__isset.role ? (out << to_string(role)) : (out << "<null>"));
  out << ", " << "system_model="; (__isset.system_model ? (out << to_string(system_model)) : (out << "<null>"));
  out << ", " << "system_root="; (__isset.system_root ? (out << to_string(system_root)) : (out << "<null>"));
  out << ", " << "workgroup="; (__isset.workgroup ? (out << to_string(workgroup)) : (out << "<null>"));
  out << ", " << "os_version="; (__isset.os_version ? (out << to_string(os_version)) : (out << "<null>"));
  out << ", " << "cluster_infos="; (__isset.cluster_infos ? (out << to_string(cluster_infos)) : (out << "<null>"));
  out << ", " << "disk_infos="; (__isset.disk_infos ? (out << to_string(disk_infos)) : (out << "<null>"));
  out << ", " << "network_infos="; (__isset.network_infos ? (out << to_string(network_infos)) : (out << "<null>"));
  out << ", " << "partition_infos="; (__isset.partition_infos ? (out << to_string(partition_infos)) : (out << "<null>"));
  out << ", " << "volume_infos="; (__isset.volume_infos ? (out << to_string(volume_infos)) : (out << "<null>"));
  out << ", " << "is_vcbt_driver_installed="; (__isset.is_vcbt_driver_installed ? (out << to_string(is_vcbt_driver_installed)) : (out << "<null>"));
  out << ", " << "is_vcbt_enabled="; (__isset.is_vcbt_enabled ? (out << to_string(is_vcbt_enabled)) : (out << "<null>"));
  out << ", " << "current_vcbt_version="; (__isset.current_vcbt_version ? (out << to_string(current_vcbt_version)) : (out << "<null>"));
  out << ", " << "installed_vcbt_version="; (__isset.installed_vcbt_version ? (out << to_string(installed_vcbt_version)) : (out << "<null>"));
  out << ", " << "is_winpe="; (__isset.is_winpe ? (out << to_string(is_winpe)) : (out << "<null>"));
  out << ", " << "system_default_ui_language="; (__isset.system_default_ui_language ? (out << to_string(system_default_ui_language)) : (out << "<null>"));
  out << ")";
}


virtual_host::~virtual_host() throw() {
}


void virtual_host::__set_name_ref(const std::string& val) {
  this->name_ref = val;
__isset.name_ref = true;
}

void virtual_host::__set_name(const std::string& val) {
  this->name = val;
__isset.name = true;
}

void virtual_host::__set_ip_addresses(const std::vector<std::string> & val) {
  this->ip_addresses = val;
__isset.ip_addresses = true;
}

void virtual_host::__set_ip_address(const std::string& val) {
  this->ip_address = val;
__isset.ip_address = true;
}

void virtual_host::__set_product_name(const std::string& val) {
  this->product_name = val;
__isset.product_name = true;
}

void virtual_host::__set_version(const std::string& val) {
  this->version = val;
__isset.version = true;
}

void virtual_host::__set_power_state(const hv_host_power_state::type val) {
  this->power_state = val;
__isset.power_state = true;
}

void virtual_host::__set_state(const std::string& val) {
  this->state = val;
__isset.state = true;
}

void virtual_host::__set_in_maintenance_mode(const bool val) {
  this->in_maintenance_mode = val;
__isset.in_maintenance_mode = true;
}

void virtual_host::__set_vms(const std::map<std::string, std::string> & val) {
  this->vms = val;
__isset.vms = true;
}

void virtual_host::__set_datastores(const std::map<std::string, std::string> & val) {
  this->datastores = val;
__isset.datastores = true;
}

void virtual_host::__set_networks(const std::map<std::string, std::string> & val) {
  this->networks = val;
__isset.networks = true;
}

void virtual_host::__set_datacenter_name(const std::string& val) {
  this->datacenter_name = val;
__isset.datacenter_name = true;
}

void virtual_host::__set_domain_name(const std::string& val) {
  this->domain_name = val;
__isset.domain_name = true;
}

void virtual_host::__set_cluster_key(const std::string& val) {
  this->cluster_key = val;
__isset.cluster_key = true;
}

void virtual_host::__set_full_name(const std::string& val) {
  this->full_name = val;
__isset.full_name = true;
}

void virtual_host::__set_lic_features(const std::map<std::string, std::vector<std::string> > & val) {
  this->lic_features = val;
__isset.lic_features = true;
}

void virtual_host::__set_name_list(const std::vector<std::string> & val) {
  this->name_list = val;
__isset.name_list = true;
}

void virtual_host::__set_domain_name_list(const std::vector<std::string> & val) {
  this->domain_name_list = val;
__isset.domain_name_list = true;
}

void virtual_host::__set_connection_type(const hv_connection_type::type val) {
  this->connection_type = val;
__isset.connection_type = true;
}

void virtual_host::__set_virtual_center_name(const std::string& val) {
  this->virtual_center_name = val;
__isset.virtual_center_name = true;
}

void virtual_host::__set_virtual_center_version(const std::string& val) {
  this->virtual_center_version = val;
__isset.virtual_center_version = true;
}

void virtual_host::__set_uuid(const std::string& val) {
  this->uuid = val;
__isset.uuid = true;
}

void virtual_host::__set_number_of_cpu_cores(const int16_t val) {
  this->number_of_cpu_cores = val;
__isset.number_of_cpu_cores = true;
}

void virtual_host::__set_number_of_cpu_packages(const int16_t val) {
  this->number_of_cpu_packages = val;
__isset.number_of_cpu_packages = true;
}

void virtual_host::__set_size_of_memory(const int64_t val) {
  this->size_of_memory = val;
__isset.size_of_memory = true;
}
std::ostream& operator<<(std::ostream& out, const virtual_host& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t virtual_host::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name_ref);
          this->__isset.name_ref = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->ip_addresses.clear();
            uint32_t _size173;
            ::apache::thrift::protocol::TType _etype176;
            xfer += iprot->readListBegin(_etype176, _size173);
            this->ip_addresses.resize(_size173);
            uint32_t _i177;
            for (_i177 = 0; _i177 < _size173; ++_i177)
            {
              xfer += iprot->readString(this->ip_addresses[_i177]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.ip_addresses = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ip_address);
          this->__isset.ip_address = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->product_name);
          this->__isset.product_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast178;
          xfer += iprot->readI32(ecast178);
          this->power_state = (hv_host_power_state::type)ecast178;
          this->__isset.power_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->state);
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->in_maintenance_mode);
          this->__isset.in_maintenance_mode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->vms.clear();
            uint32_t _size179;
            ::apache::thrift::protocol::TType _ktype180;
            ::apache::thrift::protocol::TType _vtype181;
            xfer += iprot->readMapBegin(_ktype180, _vtype181, _size179);
            uint32_t _i183;
            for (_i183 = 0; _i183 < _size179; ++_i183)
            {
              std::string _key184;
              xfer += iprot->readString(_key184);
              std::string& _val185 = this->vms[_key184];
              xfer += iprot->readString(_val185);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.vms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->datastores.clear();
            uint32_t _size186;
            ::apache::thrift::protocol::TType _ktype187;
            ::apache::thrift::protocol::TType _vtype188;
            xfer += iprot->readMapBegin(_ktype187, _vtype188, _size186);
            uint32_t _i190;
            for (_i190 = 0; _i190 < _size186; ++_i190)
            {
              std::string _key191;
              xfer += iprot->readString(_key191);
              std::string& _val192 = this->datastores[_key191];
              xfer += iprot->readString(_val192);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.datastores = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->networks.clear();
            uint32_t _size193;
            ::apache::thrift::protocol::TType _ktype194;
            ::apache::thrift::protocol::TType _vtype195;
            xfer += iprot->readMapBegin(_ktype194, _vtype195, _size193);
            uint32_t _i197;
            for (_i197 = 0; _i197 < _size193; ++_i197)
            {
              std::string _key198;
              xfer += iprot->readString(_key198);
              std::string& _val199 = this->networks[_key198];
              xfer += iprot->readString(_val199);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.networks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->datacenter_name);
          this->__isset.datacenter_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->domain_name);
          this->__isset.domain_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cluster_key);
          this->__isset.cluster_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->full_name);
          this->__isset.full_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->lic_features.clear();
            uint32_t _size200;
            ::apache::thrift::protocol::TType _ktype201;
            ::apache::thrift::protocol::TType _vtype202;
            xfer += iprot->readMapBegin(_ktype201, _vtype202, _size200);
            uint32_t _i204;
            for (_i204 = 0; _i204 < _size200; ++_i204)
            {
              std::string _key205;
              xfer += iprot->readString(_key205);
              std::vector<std::string> & _val206 = this->lic_features[_key205];
              {
                _val206.clear();
                uint32_t _size207;
                ::apache::thrift::protocol::TType _etype210;
                xfer += iprot->readListBegin(_etype210, _size207);
                _val206.resize(_size207);
                uint32_t _i211;
                for (_i211 = 0; _i211 < _size207; ++_i211)
                {
                  xfer += iprot->readString(_val206[_i211]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.lic_features = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->name_list.clear();
            uint32_t _size212;
            ::apache::thrift::protocol::TType _etype215;
            xfer += iprot->readListBegin(_etype215, _size212);
            this->name_list.resize(_size212);
            uint32_t _i216;
            for (_i216 = 0; _i216 < _size212; ++_i216)
            {
              xfer += iprot->readString(this->name_list[_i216]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.name_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->domain_name_list.clear();
            uint32_t _size217;
            ::apache::thrift::protocol::TType _etype220;
            xfer += iprot->readListBegin(_etype220, _size217);
            this->domain_name_list.resize(_size217);
            uint32_t _i221;
            for (_i221 = 0; _i221 < _size217; ++_i221)
            {
              xfer += iprot->readString(this->domain_name_list[_i221]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.domain_name_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast222;
          xfer += iprot->readI32(ecast222);
          this->connection_type = (hv_connection_type::type)ecast222;
          this->__isset.connection_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->virtual_center_name);
          this->__isset.virtual_center_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->virtual_center_version);
          this->__isset.virtual_center_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->uuid);
          this->__isset.uuid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->number_of_cpu_cores);
          this->__isset.number_of_cpu_cores = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->number_of_cpu_packages);
          this->__isset.number_of_cpu_packages = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 26:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->size_of_memory);
          this->__isset.size_of_memory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t virtual_host::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("virtual_host");

  if (this->__isset.name_ref) {
    xfer += oprot->writeFieldBegin("name_ref", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->name_ref);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ip_addresses) {
    xfer += oprot->writeFieldBegin("ip_addresses", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->ip_addresses.size()));
      std::vector<std::string> ::const_iterator _iter223;
      for (_iter223 = this->ip_addresses.begin(); _iter223 != this->ip_addresses.end(); ++_iter223)
      {
        xfer += oprot->writeString((*_iter223));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ip_address) {
    xfer += oprot->writeFieldBegin("ip_address", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->ip_address);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.product_name) {
    xfer += oprot->writeFieldBegin("product_name", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->product_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.version) {
    xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.power_state) {
    xfer += oprot->writeFieldBegin("power_state", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32((int32_t)this->power_state);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.state) {
    xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->state);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.in_maintenance_mode) {
    xfer += oprot->writeFieldBegin("in_maintenance_mode", ::apache::thrift::protocol::T_BOOL, 9);
    xfer += oprot->writeBool(this->in_maintenance_mode);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vms) {
    xfer += oprot->writeFieldBegin("vms", ::apache::thrift::protocol::T_MAP, 10);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->vms.size()));
      std::map<std::string, std::string> ::const_iterator _iter224;
      for (_iter224 = this->vms.begin(); _iter224 != this->vms.end(); ++_iter224)
      {
        xfer += oprot->writeString(_iter224->first);
        xfer += oprot->writeString(_iter224->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.datastores) {
    xfer += oprot->writeFieldBegin("datastores", ::apache::thrift::protocol::T_MAP, 11);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->datastores.size()));
      std::map<std::string, std::string> ::const_iterator _iter225;
      for (_iter225 = this->datastores.begin(); _iter225 != this->datastores.end(); ++_iter225)
      {
        xfer += oprot->writeString(_iter225->first);
        xfer += oprot->writeString(_iter225->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.networks) {
    xfer += oprot->writeFieldBegin("networks", ::apache::thrift::protocol::T_MAP, 12);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->networks.size()));
      std::map<std::string, std::string> ::const_iterator _iter226;
      for (_iter226 = this->networks.begin(); _iter226 != this->networks.end(); ++_iter226)
      {
        xfer += oprot->writeString(_iter226->first);
        xfer += oprot->writeString(_iter226->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.datacenter_name) {
    xfer += oprot->writeFieldBegin("datacenter_name", ::apache::thrift::protocol::T_STRING, 13);
    xfer += oprot->writeString(this->datacenter_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.domain_name) {
    xfer += oprot->writeFieldBegin("domain_name", ::apache::thrift::protocol::T_STRING, 14);
    xfer += oprot->writeString(this->domain_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_key) {
    xfer += oprot->writeFieldBegin("cluster_key", ::apache::thrift::protocol::T_STRING, 15);
    xfer += oprot->writeString(this->cluster_key);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.full_name) {
    xfer += oprot->writeFieldBegin("full_name", ::apache::thrift::protocol::T_STRING, 16);
    xfer += oprot->writeString(this->full_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lic_features) {
    xfer += oprot->writeFieldBegin("lic_features", ::apache::thrift::protocol::T_MAP, 17);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->lic_features.size()));
      std::map<std::string, std::vector<std::string> > ::const_iterator _iter227;
      for (_iter227 = this->lic_features.begin(); _iter227 != this->lic_features.end(); ++_iter227)
      {
        xfer += oprot->writeString(_iter227->first);
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter227->second.size()));
          std::vector<std::string> ::const_iterator _iter228;
          for (_iter228 = _iter227->second.begin(); _iter228 != _iter227->second.end(); ++_iter228)
          {
            xfer += oprot->writeString((*_iter228));
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.name_list) {
    xfer += oprot->writeFieldBegin("name_list", ::apache::thrift::protocol::T_LIST, 18);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->name_list.size()));
      std::vector<std::string> ::const_iterator _iter229;
      for (_iter229 = this->name_list.begin(); _iter229 != this->name_list.end(); ++_iter229)
      {
        xfer += oprot->writeString((*_iter229));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.domain_name_list) {
    xfer += oprot->writeFieldBegin("domain_name_list", ::apache::thrift::protocol::T_LIST, 19);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->domain_name_list.size()));
      std::vector<std::string> ::const_iterator _iter230;
      for (_iter230 = this->domain_name_list.begin(); _iter230 != this->domain_name_list.end(); ++_iter230)
      {
        xfer += oprot->writeString((*_iter230));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.connection_type) {
    xfer += oprot->writeFieldBegin("connection_type", ::apache::thrift::protocol::T_I32, 20);
    xfer += oprot->writeI32((int32_t)this->connection_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.virtual_center_name) {
    xfer += oprot->writeFieldBegin("virtual_center_name", ::apache::thrift::protocol::T_STRING, 21);
    xfer += oprot->writeString(this->virtual_center_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.virtual_center_version) {
    xfer += oprot->writeFieldBegin("virtual_center_version", ::apache::thrift::protocol::T_STRING, 22);
    xfer += oprot->writeString(this->virtual_center_version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.uuid) {
    xfer += oprot->writeFieldBegin("uuid", ::apache::thrift::protocol::T_STRING, 23);
    xfer += oprot->writeString(this->uuid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.number_of_cpu_cores) {
    xfer += oprot->writeFieldBegin("number_of_cpu_cores", ::apache::thrift::protocol::T_I16, 24);
    xfer += oprot->writeI16(this->number_of_cpu_cores);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.number_of_cpu_packages) {
    xfer += oprot->writeFieldBegin("number_of_cpu_packages", ::apache::thrift::protocol::T_I16, 25);
    xfer += oprot->writeI16(this->number_of_cpu_packages);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.size_of_memory) {
    xfer += oprot->writeFieldBegin("size_of_memory", ::apache::thrift::protocol::T_I64, 26);
    xfer += oprot->writeI64(this->size_of_memory);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(virtual_host &a, virtual_host &b) {
  using ::std::swap;
  swap(a.name_ref, b.name_ref);
  swap(a.name, b.name);
  swap(a.ip_addresses, b.ip_addresses);
  swap(a.ip_address, b.ip_address);
  swap(a.product_name, b.product_name);
  swap(a.version, b.version);
  swap(a.power_state, b.power_state);
  swap(a.state, b.state);
  swap(a.in_maintenance_mode, b.in_maintenance_mode);
  swap(a.vms, b.vms);
  swap(a.datastores, b.datastores);
  swap(a.networks, b.networks);
  swap(a.datacenter_name, b.datacenter_name);
  swap(a.domain_name, b.domain_name);
  swap(a.cluster_key, b.cluster_key);
  swap(a.full_name, b.full_name);
  swap(a.lic_features, b.lic_features);
  swap(a.name_list, b.name_list);
  swap(a.domain_name_list, b.domain_name_list);
  swap(a.connection_type, b.connection_type);
  swap(a.virtual_center_name, b.virtual_center_name);
  swap(a.virtual_center_version, b.virtual_center_version);
  swap(a.uuid, b.uuid);
  swap(a.number_of_cpu_cores, b.number_of_cpu_cores);
  swap(a.number_of_cpu_packages, b.number_of_cpu_packages);
  swap(a.size_of_memory, b.size_of_memory);
  swap(a.__isset, b.__isset);
}

virtual_host::virtual_host(const virtual_host& other231) {
  name_ref = other231.name_ref;
  name = other231.name;
  ip_addresses = other231.ip_addresses;
  ip_address = other231.ip_address;
  product_name = other231.product_name;
  version = other231.version;
  power_state = other231.power_state;
  state = other231.state;
  in_maintenance_mode = other231.in_maintenance_mode;
  vms = other231.vms;
  datastores = other231.datastores;
  networks = other231.networks;
  datacenter_name = other231.datacenter_name;
  domain_name = other231.domain_name;
  cluster_key = other231.cluster_key;
  full_name = other231.full_name;
  lic_features = other231.lic_features;
  name_list = other231.name_list;
  domain_name_list = other231.domain_name_list;
  connection_type = other231.connection_type;
  virtual_center_name = other231.virtual_center_name;
  virtual_center_version = other231.virtual_center_version;
  uuid = other231.uuid;
  number_of_cpu_cores = other231.number_of_cpu_cores;
  number_of_cpu_packages = other231.number_of_cpu_packages;
  size_of_memory = other231.size_of_memory;
  __isset = other231.__isset;
}
virtual_host& virtual_host::operator=(const virtual_host& other232) {
  name_ref = other232.name_ref;
  name = other232.name;
  ip_addresses = other232.ip_addresses;
  ip_address = other232.ip_address;
  product_name = other232.product_name;
  version = other232.version;
  power_state = other232.power_state;
  state = other232.state;
  in_maintenance_mode = other232.in_maintenance_mode;
  vms = other232.vms;
  datastores = other232.datastores;
  networks = other232.networks;
  datacenter_name = other232.datacenter_name;
  domain_name = other232.domain_name;
  cluster_key = other232.cluster_key;
  full_name = other232.full_name;
  lic_features = other232.lic_features;
  name_list = other232.name_list;
  domain_name_list = other232.domain_name_list;
  connection_type = other232.connection_type;
  virtual_center_name = other232.virtual_center_name;
  virtual_center_version = other232.virtual_center_version;
  uuid = other232.uuid;
  number_of_cpu_cores = other232.number_of_cpu_cores;
  number_of_cpu_packages = other232.number_of_cpu_packages;
  size_of_memory = other232.size_of_memory;
  __isset = other232.__isset;
  return *this;
}
void virtual_host::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "virtual_host(";
  out << "name_ref="; (__isset.name_ref ? (out << to_string(name_ref)) : (out << "<null>"));
  out << ", " << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
  out << ", " << "ip_addresses="; (__isset.ip_addresses ? (out << to_string(ip_addresses)) : (out << "<null>"));
  out << ", " << "ip_address="; (__isset.ip_address ? (out << to_string(ip_address)) : (out << "<null>"));
  out << ", " << "product_name="; (__isset.product_name ? (out << to_string(product_name)) : (out << "<null>"));
  out << ", " << "version="; (__isset.version ? (out << to_string(version)) : (out << "<null>"));
  out << ", " << "power_state="; (__isset.power_state ? (out << to_string(power_state)) : (out << "<null>"));
  out << ", " << "state="; (__isset.state ? (out << to_string(state)) : (out << "<null>"));
  out << ", " << "in_maintenance_mode="; (__isset.in_maintenance_mode ? (out << to_string(in_maintenance_mode)) : (out << "<null>"));
  out << ", " << "vms="; (__isset.vms ? (out << to_string(vms)) : (out << "<null>"));
  out << ", " << "datastores="; (__isset.datastores ? (out << to_string(datastores)) : (out << "<null>"));
  out << ", " << "networks="; (__isset.networks ? (out << to_string(networks)) : (out << "<null>"));
  out << ", " << "datacenter_name="; (__isset.datacenter_name ? (out << to_string(datacenter_name)) : (out << "<null>"));
  out << ", " << "domain_name="; (__isset.domain_name ? (out << to_string(domain_name)) : (out << "<null>"));
  out << ", " << "cluster_key="; (__isset.cluster_key ? (out << to_string(cluster_key)) : (out << "<null>"));
  out << ", " << "full_name="; (__isset.full_name ? (out << to_string(full_name)) : (out << "<null>"));
  out << ", " << "lic_features="; (__isset.lic_features ? (out << to_string(lic_features)) : (out << "<null>"));
  out << ", " << "name_list="; (__isset.name_list ? (out << to_string(name_list)) : (out << "<null>"));
  out << ", " << "domain_name_list="; (__isset.domain_name_list ? (out << to_string(domain_name_list)) : (out << "<null>"));
  out << ", " << "connection_type="; (__isset.connection_type ? (out << to_string(connection_type)) : (out << "<null>"));
  out << ", " << "virtual_center_name="; (__isset.virtual_center_name ? (out << to_string(virtual_center_name)) : (out << "<null>"));
  out << ", " << "virtual_center_version="; (__isset.virtual_center_version ? (out << to_string(virtual_center_version)) : (out << "<null>"));
  out << ", " << "uuid="; (__isset.uuid ? (out << to_string(uuid)) : (out << "<null>"));
  out << ", " << "number_of_cpu_cores="; (__isset.number_of_cpu_cores ? (out << to_string(number_of_cpu_cores)) : (out << "<null>"));
  out << ", " << "number_of_cpu_packages="; (__isset.number_of_cpu_packages ? (out << to_string(number_of_cpu_packages)) : (out << "<null>"));
  out << ", " << "size_of_memory="; (__isset.size_of_memory ? (out << to_string(size_of_memory)) : (out << "<null>"));
  out << ")";
}


virtual_network_adapter::~virtual_network_adapter() throw() {
}


void virtual_network_adapter::__set_key(const int32_t val) {
  this->key = val;
__isset.key = true;
}

void virtual_network_adapter::__set_name(const std::string& val) {
  this->name = val;
__isset.name = true;
}

void virtual_network_adapter::__set_mac_address(const std::string& val) {
  this->mac_address = val;
__isset.mac_address = true;
}

void virtual_network_adapter::__set_network(const std::string& val) {
  this->network = val;
__isset.network = true;
}

void virtual_network_adapter::__set_port_group(const std::string& val) {
  this->port_group = val;
__isset.port_group = true;
}

void virtual_network_adapter::__set_type(const std::string& val) {
  this->type = val;
__isset.type = true;
}

void virtual_network_adapter::__set_is_connected(const bool val) {
  this->is_connected = val;
__isset.is_connected = true;
}

void virtual_network_adapter::__set_is_start_connected(const bool val) {
  this->is_start_connected = val;
__isset.is_start_connected = true;
}

void virtual_network_adapter::__set_is_allow_guest_control(const bool val) {
  this->is_allow_guest_control = val;
__isset.is_allow_guest_control = true;
}

void virtual_network_adapter::__set_address_type(const std::string& val) {
  this->address_type = val;
__isset.address_type = true;
}

void virtual_network_adapter::__set_ip_addresses(const std::vector<std::string> & val) {
  this->ip_addresses = val;
__isset.ip_addresses = true;
}
std::ostream& operator<<(std::ostream& out, const virtual_network_adapter& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t virtual_network_adapter::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->mac_address);
          this->__isset.mac_address = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->network);
          this->__isset.network = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->port_group);
          this->__isset.port_group = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_connected);
          this->__isset.is_connected = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_start_connected);
          this->__isset.is_start_connected = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_allow_guest_control);
          this->__isset.is_allow_guest_control = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->address_type);
          this->__isset.address_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->ip_addresses.clear();
            uint32_t _size233;
            ::apache::thrift::protocol::TType _etype236;
            xfer += iprot->readListBegin(_etype236, _size233);
            this->ip_addresses.resize(_size233);
            uint32_t _i237;
            for (_i237 = 0; _i237 < _size233; ++_i237)
            {
              xfer += iprot->readString(this->ip_addresses[_i237]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.ip_addresses = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t virtual_network_adapter::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("virtual_network_adapter");

  if (this->__isset.key) {
    xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->key);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mac_address) {
    xfer += oprot->writeFieldBegin("mac_address", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->mac_address);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.network) {
    xfer += oprot->writeFieldBegin("network", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->network);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.port_group) {
    xfer += oprot->writeFieldBegin("port_group", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->port_group);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.type) {
    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_connected) {
    xfer += oprot->writeFieldBegin("is_connected", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->is_connected);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_start_connected) {
    xfer += oprot->writeFieldBegin("is_start_connected", ::apache::thrift::protocol::T_BOOL, 8);
    xfer += oprot->writeBool(this->is_start_connected);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_allow_guest_control) {
    xfer += oprot->writeFieldBegin("is_allow_guest_control", ::apache::thrift::protocol::T_BOOL, 9);
    xfer += oprot->writeBool(this->is_allow_guest_control);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.address_type) {
    xfer += oprot->writeFieldBegin("address_type", ::apache::thrift::protocol::T_STRING, 10);
    xfer += oprot->writeString(this->address_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ip_addresses) {
    xfer += oprot->writeFieldBegin("ip_addresses", ::apache::thrift::protocol::T_LIST, 11);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->ip_addresses.size()));
      std::vector<std::string> ::const_iterator _iter238;
      for (_iter238 = this->ip_addresses.begin(); _iter238 != this->ip_addresses.end(); ++_iter238)
      {
        xfer += oprot->writeString((*_iter238));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(virtual_network_adapter &a, virtual_network_adapter &b) {
  using ::std::swap;
  swap(a.key, b.key);
  swap(a.name, b.name);
  swap(a.mac_address, b.mac_address);
  swap(a.network, b.network);
  swap(a.port_group, b.port_group);
  swap(a.type, b.type);
  swap(a.is_connected, b.is_connected);
  swap(a.is_start_connected, b.is_start_connected);
  swap(a.is_allow_guest_control, b.is_allow_guest_control);
  swap(a.address_type, b.address_type);
  swap(a.ip_addresses, b.ip_addresses);
  swap(a.__isset, b.__isset);
}

virtual_network_adapter::virtual_network_adapter(const virtual_network_adapter& other239) {
  key = other239.key;
  name = other239.name;
  mac_address = other239.mac_address;
  network = other239.network;
  port_group = other239.port_group;
  type = other239.type;
  is_connected = other239.is_connected;
  is_start_connected = other239.is_start_connected;
  is_allow_guest_control = other239.is_allow_guest_control;
  address_type = other239.address_type;
  ip_addresses = other239.ip_addresses;
  __isset = other239.__isset;
}
virtual_network_adapter& virtual_network_adapter::operator=(const virtual_network_adapter& other240) {
  key = other240.key;
  name = other240.name;
  mac_address = other240.mac_address;
  network = other240.network;
  port_group = other240.port_group;
  type = other240.type;
  is_connected = other240.is_connected;
  is_start_connected = other240.is_start_connected;
  is_allow_guest_control = other240.is_allow_guest_control;
  address_type = other240.address_type;
  ip_addresses = other240.ip_addresses;
  __isset = other240.__isset;
  return *this;
}
void virtual_network_adapter::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "virtual_network_adapter(";
  out << "key="; (__isset.key ? (out << to_string(key)) : (out << "<null>"));
  out << ", " << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
  out << ", " << "mac_address="; (__isset.mac_address ? (out << to_string(mac_address)) : (out << "<null>"));
  out << ", " << "network="; (__isset.network ? (out << to_string(network)) : (out << "<null>"));
  out << ", " << "port_group="; (__isset.port_group ? (out << to_string(port_group)) : (out << "<null>"));
  out << ", " << "type="; (__isset.type ? (out << to_string(type)) : (out << "<null>"));
  out << ", " << "is_connected="; (__isset.is_connected ? (out << to_string(is_connected)) : (out << "<null>"));
  out << ", " << "is_start_connected="; (__isset.is_start_connected ? (out << to_string(is_start_connected)) : (out << "<null>"));
  out << ", " << "is_allow_guest_control="; (__isset.is_allow_guest_control ? (out << to_string(is_allow_guest_control)) : (out << "<null>"));
  out << ", " << "address_type="; (__isset.address_type ? (out << to_string(address_type)) : (out << "<null>"));
  out << ", " << "ip_addresses="; (__isset.ip_addresses ? (out << to_string(ip_addresses)) : (out << "<null>"));
  out << ")";
}


virtual_machine_snapshots::~virtual_machine_snapshots() throw() {
}


void virtual_machine_snapshots::__set_name(const std::string& val) {
  this->name = val;
__isset.name = true;
}

void virtual_machine_snapshots::__set_description(const std::string& val) {
  this->description = val;
__isset.description = true;
}

void virtual_machine_snapshots::__set_create_time(const std::string& val) {
  this->create_time = val;
__isset.create_time = true;
}

void virtual_machine_snapshots::__set_quiesced(const bool val) {
  this->quiesced = val;
__isset.quiesced = true;
}

void virtual_machine_snapshots::__set_id(const int32_t val) {
  this->id = val;
__isset.id = true;
}

void virtual_machine_snapshots::__set_backup_manifest(const std::string& val) {
  this->backup_manifest = val;
__isset.backup_manifest = true;
}

void virtual_machine_snapshots::__set_replay_supported(const bool val) {
  this->replay_supported = val;
__isset.replay_supported = true;
}

void virtual_machine_snapshots::__set_child_snapshot_list(const std::vector<virtual_machine_snapshots> & val) {
  this->child_snapshot_list = val;
__isset.child_snapshot_list = true;
}
std::ostream& operator<<(std::ostream& out, const virtual_machine_snapshots& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t virtual_machine_snapshots::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->description);
          this->__isset.description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->create_time);
          this->__isset.create_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->quiesced);
          this->__isset.quiesced = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->backup_manifest);
          this->__isset.backup_manifest = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->replay_supported);
          this->__isset.replay_supported = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->child_snapshot_list.clear();
            uint32_t _size241;
            ::apache::thrift::protocol::TType _etype244;
            xfer += iprot->readListBegin(_etype244, _size241);
            this->child_snapshot_list.resize(_size241);
            uint32_t _i245;
            for (_i245 = 0; _i245 < _size241; ++_i245)
            {
              xfer += this->child_snapshot_list[_i245].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.child_snapshot_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t virtual_machine_snapshots::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("virtual_machine_snapshots");

  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.description) {
    xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->description);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.create_time) {
    xfer += oprot->writeFieldBegin("create_time", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->create_time);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.quiesced) {
    xfer += oprot->writeFieldBegin("quiesced", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->quiesced);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.backup_manifest) {
    xfer += oprot->writeFieldBegin("backup_manifest", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->backup_manifest);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.replay_supported) {
    xfer += oprot->writeFieldBegin("replay_supported", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->replay_supported);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.child_snapshot_list) {
    xfer += oprot->writeFieldBegin("child_snapshot_list", ::apache::thrift::protocol::T_LIST, 8);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->child_snapshot_list.size()));
      std::vector<virtual_machine_snapshots> ::const_iterator _iter246;
      for (_iter246 = this->child_snapshot_list.begin(); _iter246 != this->child_snapshot_list.end(); ++_iter246)
      {
        xfer += (*_iter246).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(virtual_machine_snapshots &a, virtual_machine_snapshots &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.description, b.description);
  swap(a.create_time, b.create_time);
  swap(a.quiesced, b.quiesced);
  swap(a.id, b.id);
  swap(a.backup_manifest, b.backup_manifest);
  swap(a.replay_supported, b.replay_supported);
  swap(a.child_snapshot_list, b.child_snapshot_list);
  swap(a.__isset, b.__isset);
}

virtual_machine_snapshots::virtual_machine_snapshots(const virtual_machine_snapshots& other247) {
  name = other247.name;
  description = other247.description;
  create_time = other247.create_time;
  quiesced = other247.quiesced;
  id = other247.id;
  backup_manifest = other247.backup_manifest;
  replay_supported = other247.replay_supported;
  child_snapshot_list = other247.child_snapshot_list;
  __isset = other247.__isset;
}
virtual_machine_snapshots& virtual_machine_snapshots::operator=(const virtual_machine_snapshots& other248) {
  name = other248.name;
  description = other248.description;
  create_time = other248.create_time;
  quiesced = other248.quiesced;
  id = other248.id;
  backup_manifest = other248.backup_manifest;
  replay_supported = other248.replay_supported;
  child_snapshot_list = other248.child_snapshot_list;
  __isset = other248.__isset;
  return *this;
}
void virtual_machine_snapshots::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "virtual_machine_snapshots(";
  out << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
  out << ", " << "description="; (__isset.description ? (out << to_string(description)) : (out << "<null>"));
  out << ", " << "create_time="; (__isset.create_time ? (out << to_string(create_time)) : (out << "<null>"));
  out << ", " << "quiesced="; (__isset.quiesced ? (out << to_string(quiesced)) : (out << "<null>"));
  out << ", " << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "backup_manifest="; (__isset.backup_manifest ? (out << to_string(backup_manifest)) : (out << "<null>"));
  out << ", " << "replay_supported="; (__isset.replay_supported ? (out << to_string(replay_supported)) : (out << "<null>"));
  out << ", " << "child_snapshot_list="; (__isset.child_snapshot_list ? (out << to_string(child_snapshot_list)) : (out << "<null>"));
  out << ")";
}


virtual_disk_info::~virtual_disk_info() throw() {
}


void virtual_disk_info::__set_key(const std::string& val) {
  this->key = val;
__isset.key = true;
}

void virtual_disk_info::__set_name(const std::string& val) {
  this->name = val;
__isset.name = true;
}

void virtual_disk_info::__set_id(const std::string& val) {
  this->id = val;
__isset.id = true;
}

void virtual_disk_info::__set_size_kb(const int64_t val) {
  this->size_kb = val;
__isset.size_kb = true;
}

void virtual_disk_info::__set_size(const int64_t val) {
  this->size = val;
__isset.size = true;
}

void virtual_disk_info::__set_controller_type(const hv_controller_type::type val) {
  this->controller_type = val;
__isset.controller_type = true;
}

void virtual_disk_info::__set_thin_provisioned(const bool val) {
  this->thin_provisioned = val;
__isset.thin_provisioned = true;
}
std::ostream& operator<<(std::ostream& out, const virtual_disk_info& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t virtual_disk_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->size_kb);
          this->__isset.size_kb = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->size);
          this->__isset.size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast249;
          xfer += iprot->readI32(ecast249);
          this->controller_type = (hv_controller_type::type)ecast249;
          this->__isset.controller_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->thin_provisioned);
          this->__isset.thin_provisioned = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t virtual_disk_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("virtual_disk_info");

  if (this->__isset.key) {
    xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->key);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.size_kb) {
    xfer += oprot->writeFieldBegin("size_kb", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->size_kb);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.size) {
    xfer += oprot->writeFieldBegin("size", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.controller_type) {
    xfer += oprot->writeFieldBegin("controller_type", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32((int32_t)this->controller_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.thin_provisioned) {
    xfer += oprot->writeFieldBegin("thin_provisioned", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->thin_provisioned);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(virtual_disk_info &a, virtual_disk_info &b) {
  using ::std::swap;
  swap(a.key, b.key);
  swap(a.name, b.name);
  swap(a.id, b.id);
  swap(a.size_kb, b.size_kb);
  swap(a.size, b.size);
  swap(a.controller_type, b.controller_type);
  swap(a.thin_provisioned, b.thin_provisioned);
  swap(a.__isset, b.__isset);
}

virtual_disk_info::virtual_disk_info(const virtual_disk_info& other250) {
  key = other250.key;
  name = other250.name;
  id = other250.id;
  size_kb = other250.size_kb;
  size = other250.size;
  controller_type = other250.controller_type;
  thin_provisioned = other250.thin_provisioned;
  __isset = other250.__isset;
}
virtual_disk_info& virtual_disk_info::operator=(const virtual_disk_info& other251) {
  key = other251.key;
  name = other251.name;
  id = other251.id;
  size_kb = other251.size_kb;
  size = other251.size;
  controller_type = other251.controller_type;
  thin_provisioned = other251.thin_provisioned;
  __isset = other251.__isset;
  return *this;
}
void virtual_disk_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "virtual_disk_info(";
  out << "key="; (__isset.key ? (out << to_string(key)) : (out << "<null>"));
  out << ", " << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
  out << ", " << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "size_kb="; (__isset.size_kb ? (out << to_string(size_kb)) : (out << "<null>"));
  out << ", " << "size="; (__isset.size ? (out << to_string(size)) : (out << "<null>"));
  out << ", " << "controller_type="; (__isset.controller_type ? (out << to_string(controller_type)) : (out << "<null>"));
  out << ", " << "thin_provisioned="; (__isset.thin_provisioned ? (out << to_string(thin_provisioned)) : (out << "<null>"));
  out << ")";
}


virtual_machine::~virtual_machine() throw() {
}


void virtual_machine::__set_uuid(const std::string& val) {
  this->uuid = val;
__isset.uuid = true;
}

void virtual_machine::__set_name(const std::string& val) {
  this->name = val;
__isset.name = true;
}

void virtual_machine::__set_host_key(const std::string& val) {
  this->host_key = val;
__isset.host_key = true;
}

void virtual_machine::__set_host_ip(const std::string& val) {
  this->host_ip = val;
__isset.host_ip = true;
}

void virtual_machine::__set_host_name(const std::string& val) {
  this->host_name = val;
__isset.host_name = true;
}

void virtual_machine::__set_cluster_key(const std::string& val) {
  this->cluster_key = val;
__isset.cluster_key = true;
}

void virtual_machine::__set_cluster_name(const std::string& val) {
  this->cluster_name = val;
__isset.cluster_name = true;
}

void virtual_machine::__set_annotation(const std::string& val) {
  this->annotation = val;
__isset.annotation = true;
}

void virtual_machine::__set_is_cpu_hot_add(const bool val) {
  this->is_cpu_hot_add = val;
__isset.is_cpu_hot_add = true;
}

void virtual_machine::__set_is_cpu_hot_remove(const bool val) {
  this->is_cpu_hot_remove = val;
__isset.is_cpu_hot_remove = true;
}

void virtual_machine::__set_memory_mb(const int32_t val) {
  this->memory_mb = val;
__isset.memory_mb = true;
}

void virtual_machine::__set_number_of_cpu(const int32_t val) {
  this->number_of_cpu = val;
__isset.number_of_cpu = true;
}

void virtual_machine::__set_is_template(const bool val) {
  this->is_template = val;
__isset.is_template = true;
}

void virtual_machine::__set_config_path(const std::string& val) {
  this->config_path = val;
__isset.config_path = true;
}

void virtual_machine::__set_config_path_file(const std::string& val) {
  this->config_path_file = val;
__isset.config_path_file = true;
}

void virtual_machine::__set_version(const int32_t val) {
  this->version = val;
__isset.version = true;
}

void virtual_machine::__set_power_state(const hv_vm_power_state::type val) {
  this->power_state = val;
__isset.power_state = true;
}

void virtual_machine::__set_connection_state(const hv_vm_connection_state::type val) {
  this->connection_state = val;
__isset.connection_state = true;
}

void virtual_machine::__set_tools_status(const hv_vm_tools_status::type val) {
  this->tools_status = val;
__isset.tools_status = true;
}

void virtual_machine::__set_firmware(const hv_vm_firmware::type val) {
  this->firmware = val;
__isset.firmware = true;
}

void virtual_machine::__set_guest_os_type(const hv_guest_os_type::type val) {
  this->guest_os_type = val;
__isset.guest_os_type = true;
}

void virtual_machine::__set_guest_id(const std::string& val) {
  this->guest_id = val;
__isset.guest_id = true;
}

void virtual_machine::__set_guest_os_name(const std::string& val) {
  this->guest_os_name = val;
__isset.guest_os_name = true;
}

void virtual_machine::__set_is_disk_uuid_enabled(const bool val) {
  this->is_disk_uuid_enabled = val;
__isset.is_disk_uuid_enabled = true;
}

void virtual_machine::__set_folder_path(const std::string& val) {
  this->folder_path = val;
__isset.folder_path = true;
}

void virtual_machine::__set_resource_pool_path(const std::string& val) {
  this->resource_pool_path = val;
__isset.resource_pool_path = true;
}

void virtual_machine::__set_disks(const std::vector<virtual_disk_info> & val) {
  this->disks = val;
__isset.disks = true;
}

void virtual_machine::__set_networks(const std::map<std::string, std::string> & val) {
  this->networks = val;
__isset.networks = true;
}

void virtual_machine::__set_datacenter_name(const std::string& val) {
  this->datacenter_name = val;
__isset.datacenter_name = true;
}

void virtual_machine::__set_network_adapters(const std::vector<virtual_network_adapter> & val) {
  this->network_adapters = val;
__isset.network_adapters = true;
}

void virtual_machine::__set_root_snapshot_list(const std::vector<virtual_machine_snapshots> & val) {
  this->root_snapshot_list = val;
__isset.root_snapshot_list = true;
}

void virtual_machine::__set_guest_host_name(const std::string& val) {
  this->guest_host_name = val;
__isset.guest_host_name = true;
}

void virtual_machine::__set_guest_ip(const std::string& val) {
  this->guest_ip = val;
__isset.guest_ip = true;
}

void virtual_machine::__set_has_cdrom(const bool val) {
  this->has_cdrom = val;
__isset.has_cdrom = true;
}
std::ostream& operator<<(std::ostream& out, const virtual_machine& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t virtual_machine::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->uuid);
          this->__isset.uuid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host_key);
          this->__isset.host_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host_ip);
          this->__isset.host_ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host_name);
          this->__isset.host_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cluster_key);
          this->__isset.cluster_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cluster_name);
          this->__isset.cluster_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->annotation);
          this->__isset.annotation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_cpu_hot_add);
          this->__isset.is_cpu_hot_add = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_cpu_hot_remove);
          this->__isset.is_cpu_hot_remove = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->memory_mb);
          this->__isset.memory_mb = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->number_of_cpu);
          this->__isset.number_of_cpu = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_template);
          this->__isset.is_template = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->config_path);
          this->__isset.config_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->config_path_file);
          this->__isset.config_path_file = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast252;
          xfer += iprot->readI32(ecast252);
          this->power_state = (hv_vm_power_state::type)ecast252;
          this->__isset.power_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast253;
          xfer += iprot->readI32(ecast253);
          this->connection_state = (hv_vm_connection_state::type)ecast253;
          this->__isset.connection_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast254;
          xfer += iprot->readI32(ecast254);
          this->tools_status = (hv_vm_tools_status::type)ecast254;
          this->__isset.tools_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast255;
          xfer += iprot->readI32(ecast255);
          this->firmware = (hv_vm_firmware::type)ecast255;
          this->__isset.firmware = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast256;
          xfer += iprot->readI32(ecast256);
          this->guest_os_type = (hv_guest_os_type::type)ecast256;
          this->__isset.guest_os_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guest_id);
          this->__isset.guest_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guest_os_name);
          this->__isset.guest_os_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_disk_uuid_enabled);
          this->__isset.is_disk_uuid_enabled = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->folder_path);
          this->__isset.folder_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 26:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resource_pool_path);
          this->__isset.resource_pool_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 27:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->disks.clear();
            uint32_t _size257;
            ::apache::thrift::protocol::TType _etype260;
            xfer += iprot->readListBegin(_etype260, _size257);
            this->disks.resize(_size257);
            uint32_t _i261;
            for (_i261 = 0; _i261 < _size257; ++_i261)
            {
              xfer += this->disks[_i261].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.disks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 28:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->networks.clear();
            uint32_t _size262;
            ::apache::thrift::protocol::TType _ktype263;
            ::apache::thrift::protocol::TType _vtype264;
            xfer += iprot->readMapBegin(_ktype263, _vtype264, _size262);
            uint32_t _i266;
            for (_i266 = 0; _i266 < _size262; ++_i266)
            {
              std::string _key267;
              xfer += iprot->readString(_key267);
              std::string& _val268 = this->networks[_key267];
              xfer += iprot->readString(_val268);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.networks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 29:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->datacenter_name);
          this->__isset.datacenter_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->network_adapters.clear();
            uint32_t _size269;
            ::apache::thrift::protocol::TType _etype272;
            xfer += iprot->readListBegin(_etype272, _size269);
            this->network_adapters.resize(_size269);
            uint32_t _i273;
            for (_i273 = 0; _i273 < _size269; ++_i273)
            {
              xfer += this->network_adapters[_i273].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.network_adapters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 31:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->root_snapshot_list.clear();
            uint32_t _size274;
            ::apache::thrift::protocol::TType _etype277;
            xfer += iprot->readListBegin(_etype277, _size274);
            this->root_snapshot_list.resize(_size274);
            uint32_t _i278;
            for (_i278 = 0; _i278 < _size274; ++_i278)
            {
              xfer += this->root_snapshot_list[_i278].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.root_snapshot_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 32:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guest_host_name);
          this->__isset.guest_host_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 33:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guest_ip);
          this->__isset.guest_ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 34:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->has_cdrom);
          this->__isset.has_cdrom = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t virtual_machine::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("virtual_machine");

  if (this->__isset.uuid) {
    xfer += oprot->writeFieldBegin("uuid", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->uuid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.host_key) {
    xfer += oprot->writeFieldBegin("host_key", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->host_key);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.host_ip) {
    xfer += oprot->writeFieldBegin("host_ip", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->host_ip);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.host_name) {
    xfer += oprot->writeFieldBegin("host_name", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->host_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_key) {
    xfer += oprot->writeFieldBegin("cluster_key", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->cluster_key);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_name) {
    xfer += oprot->writeFieldBegin("cluster_name", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->cluster_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.annotation) {
    xfer += oprot->writeFieldBegin("annotation", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->annotation);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_cpu_hot_add) {
    xfer += oprot->writeFieldBegin("is_cpu_hot_add", ::apache::thrift::protocol::T_BOOL, 9);
    xfer += oprot->writeBool(this->is_cpu_hot_add);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_cpu_hot_remove) {
    xfer += oprot->writeFieldBegin("is_cpu_hot_remove", ::apache::thrift::protocol::T_BOOL, 10);
    xfer += oprot->writeBool(this->is_cpu_hot_remove);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.memory_mb) {
    xfer += oprot->writeFieldBegin("memory_mb", ::apache::thrift::protocol::T_I32, 11);
    xfer += oprot->writeI32(this->memory_mb);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.number_of_cpu) {
    xfer += oprot->writeFieldBegin("number_of_cpu", ::apache::thrift::protocol::T_I32, 12);
    xfer += oprot->writeI32(this->number_of_cpu);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_template) {
    xfer += oprot->writeFieldBegin("is_template", ::apache::thrift::protocol::T_BOOL, 13);
    xfer += oprot->writeBool(this->is_template);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.config_path) {
    xfer += oprot->writeFieldBegin("config_path", ::apache::thrift::protocol::T_STRING, 14);
    xfer += oprot->writeString(this->config_path);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.config_path_file) {
    xfer += oprot->writeFieldBegin("config_path_file", ::apache::thrift::protocol::T_STRING, 15);
    xfer += oprot->writeString(this->config_path_file);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.version) {
    xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_I32, 16);
    xfer += oprot->writeI32(this->version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.power_state) {
    xfer += oprot->writeFieldBegin("power_state", ::apache::thrift::protocol::T_I32, 17);
    xfer += oprot->writeI32((int32_t)this->power_state);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.connection_state) {
    xfer += oprot->writeFieldBegin("connection_state", ::apache::thrift::protocol::T_I32, 18);
    xfer += oprot->writeI32((int32_t)this->connection_state);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tools_status) {
    xfer += oprot->writeFieldBegin("tools_status", ::apache::thrift::protocol::T_I32, 19);
    xfer += oprot->writeI32((int32_t)this->tools_status);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.firmware) {
    xfer += oprot->writeFieldBegin("firmware", ::apache::thrift::protocol::T_I32, 20);
    xfer += oprot->writeI32((int32_t)this->firmware);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.guest_os_type) {
    xfer += oprot->writeFieldBegin("guest_os_type", ::apache::thrift::protocol::T_I32, 21);
    xfer += oprot->writeI32((int32_t)this->guest_os_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.guest_id) {
    xfer += oprot->writeFieldBegin("guest_id", ::apache::thrift::protocol::T_STRING, 22);
    xfer += oprot->writeString(this->guest_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.guest_os_name) {
    xfer += oprot->writeFieldBegin("guest_os_name", ::apache::thrift::protocol::T_STRING, 23);
    xfer += oprot->writeString(this->guest_os_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_disk_uuid_enabled) {
    xfer += oprot->writeFieldBegin("is_disk_uuid_enabled", ::apache::thrift::protocol::T_BOOL, 24);
    xfer += oprot->writeBool(this->is_disk_uuid_enabled);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.folder_path) {
    xfer += oprot->writeFieldBegin("folder_path", ::apache::thrift::protocol::T_STRING, 25);
    xfer += oprot->writeString(this->folder_path);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.resource_pool_path) {
    xfer += oprot->writeFieldBegin("resource_pool_path", ::apache::thrift::protocol::T_STRING, 26);
    xfer += oprot->writeString(this->resource_pool_path);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.disks) {
    xfer += oprot->writeFieldBegin("disks", ::apache::thrift::protocol::T_LIST, 27);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->disks.size()));
      std::vector<virtual_disk_info> ::const_iterator _iter279;
      for (_iter279 = this->disks.begin(); _iter279 != this->disks.end(); ++_iter279)
      {
        xfer += (*_iter279).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.networks) {
    xfer += oprot->writeFieldBegin("networks", ::apache::thrift::protocol::T_MAP, 28);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->networks.size()));
      std::map<std::string, std::string> ::const_iterator _iter280;
      for (_iter280 = this->networks.begin(); _iter280 != this->networks.end(); ++_iter280)
      {
        xfer += oprot->writeString(_iter280->first);
        xfer += oprot->writeString(_iter280->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.datacenter_name) {
    xfer += oprot->writeFieldBegin("datacenter_name", ::apache::thrift::protocol::T_STRING, 29);
    xfer += oprot->writeString(this->datacenter_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.network_adapters) {
    xfer += oprot->writeFieldBegin("network_adapters", ::apache::thrift::protocol::T_LIST, 30);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->network_adapters.size()));
      std::vector<virtual_network_adapter> ::const_iterator _iter281;
      for (_iter281 = this->network_adapters.begin(); _iter281 != this->network_adapters.end(); ++_iter281)
      {
        xfer += (*_iter281).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.root_snapshot_list) {
    xfer += oprot->writeFieldBegin("root_snapshot_list", ::apache::thrift::protocol::T_LIST, 31);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->root_snapshot_list.size()));
      std::vector<virtual_machine_snapshots> ::const_iterator _iter282;
      for (_iter282 = this->root_snapshot_list.begin(); _iter282 != this->root_snapshot_list.end(); ++_iter282)
      {
        xfer += (*_iter282).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.guest_host_name) {
    xfer += oprot->writeFieldBegin("guest_host_name", ::apache::thrift::protocol::T_STRING, 32);
    xfer += oprot->writeString(this->guest_host_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.guest_ip) {
    xfer += oprot->writeFieldBegin("guest_ip", ::apache::thrift::protocol::T_STRING, 33);
    xfer += oprot->writeString(this->guest_ip);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.has_cdrom) {
    xfer += oprot->writeFieldBegin("has_cdrom", ::apache::thrift::protocol::T_BOOL, 34);
    xfer += oprot->writeBool(this->has_cdrom);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(virtual_machine &a, virtual_machine &b) {
  using ::std::swap;
  swap(a.uuid, b.uuid);
  swap(a.name, b.name);
  swap(a.host_key, b.host_key);
  swap(a.host_ip, b.host_ip);
  swap(a.host_name, b.host_name);
  swap(a.cluster_key, b.cluster_key);
  swap(a.cluster_name, b.cluster_name);
  swap(a.annotation, b.annotation);
  swap(a.is_cpu_hot_add, b.is_cpu_hot_add);
  swap(a.is_cpu_hot_remove, b.is_cpu_hot_remove);
  swap(a.memory_mb, b.memory_mb);
  swap(a.number_of_cpu, b.number_of_cpu);
  swap(a.is_template, b.is_template);
  swap(a.config_path, b.config_path);
  swap(a.config_path_file, b.config_path_file);
  swap(a.version, b.version);
  swap(a.power_state, b.power_state);
  swap(a.connection_state, b.connection_state);
  swap(a.tools_status, b.tools_status);
  swap(a.firmware, b.firmware);
  swap(a.guest_os_type, b.guest_os_type);
  swap(a.guest_id, b.guest_id);
  swap(a.guest_os_name, b.guest_os_name);
  swap(a.is_disk_uuid_enabled, b.is_disk_uuid_enabled);
  swap(a.folder_path, b.folder_path);
  swap(a.resource_pool_path, b.resource_pool_path);
  swap(a.disks, b.disks);
  swap(a.networks, b.networks);
  swap(a.datacenter_name, b.datacenter_name);
  swap(a.network_adapters, b.network_adapters);
  swap(a.root_snapshot_list, b.root_snapshot_list);
  swap(a.guest_host_name, b.guest_host_name);
  swap(a.guest_ip, b.guest_ip);
  swap(a.has_cdrom, b.has_cdrom);
  swap(a.__isset, b.__isset);
}

virtual_machine::virtual_machine(const virtual_machine& other283) {
  uuid = other283.uuid;
  name = other283.name;
  host_key = other283.host_key;
  host_ip = other283.host_ip;
  host_name = other283.host_name;
  cluster_key = other283.cluster_key;
  cluster_name = other283.cluster_name;
  annotation = other283.annotation;
  is_cpu_hot_add = other283.is_cpu_hot_add;
  is_cpu_hot_remove = other283.is_cpu_hot_remove;
  memory_mb = other283.memory_mb;
  number_of_cpu = other283.number_of_cpu;
  is_template = other283.is_template;
  config_path = other283.config_path;
  config_path_file = other283.config_path_file;
  version = other283.version;
  power_state = other283.power_state;
  connection_state = other283.connection_state;
  tools_status = other283.tools_status;
  firmware = other283.firmware;
  guest_os_type = other283.guest_os_type;
  guest_id = other283.guest_id;
  guest_os_name = other283.guest_os_name;
  is_disk_uuid_enabled = other283.is_disk_uuid_enabled;
  folder_path = other283.folder_path;
  resource_pool_path = other283.resource_pool_path;
  disks = other283.disks;
  networks = other283.networks;
  datacenter_name = other283.datacenter_name;
  network_adapters = other283.network_adapters;
  root_snapshot_list = other283.root_snapshot_list;
  guest_host_name = other283.guest_host_name;
  guest_ip = other283.guest_ip;
  has_cdrom = other283.has_cdrom;
  __isset = other283.__isset;
}
virtual_machine& virtual_machine::operator=(const virtual_machine& other284) {
  uuid = other284.uuid;
  name = other284.name;
  host_key = other284.host_key;
  host_ip = other284.host_ip;
  host_name = other284.host_name;
  cluster_key = other284.cluster_key;
  cluster_name = other284.cluster_name;
  annotation = other284.annotation;
  is_cpu_hot_add = other284.is_cpu_hot_add;
  is_cpu_hot_remove = other284.is_cpu_hot_remove;
  memory_mb = other284.memory_mb;
  number_of_cpu = other284.number_of_cpu;
  is_template = other284.is_template;
  config_path = other284.config_path;
  config_path_file = other284.config_path_file;
  version = other284.version;
  power_state = other284.power_state;
  connection_state = other284.connection_state;
  tools_status = other284.tools_status;
  firmware = other284.firmware;
  guest_os_type = other284.guest_os_type;
  guest_id = other284.guest_id;
  guest_os_name = other284.guest_os_name;
  is_disk_uuid_enabled = other284.is_disk_uuid_enabled;
  folder_path = other284.folder_path;
  resource_pool_path = other284.resource_pool_path;
  disks = other284.disks;
  networks = other284.networks;
  datacenter_name = other284.datacenter_name;
  network_adapters = other284.network_adapters;
  root_snapshot_list = other284.root_snapshot_list;
  guest_host_name = other284.guest_host_name;
  guest_ip = other284.guest_ip;
  has_cdrom = other284.has_cdrom;
  __isset = other284.__isset;
  return *this;
}
void virtual_machine::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "virtual_machine(";
  out << "uuid="; (__isset.uuid ? (out << to_string(uuid)) : (out << "<null>"));
  out << ", " << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
  out << ", " << "host_key="; (__isset.host_key ? (out << to_string(host_key)) : (out << "<null>"));
  out << ", " << "host_ip="; (__isset.host_ip ? (out << to_string(host_ip)) : (out << "<null>"));
  out << ", " << "host_name="; (__isset.host_name ? (out << to_string(host_name)) : (out << "<null>"));
  out << ", " << "cluster_key="; (__isset.cluster_key ? (out << to_string(cluster_key)) : (out << "<null>"));
  out << ", " << "cluster_name="; (__isset.cluster_name ? (out << to_string(cluster_name)) : (out << "<null>"));
  out << ", " << "annotation="; (__isset.annotation ? (out << to_string(annotation)) : (out << "<null>"));
  out << ", " << "is_cpu_hot_add="; (__isset.is_cpu_hot_add ? (out << to_string(is_cpu_hot_add)) : (out << "<null>"));
  out << ", " << "is_cpu_hot_remove="; (__isset.is_cpu_hot_remove ? (out << to_string(is_cpu_hot_remove)) : (out << "<null>"));
  out << ", " << "memory_mb="; (__isset.memory_mb ? (out << to_string(memory_mb)) : (out << "<null>"));
  out << ", " << "number_of_cpu="; (__isset.number_of_cpu ? (out << to_string(number_of_cpu)) : (out << "<null>"));
  out << ", " << "is_template="; (__isset.is_template ? (out << to_string(is_template)) : (out << "<null>"));
  out << ", " << "config_path="; (__isset.config_path ? (out << to_string(config_path)) : (out << "<null>"));
  out << ", " << "config_path_file="; (__isset.config_path_file ? (out << to_string(config_path_file)) : (out << "<null>"));
  out << ", " << "version="; (__isset.version ? (out << to_string(version)) : (out << "<null>"));
  out << ", " << "power_state="; (__isset.power_state ? (out << to_string(power_state)) : (out << "<null>"));
  out << ", " << "connection_state="; (__isset.connection_state ? (out << to_string(connection_state)) : (out << "<null>"));
  out << ", " << "tools_status="; (__isset.tools_status ? (out << to_string(tools_status)) : (out << "<null>"));
  out << ", " << "firmware="; (__isset.firmware ? (out << to_string(firmware)) : (out << "<null>"));
  out << ", " << "guest_os_type="; (__isset.guest_os_type ? (out << to_string(guest_os_type)) : (out << "<null>"));
  out << ", " << "guest_id="; (__isset.guest_id ? (out << to_string(guest_id)) : (out << "<null>"));
  out << ", " << "guest_os_name="; (__isset.guest_os_name ? (out << to_string(guest_os_name)) : (out << "<null>"));
  out << ", " << "is_disk_uuid_enabled="; (__isset.is_disk_uuid_enabled ? (out << to_string(is_disk_uuid_enabled)) : (out << "<null>"));
  out << ", " << "folder_path="; (__isset.folder_path ? (out << to_string(folder_path)) : (out << "<null>"));
  out << ", " << "resource_pool_path="; (__isset.resource_pool_path ? (out << to_string(resource_pool_path)) : (out << "<null>"));
  out << ", " << "disks="; (__isset.disks ? (out << to_string(disks)) : (out << "<null>"));
  out << ", " << "networks="; (__isset.networks ? (out << to_string(networks)) : (out << "<null>"));
  out << ", " << "datacenter_name="; (__isset.datacenter_name ? (out << to_string(datacenter_name)) : (out << "<null>"));
  out << ", " << "network_adapters="; (__isset.network_adapters ? (out << to_string(network_adapters)) : (out << "<null>"));
  out << ", " << "root_snapshot_list="; (__isset.root_snapshot_list ? (out << to_string(root_snapshot_list)) : (out << "<null>"));
  out << ", " << "guest_host_name="; (__isset.guest_host_name ? (out << to_string(guest_host_name)) : (out << "<null>"));
  out << ", " << "guest_ip="; (__isset.guest_ip ? (out << to_string(guest_ip)) : (out << "<null>"));
  out << ", " << "has_cdrom="; (__isset.has_cdrom ? (out << to_string(has_cdrom)) : (out << "<null>"));
  out << ")";
}


invalid_operation::~invalid_operation() throw() {
}


void invalid_operation::__set_what_op(const int32_t val) {
  this->what_op = val;
}

void invalid_operation::__set_why(const std::string& val) {
  this->why = val;
}

void invalid_operation::__set_format(const std::string& val) {
  this->format = val;
__isset.format = true;
}

void invalid_operation::__set_arguments(const std::vector<std::string> & val) {
  this->arguments = val;
__isset.arguments = true;
}
std::ostream& operator<<(std::ostream& out, const invalid_operation& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t invalid_operation::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->what_op);
          this->__isset.what_op = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->why);
          this->__isset.why = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->format);
          this->__isset.format = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->arguments.clear();
            uint32_t _size285;
            ::apache::thrift::protocol::TType _etype288;
            xfer += iprot->readListBegin(_etype288, _size285);
            this->arguments.resize(_size285);
            uint32_t _i289;
            for (_i289 = 0; _i289 < _size285; ++_i289)
            {
              xfer += iprot->readString(this->arguments[_i289]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.arguments = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t invalid_operation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("invalid_operation");

  xfer += oprot->writeFieldBegin("what_op", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->what_op);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("why", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->why);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.format) {
    xfer += oprot->writeFieldBegin("format", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->format);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.arguments) {
    xfer += oprot->writeFieldBegin("arguments", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->arguments.size()));
      std::vector<std::string> ::const_iterator _iter290;
      for (_iter290 = this->arguments.begin(); _iter290 != this->arguments.end(); ++_iter290)
      {
        xfer += oprot->writeString((*_iter290));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(invalid_operation &a, invalid_operation &b) {
  using ::std::swap;
  swap(a.what_op, b.what_op);
  swap(a.why, b.why);
  swap(a.format, b.format);
  swap(a.arguments, b.arguments);
  swap(a.__isset, b.__isset);
}

invalid_operation::invalid_operation(const invalid_operation& other291) : TException() {
  what_op = other291.what_op;
  why = other291.why;
  format = other291.format;
  arguments = other291.arguments;
  __isset = other291.__isset;
}
invalid_operation& invalid_operation::operator=(const invalid_operation& other292) {
  what_op = other292.what_op;
  why = other292.why;
  format = other292.format;
  arguments = other292.arguments;
  __isset = other292.__isset;
  return *this;
}
void invalid_operation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "invalid_operation(";
  out << "what_op=" << to_string(what_op);
  out << ", " << "why=" << to_string(why);
  out << ", " << "format="; (__isset.format ? (out << to_string(format)) : (out << "<null>"));
  out << ", " << "arguments="; (__isset.arguments ? (out << to_string(arguments)) : (out << "<null>"));
  out << ")";
}

const char* invalid_operation::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: invalid_operation";
  }
}


job_trigger::~job_trigger() throw() {
}


void job_trigger::__set_type(const job_trigger_type::type val) {
  this->type = val;
__isset.type = true;
}

void job_trigger::__set_start(const std::string& val) {
  this->start = val;
__isset.start = true;
}

void job_trigger::__set_finish(const std::string& val) {
  this->finish = val;
__isset.finish = true;
}

void job_trigger::__set_interval(const int32_t val) {
  this->interval = val;
__isset.interval = true;
}

void job_trigger::__set_id(const std::string& val) {
  this->id = val;
__isset.id = true;
}

void job_trigger::__set_duration(const int32_t val) {
  this->duration = val;
__isset.duration = true;
}
std::ostream& operator<<(std::ostream& out, const job_trigger& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t job_trigger::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast293;
          xfer += iprot->readI32(ecast293);
          this->type = (job_trigger_type::type)ecast293;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->start);
          this->__isset.start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->finish);
          this->__isset.finish = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->interval);
          this->__isset.interval = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->duration);
          this->__isset.duration = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t job_trigger::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("job_trigger");

  if (this->__isset.type) {
    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32((int32_t)this->type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.start) {
    xfer += oprot->writeFieldBegin("start", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->start);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.finish) {
    xfer += oprot->writeFieldBegin("finish", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->finish);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.interval) {
    xfer += oprot->writeFieldBegin("interval", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->interval);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.duration) {
    xfer += oprot->writeFieldBegin("duration", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(this->duration);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(job_trigger &a, job_trigger &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.start, b.start);
  swap(a.finish, b.finish);
  swap(a.interval, b.interval);
  swap(a.id, b.id);
  swap(a.duration, b.duration);
  swap(a.__isset, b.__isset);
}

job_trigger::job_trigger(const job_trigger& other294) {
  type = other294.type;
  start = other294.start;
  finish = other294.finish;
  interval = other294.interval;
  id = other294.id;
  duration = other294.duration;
  __isset = other294.__isset;
}
job_trigger& job_trigger::operator=(const job_trigger& other295) {
  type = other295.type;
  start = other295.start;
  finish = other295.finish;
  interval = other295.interval;
  id = other295.id;
  duration = other295.duration;
  __isset = other295.__isset;
  return *this;
}
void job_trigger::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "job_trigger(";
  out << "type="; (__isset.type ? (out << to_string(type)) : (out << "<null>"));
  out << ", " << "start="; (__isset.start ? (out << to_string(start)) : (out << "<null>"));
  out << ", " << "finish="; (__isset.finish ? (out << to_string(finish)) : (out << "<null>"));
  out << ", " << "interval="; (__isset.interval ? (out << to_string(interval)) : (out << "<null>"));
  out << ", " << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "duration="; (__isset.duration ? (out << to_string(duration)) : (out << "<null>"));
  out << ")";
}


job_history::~job_history() throw() {
}


void job_history::__set_time(const std::string& val) {
  this->time = val;
__isset.time = true;
}

void job_history::__set_state(const job_state::type val) {
  this->state = val;
__isset.state = true;
}

void job_history::__set_error(const int32_t val) {
  this->error = val;
__isset.error = true;
}

void job_history::__set_description(const std::string& val) {
  this->description = val;
__isset.description = true;
}

void job_history::__set_format(const std::string& val) {
  this->format = val;
__isset.format = true;
}

void job_history::__set_arguments(const std::vector<std::string> & val) {
  this->arguments = val;
__isset.arguments = true;
}

void job_history::__set_is_display(const bool val) {
  this->is_display = val;
__isset.is_display = true;
}
std::ostream& operator<<(std::ostream& out, const job_history& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t job_history::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->time);
          this->__isset.time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast296;
          xfer += iprot->readI32(ecast296);
          this->state = (job_state::type)ecast296;
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->error);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->description);
          this->__isset.description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->format);
          this->__isset.format = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->arguments.clear();
            uint32_t _size297;
            ::apache::thrift::protocol::TType _etype300;
            xfer += iprot->readListBegin(_etype300, _size297);
            this->arguments.resize(_size297);
            uint32_t _i301;
            for (_i301 = 0; _i301 < _size297; ++_i301)
            {
              xfer += iprot->readString(this->arguments[_i301]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.arguments = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_display);
          this->__isset.is_display = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t job_history::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("job_history");

  if (this->__isset.time) {
    xfer += oprot->writeFieldBegin("time", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->time);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.state) {
    xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32((int32_t)this->state);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->error);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.description) {
    xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->description);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.format) {
    xfer += oprot->writeFieldBegin("format", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->format);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.arguments) {
    xfer += oprot->writeFieldBegin("arguments", ::apache::thrift::protocol::T_LIST, 8);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->arguments.size()));
      std::vector<std::string> ::const_iterator _iter302;
      for (_iter302 = this->arguments.begin(); _iter302 != this->arguments.end(); ++_iter302)
      {
        xfer += oprot->writeString((*_iter302));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_display) {
    xfer += oprot->writeFieldBegin("is_display", ::apache::thrift::protocol::T_BOOL, 9);
    xfer += oprot->writeBool(this->is_display);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(job_history &a, job_history &b) {
  using ::std::swap;
  swap(a.time, b.time);
  swap(a.state, b.state);
  swap(a.error, b.error);
  swap(a.description, b.description);
  swap(a.format, b.format);
  swap(a.arguments, b.arguments);
  swap(a.is_display, b.is_display);
  swap(a.__isset, b.__isset);
}

job_history::job_history(const job_history& other303) {
  time = other303.time;
  state = other303.state;
  error = other303.error;
  description = other303.description;
  format = other303.format;
  arguments = other303.arguments;
  is_display = other303.is_display;
  __isset = other303.__isset;
}
job_history& job_history::operator=(const job_history& other304) {
  time = other304.time;
  state = other304.state;
  error = other304.error;
  description = other304.description;
  format = other304.format;
  arguments = other304.arguments;
  is_display = other304.is_display;
  __isset = other304.__isset;
  return *this;
}
void job_history::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "job_history(";
  out << "time="; (__isset.time ? (out << to_string(time)) : (out << "<null>"));
  out << ", " << "state="; (__isset.state ? (out << to_string(state)) : (out << "<null>"));
  out << ", " << "error="; (__isset.error ? (out << to_string(error)) : (out << "<null>"));
  out << ", " << "description="; (__isset.description ? (out << to_string(description)) : (out << "<null>"));
  out << ", " << "format="; (__isset.format ? (out << to_string(format)) : (out << "<null>"));
  out << ", " << "arguments="; (__isset.arguments ? (out << to_string(arguments)) : (out << "<null>"));
  out << ", " << "is_display="; (__isset.is_display ? (out << to_string(is_display)) : (out << "<null>"));
  out << ")";
}


create_job_detail::~create_job_detail() throw() {
}


void create_job_detail::__set_type(const job_type::type val) {
  this->type = val;
__isset.type = true;
}

void create_job_detail::__set_triggers(const std::vector<job_trigger> & val) {
  this->triggers = val;
__isset.triggers = true;
}

void create_job_detail::__set_management_id(const std::string& val) {
  this->management_id = val;
__isset.management_id = true;
}

void create_job_detail::__set_mgmt_addr(const std::set<std::string> & val) {
  this->mgmt_addr = val;
__isset.mgmt_addr = true;
}

void create_job_detail::__set_mgmt_port(const int32_t val) {
  this->mgmt_port = val;
__isset.mgmt_port = true;
}

void create_job_detail::__set_is_ssl(const bool val) {
  this->is_ssl = val;
__isset.is_ssl = true;
}
std::ostream& operator<<(std::ostream& out, const create_job_detail& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t create_job_detail::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast305;
          xfer += iprot->readI32(ecast305);
          this->type = (job_type::type)ecast305;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->triggers.clear();
            uint32_t _size306;
            ::apache::thrift::protocol::TType _etype309;
            xfer += iprot->readListBegin(_etype309, _size306);
            this->triggers.resize(_size306);
            uint32_t _i310;
            for (_i310 = 0; _i310 < _size306; ++_i310)
            {
              xfer += this->triggers[_i310].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.triggers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->management_id);
          this->__isset.management_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->mgmt_addr.clear();
            uint32_t _size311;
            ::apache::thrift::protocol::TType _etype314;
            xfer += iprot->readSetBegin(_etype314, _size311);
            uint32_t _i315;
            for (_i315 = 0; _i315 < _size311; ++_i315)
            {
              std::string _elem316;
              xfer += iprot->readString(_elem316);
              this->mgmt_addr.insert(_elem316);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.mgmt_addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->mgmt_port);
          this->__isset.mgmt_port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_ssl);
          this->__isset.is_ssl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t create_job_detail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("create_job_detail");

  if (this->__isset.type) {
    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32((int32_t)this->type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.triggers) {
    xfer += oprot->writeFieldBegin("triggers", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->triggers.size()));
      std::vector<job_trigger> ::const_iterator _iter317;
      for (_iter317 = this->triggers.begin(); _iter317 != this->triggers.end(); ++_iter317)
      {
        xfer += (*_iter317).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.management_id) {
    xfer += oprot->writeFieldBegin("management_id", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->management_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mgmt_addr) {
    xfer += oprot->writeFieldBegin("mgmt_addr", ::apache::thrift::protocol::T_SET, 4);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->mgmt_addr.size()));
      std::set<std::string> ::const_iterator _iter318;
      for (_iter318 = this->mgmt_addr.begin(); _iter318 != this->mgmt_addr.end(); ++_iter318)
      {
        xfer += oprot->writeString((*_iter318));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mgmt_port) {
    xfer += oprot->writeFieldBegin("mgmt_port", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->mgmt_port);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_ssl) {
    xfer += oprot->writeFieldBegin("is_ssl", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->is_ssl);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(create_job_detail &a, create_job_detail &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.triggers, b.triggers);
  swap(a.management_id, b.management_id);
  swap(a.mgmt_addr, b.mgmt_addr);
  swap(a.mgmt_port, b.mgmt_port);
  swap(a.is_ssl, b.is_ssl);
  swap(a.__isset, b.__isset);
}

create_job_detail::create_job_detail(const create_job_detail& other319) {
  type = other319.type;
  triggers = other319.triggers;
  management_id = other319.management_id;
  mgmt_addr = other319.mgmt_addr;
  mgmt_port = other319.mgmt_port;
  is_ssl = other319.is_ssl;
  __isset = other319.__isset;
}
create_job_detail& create_job_detail::operator=(const create_job_detail& other320) {
  type = other320.type;
  triggers = other320.triggers;
  management_id = other320.management_id;
  mgmt_addr = other320.mgmt_addr;
  mgmt_port = other320.mgmt_port;
  is_ssl = other320.is_ssl;
  __isset = other320.__isset;
  return *this;
}
void create_job_detail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "create_job_detail(";
  out << "type="; (__isset.type ? (out << to_string(type)) : (out << "<null>"));
  out << ", " << "triggers="; (__isset.triggers ? (out << to_string(triggers)) : (out << "<null>"));
  out << ", " << "management_id="; (__isset.management_id ? (out << to_string(management_id)) : (out << "<null>"));
  out << ", " << "mgmt_addr="; (__isset.mgmt_addr ? (out << to_string(mgmt_addr)) : (out << "<null>"));
  out << ", " << "mgmt_port="; (__isset.mgmt_port ? (out << to_string(mgmt_port)) : (out << "<null>"));
  out << ", " << "is_ssl="; (__isset.is_ssl ? (out << to_string(is_ssl)) : (out << "<null>"));
  out << ")";
}


packer_disk_image::~packer_disk_image() throw() {
}


void packer_disk_image::__set_name(const std::string& val) {
  this->name = val;
__isset.name = true;
}

void packer_disk_image::__set_parent(const std::string& val) {
  this->parent = val;
__isset.parent = true;
}

void packer_disk_image::__set_base(const std::string& val) {
  this->base = val;
__isset.base = true;
}
std::ostream& operator<<(std::ostream& out, const packer_disk_image& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t packer_disk_image::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->parent);
          this->__isset.parent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->base);
          this->__isset.base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t packer_disk_image::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("packer_disk_image");

  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.parent) {
    xfer += oprot->writeFieldBegin("parent", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->parent);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.base) {
    xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->base);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(packer_disk_image &a, packer_disk_image &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.parent, b.parent);
  swap(a.base, b.base);
  swap(a.__isset, b.__isset);
}

packer_disk_image::packer_disk_image(const packer_disk_image& other321) {
  name = other321.name;
  parent = other321.parent;
  base = other321.base;
  __isset = other321.__isset;
}
packer_disk_image& packer_disk_image::operator=(const packer_disk_image& other322) {
  name = other322.name;
  parent = other322.parent;
  base = other322.base;
  __isset = other322.__isset;
  return *this;
}
void packer_disk_image::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "packer_disk_image(";
  out << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
  out << ", " << "parent="; (__isset.parent ? (out << to_string(parent)) : (out << "<null>"));
  out << ", " << "base="; (__isset.base ? (out << to_string(base)) : (out << "<null>"));
  out << ")";
}


virtual_partition_info::~virtual_partition_info() throw() {
}


void virtual_partition_info::__set_partition_number(const int32_t val) {
  this->partition_number = val;
__isset.partition_number = true;
}

void virtual_partition_info::__set_offset(const int64_t val) {
  this->offset = val;
__isset.offset = true;
}

void virtual_partition_info::__set_size(const int64_t val) {
  this->size = val;
__isset.size = true;
}
std::ostream& operator<<(std::ostream& out, const virtual_partition_info& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t virtual_partition_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->partition_number);
          this->__isset.partition_number = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->offset);
          this->__isset.offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->size);
          this->__isset.size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t virtual_partition_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("virtual_partition_info");

  if (this->__isset.partition_number) {
    xfer += oprot->writeFieldBegin("partition_number", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->partition_number);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.offset) {
    xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->offset);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.size) {
    xfer += oprot->writeFieldBegin("size", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->size);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(virtual_partition_info &a, virtual_partition_info &b) {
  using ::std::swap;
  swap(a.partition_number, b.partition_number);
  swap(a.offset, b.offset);
  swap(a.size, b.size);
  swap(a.__isset, b.__isset);
}

virtual_partition_info::virtual_partition_info(const virtual_partition_info& other323) {
  partition_number = other323.partition_number;
  offset = other323.offset;
  size = other323.size;
  __isset = other323.__isset;
}
virtual_partition_info& virtual_partition_info::operator=(const virtual_partition_info& other324) {
  partition_number = other324.partition_number;
  offset = other324.offset;
  size = other324.size;
  __isset = other324.__isset;
  return *this;
}
void virtual_partition_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "virtual_partition_info(";
  out << "partition_number="; (__isset.partition_number ? (out << to_string(partition_number)) : (out << "<null>"));
  out << ", " << "offset="; (__isset.offset ? (out << to_string(offset)) : (out << "<null>"));
  out << ", " << "size="; (__isset.size ? (out << to_string(size)) : (out << "<null>"));
  out << ")";
}


virtual_disk_info_ex::~virtual_disk_info_ex() throw() {
}


void virtual_disk_info_ex::__set_id(const std::string& val) {
  this->id = val;
__isset.id = true;
}

void virtual_disk_info_ex::__set_size(const int64_t val) {
  this->size = val;
__isset.size = true;
}

void virtual_disk_info_ex::__set_partition_style(const partition_style::type val) {
  this->partition_style = val;
__isset.partition_style = true;
}

void virtual_disk_info_ex::__set_guid(const std::string& val) {
  this->guid = val;
__isset.guid = true;
}

void virtual_disk_info_ex::__set_signature(const int32_t val) {
  this->signature = val;
__isset.signature = true;
}

void virtual_disk_info_ex::__set_is_system(const bool val) {
  this->is_system = val;
__isset.is_system = true;
}

void virtual_disk_info_ex::__set_partitions(const std::set<virtual_partition_info> & val) {
  this->partitions = val;
__isset.partitions = true;
}
std::ostream& operator<<(std::ostream& out, const virtual_disk_info_ex& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t virtual_disk_info_ex::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->size);
          this->__isset.size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast325;
          xfer += iprot->readI32(ecast325);
          this->partition_style = (partition_style::type)ecast325;
          this->__isset.partition_style = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guid);
          this->__isset.guid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->signature);
          this->__isset.signature = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_system);
          this->__isset.is_system = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->partitions.clear();
            uint32_t _size326;
            ::apache::thrift::protocol::TType _etype329;
            xfer += iprot->readSetBegin(_etype329, _size326);
            uint32_t _i330;
            for (_i330 = 0; _i330 < _size326; ++_i330)
            {
              virtual_partition_info _elem331;
              xfer += _elem331.read(iprot);
              this->partitions.insert(_elem331);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t virtual_disk_info_ex::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("virtual_disk_info_ex");

  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.size) {
    xfer += oprot->writeFieldBegin("size", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partition_style) {
    xfer += oprot->writeFieldBegin("partition_style", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32((int32_t)this->partition_style);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.guid) {
    xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->guid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.signature) {
    xfer += oprot->writeFieldBegin("signature", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->signature);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_system) {
    xfer += oprot->writeFieldBegin("is_system", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->is_system);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partitions) {
    xfer += oprot->writeFieldBegin("partitions", ::apache::thrift::protocol::T_SET, 7);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitions.size()));
      std::set<virtual_partition_info> ::const_iterator _iter332;
      for (_iter332 = this->partitions.begin(); _iter332 != this->partitions.end(); ++_iter332)
      {
        xfer += (*_iter332).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(virtual_disk_info_ex &a, virtual_disk_info_ex &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.size, b.size);
  swap(a.partition_style, b.partition_style);
  swap(a.guid, b.guid);
  swap(a.signature, b.signature);
  swap(a.is_system, b.is_system);
  swap(a.partitions, b.partitions);
  swap(a.__isset, b.__isset);
}

virtual_disk_info_ex::virtual_disk_info_ex(const virtual_disk_info_ex& other333) {
  id = other333.id;
  size = other333.size;
  partition_style = other333.partition_style;
  guid = other333.guid;
  signature = other333.signature;
  is_system = other333.is_system;
  partitions = other333.partitions;
  __isset = other333.__isset;
}
virtual_disk_info_ex& virtual_disk_info_ex::operator=(const virtual_disk_info_ex& other334) {
  id = other334.id;
  size = other334.size;
  partition_style = other334.partition_style;
  guid = other334.guid;
  signature = other334.signature;
  is_system = other334.is_system;
  partitions = other334.partitions;
  __isset = other334.__isset;
  return *this;
}
void virtual_disk_info_ex::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "virtual_disk_info_ex(";
  out << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "size="; (__isset.size ? (out << to_string(size)) : (out << "<null>"));
  out << ", " << "partition_style="; (__isset.partition_style ? (out << to_string(partition_style)) : (out << "<null>"));
  out << ", " << "guid="; (__isset.guid ? (out << to_string(guid)) : (out << "<null>"));
  out << ", " << "signature="; (__isset.signature ? (out << to_string(signature)) : (out << "<null>"));
  out << ", " << "is_system="; (__isset.is_system ? (out << to_string(is_system)) : (out << "<null>"));
  out << ", " << "partitions="; (__isset.partitions ? (out << to_string(partitions)) : (out << "<null>"));
  out << ")";
}


virtual_create_packer_job_detail::~virtual_create_packer_job_detail() throw() {
}


void virtual_create_packer_job_detail::__set_disks(const std::set<std::string> & val) {
  this->disks = val;
__isset.disks = true;
}

void virtual_create_packer_job_detail::__set_host(const std::string& val) {
  this->host = val;
__isset.host = true;
}

void virtual_create_packer_job_detail::__set_addr(const std::set<std::string> & val) {
  this->addr = val;
__isset.addr = true;
}

void virtual_create_packer_job_detail::__set_username(const std::string& val) {
  this->username = val;
__isset.username = true;
}

void virtual_create_packer_job_detail::__set_password(const std::string& val) {
  this->password = val;
__isset.password = true;
}

void virtual_create_packer_job_detail::__set_virtual_machine_id(const std::string& val) {
  this->virtual_machine_id = val;
__isset.virtual_machine_id = true;
}

void virtual_create_packer_job_detail::__set_snapshot(const std::string& val) {
  this->snapshot = val;
__isset.snapshot = true;
}

void virtual_create_packer_job_detail::__set_images(const std::map<std::string, packer_disk_image> & val) {
  this->images = val;
__isset.images = true;
}

void virtual_create_packer_job_detail::__set_backup_size(const std::map<std::string, int64_t> & val) {
  this->backup_size = val;
__isset.backup_size = true;
}

void virtual_create_packer_job_detail::__set_backup_progress(const std::map<std::string, int64_t> & val) {
  this->backup_progress = val;
__isset.backup_progress = true;
}

void virtual_create_packer_job_detail::__set_backup_image_offset(const std::map<std::string, int64_t> & val) {
  this->backup_image_offset = val;
__isset.backup_image_offset = true;
}

void virtual_create_packer_job_detail::__set_previous_change_ids(const std::map<std::string, std::string> & val) {
  this->previous_change_ids = val;
__isset.previous_change_ids = true;
}

void virtual_create_packer_job_detail::__set_completed_blocks(const std::map<std::string, std::vector<io_changed_range> > & val) {
  this->completed_blocks = val;
__isset.completed_blocks = true;
}
std::ostream& operator<<(std::ostream& out, const virtual_create_packer_job_detail& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t virtual_create_packer_job_detail::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->disks.clear();
            uint32_t _size335;
            ::apache::thrift::protocol::TType _etype338;
            xfer += iprot->readSetBegin(_etype338, _size335);
            uint32_t _i339;
            for (_i339 = 0; _i339 < _size335; ++_i339)
            {
              std::string _elem340;
              xfer += iprot->readString(_elem340);
              this->disks.insert(_elem340);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.disks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host);
          this->__isset.host = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->addr.clear();
            uint32_t _size341;
            ::apache::thrift::protocol::TType _etype344;
            xfer += iprot->readSetBegin(_etype344, _size341);
            uint32_t _i345;
            for (_i345 = 0; _i345 < _size341; ++_i345)
            {
              std::string _elem346;
              xfer += iprot->readString(_elem346);
              this->addr.insert(_elem346);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->username);
          this->__isset.username = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->password);
          this->__isset.password = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->virtual_machine_id);
          this->__isset.virtual_machine_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->snapshot);
          this->__isset.snapshot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->images.clear();
            uint32_t _size347;
            ::apache::thrift::protocol::TType _ktype348;
            ::apache::thrift::protocol::TType _vtype349;
            xfer += iprot->readMapBegin(_ktype348, _vtype349, _size347);
            uint32_t _i351;
            for (_i351 = 0; _i351 < _size347; ++_i351)
            {
              std::string _key352;
              xfer += iprot->readString(_key352);
              packer_disk_image& _val353 = this->images[_key352];
              xfer += _val353.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.images = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->backup_size.clear();
            uint32_t _size354;
            ::apache::thrift::protocol::TType _ktype355;
            ::apache::thrift::protocol::TType _vtype356;
            xfer += iprot->readMapBegin(_ktype355, _vtype356, _size354);
            uint32_t _i358;
            for (_i358 = 0; _i358 < _size354; ++_i358)
            {
              std::string _key359;
              xfer += iprot->readString(_key359);
              int64_t& _val360 = this->backup_size[_key359];
              xfer += iprot->readI64(_val360);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.backup_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->backup_progress.clear();
            uint32_t _size361;
            ::apache::thrift::protocol::TType _ktype362;
            ::apache::thrift::protocol::TType _vtype363;
            xfer += iprot->readMapBegin(_ktype362, _vtype363, _size361);
            uint32_t _i365;
            for (_i365 = 0; _i365 < _size361; ++_i365)
            {
              std::string _key366;
              xfer += iprot->readString(_key366);
              int64_t& _val367 = this->backup_progress[_key366];
              xfer += iprot->readI64(_val367);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.backup_progress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->backup_image_offset.clear();
            uint32_t _size368;
            ::apache::thrift::protocol::TType _ktype369;
            ::apache::thrift::protocol::TType _vtype370;
            xfer += iprot->readMapBegin(_ktype369, _vtype370, _size368);
            uint32_t _i372;
            for (_i372 = 0; _i372 < _size368; ++_i372)
            {
              std::string _key373;
              xfer += iprot->readString(_key373);
              int64_t& _val374 = this->backup_image_offset[_key373];
              xfer += iprot->readI64(_val374);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.backup_image_offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->previous_change_ids.clear();
            uint32_t _size375;
            ::apache::thrift::protocol::TType _ktype376;
            ::apache::thrift::protocol::TType _vtype377;
            xfer += iprot->readMapBegin(_ktype376, _vtype377, _size375);
            uint32_t _i379;
            for (_i379 = 0; _i379 < _size375; ++_i379)
            {
              std::string _key380;
              xfer += iprot->readString(_key380);
              std::string& _val381 = this->previous_change_ids[_key380];
              xfer += iprot->readString(_val381);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.previous_change_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->completed_blocks.clear();
            uint32_t _size382;
            ::apache::thrift::protocol::TType _ktype383;
            ::apache::thrift::protocol::TType _vtype384;
            xfer += iprot->readMapBegin(_ktype383, _vtype384, _size382);
            uint32_t _i386;
            for (_i386 = 0; _i386 < _size382; ++_i386)
            {
              std::string _key387;
              xfer += iprot->readString(_key387);
              std::vector<io_changed_range> & _val388 = this->completed_blocks[_key387];
              {
                _val388.clear();
                uint32_t _size389;
                ::apache::thrift::protocol::TType _etype392;
                xfer += iprot->readListBegin(_etype392, _size389);
                _val388.resize(_size389);
                uint32_t _i393;
                for (_i393 = 0; _i393 < _size389; ++_i393)
                {
                  xfer += _val388[_i393].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.completed_blocks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t virtual_create_packer_job_detail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("virtual_create_packer_job_detail");

  if (this->__isset.disks) {
    xfer += oprot->writeFieldBegin("disks", ::apache::thrift::protocol::T_SET, 1);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->disks.size()));
      std::set<std::string> ::const_iterator _iter394;
      for (_iter394 = this->disks.begin(); _iter394 != this->disks.end(); ++_iter394)
      {
        xfer += oprot->writeString((*_iter394));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.host) {
    xfer += oprot->writeFieldBegin("host", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->host);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.addr) {
    xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_SET, 3);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->addr.size()));
      std::set<std::string> ::const_iterator _iter395;
      for (_iter395 = this->addr.begin(); _iter395 != this->addr.end(); ++_iter395)
      {
        xfer += oprot->writeString((*_iter395));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.username) {
    xfer += oprot->writeFieldBegin("username", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->username);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.password) {
    xfer += oprot->writeFieldBegin("password", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->password);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.virtual_machine_id) {
    xfer += oprot->writeFieldBegin("virtual_machine_id", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->virtual_machine_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.snapshot) {
    xfer += oprot->writeFieldBegin("snapshot", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->snapshot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.images) {
    xfer += oprot->writeFieldBegin("images", ::apache::thrift::protocol::T_MAP, 10);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->images.size()));
      std::map<std::string, packer_disk_image> ::const_iterator _iter396;
      for (_iter396 = this->images.begin(); _iter396 != this->images.end(); ++_iter396)
      {
        xfer += oprot->writeString(_iter396->first);
        xfer += _iter396->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.backup_size) {
    xfer += oprot->writeFieldBegin("backup_size", ::apache::thrift::protocol::T_MAP, 14);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->backup_size.size()));
      std::map<std::string, int64_t> ::const_iterator _iter397;
      for (_iter397 = this->backup_size.begin(); _iter397 != this->backup_size.end(); ++_iter397)
      {
        xfer += oprot->writeString(_iter397->first);
        xfer += oprot->writeI64(_iter397->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.backup_progress) {
    xfer += oprot->writeFieldBegin("backup_progress", ::apache::thrift::protocol::T_MAP, 15);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->backup_progress.size()));
      std::map<std::string, int64_t> ::const_iterator _iter398;
      for (_iter398 = this->backup_progress.begin(); _iter398 != this->backup_progress.end(); ++_iter398)
      {
        xfer += oprot->writeString(_iter398->first);
        xfer += oprot->writeI64(_iter398->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.backup_image_offset) {
    xfer += oprot->writeFieldBegin("backup_image_offset", ::apache::thrift::protocol::T_MAP, 16);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->backup_image_offset.size()));
      std::map<std::string, int64_t> ::const_iterator _iter399;
      for (_iter399 = this->backup_image_offset.begin(); _iter399 != this->backup_image_offset.end(); ++_iter399)
      {
        xfer += oprot->writeString(_iter399->first);
        xfer += oprot->writeI64(_iter399->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.previous_change_ids) {
    xfer += oprot->writeFieldBegin("previous_change_ids", ::apache::thrift::protocol::T_MAP, 17);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->previous_change_ids.size()));
      std::map<std::string, std::string> ::const_iterator _iter400;
      for (_iter400 = this->previous_change_ids.begin(); _iter400 != this->previous_change_ids.end(); ++_iter400)
      {
        xfer += oprot->writeString(_iter400->first);
        xfer += oprot->writeString(_iter400->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.completed_blocks) {
    xfer += oprot->writeFieldBegin("completed_blocks", ::apache::thrift::protocol::T_MAP, 18);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->completed_blocks.size()));
      std::map<std::string, std::vector<io_changed_range> > ::const_iterator _iter401;
      for (_iter401 = this->completed_blocks.begin(); _iter401 != this->completed_blocks.end(); ++_iter401)
      {
        xfer += oprot->writeString(_iter401->first);
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter401->second.size()));
          std::vector<io_changed_range> ::const_iterator _iter402;
          for (_iter402 = _iter401->second.begin(); _iter402 != _iter401->second.end(); ++_iter402)
          {
            xfer += (*_iter402).write(oprot);
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(virtual_create_packer_job_detail &a, virtual_create_packer_job_detail &b) {
  using ::std::swap;
  swap(a.disks, b.disks);
  swap(a.host, b.host);
  swap(a.addr, b.addr);
  swap(a.username, b.username);
  swap(a.password, b.password);
  swap(a.virtual_machine_id, b.virtual_machine_id);
  swap(a.snapshot, b.snapshot);
  swap(a.images, b.images);
  swap(a.backup_size, b.backup_size);
  swap(a.backup_progress, b.backup_progress);
  swap(a.backup_image_offset, b.backup_image_offset);
  swap(a.previous_change_ids, b.previous_change_ids);
  swap(a.completed_blocks, b.completed_blocks);
  swap(a.__isset, b.__isset);
}

virtual_create_packer_job_detail::virtual_create_packer_job_detail(const virtual_create_packer_job_detail& other403) {
  disks = other403.disks;
  host = other403.host;
  addr = other403.addr;
  username = other403.username;
  password = other403.password;
  virtual_machine_id = other403.virtual_machine_id;
  snapshot = other403.snapshot;
  images = other403.images;
  backup_size = other403.backup_size;
  backup_progress = other403.backup_progress;
  backup_image_offset = other403.backup_image_offset;
  previous_change_ids = other403.previous_change_ids;
  completed_blocks = other403.completed_blocks;
  __isset = other403.__isset;
}
virtual_create_packer_job_detail& virtual_create_packer_job_detail::operator=(const virtual_create_packer_job_detail& other404) {
  disks = other404.disks;
  host = other404.host;
  addr = other404.addr;
  username = other404.username;
  password = other404.password;
  virtual_machine_id = other404.virtual_machine_id;
  snapshot = other404.snapshot;
  images = other404.images;
  backup_size = other404.backup_size;
  backup_progress = other404.backup_progress;
  backup_image_offset = other404.backup_image_offset;
  previous_change_ids = other404.previous_change_ids;
  completed_blocks = other404.completed_blocks;
  __isset = other404.__isset;
  return *this;
}
void virtual_create_packer_job_detail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "virtual_create_packer_job_detail(";
  out << "disks="; (__isset.disks ? (out << to_string(disks)) : (out << "<null>"));
  out << ", " << "host="; (__isset.host ? (out << to_string(host)) : (out << "<null>"));
  out << ", " << "addr="; (__isset.addr ? (out << to_string(addr)) : (out << "<null>"));
  out << ", " << "username="; (__isset.username ? (out << to_string(username)) : (out << "<null>"));
  out << ", " << "password="; (__isset.password ? (out << to_string(password)) : (out << "<null>"));
  out << ", " << "virtual_machine_id="; (__isset.virtual_machine_id ? (out << to_string(virtual_machine_id)) : (out << "<null>"));
  out << ", " << "snapshot="; (__isset.snapshot ? (out << to_string(snapshot)) : (out << "<null>"));
  out << ", " << "images="; (__isset.images ? (out << to_string(images)) : (out << "<null>"));
  out << ", " << "backup_size="; (__isset.backup_size ? (out << to_string(backup_size)) : (out << "<null>"));
  out << ", " << "backup_progress="; (__isset.backup_progress ? (out << to_string(backup_progress)) : (out << "<null>"));
  out << ", " << "backup_image_offset="; (__isset.backup_image_offset ? (out << to_string(backup_image_offset)) : (out << "<null>"));
  out << ", " << "previous_change_ids="; (__isset.previous_change_ids ? (out << to_string(previous_change_ids)) : (out << "<null>"));
  out << ", " << "completed_blocks="; (__isset.completed_blocks ? (out << to_string(completed_blocks)) : (out << "<null>"));
  out << ")";
}


physical_vcbt_journal::~physical_vcbt_journal() throw() {
}


void physical_vcbt_journal::__set_id(const int64_t val) {
  this->id = val;
__isset.id = true;
}

void physical_vcbt_journal::__set_first_key(const int64_t val) {
  this->first_key = val;
__isset.first_key = true;
}

void physical_vcbt_journal::__set_latest_key(const int64_t val) {
  this->latest_key = val;
__isset.latest_key = true;
}

void physical_vcbt_journal::__set_lowest_valid_key(const int64_t val) {
  this->lowest_valid_key = val;
__isset.lowest_valid_key = true;
}
std::ostream& operator<<(std::ostream& out, const physical_vcbt_journal& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t physical_vcbt_journal::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->first_key);
          this->__isset.first_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->latest_key);
          this->__isset.latest_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lowest_valid_key);
          this->__isset.lowest_valid_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_vcbt_journal::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_vcbt_journal");

  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.first_key) {
    xfer += oprot->writeFieldBegin("first_key", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->first_key);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.latest_key) {
    xfer += oprot->writeFieldBegin("latest_key", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->latest_key);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lowest_valid_key) {
    xfer += oprot->writeFieldBegin("lowest_valid_key", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->lowest_valid_key);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(physical_vcbt_journal &a, physical_vcbt_journal &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.first_key, b.first_key);
  swap(a.latest_key, b.latest_key);
  swap(a.lowest_valid_key, b.lowest_valid_key);
  swap(a.__isset, b.__isset);
}

physical_vcbt_journal::physical_vcbt_journal(const physical_vcbt_journal& other405) {
  id = other405.id;
  first_key = other405.first_key;
  latest_key = other405.latest_key;
  lowest_valid_key = other405.lowest_valid_key;
  __isset = other405.__isset;
}
physical_vcbt_journal& physical_vcbt_journal::operator=(const physical_vcbt_journal& other406) {
  id = other406.id;
  first_key = other406.first_key;
  latest_key = other406.latest_key;
  lowest_valid_key = other406.lowest_valid_key;
  __isset = other406.__isset;
  return *this;
}
void physical_vcbt_journal::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "physical_vcbt_journal(";
  out << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "first_key="; (__isset.first_key ? (out << to_string(first_key)) : (out << "<null>"));
  out << ", " << "latest_key="; (__isset.latest_key ? (out << to_string(latest_key)) : (out << "<null>"));
  out << ", " << "lowest_valid_key="; (__isset.lowest_valid_key ? (out << to_string(lowest_valid_key)) : (out << "<null>"));
  out << ")";
}


io_changed_range::~io_changed_range() throw() {
}


void io_changed_range::__set_offset(const int64_t val) {
  this->offset = val;
}

void io_changed_range::__set_start(const int64_t val) {
  this->start = val;
}

void io_changed_range::__set_length(const int64_t val) {
  this->length = val;
}
std::ostream& operator<<(std::ostream& out, const io_changed_range& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t io_changed_range::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->offset);
          this->__isset.offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->start);
          this->__isset.start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->length);
          this->__isset.length = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t io_changed_range::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("io_changed_range");

  xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->offset);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->start);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("length", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->length);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(io_changed_range &a, io_changed_range &b) {
  using ::std::swap;
  swap(a.offset, b.offset);
  swap(a.start, b.start);
  swap(a.length, b.length);
  swap(a.__isset, b.__isset);
}

io_changed_range::io_changed_range(const io_changed_range& other407) {
  offset = other407.offset;
  start = other407.start;
  length = other407.length;
  __isset = other407.__isset;
}
io_changed_range& io_changed_range::operator=(const io_changed_range& other408) {
  offset = other408.offset;
  start = other408.start;
  length = other408.length;
  __isset = other408.__isset;
  return *this;
}
void io_changed_range::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "io_changed_range(";
  out << "offset=" << to_string(offset);
  out << ", " << "start=" << to_string(start);
  out << ", " << "length=" << to_string(length);
  out << ")";
}


physical_create_packer_job_detail::~physical_create_packer_job_detail() throw() {
}


void physical_create_packer_job_detail::__set_disks(const std::set<std::string> & val) {
  this->disks = val;
__isset.disks = true;
}

void physical_create_packer_job_detail::__set_snapshots(const std::vector<snapshot> & val) {
  this->snapshots = val;
__isset.snapshots = true;
}

void physical_create_packer_job_detail::__set_previous_journals(const std::map<int64_t, physical_vcbt_journal> & val) {
  this->previous_journals = val;
__isset.previous_journals = true;
}

void physical_create_packer_job_detail::__set_images(const std::map<std::string, packer_disk_image> & val) {
  this->images = val;
__isset.images = true;
}

void physical_create_packer_job_detail::__set_backup_size(const std::map<std::string, int64_t> & val) {
  this->backup_size = val;
__isset.backup_size = true;
}

void physical_create_packer_job_detail::__set_backup_progress(const std::map<std::string, int64_t> & val) {
  this->backup_progress = val;
__isset.backup_progress = true;
}

void physical_create_packer_job_detail::__set_backup_image_offset(const std::map<std::string, int64_t> & val) {
  this->backup_image_offset = val;
__isset.backup_image_offset = true;
}

void physical_create_packer_job_detail::__set_cdr_journals(const std::map<int64_t, physical_vcbt_journal> & val) {
  this->cdr_journals = val;
__isset.cdr_journals = true;
}

void physical_create_packer_job_detail::__set_cdr_changed_ranges(const std::map<std::string, std::vector<io_changed_range> > & val) {
  this->cdr_changed_ranges = val;
__isset.cdr_changed_ranges = true;
}

void physical_create_packer_job_detail::__set_completed_blocks(const std::map<std::string, std::vector<io_changed_range> > & val) {
  this->completed_blocks = val;
__isset.completed_blocks = true;
}

void physical_create_packer_job_detail::__set_excluded_paths(const std::set<std::string> & val) {
  this->excluded_paths = val;
__isset.excluded_paths = true;
}

void physical_create_packer_job_detail::__set_resync_paths(const std::set<std::string> & val) {
  this->resync_paths = val;
__isset.resync_paths = true;
}
std::ostream& operator<<(std::ostream& out, const physical_create_packer_job_detail& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t physical_create_packer_job_detail::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->disks.clear();
            uint32_t _size409;
            ::apache::thrift::protocol::TType _etype412;
            xfer += iprot->readSetBegin(_etype412, _size409);
            uint32_t _i413;
            for (_i413 = 0; _i413 < _size409; ++_i413)
            {
              std::string _elem414;
              xfer += iprot->readString(_elem414);
              this->disks.insert(_elem414);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.disks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->snapshots.clear();
            uint32_t _size415;
            ::apache::thrift::protocol::TType _etype418;
            xfer += iprot->readListBegin(_etype418, _size415);
            this->snapshots.resize(_size415);
            uint32_t _i419;
            for (_i419 = 0; _i419 < _size415; ++_i419)
            {
              xfer += this->snapshots[_i419].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.snapshots = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->previous_journals.clear();
            uint32_t _size420;
            ::apache::thrift::protocol::TType _ktype421;
            ::apache::thrift::protocol::TType _vtype422;
            xfer += iprot->readMapBegin(_ktype421, _vtype422, _size420);
            uint32_t _i424;
            for (_i424 = 0; _i424 < _size420; ++_i424)
            {
              int64_t _key425;
              xfer += iprot->readI64(_key425);
              physical_vcbt_journal& _val426 = this->previous_journals[_key425];
              xfer += _val426.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.previous_journals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->images.clear();
            uint32_t _size427;
            ::apache::thrift::protocol::TType _ktype428;
            ::apache::thrift::protocol::TType _vtype429;
            xfer += iprot->readMapBegin(_ktype428, _vtype429, _size427);
            uint32_t _i431;
            for (_i431 = 0; _i431 < _size427; ++_i431)
            {
              std::string _key432;
              xfer += iprot->readString(_key432);
              packer_disk_image& _val433 = this->images[_key432];
              xfer += _val433.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.images = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->backup_size.clear();
            uint32_t _size434;
            ::apache::thrift::protocol::TType _ktype435;
            ::apache::thrift::protocol::TType _vtype436;
            xfer += iprot->readMapBegin(_ktype435, _vtype436, _size434);
            uint32_t _i438;
            for (_i438 = 0; _i438 < _size434; ++_i438)
            {
              std::string _key439;
              xfer += iprot->readString(_key439);
              int64_t& _val440 = this->backup_size[_key439];
              xfer += iprot->readI64(_val440);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.backup_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->backup_progress.clear();
            uint32_t _size441;
            ::apache::thrift::protocol::TType _ktype442;
            ::apache::thrift::protocol::TType _vtype443;
            xfer += iprot->readMapBegin(_ktype442, _vtype443, _size441);
            uint32_t _i445;
            for (_i445 = 0; _i445 < _size441; ++_i445)
            {
              std::string _key446;
              xfer += iprot->readString(_key446);
              int64_t& _val447 = this->backup_progress[_key446];
              xfer += iprot->readI64(_val447);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.backup_progress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->backup_image_offset.clear();
            uint32_t _size448;
            ::apache::thrift::protocol::TType _ktype449;
            ::apache::thrift::protocol::TType _vtype450;
            xfer += iprot->readMapBegin(_ktype449, _vtype450, _size448);
            uint32_t _i452;
            for (_i452 = 0; _i452 < _size448; ++_i452)
            {
              std::string _key453;
              xfer += iprot->readString(_key453);
              int64_t& _val454 = this->backup_image_offset[_key453];
              xfer += iprot->readI64(_val454);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.backup_image_offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->cdr_journals.clear();
            uint32_t _size455;
            ::apache::thrift::protocol::TType _ktype456;
            ::apache::thrift::protocol::TType _vtype457;
            xfer += iprot->readMapBegin(_ktype456, _vtype457, _size455);
            uint32_t _i459;
            for (_i459 = 0; _i459 < _size455; ++_i459)
            {
              int64_t _key460;
              xfer += iprot->readI64(_key460);
              physical_vcbt_journal& _val461 = this->cdr_journals[_key460];
              xfer += _val461.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.cdr_journals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->cdr_changed_ranges.clear();
            uint32_t _size462;
            ::apache::thrift::protocol::TType _ktype463;
            ::apache::thrift::protocol::TType _vtype464;
            xfer += iprot->readMapBegin(_ktype463, _vtype464, _size462);
            uint32_t _i466;
            for (_i466 = 0; _i466 < _size462; ++_i466)
            {
              std::string _key467;
              xfer += iprot->readString(_key467);
              std::vector<io_changed_range> & _val468 = this->cdr_changed_ranges[_key467];
              {
                _val468.clear();
                uint32_t _size469;
                ::apache::thrift::protocol::TType _etype472;
                xfer += iprot->readListBegin(_etype472, _size469);
                _val468.resize(_size469);
                uint32_t _i473;
                for (_i473 = 0; _i473 < _size469; ++_i473)
                {
                  xfer += _val468[_i473].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.cdr_changed_ranges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->completed_blocks.clear();
            uint32_t _size474;
            ::apache::thrift::protocol::TType _ktype475;
            ::apache::thrift::protocol::TType _vtype476;
            xfer += iprot->readMapBegin(_ktype475, _vtype476, _size474);
            uint32_t _i478;
            for (_i478 = 0; _i478 < _size474; ++_i478)
            {
              std::string _key479;
              xfer += iprot->readString(_key479);
              std::vector<io_changed_range> & _val480 = this->completed_blocks[_key479];
              {
                _val480.clear();
                uint32_t _size481;
                ::apache::thrift::protocol::TType _etype484;
                xfer += iprot->readListBegin(_etype484, _size481);
                _val480.resize(_size481);
                uint32_t _i485;
                for (_i485 = 0; _i485 < _size481; ++_i485)
                {
                  xfer += _val480[_i485].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.completed_blocks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->excluded_paths.clear();
            uint32_t _size486;
            ::apache::thrift::protocol::TType _etype489;
            xfer += iprot->readSetBegin(_etype489, _size486);
            uint32_t _i490;
            for (_i490 = 0; _i490 < _size486; ++_i490)
            {
              std::string _elem491;
              xfer += iprot->readString(_elem491);
              this->excluded_paths.insert(_elem491);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.excluded_paths = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->resync_paths.clear();
            uint32_t _size492;
            ::apache::thrift::protocol::TType _etype495;
            xfer += iprot->readSetBegin(_etype495, _size492);
            uint32_t _i496;
            for (_i496 = 0; _i496 < _size492; ++_i496)
            {
              std::string _elem497;
              xfer += iprot->readString(_elem497);
              this->resync_paths.insert(_elem497);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.resync_paths = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_create_packer_job_detail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_create_packer_job_detail");

  if (this->__isset.disks) {
    xfer += oprot->writeFieldBegin("disks", ::apache::thrift::protocol::T_SET, 1);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->disks.size()));
      std::set<std::string> ::const_iterator _iter498;
      for (_iter498 = this->disks.begin(); _iter498 != this->disks.end(); ++_iter498)
      {
        xfer += oprot->writeString((*_iter498));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.snapshots) {
    xfer += oprot->writeFieldBegin("snapshots", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->snapshots.size()));
      std::vector<snapshot> ::const_iterator _iter499;
      for (_iter499 = this->snapshots.begin(); _iter499 != this->snapshots.end(); ++_iter499)
      {
        xfer += (*_iter499).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.previous_journals) {
    xfer += oprot->writeFieldBegin("previous_journals", ::apache::thrift::protocol::T_MAP, 3);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I64, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->previous_journals.size()));
      std::map<int64_t, physical_vcbt_journal> ::const_iterator _iter500;
      for (_iter500 = this->previous_journals.begin(); _iter500 != this->previous_journals.end(); ++_iter500)
      {
        xfer += oprot->writeI64(_iter500->first);
        xfer += _iter500->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.images) {
    xfer += oprot->writeFieldBegin("images", ::apache::thrift::protocol::T_MAP, 4);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->images.size()));
      std::map<std::string, packer_disk_image> ::const_iterator _iter501;
      for (_iter501 = this->images.begin(); _iter501 != this->images.end(); ++_iter501)
      {
        xfer += oprot->writeString(_iter501->first);
        xfer += _iter501->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.backup_size) {
    xfer += oprot->writeFieldBegin("backup_size", ::apache::thrift::protocol::T_MAP, 5);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->backup_size.size()));
      std::map<std::string, int64_t> ::const_iterator _iter502;
      for (_iter502 = this->backup_size.begin(); _iter502 != this->backup_size.end(); ++_iter502)
      {
        xfer += oprot->writeString(_iter502->first);
        xfer += oprot->writeI64(_iter502->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.backup_progress) {
    xfer += oprot->writeFieldBegin("backup_progress", ::apache::thrift::protocol::T_MAP, 6);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->backup_progress.size()));
      std::map<std::string, int64_t> ::const_iterator _iter503;
      for (_iter503 = this->backup_progress.begin(); _iter503 != this->backup_progress.end(); ++_iter503)
      {
        xfer += oprot->writeString(_iter503->first);
        xfer += oprot->writeI64(_iter503->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.backup_image_offset) {
    xfer += oprot->writeFieldBegin("backup_image_offset", ::apache::thrift::protocol::T_MAP, 7);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->backup_image_offset.size()));
      std::map<std::string, int64_t> ::const_iterator _iter504;
      for (_iter504 = this->backup_image_offset.begin(); _iter504 != this->backup_image_offset.end(); ++_iter504)
      {
        xfer += oprot->writeString(_iter504->first);
        xfer += oprot->writeI64(_iter504->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cdr_journals) {
    xfer += oprot->writeFieldBegin("cdr_journals", ::apache::thrift::protocol::T_MAP, 8);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I64, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cdr_journals.size()));
      std::map<int64_t, physical_vcbt_journal> ::const_iterator _iter505;
      for (_iter505 = this->cdr_journals.begin(); _iter505 != this->cdr_journals.end(); ++_iter505)
      {
        xfer += oprot->writeI64(_iter505->first);
        xfer += _iter505->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cdr_changed_ranges) {
    xfer += oprot->writeFieldBegin("cdr_changed_ranges", ::apache::thrift::protocol::T_MAP, 9);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->cdr_changed_ranges.size()));
      std::map<std::string, std::vector<io_changed_range> > ::const_iterator _iter506;
      for (_iter506 = this->cdr_changed_ranges.begin(); _iter506 != this->cdr_changed_ranges.end(); ++_iter506)
      {
        xfer += oprot->writeString(_iter506->first);
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter506->second.size()));
          std::vector<io_changed_range> ::const_iterator _iter507;
          for (_iter507 = _iter506->second.begin(); _iter507 != _iter506->second.end(); ++_iter507)
          {
            xfer += (*_iter507).write(oprot);
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.completed_blocks) {
    xfer += oprot->writeFieldBegin("completed_blocks", ::apache::thrift::protocol::T_MAP, 10);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->completed_blocks.size()));
      std::map<std::string, std::vector<io_changed_range> > ::const_iterator _iter508;
      for (_iter508 = this->completed_blocks.begin(); _iter508 != this->completed_blocks.end(); ++_iter508)
      {
        xfer += oprot->writeString(_iter508->first);
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter508->second.size()));
          std::vector<io_changed_range> ::const_iterator _iter509;
          for (_iter509 = _iter508->second.begin(); _iter509 != _iter508->second.end(); ++_iter509)
          {
            xfer += (*_iter509).write(oprot);
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.excluded_paths) {
    xfer += oprot->writeFieldBegin("excluded_paths", ::apache::thrift::protocol::T_SET, 11);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->excluded_paths.size()));
      std::set<std::string> ::const_iterator _iter510;
      for (_iter510 = this->excluded_paths.begin(); _iter510 != this->excluded_paths.end(); ++_iter510)
      {
        xfer += oprot->writeString((*_iter510));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.resync_paths) {
    xfer += oprot->writeFieldBegin("resync_paths", ::apache::thrift::protocol::T_SET, 12);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->resync_paths.size()));
      std::set<std::string> ::const_iterator _iter511;
      for (_iter511 = this->resync_paths.begin(); _iter511 != this->resync_paths.end(); ++_iter511)
      {
        xfer += oprot->writeString((*_iter511));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(physical_create_packer_job_detail &a, physical_create_packer_job_detail &b) {
  using ::std::swap;
  swap(a.disks, b.disks);
  swap(a.snapshots, b.snapshots);
  swap(a.previous_journals, b.previous_journals);
  swap(a.images, b.images);
  swap(a.backup_size, b.backup_size);
  swap(a.backup_progress, b.backup_progress);
  swap(a.backup_image_offset, b.backup_image_offset);
  swap(a.cdr_journals, b.cdr_journals);
  swap(a.cdr_changed_ranges, b.cdr_changed_ranges);
  swap(a.completed_blocks, b.completed_blocks);
  swap(a.excluded_paths, b.excluded_paths);
  swap(a.resync_paths, b.resync_paths);
  swap(a.__isset, b.__isset);
}

physical_create_packer_job_detail::physical_create_packer_job_detail(const physical_create_packer_job_detail& other512) {
  disks = other512.disks;
  snapshots = other512.snapshots;
  previous_journals = other512.previous_journals;
  images = other512.images;
  backup_size = other512.backup_size;
  backup_progress = other512.backup_progress;
  backup_image_offset = other512.backup_image_offset;
  cdr_journals = other512.cdr_journals;
  cdr_changed_ranges = other512.cdr_changed_ranges;
  completed_blocks = other512.completed_blocks;
  excluded_paths = other512.excluded_paths;
  resync_paths = other512.resync_paths;
  __isset = other512.__isset;
}
physical_create_packer_job_detail& physical_create_packer_job_detail::operator=(const physical_create_packer_job_detail& other513) {
  disks = other513.disks;
  snapshots = other513.snapshots;
  previous_journals = other513.previous_journals;
  images = other513.images;
  backup_size = other513.backup_size;
  backup_progress = other513.backup_progress;
  backup_image_offset = other513.backup_image_offset;
  cdr_journals = other513.cdr_journals;
  cdr_changed_ranges = other513.cdr_changed_ranges;
  completed_blocks = other513.completed_blocks;
  excluded_paths = other513.excluded_paths;
  resync_paths = other513.resync_paths;
  __isset = other513.__isset;
  return *this;
}
void physical_create_packer_job_detail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "physical_create_packer_job_detail(";
  out << "disks="; (__isset.disks ? (out << to_string(disks)) : (out << "<null>"));
  out << ", " << "snapshots="; (__isset.snapshots ? (out << to_string(snapshots)) : (out << "<null>"));
  out << ", " << "previous_journals="; (__isset.previous_journals ? (out << to_string(previous_journals)) : (out << "<null>"));
  out << ", " << "images="; (__isset.images ? (out << to_string(images)) : (out << "<null>"));
  out << ", " << "backup_size="; (__isset.backup_size ? (out << to_string(backup_size)) : (out << "<null>"));
  out << ", " << "backup_progress="; (__isset.backup_progress ? (out << to_string(backup_progress)) : (out << "<null>"));
  out << ", " << "backup_image_offset="; (__isset.backup_image_offset ? (out << to_string(backup_image_offset)) : (out << "<null>"));
  out << ", " << "cdr_journals="; (__isset.cdr_journals ? (out << to_string(cdr_journals)) : (out << "<null>"));
  out << ", " << "cdr_changed_ranges="; (__isset.cdr_changed_ranges ? (out << to_string(cdr_changed_ranges)) : (out << "<null>"));
  out << ", " << "completed_blocks="; (__isset.completed_blocks ? (out << to_string(completed_blocks)) : (out << "<null>"));
  out << ", " << "excluded_paths="; (__isset.excluded_paths ? (out << to_string(excluded_paths)) : (out << "<null>"));
  out << ", " << "resync_paths="; (__isset.resync_paths ? (out << to_string(resync_paths)) : (out << "<null>"));
  out << ")";
}


_create_packer_job_detail::~_create_packer_job_detail() throw() {
}


void _create_packer_job_detail::__set_p(const physical_create_packer_job_detail& val) {
  this->p = val;
__isset.p = true;
}

void _create_packer_job_detail::__set_v(const virtual_create_packer_job_detail& val) {
  this->v = val;
__isset.v = true;
}
std::ostream& operator<<(std::ostream& out, const _create_packer_job_detail& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t _create_packer_job_detail::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->p.read(iprot);
          this->__isset.p = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->v.read(iprot);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t _create_packer_job_detail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("_create_packer_job_detail");

  if (this->__isset.p) {
    xfer += oprot->writeFieldBegin("p", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->p.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.v) {
    xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->v.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(_create_packer_job_detail &a, _create_packer_job_detail &b) {
  using ::std::swap;
  swap(a.p, b.p);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

_create_packer_job_detail::_create_packer_job_detail(const _create_packer_job_detail& other514) {
  p = other514.p;
  v = other514.v;
  __isset = other514.__isset;
}
_create_packer_job_detail& _create_packer_job_detail::operator=(const _create_packer_job_detail& other515) {
  p = other515.p;
  v = other515.v;
  __isset = other515.__isset;
  return *this;
}
void _create_packer_job_detail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "_create_packer_job_detail(";
  out << "p="; (__isset.p ? (out << to_string(p)) : (out << "<null>"));
  out << ", " << "v="; (__isset.v ? (out << to_string(v)) : (out << "<null>"));
  out << ")";
}


create_packer_job_detail::~create_packer_job_detail() throw() {
}


void create_packer_job_detail::__set_type(const job_type::type val) {
  this->type = val;
}

void create_packer_job_detail::__set_connection_ids(const std::set<std::string> & val) {
  this->connection_ids = val;
}

void create_packer_job_detail::__set_carriers(const std::map<std::string, std::set<std::string> > & val) {
  this->carriers = val;
}

void create_packer_job_detail::__set_detail(const _create_packer_job_detail& val) {
  this->detail = val;
}

void create_packer_job_detail::__set_checksum_verify(const bool val) {
  this->checksum_verify = val;
__isset.checksum_verify = true;
}

void create_packer_job_detail::__set_timeout(const int32_t val) {
  this->timeout = val;
__isset.timeout = true;
}

void create_packer_job_detail::__set_is_encrypted(const bool val) {
  this->is_encrypted = val;
__isset.is_encrypted = true;
}

void create_packer_job_detail::__set_worker_thread_number(const int32_t val) {
  this->worker_thread_number = val;
__isset.worker_thread_number = true;
}

void create_packer_job_detail::__set_file_system_filter_enable(const bool val) {
  this->file_system_filter_enable = val;
__isset.file_system_filter_enable = true;
}

void create_packer_job_detail::__set_min_transport_size(const int32_t val) {
  this->min_transport_size = val;
__isset.min_transport_size = true;
}

void create_packer_job_detail::__set_full_min_transport_size(const int32_t val) {
  this->full_min_transport_size = val;
__isset.full_min_transport_size = true;
}

void create_packer_job_detail::__set_is_compressed(const bool val) {
  this->is_compressed = val;
__isset.is_compressed = true;
}

void create_packer_job_detail::__set_is_checksum(const bool val) {
  this->is_checksum = val;
__isset.is_checksum = true;
}

void create_packer_job_detail::__set_priority_carrier(const std::map<std::string, std::string> & val) {
  this->priority_carrier = val;
__isset.priority_carrier = true;
}

void create_packer_job_detail::__set_is_only_single_system_disk(const bool val) {
  this->is_only_single_system_disk = val;
__isset.is_only_single_system_disk = true;
}

void create_packer_job_detail::__set_is_compressed_by_packer(const bool val) {
  this->is_compressed_by_packer = val;
__isset.is_compressed_by_packer = true;
}
std::ostream& operator<<(std::ostream& out, const create_packer_job_detail& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t create_packer_job_detail::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast516;
          xfer += iprot->readI32(ecast516);
          this->type = (job_type::type)ecast516;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->connection_ids.clear();
            uint32_t _size517;
            ::apache::thrift::protocol::TType _etype520;
            xfer += iprot->readSetBegin(_etype520, _size517);
            uint32_t _i521;
            for (_i521 = 0; _i521 < _size517; ++_i521)
            {
              std::string _elem522;
              xfer += iprot->readString(_elem522);
              this->connection_ids.insert(_elem522);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.connection_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->carriers.clear();
            uint32_t _size523;
            ::apache::thrift::protocol::TType _ktype524;
            ::apache::thrift::protocol::TType _vtype525;
            xfer += iprot->readMapBegin(_ktype524, _vtype525, _size523);
            uint32_t _i527;
            for (_i527 = 0; _i527 < _size523; ++_i527)
            {
              std::string _key528;
              xfer += iprot->readString(_key528);
              std::set<std::string> & _val529 = this->carriers[_key528];
              {
                _val529.clear();
                uint32_t _size530;
                ::apache::thrift::protocol::TType _etype533;
                xfer += iprot->readSetBegin(_etype533, _size530);
                uint32_t _i534;
                for (_i534 = 0; _i534 < _size530; ++_i534)
                {
                  std::string _elem535;
                  xfer += iprot->readString(_elem535);
                  _val529.insert(_elem535);
                }
                xfer += iprot->readSetEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.carriers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->detail.read(iprot);
          this->__isset.detail = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->checksum_verify);
          this->__isset.checksum_verify = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->timeout);
          this->__isset.timeout = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_encrypted);
          this->__isset.is_encrypted = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->worker_thread_number);
          this->__isset.worker_thread_number = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->file_system_filter_enable);
          this->__isset.file_system_filter_enable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->min_transport_size);
          this->__isset.min_transport_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->full_min_transport_size);
          this->__isset.full_min_transport_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_compressed);
          this->__isset.is_compressed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_checksum);
          this->__isset.is_checksum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->priority_carrier.clear();
            uint32_t _size536;
            ::apache::thrift::protocol::TType _ktype537;
            ::apache::thrift::protocol::TType _vtype538;
            xfer += iprot->readMapBegin(_ktype537, _vtype538, _size536);
            uint32_t _i540;
            for (_i540 = 0; _i540 < _size536; ++_i540)
            {
              std::string _key541;
              xfer += iprot->readString(_key541);
              std::string& _val542 = this->priority_carrier[_key541];
              xfer += iprot->readString(_val542);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.priority_carrier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_only_single_system_disk);
          this->__isset.is_only_single_system_disk = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_compressed_by_packer);
          this->__isset.is_compressed_by_packer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t create_packer_job_detail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("create_packer_job_detail");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("connection_ids", ::apache::thrift::protocol::T_SET, 2);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->connection_ids.size()));
    std::set<std::string> ::const_iterator _iter543;
    for (_iter543 = this->connection_ids.begin(); _iter543 != this->connection_ids.end(); ++_iter543)
    {
      xfer += oprot->writeString((*_iter543));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("carriers", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_SET, static_cast<uint32_t>(this->carriers.size()));
    std::map<std::string, std::set<std::string> > ::const_iterator _iter544;
    for (_iter544 = this->carriers.begin(); _iter544 != this->carriers.end(); ++_iter544)
    {
      xfer += oprot->writeString(_iter544->first);
      {
        xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter544->second.size()));
        std::set<std::string> ::const_iterator _iter545;
        for (_iter545 = _iter544->second.begin(); _iter545 != _iter544->second.end(); ++_iter545)
        {
          xfer += oprot->writeString((*_iter545));
        }
        xfer += oprot->writeSetEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("detail", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->detail.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.checksum_verify) {
    xfer += oprot->writeFieldBegin("checksum_verify", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->checksum_verify);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timeout) {
    xfer += oprot->writeFieldBegin("timeout", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(this->timeout);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_encrypted) {
    xfer += oprot->writeFieldBegin("is_encrypted", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->is_encrypted);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.worker_thread_number) {
    xfer += oprot->writeFieldBegin("worker_thread_number", ::apache::thrift::protocol::T_I32, 8);
    xfer += oprot->writeI32(this->worker_thread_number);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.file_system_filter_enable) {
    xfer += oprot->writeFieldBegin("file_system_filter_enable", ::apache::thrift::protocol::T_BOOL, 9);
    xfer += oprot->writeBool(this->file_system_filter_enable);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.min_transport_size) {
    xfer += oprot->writeFieldBegin("min_transport_size", ::apache::thrift::protocol::T_I32, 10);
    xfer += oprot->writeI32(this->min_transport_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.full_min_transport_size) {
    xfer += oprot->writeFieldBegin("full_min_transport_size", ::apache::thrift::protocol::T_I32, 11);
    xfer += oprot->writeI32(this->full_min_transport_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_compressed) {
    xfer += oprot->writeFieldBegin("is_compressed", ::apache::thrift::protocol::T_BOOL, 12);
    xfer += oprot->writeBool(this->is_compressed);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_checksum) {
    xfer += oprot->writeFieldBegin("is_checksum", ::apache::thrift::protocol::T_BOOL, 13);
    xfer += oprot->writeBool(this->is_checksum);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.priority_carrier) {
    xfer += oprot->writeFieldBegin("priority_carrier", ::apache::thrift::protocol::T_MAP, 14);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->priority_carrier.size()));
      std::map<std::string, std::string> ::const_iterator _iter546;
      for (_iter546 = this->priority_carrier.begin(); _iter546 != this->priority_carrier.end(); ++_iter546)
      {
        xfer += oprot->writeString(_iter546->first);
        xfer += oprot->writeString(_iter546->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_only_single_system_disk) {
    xfer += oprot->writeFieldBegin("is_only_single_system_disk", ::apache::thrift::protocol::T_BOOL, 15);
    xfer += oprot->writeBool(this->is_only_single_system_disk);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_compressed_by_packer) {
    xfer += oprot->writeFieldBegin("is_compressed_by_packer", ::apache::thrift::protocol::T_BOOL, 16);
    xfer += oprot->writeBool(this->is_compressed_by_packer);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(create_packer_job_detail &a, create_packer_job_detail &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.connection_ids, b.connection_ids);
  swap(a.carriers, b.carriers);
  swap(a.detail, b.detail);
  swap(a.checksum_verify, b.checksum_verify);
  swap(a.timeout, b.timeout);
  swap(a.is_encrypted, b.is_encrypted);
  swap(a.worker_thread_number, b.worker_thread_number);
  swap(a.file_system_filter_enable, b.file_system_filter_enable);
  swap(a.min_transport_size, b.min_transport_size);
  swap(a.full_min_transport_size, b.full_min_transport_size);
  swap(a.is_compressed, b.is_compressed);
  swap(a.is_checksum, b.is_checksum);
  swap(a.priority_carrier, b.priority_carrier);
  swap(a.is_only_single_system_disk, b.is_only_single_system_disk);
  swap(a.is_compressed_by_packer, b.is_compressed_by_packer);
  swap(a.__isset, b.__isset);
}

create_packer_job_detail::create_packer_job_detail(const create_packer_job_detail& other547) {
  type = other547.type;
  connection_ids = other547.connection_ids;
  carriers = other547.carriers;
  detail = other547.detail;
  checksum_verify = other547.checksum_verify;
  timeout = other547.timeout;
  is_encrypted = other547.is_encrypted;
  worker_thread_number = other547.worker_thread_number;
  file_system_filter_enable = other547.file_system_filter_enable;
  min_transport_size = other547.min_transport_size;
  full_min_transport_size = other547.full_min_transport_size;
  is_compressed = other547.is_compressed;
  is_checksum = other547.is_checksum;
  priority_carrier = other547.priority_carrier;
  is_only_single_system_disk = other547.is_only_single_system_disk;
  is_compressed_by_packer = other547.is_compressed_by_packer;
  __isset = other547.__isset;
}
create_packer_job_detail& create_packer_job_detail::operator=(const create_packer_job_detail& other548) {
  type = other548.type;
  connection_ids = other548.connection_ids;
  carriers = other548.carriers;
  detail = other548.detail;
  checksum_verify = other548.checksum_verify;
  timeout = other548.timeout;
  is_encrypted = other548.is_encrypted;
  worker_thread_number = other548.worker_thread_number;
  file_system_filter_enable = other548.file_system_filter_enable;
  min_transport_size = other548.min_transport_size;
  full_min_transport_size = other548.full_min_transport_size;
  is_compressed = other548.is_compressed;
  is_checksum = other548.is_checksum;
  priority_carrier = other548.priority_carrier;
  is_only_single_system_disk = other548.is_only_single_system_disk;
  is_compressed_by_packer = other548.is_compressed_by_packer;
  __isset = other548.__isset;
  return *this;
}
void create_packer_job_detail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "create_packer_job_detail(";
  out << "type=" << to_string(type);
  out << ", " << "connection_ids=" << to_string(connection_ids);
  out << ", " << "carriers=" << to_string(carriers);
  out << ", " << "detail=" << to_string(detail);
  out << ", " << "checksum_verify="; (__isset.checksum_verify ? (out << to_string(checksum_verify)) : (out << "<null>"));
  out << ", " << "timeout="; (__isset.timeout ? (out << to_string(timeout)) : (out << "<null>"));
  out << ", " << "is_encrypted="; (__isset.is_encrypted ? (out << to_string(is_encrypted)) : (out << "<null>"));
  out << ", " << "worker_thread_number="; (__isset.worker_thread_number ? (out << to_string(worker_thread_number)) : (out << "<null>"));
  out << ", " << "file_system_filter_enable="; (__isset.file_system_filter_enable ? (out << to_string(file_system_filter_enable)) : (out << "<null>"));
  out << ", " << "min_transport_size="; (__isset.min_transport_size ? (out << to_string(min_transport_size)) : (out << "<null>"));
  out << ", " << "full_min_transport_size="; (__isset.full_min_transport_size ? (out << to_string(full_min_transport_size)) : (out << "<null>"));
  out << ", " << "is_compressed="; (__isset.is_compressed ? (out << to_string(is_compressed)) : (out << "<null>"));
  out << ", " << "is_checksum="; (__isset.is_checksum ? (out << to_string(is_checksum)) : (out << "<null>"));
  out << ", " << "priority_carrier="; (__isset.priority_carrier ? (out << to_string(priority_carrier)) : (out << "<null>"));
  out << ", " << "is_only_single_system_disk="; (__isset.is_only_single_system_disk ? (out << to_string(is_only_single_system_disk)) : (out << "<null>"));
  out << ", " << "is_compressed_by_packer="; (__isset.is_compressed_by_packer ? (out << to_string(is_compressed_by_packer)) : (out << "<null>"));
  out << ")";
}


virtual_packer_job_detail::~virtual_packer_job_detail() throw() {
}


void virtual_packer_job_detail::__set_original_size(const std::map<std::string, int64_t> & val) {
  this->original_size = val;
__isset.original_size = true;
}

void virtual_packer_job_detail::__set_backup_size(const std::map<std::string, int64_t> & val) {
  this->backup_size = val;
__isset.backup_size = true;
}

void virtual_packer_job_detail::__set_backup_progress(const std::map<std::string, int64_t> & val) {
  this->backup_progress = val;
__isset.backup_progress = true;
}

void virtual_packer_job_detail::__set_backup_image_offset(const std::map<std::string, int64_t> & val) {
  this->backup_image_offset = val;
__isset.backup_image_offset = true;
}

void virtual_packer_job_detail::__set_change_ids(const std::map<std::string, std::string> & val) {
  this->change_ids = val;
__isset.change_ids = true;
}

void virtual_packer_job_detail::__set_guest_os_type(const hv_guest_os_type::type val) {
  this->guest_os_type = val;
__isset.guest_os_type = true;
}

void virtual_packer_job_detail::__set_completed_blocks(const std::map<std::string, std::vector<io_changed_range> > & val) {
  this->completed_blocks = val;
__isset.completed_blocks = true;
}

void virtual_packer_job_detail::__set_disk_infos(const std::vector<virtual_disk_info_ex> & val) {
  this->disk_infos = val;
__isset.disk_infos = true;
}
std::ostream& operator<<(std::ostream& out, const virtual_packer_job_detail& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t virtual_packer_job_detail::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->original_size.clear();
            uint32_t _size549;
            ::apache::thrift::protocol::TType _ktype550;
            ::apache::thrift::protocol::TType _vtype551;
            xfer += iprot->readMapBegin(_ktype550, _vtype551, _size549);
            uint32_t _i553;
            for (_i553 = 0; _i553 < _size549; ++_i553)
            {
              std::string _key554;
              xfer += iprot->readString(_key554);
              int64_t& _val555 = this->original_size[_key554];
              xfer += iprot->readI64(_val555);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.original_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->backup_size.clear();
            uint32_t _size556;
            ::apache::thrift::protocol::TType _ktype557;
            ::apache::thrift::protocol::TType _vtype558;
            xfer += iprot->readMapBegin(_ktype557, _vtype558, _size556);
            uint32_t _i560;
            for (_i560 = 0; _i560 < _size556; ++_i560)
            {
              std::string _key561;
              xfer += iprot->readString(_key561);
              int64_t& _val562 = this->backup_size[_key561];
              xfer += iprot->readI64(_val562);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.backup_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->backup_progress.clear();
            uint32_t _size563;
            ::apache::thrift::protocol::TType _ktype564;
            ::apache::thrift::protocol::TType _vtype565;
            xfer += iprot->readMapBegin(_ktype564, _vtype565, _size563);
            uint32_t _i567;
            for (_i567 = 0; _i567 < _size563; ++_i567)
            {
              std::string _key568;
              xfer += iprot->readString(_key568);
              int64_t& _val569 = this->backup_progress[_key568];
              xfer += iprot->readI64(_val569);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.backup_progress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->backup_image_offset.clear();
            uint32_t _size570;
            ::apache::thrift::protocol::TType _ktype571;
            ::apache::thrift::protocol::TType _vtype572;
            xfer += iprot->readMapBegin(_ktype571, _vtype572, _size570);
            uint32_t _i574;
            for (_i574 = 0; _i574 < _size570; ++_i574)
            {
              std::string _key575;
              xfer += iprot->readString(_key575);
              int64_t& _val576 = this->backup_image_offset[_key575];
              xfer += iprot->readI64(_val576);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.backup_image_offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->change_ids.clear();
            uint32_t _size577;
            ::apache::thrift::protocol::TType _ktype578;
            ::apache::thrift::protocol::TType _vtype579;
            xfer += iprot->readMapBegin(_ktype578, _vtype579, _size577);
            uint32_t _i581;
            for (_i581 = 0; _i581 < _size577; ++_i581)
            {
              std::string _key582;
              xfer += iprot->readString(_key582);
              std::string& _val583 = this->change_ids[_key582];
              xfer += iprot->readString(_val583);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.change_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast584;
          xfer += iprot->readI32(ecast584);
          this->guest_os_type = (hv_guest_os_type::type)ecast584;
          this->__isset.guest_os_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->completed_blocks.clear();
            uint32_t _size585;
            ::apache::thrift::protocol::TType _ktype586;
            ::apache::thrift::protocol::TType _vtype587;
            xfer += iprot->readMapBegin(_ktype586, _vtype587, _size585);
            uint32_t _i589;
            for (_i589 = 0; _i589 < _size585; ++_i589)
            {
              std::string _key590;
              xfer += iprot->readString(_key590);
              std::vector<io_changed_range> & _val591 = this->completed_blocks[_key590];
              {
                _val591.clear();
                uint32_t _size592;
                ::apache::thrift::protocol::TType _etype595;
                xfer += iprot->readListBegin(_etype595, _size592);
                _val591.resize(_size592);
                uint32_t _i596;
                for (_i596 = 0; _i596 < _size592; ++_i596)
                {
                  xfer += _val591[_i596].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.completed_blocks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->disk_infos.clear();
            uint32_t _size597;
            ::apache::thrift::protocol::TType _etype600;
            xfer += iprot->readListBegin(_etype600, _size597);
            this->disk_infos.resize(_size597);
            uint32_t _i601;
            for (_i601 = 0; _i601 < _size597; ++_i601)
            {
              xfer += this->disk_infos[_i601].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.disk_infos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t virtual_packer_job_detail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("virtual_packer_job_detail");

  if (this->__isset.original_size) {
    xfer += oprot->writeFieldBegin("original_size", ::apache::thrift::protocol::T_MAP, 1);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->original_size.size()));
      std::map<std::string, int64_t> ::const_iterator _iter602;
      for (_iter602 = this->original_size.begin(); _iter602 != this->original_size.end(); ++_iter602)
      {
        xfer += oprot->writeString(_iter602->first);
        xfer += oprot->writeI64(_iter602->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.backup_size) {
    xfer += oprot->writeFieldBegin("backup_size", ::apache::thrift::protocol::T_MAP, 2);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->backup_size.size()));
      std::map<std::string, int64_t> ::const_iterator _iter603;
      for (_iter603 = this->backup_size.begin(); _iter603 != this->backup_size.end(); ++_iter603)
      {
        xfer += oprot->writeString(_iter603->first);
        xfer += oprot->writeI64(_iter603->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.backup_progress) {
    xfer += oprot->writeFieldBegin("backup_progress", ::apache::thrift::protocol::T_MAP, 3);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->backup_progress.size()));
      std::map<std::string, int64_t> ::const_iterator _iter604;
      for (_iter604 = this->backup_progress.begin(); _iter604 != this->backup_progress.end(); ++_iter604)
      {
        xfer += oprot->writeString(_iter604->first);
        xfer += oprot->writeI64(_iter604->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.backup_image_offset) {
    xfer += oprot->writeFieldBegin("backup_image_offset", ::apache::thrift::protocol::T_MAP, 4);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->backup_image_offset.size()));
      std::map<std::string, int64_t> ::const_iterator _iter605;
      for (_iter605 = this->backup_image_offset.begin(); _iter605 != this->backup_image_offset.end(); ++_iter605)
      {
        xfer += oprot->writeString(_iter605->first);
        xfer += oprot->writeI64(_iter605->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.change_ids) {
    xfer += oprot->writeFieldBegin("change_ids", ::apache::thrift::protocol::T_MAP, 5);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->change_ids.size()));
      std::map<std::string, std::string> ::const_iterator _iter606;
      for (_iter606 = this->change_ids.begin(); _iter606 != this->change_ids.end(); ++_iter606)
      {
        xfer += oprot->writeString(_iter606->first);
        xfer += oprot->writeString(_iter606->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.guest_os_type) {
    xfer += oprot->writeFieldBegin("guest_os_type", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32((int32_t)this->guest_os_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.completed_blocks) {
    xfer += oprot->writeFieldBegin("completed_blocks", ::apache::thrift::protocol::T_MAP, 7);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->completed_blocks.size()));
      std::map<std::string, std::vector<io_changed_range> > ::const_iterator _iter607;
      for (_iter607 = this->completed_blocks.begin(); _iter607 != this->completed_blocks.end(); ++_iter607)
      {
        xfer += oprot->writeString(_iter607->first);
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter607->second.size()));
          std::vector<io_changed_range> ::const_iterator _iter608;
          for (_iter608 = _iter607->second.begin(); _iter608 != _iter607->second.end(); ++_iter608)
          {
            xfer += (*_iter608).write(oprot);
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.disk_infos) {
    xfer += oprot->writeFieldBegin("disk_infos", ::apache::thrift::protocol::T_LIST, 8);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->disk_infos.size()));
      std::vector<virtual_disk_info_ex> ::const_iterator _iter609;
      for (_iter609 = this->disk_infos.begin(); _iter609 != this->disk_infos.end(); ++_iter609)
      {
        xfer += (*_iter609).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(virtual_packer_job_detail &a, virtual_packer_job_detail &b) {
  using ::std::swap;
  swap(a.original_size, b.original_size);
  swap(a.backup_size, b.backup_size);
  swap(a.backup_progress, b.backup_progress);
  swap(a.backup_image_offset, b.backup_image_offset);
  swap(a.change_ids, b.change_ids);
  swap(a.guest_os_type, b.guest_os_type);
  swap(a.completed_blocks, b.completed_blocks);
  swap(a.disk_infos, b.disk_infos);
  swap(a.__isset, b.__isset);
}

virtual_packer_job_detail::virtual_packer_job_detail(const virtual_packer_job_detail& other610) {
  original_size = other610.original_size;
  backup_size = other610.backup_size;
  backup_progress = other610.backup_progress;
  backup_image_offset = other610.backup_image_offset;
  change_ids = other610.change_ids;
  guest_os_type = other610.guest_os_type;
  completed_blocks = other610.completed_blocks;
  disk_infos = other610.disk_infos;
  __isset = other610.__isset;
}
virtual_packer_job_detail& virtual_packer_job_detail::operator=(const virtual_packer_job_detail& other611) {
  original_size = other611.original_size;
  backup_size = other611.backup_size;
  backup_progress = other611.backup_progress;
  backup_image_offset = other611.backup_image_offset;
  change_ids = other611.change_ids;
  guest_os_type = other611.guest_os_type;
  completed_blocks = other611.completed_blocks;
  disk_infos = other611.disk_infos;
  __isset = other611.__isset;
  return *this;
}
void virtual_packer_job_detail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "virtual_packer_job_detail(";
  out << "original_size="; (__isset.original_size ? (out << to_string(original_size)) : (out << "<null>"));
  out << ", " << "backup_size="; (__isset.backup_size ? (out << to_string(backup_size)) : (out << "<null>"));
  out << ", " << "backup_progress="; (__isset.backup_progress ? (out << to_string(backup_progress)) : (out << "<null>"));
  out << ", " << "backup_image_offset="; (__isset.backup_image_offset ? (out << to_string(backup_image_offset)) : (out << "<null>"));
  out << ", " << "change_ids="; (__isset.change_ids ? (out << to_string(change_ids)) : (out << "<null>"));
  out << ", " << "guest_os_type="; (__isset.guest_os_type ? (out << to_string(guest_os_type)) : (out << "<null>"));
  out << ", " << "completed_blocks="; (__isset.completed_blocks ? (out << to_string(completed_blocks)) : (out << "<null>"));
  out << ", " << "disk_infos="; (__isset.disk_infos ? (out << to_string(disk_infos)) : (out << "<null>"));
  out << ")";
}


physical_packer_job_detail::~physical_packer_job_detail() throw() {
}


void physical_packer_job_detail::__set_original_size(const std::map<std::string, int64_t> & val) {
  this->original_size = val;
__isset.original_size = true;
}

void physical_packer_job_detail::__set_backup_size(const std::map<std::string, int64_t> & val) {
  this->backup_size = val;
__isset.backup_size = true;
}

void physical_packer_job_detail::__set_backup_progress(const std::map<std::string, int64_t> & val) {
  this->backup_progress = val;
__isset.backup_progress = true;
}

void physical_packer_job_detail::__set_backup_image_offset(const std::map<std::string, int64_t> & val) {
  this->backup_image_offset = val;
__isset.backup_image_offset = true;
}

void physical_packer_job_detail::__set_vcbt_journals(const std::map<int64_t, physical_vcbt_journal> & val) {
  this->vcbt_journals = val;
__isset.vcbt_journals = true;
}

void physical_packer_job_detail::__set_guest_os_type(const hv_guest_os_type::type val) {
  this->guest_os_type = val;
__isset.guest_os_type = true;
}

void physical_packer_job_detail::__set_cdr_changed_ranges(const std::map<std::string, std::vector<io_changed_range> > & val) {
  this->cdr_changed_ranges = val;
__isset.cdr_changed_ranges = true;
}

void physical_packer_job_detail::__set_completed_blocks(const std::map<std::string, std::vector<io_changed_range> > & val) {
  this->completed_blocks = val;
__isset.completed_blocks = true;
}
std::ostream& operator<<(std::ostream& out, const physical_packer_job_detail& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t physical_packer_job_detail::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->original_size.clear();
            uint32_t _size612;
            ::apache::thrift::protocol::TType _ktype613;
            ::apache::thrift::protocol::TType _vtype614;
            xfer += iprot->readMapBegin(_ktype613, _vtype614, _size612);
            uint32_t _i616;
            for (_i616 = 0; _i616 < _size612; ++_i616)
            {
              std::string _key617;
              xfer += iprot->readString(_key617);
              int64_t& _val618 = this->original_size[_key617];
              xfer += iprot->readI64(_val618);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.original_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->backup_size.clear();
            uint32_t _size619;
            ::apache::thrift::protocol::TType _ktype620;
            ::apache::thrift::protocol::TType _vtype621;
            xfer += iprot->readMapBegin(_ktype620, _vtype621, _size619);
            uint32_t _i623;
            for (_i623 = 0; _i623 < _size619; ++_i623)
            {
              std::string _key624;
              xfer += iprot->readString(_key624);
              int64_t& _val625 = this->backup_size[_key624];
              xfer += iprot->readI64(_val625);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.backup_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->backup_progress.clear();
            uint32_t _size626;
            ::apache::thrift::protocol::TType _ktype627;
            ::apache::thrift::protocol::TType _vtype628;
            xfer += iprot->readMapBegin(_ktype627, _vtype628, _size626);
            uint32_t _i630;
            for (_i630 = 0; _i630 < _size626; ++_i630)
            {
              std::string _key631;
              xfer += iprot->readString(_key631);
              int64_t& _val632 = this->backup_progress[_key631];
              xfer += iprot->readI64(_val632);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.backup_progress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->backup_image_offset.clear();
            uint32_t _size633;
            ::apache::thrift::protocol::TType _ktype634;
            ::apache::thrift::protocol::TType _vtype635;
            xfer += iprot->readMapBegin(_ktype634, _vtype635, _size633);
            uint32_t _i637;
            for (_i637 = 0; _i637 < _size633; ++_i637)
            {
              std::string _key638;
              xfer += iprot->readString(_key638);
              int64_t& _val639 = this->backup_image_offset[_key638];
              xfer += iprot->readI64(_val639);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.backup_image_offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->vcbt_journals.clear();
            uint32_t _size640;
            ::apache::thrift::protocol::TType _ktype641;
            ::apache::thrift::protocol::TType _vtype642;
            xfer += iprot->readMapBegin(_ktype641, _vtype642, _size640);
            uint32_t _i644;
            for (_i644 = 0; _i644 < _size640; ++_i644)
            {
              int64_t _key645;
              xfer += iprot->readI64(_key645);
              physical_vcbt_journal& _val646 = this->vcbt_journals[_key645];
              xfer += _val646.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.vcbt_journals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast647;
          xfer += iprot->readI32(ecast647);
          this->guest_os_type = (hv_guest_os_type::type)ecast647;
          this->__isset.guest_os_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->cdr_changed_ranges.clear();
            uint32_t _size648;
            ::apache::thrift::protocol::TType _ktype649;
            ::apache::thrift::protocol::TType _vtype650;
            xfer += iprot->readMapBegin(_ktype649, _vtype650, _size648);
            uint32_t _i652;
            for (_i652 = 0; _i652 < _size648; ++_i652)
            {
              std::string _key653;
              xfer += iprot->readString(_key653);
              std::vector<io_changed_range> & _val654 = this->cdr_changed_ranges[_key653];
              {
                _val654.clear();
                uint32_t _size655;
                ::apache::thrift::protocol::TType _etype658;
                xfer += iprot->readListBegin(_etype658, _size655);
                _val654.resize(_size655);
                uint32_t _i659;
                for (_i659 = 0; _i659 < _size655; ++_i659)
                {
                  xfer += _val654[_i659].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.cdr_changed_ranges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->completed_blocks.clear();
            uint32_t _size660;
            ::apache::thrift::protocol::TType _ktype661;
            ::apache::thrift::protocol::TType _vtype662;
            xfer += iprot->readMapBegin(_ktype661, _vtype662, _size660);
            uint32_t _i664;
            for (_i664 = 0; _i664 < _size660; ++_i664)
            {
              std::string _key665;
              xfer += iprot->readString(_key665);
              std::vector<io_changed_range> & _val666 = this->completed_blocks[_key665];
              {
                _val666.clear();
                uint32_t _size667;
                ::apache::thrift::protocol::TType _etype670;
                xfer += iprot->readListBegin(_etype670, _size667);
                _val666.resize(_size667);
                uint32_t _i671;
                for (_i671 = 0; _i671 < _size667; ++_i671)
                {
                  xfer += _val666[_i671].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.completed_blocks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_job_detail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_job_detail");

  if (this->__isset.original_size) {
    xfer += oprot->writeFieldBegin("original_size", ::apache::thrift::protocol::T_MAP, 1);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->original_size.size()));
      std::map<std::string, int64_t> ::const_iterator _iter672;
      for (_iter672 = this->original_size.begin(); _iter672 != this->original_size.end(); ++_iter672)
      {
        xfer += oprot->writeString(_iter672->first);
        xfer += oprot->writeI64(_iter672->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.backup_size) {
    xfer += oprot->writeFieldBegin("backup_size", ::apache::thrift::protocol::T_MAP, 2);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->backup_size.size()));
      std::map<std::string, int64_t> ::const_iterator _iter673;
      for (_iter673 = this->backup_size.begin(); _iter673 != this->backup_size.end(); ++_iter673)
      {
        xfer += oprot->writeString(_iter673->first);
        xfer += oprot->writeI64(_iter673->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.backup_progress) {
    xfer += oprot->writeFieldBegin("backup_progress", ::apache::thrift::protocol::T_MAP, 3);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->backup_progress.size()));
      std::map<std::string, int64_t> ::const_iterator _iter674;
      for (_iter674 = this->backup_progress.begin(); _iter674 != this->backup_progress.end(); ++_iter674)
      {
        xfer += oprot->writeString(_iter674->first);
        xfer += oprot->writeI64(_iter674->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.backup_image_offset) {
    xfer += oprot->writeFieldBegin("backup_image_offset", ::apache::thrift::protocol::T_MAP, 4);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->backup_image_offset.size()));
      std::map<std::string, int64_t> ::const_iterator _iter675;
      for (_iter675 = this->backup_image_offset.begin(); _iter675 != this->backup_image_offset.end(); ++_iter675)
      {
        xfer += oprot->writeString(_iter675->first);
        xfer += oprot->writeI64(_iter675->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vcbt_journals) {
    xfer += oprot->writeFieldBegin("vcbt_journals", ::apache::thrift::protocol::T_MAP, 5);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I64, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->vcbt_journals.size()));
      std::map<int64_t, physical_vcbt_journal> ::const_iterator _iter676;
      for (_iter676 = this->vcbt_journals.begin(); _iter676 != this->vcbt_journals.end(); ++_iter676)
      {
        xfer += oprot->writeI64(_iter676->first);
        xfer += _iter676->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.guest_os_type) {
    xfer += oprot->writeFieldBegin("guest_os_type", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32((int32_t)this->guest_os_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cdr_changed_ranges) {
    xfer += oprot->writeFieldBegin("cdr_changed_ranges", ::apache::thrift::protocol::T_MAP, 7);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->cdr_changed_ranges.size()));
      std::map<std::string, std::vector<io_changed_range> > ::const_iterator _iter677;
      for (_iter677 = this->cdr_changed_ranges.begin(); _iter677 != this->cdr_changed_ranges.end(); ++_iter677)
      {
        xfer += oprot->writeString(_iter677->first);
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter677->second.size()));
          std::vector<io_changed_range> ::const_iterator _iter678;
          for (_iter678 = _iter677->second.begin(); _iter678 != _iter677->second.end(); ++_iter678)
          {
            xfer += (*_iter678).write(oprot);
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.completed_blocks) {
    xfer += oprot->writeFieldBegin("completed_blocks", ::apache::thrift::protocol::T_MAP, 8);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->completed_blocks.size()));
      std::map<std::string, std::vector<io_changed_range> > ::const_iterator _iter679;
      for (_iter679 = this->completed_blocks.begin(); _iter679 != this->completed_blocks.end(); ++_iter679)
      {
        xfer += oprot->writeString(_iter679->first);
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter679->second.size()));
          std::vector<io_changed_range> ::const_iterator _iter680;
          for (_iter680 = _iter679->second.begin(); _iter680 != _iter679->second.end(); ++_iter680)
          {
            xfer += (*_iter680).write(oprot);
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(physical_packer_job_detail &a, physical_packer_job_detail &b) {
  using ::std::swap;
  swap(a.original_size, b.original_size);
  swap(a.backup_size, b.backup_size);
  swap(a.backup_progress, b.backup_progress);
  swap(a.backup_image_offset, b.backup_image_offset);
  swap(a.vcbt_journals, b.vcbt_journals);
  swap(a.guest_os_type, b.guest_os_type);
  swap(a.cdr_changed_ranges, b.cdr_changed_ranges);
  swap(a.completed_blocks, b.completed_blocks);
  swap(a.__isset, b.__isset);
}

physical_packer_job_detail::physical_packer_job_detail(const physical_packer_job_detail& other681) {
  original_size = other681.original_size;
  backup_size = other681.backup_size;
  backup_progress = other681.backup_progress;
  backup_image_offset = other681.backup_image_offset;
  vcbt_journals = other681.vcbt_journals;
  guest_os_type = other681.guest_os_type;
  cdr_changed_ranges = other681.cdr_changed_ranges;
  completed_blocks = other681.completed_blocks;
  __isset = other681.__isset;
}
physical_packer_job_detail& physical_packer_job_detail::operator=(const physical_packer_job_detail& other682) {
  original_size = other682.original_size;
  backup_size = other682.backup_size;
  backup_progress = other682.backup_progress;
  backup_image_offset = other682.backup_image_offset;
  vcbt_journals = other682.vcbt_journals;
  guest_os_type = other682.guest_os_type;
  cdr_changed_ranges = other682.cdr_changed_ranges;
  completed_blocks = other682.completed_blocks;
  __isset = other682.__isset;
  return *this;
}
void physical_packer_job_detail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "physical_packer_job_detail(";
  out << "original_size="; (__isset.original_size ? (out << to_string(original_size)) : (out << "<null>"));
  out << ", " << "backup_size="; (__isset.backup_size ? (out << to_string(backup_size)) : (out << "<null>"));
  out << ", " << "backup_progress="; (__isset.backup_progress ? (out << to_string(backup_progress)) : (out << "<null>"));
  out << ", " << "backup_image_offset="; (__isset.backup_image_offset ? (out << to_string(backup_image_offset)) : (out << "<null>"));
  out << ", " << "vcbt_journals="; (__isset.vcbt_journals ? (out << to_string(vcbt_journals)) : (out << "<null>"));
  out << ", " << "guest_os_type="; (__isset.guest_os_type ? (out << to_string(guest_os_type)) : (out << "<null>"));
  out << ", " << "cdr_changed_ranges="; (__isset.cdr_changed_ranges ? (out << to_string(cdr_changed_ranges)) : (out << "<null>"));
  out << ", " << "completed_blocks="; (__isset.completed_blocks ? (out << to_string(completed_blocks)) : (out << "<null>"));
  out << ")";
}


_packer_job_detail::~_packer_job_detail() throw() {
}


void _packer_job_detail::__set_p(const physical_packer_job_detail& val) {
  this->p = val;
__isset.p = true;
}

void _packer_job_detail::__set_v(const virtual_packer_job_detail& val) {
  this->v = val;
__isset.v = true;
}
std::ostream& operator<<(std::ostream& out, const _packer_job_detail& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t _packer_job_detail::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->p.read(iprot);
          this->__isset.p = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->v.read(iprot);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t _packer_job_detail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("_packer_job_detail");

  if (this->__isset.p) {
    xfer += oprot->writeFieldBegin("p", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->p.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.v) {
    xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->v.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(_packer_job_detail &a, _packer_job_detail &b) {
  using ::std::swap;
  swap(a.p, b.p);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

_packer_job_detail::_packer_job_detail(const _packer_job_detail& other683) {
  p = other683.p;
  v = other683.v;
  __isset = other683.__isset;
}
_packer_job_detail& _packer_job_detail::operator=(const _packer_job_detail& other684) {
  p = other684.p;
  v = other684.v;
  __isset = other684.__isset;
  return *this;
}
void _packer_job_detail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "_packer_job_detail(";
  out << "p="; (__isset.p ? (out << to_string(p)) : (out << "<null>"));
  out << ", " << "v="; (__isset.v ? (out << to_string(v)) : (out << "<null>"));
  out << ")";
}


packer_job_detail::~packer_job_detail() throw() {
}


void packer_job_detail::__set_id(const std::string& val) {
  this->id = val;
__isset.id = true;
}

void packer_job_detail::__set_type(const job_type::type val) {
  this->type = val;
__isset.type = true;
}

void packer_job_detail::__set_state(const job_state::type val) {
  this->state = val;
__isset.state = true;
}

void packer_job_detail::__set_created_time(const std::string& val) {
  this->created_time = val;
__isset.created_time = true;
}

void packer_job_detail::__set_updated_time(const std::string& val) {
  this->updated_time = val;
__isset.updated_time = true;
}

void packer_job_detail::__set_histories(const std::vector<job_history> & val) {
  this->histories = val;
__isset.histories = true;
}

void packer_job_detail::__set_detail(const _packer_job_detail& val) {
  this->detail = val;
__isset.detail = true;
}

void packer_job_detail::__set_is_error(const bool val) {
  this->is_error = val;
__isset.is_error = true;
}

void packer_job_detail::__set_boot_disk(const std::string& val) {
  this->boot_disk = val;
__isset.boot_disk = true;
}

void packer_job_detail::__set_system_disks(const std::vector<std::string> & val) {
  this->system_disks = val;
__isset.system_disks = true;
}

void packer_job_detail::__set_completed_blocks(const std::map<std::string, std::vector<io_changed_range> > & val) {
  this->completed_blocks = val;
__isset.completed_blocks = true;
}
std::ostream& operator<<(std::ostream& out, const packer_job_detail& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t packer_job_detail::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast685;
          xfer += iprot->readI32(ecast685);
          this->type = (job_type::type)ecast685;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast686;
          xfer += iprot->readI32(ecast686);
          this->state = (job_state::type)ecast686;
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->created_time);
          this->__isset.created_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->updated_time);
          this->__isset.updated_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->histories.clear();
            uint32_t _size687;
            ::apache::thrift::protocol::TType _etype690;
            xfer += iprot->readListBegin(_etype690, _size687);
            this->histories.resize(_size687);
            uint32_t _i691;
            for (_i691 = 0; _i691 < _size687; ++_i691)
            {
              xfer += this->histories[_i691].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.histories = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->detail.read(iprot);
          this->__isset.detail = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_error);
          this->__isset.is_error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->boot_disk);
          this->__isset.boot_disk = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->system_disks.clear();
            uint32_t _size692;
            ::apache::thrift::protocol::TType _etype695;
            xfer += iprot->readListBegin(_etype695, _size692);
            this->system_disks.resize(_size692);
            uint32_t _i696;
            for (_i696 = 0; _i696 < _size692; ++_i696)
            {
              xfer += iprot->readString(this->system_disks[_i696]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.system_disks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->completed_blocks.clear();
            uint32_t _size697;
            ::apache::thrift::protocol::TType _ktype698;
            ::apache::thrift::protocol::TType _vtype699;
            xfer += iprot->readMapBegin(_ktype698, _vtype699, _size697);
            uint32_t _i701;
            for (_i701 = 0; _i701 < _size697; ++_i701)
            {
              std::string _key702;
              xfer += iprot->readString(_key702);
              std::vector<io_changed_range> & _val703 = this->completed_blocks[_key702];
              {
                _val703.clear();
                uint32_t _size704;
                ::apache::thrift::protocol::TType _etype707;
                xfer += iprot->readListBegin(_etype707, _size704);
                _val703.resize(_size704);
                uint32_t _i708;
                for (_i708 = 0; _i708 < _size704; ++_i708)
                {
                  xfer += _val703[_i708].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.completed_blocks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t packer_job_detail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("packer_job_detail");

  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.type) {
    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32((int32_t)this->type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.state) {
    xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32((int32_t)this->state);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.created_time) {
    xfer += oprot->writeFieldBegin("created_time", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->created_time);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.updated_time) {
    xfer += oprot->writeFieldBegin("updated_time", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->updated_time);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.histories) {
    xfer += oprot->writeFieldBegin("histories", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->histories.size()));
      std::vector<job_history> ::const_iterator _iter709;
      for (_iter709 = this->histories.begin(); _iter709 != this->histories.end(); ++_iter709)
      {
        xfer += (*_iter709).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.detail) {
    xfer += oprot->writeFieldBegin("detail", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->detail.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_error) {
    xfer += oprot->writeFieldBegin("is_error", ::apache::thrift::protocol::T_BOOL, 8);
    xfer += oprot->writeBool(this->is_error);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.boot_disk) {
    xfer += oprot->writeFieldBegin("boot_disk", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->boot_disk);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.system_disks) {
    xfer += oprot->writeFieldBegin("system_disks", ::apache::thrift::protocol::T_LIST, 10);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->system_disks.size()));
      std::vector<std::string> ::const_iterator _iter710;
      for (_iter710 = this->system_disks.begin(); _iter710 != this->system_disks.end(); ++_iter710)
      {
        xfer += oprot->writeString((*_iter710));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.completed_blocks) {
    xfer += oprot->writeFieldBegin("completed_blocks", ::apache::thrift::protocol::T_MAP, 11);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->completed_blocks.size()));
      std::map<std::string, std::vector<io_changed_range> > ::const_iterator _iter711;
      for (_iter711 = this->completed_blocks.begin(); _iter711 != this->completed_blocks.end(); ++_iter711)
      {
        xfer += oprot->writeString(_iter711->first);
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter711->second.size()));
          std::vector<io_changed_range> ::const_iterator _iter712;
          for (_iter712 = _iter711->second.begin(); _iter712 != _iter711->second.end(); ++_iter712)
          {
            xfer += (*_iter712).write(oprot);
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(packer_job_detail &a, packer_job_detail &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.type, b.type);
  swap(a.state, b.state);
  swap(a.created_time, b.created_time);
  swap(a.updated_time, b.updated_time);
  swap(a.histories, b.histories);
  swap(a.detail, b.detail);
  swap(a.is_error, b.is_error);
  swap(a.boot_disk, b.boot_disk);
  swap(a.system_disks, b.system_disks);
  swap(a.completed_blocks, b.completed_blocks);
  swap(a.__isset, b.__isset);
}

packer_job_detail::packer_job_detail(const packer_job_detail& other713) {
  id = other713.id;
  type = other713.type;
  state = other713.state;
  created_time = other713.created_time;
  updated_time = other713.updated_time;
  histories = other713.histories;
  detail = other713.detail;
  is_error = other713.is_error;
  boot_disk = other713.boot_disk;
  system_disks = other713.system_disks;
  completed_blocks = other713.completed_blocks;
  __isset = other713.__isset;
}
packer_job_detail& packer_job_detail::operator=(const packer_job_detail& other714) {
  id = other714.id;
  type = other714.type;
  state = other714.state;
  created_time = other714.created_time;
  updated_time = other714.updated_time;
  histories = other714.histories;
  detail = other714.detail;
  is_error = other714.is_error;
  boot_disk = other714.boot_disk;
  system_disks = other714.system_disks;
  completed_blocks = other714.completed_blocks;
  __isset = other714.__isset;
  return *this;
}
void packer_job_detail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "packer_job_detail(";
  out << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "type="; (__isset.type ? (out << to_string(type)) : (out << "<null>"));
  out << ", " << "state="; (__isset.state ? (out << to_string(state)) : (out << "<null>"));
  out << ", " << "created_time="; (__isset.created_time ? (out << to_string(created_time)) : (out << "<null>"));
  out << ", " << "updated_time="; (__isset.updated_time ? (out << to_string(updated_time)) : (out << "<null>"));
  out << ", " << "histories="; (__isset.histories ? (out << to_string(histories)) : (out << "<null>"));
  out << ", " << "detail="; (__isset.detail ? (out << to_string(detail)) : (out << "<null>"));
  out << ", " << "is_error="; (__isset.is_error ? (out << to_string(is_error)) : (out << "<null>"));
  out << ", " << "boot_disk="; (__isset.boot_disk ? (out << to_string(boot_disk)) : (out << "<null>"));
  out << ", " << "system_disks="; (__isset.system_disks ? (out << to_string(system_disks)) : (out << "<null>"));
  out << ", " << "completed_blocks="; (__isset.completed_blocks ? (out << to_string(completed_blocks)) : (out << "<null>"));
  out << ")";
}


replica_job_detail::~replica_job_detail() throw() {
}


void replica_job_detail::__set_replica_id(const std::string& val) {
  this->replica_id = val;
__isset.replica_id = true;
}

void replica_job_detail::__set_host(const std::string& val) {
  this->host = val;
__isset.host = true;
}

void replica_job_detail::__set_id(const std::string& val) {
  this->id = val;
__isset.id = true;
}

void replica_job_detail::__set_type(const job_type::type val) {
  this->type = val;
__isset.type = true;
}

void replica_job_detail::__set_state(const job_state::type val) {
  this->state = val;
__isset.state = true;
}

void replica_job_detail::__set_is_error(const bool val) {
  this->is_error = val;
__isset.is_error = true;
}

void replica_job_detail::__set_created_time(const std::string& val) {
  this->created_time = val;
__isset.created_time = true;
}

void replica_job_detail::__set_updated_time(const std::string& val) {
  this->updated_time = val;
__isset.updated_time = true;
}

void replica_job_detail::__set_virtual_machine_id(const std::string& val) {
  this->virtual_machine_id = val;
__isset.virtual_machine_id = true;
}

void replica_job_detail::__set_disks(const std::set<std::string> & val) {
  this->disks = val;
__isset.disks = true;
}

void replica_job_detail::__set_connection_id(const std::string& val) {
  this->connection_id = val;
__isset.connection_id = true;
}

void replica_job_detail::__set_original_size(const std::map<std::string, int64_t> & val) {
  this->original_size = val;
__isset.original_size = true;
}

void replica_job_detail::__set_backup_progress(const std::map<std::string, int64_t> & val) {
  this->backup_progress = val;
__isset.backup_progress = true;
}

void replica_job_detail::__set_snapshot_mapping(const std::map<std::string, std::string> & val) {
  this->snapshot_mapping = val;
__isset.snapshot_mapping = true;
}

void replica_job_detail::__set_backup_size(const std::map<std::string, int64_t> & val) {
  this->backup_size = val;
__isset.backup_size = true;
}

void replica_job_detail::__set_backup_image_offset(const std::map<std::string, int64_t> & val) {
  this->backup_image_offset = val;
__isset.backup_image_offset = true;
}

void replica_job_detail::__set_cbt_info(const std::string& val) {
  this->cbt_info = val;
__isset.cbt_info = true;
}

void replica_job_detail::__set_histories(const std::vector<job_history> & val) {
  this->histories = val;
__isset.histories = true;
}

void replica_job_detail::__set_snapshot_time(const std::string& val) {
  this->snapshot_time = val;
__isset.snapshot_time = true;
}

void replica_job_detail::__set_snapshot_info(const std::string& val) {
  this->snapshot_info = val;
__isset.snapshot_info = true;
}

void replica_job_detail::__set_boot_disk(const std::string& val) {
  this->boot_disk = val;
__isset.boot_disk = true;
}

void replica_job_detail::__set_system_disks(const std::vector<std::string> & val) {
  this->system_disks = val;
__isset.system_disks = true;
}

void replica_job_detail::__set_is_pending_rerun(const bool val) {
  this->is_pending_rerun = val;
__isset.is_pending_rerun = true;
}

void replica_job_detail::__set_is_cdr(const bool val) {
  this->is_cdr = val;
__isset.is_cdr = true;
}

void replica_job_detail::__set_virtual_disk_infos(const std::vector<virtual_disk_info_ex> & val) {
  this->virtual_disk_infos = val;
__isset.virtual_disk_infos = true;
}

void replica_job_detail::__set_excluded_paths(const std::set<std::string> & val) {
  this->excluded_paths = val;
__isset.excluded_paths = true;
}
std::ostream& operator<<(std::ostream& out, const replica_job_detail& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t replica_job_detail::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->replica_id);
          this->__isset.replica_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host);
          this->__isset.host = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast715;
          xfer += iprot->readI32(ecast715);
          this->type = (job_type::type)ecast715;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast716;
          xfer += iprot->readI32(ecast716);
          this->state = (job_state::type)ecast716;
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_error);
          this->__isset.is_error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->created_time);
          this->__isset.created_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->updated_time);
          this->__isset.updated_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->virtual_machine_id);
          this->__isset.virtual_machine_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->disks.clear();
            uint32_t _size717;
            ::apache::thrift::protocol::TType _etype720;
            xfer += iprot->readSetBegin(_etype720, _size717);
            uint32_t _i721;
            for (_i721 = 0; _i721 < _size717; ++_i721)
            {
              std::string _elem722;
              xfer += iprot->readString(_elem722);
              this->disks.insert(_elem722);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.disks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->connection_id);
          this->__isset.connection_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->original_size.clear();
            uint32_t _size723;
            ::apache::thrift::protocol::TType _ktype724;
            ::apache::thrift::protocol::TType _vtype725;
            xfer += iprot->readMapBegin(_ktype724, _vtype725, _size723);
            uint32_t _i727;
            for (_i727 = 0; _i727 < _size723; ++_i727)
            {
              std::string _key728;
              xfer += iprot->readString(_key728);
              int64_t& _val729 = this->original_size[_key728];
              xfer += iprot->readI64(_val729);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.original_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->backup_progress.clear();
            uint32_t _size730;
            ::apache::thrift::protocol::TType _ktype731;
            ::apache::thrift::protocol::TType _vtype732;
            xfer += iprot->readMapBegin(_ktype731, _vtype732, _size730);
            uint32_t _i734;
            for (_i734 = 0; _i734 < _size730; ++_i734)
            {
              std::string _key735;
              xfer += iprot->readString(_key735);
              int64_t& _val736 = this->backup_progress[_key735];
              xfer += iprot->readI64(_val736);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.backup_progress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->snapshot_mapping.clear();
            uint32_t _size737;
            ::apache::thrift::protocol::TType _ktype738;
            ::apache::thrift::protocol::TType _vtype739;
            xfer += iprot->readMapBegin(_ktype738, _vtype739, _size737);
            uint32_t _i741;
            for (_i741 = 0; _i741 < _size737; ++_i741)
            {
              std::string _key742;
              xfer += iprot->readString(_key742);
              std::string& _val743 = this->snapshot_mapping[_key742];
              xfer += iprot->readString(_val743);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.snapshot_mapping = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->backup_size.clear();
            uint32_t _size744;
            ::apache::thrift::protocol::TType _ktype745;
            ::apache::thrift::protocol::TType _vtype746;
            xfer += iprot->readMapBegin(_ktype745, _vtype746, _size744);
            uint32_t _i748;
            for (_i748 = 0; _i748 < _size744; ++_i748)
            {
              std::string _key749;
              xfer += iprot->readString(_key749);
              int64_t& _val750 = this->backup_size[_key749];
              xfer += iprot->readI64(_val750);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.backup_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->backup_image_offset.clear();
            uint32_t _size751;
            ::apache::thrift::protocol::TType _ktype752;
            ::apache::thrift::protocol::TType _vtype753;
            xfer += iprot->readMapBegin(_ktype752, _vtype753, _size751);
            uint32_t _i755;
            for (_i755 = 0; _i755 < _size751; ++_i755)
            {
              std::string _key756;
              xfer += iprot->readString(_key756);
              int64_t& _val757 = this->backup_image_offset[_key756];
              xfer += iprot->readI64(_val757);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.backup_image_offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cbt_info);
          this->__isset.cbt_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->histories.clear();
            uint32_t _size758;
            ::apache::thrift::protocol::TType _etype761;
            xfer += iprot->readListBegin(_etype761, _size758);
            this->histories.resize(_size758);
            uint32_t _i762;
            for (_i762 = 0; _i762 < _size758; ++_i762)
            {
              xfer += this->histories[_i762].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.histories = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->snapshot_time);
          this->__isset.snapshot_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->snapshot_info);
          this->__isset.snapshot_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->boot_disk);
          this->__isset.boot_disk = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->system_disks.clear();
            uint32_t _size763;
            ::apache::thrift::protocol::TType _etype766;
            xfer += iprot->readListBegin(_etype766, _size763);
            this->system_disks.resize(_size763);
            uint32_t _i767;
            for (_i767 = 0; _i767 < _size763; ++_i767)
            {
              xfer += iprot->readString(this->system_disks[_i767]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.system_disks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_pending_rerun);
          this->__isset.is_pending_rerun = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_cdr);
          this->__isset.is_cdr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->virtual_disk_infos.clear();
            uint32_t _size768;
            ::apache::thrift::protocol::TType _etype771;
            xfer += iprot->readListBegin(_etype771, _size768);
            this->virtual_disk_infos.resize(_size768);
            uint32_t _i772;
            for (_i772 = 0; _i772 < _size768; ++_i772)
            {
              xfer += this->virtual_disk_infos[_i772].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.virtual_disk_infos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 26:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->excluded_paths.clear();
            uint32_t _size773;
            ::apache::thrift::protocol::TType _etype776;
            xfer += iprot->readSetBegin(_etype776, _size773);
            uint32_t _i777;
            for (_i777 = 0; _i777 < _size773; ++_i777)
            {
              std::string _elem778;
              xfer += iprot->readString(_elem778);
              this->excluded_paths.insert(_elem778);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.excluded_paths = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t replica_job_detail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("replica_job_detail");

  if (this->__isset.replica_id) {
    xfer += oprot->writeFieldBegin("replica_id", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->replica_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.host) {
    xfer += oprot->writeFieldBegin("host", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->host);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.type) {
    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32((int32_t)this->type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.state) {
    xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32((int32_t)this->state);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_error) {
    xfer += oprot->writeFieldBegin("is_error", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->is_error);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.created_time) {
    xfer += oprot->writeFieldBegin("created_time", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->created_time);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.updated_time) {
    xfer += oprot->writeFieldBegin("updated_time", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->updated_time);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.virtual_machine_id) {
    xfer += oprot->writeFieldBegin("virtual_machine_id", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->virtual_machine_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.disks) {
    xfer += oprot->writeFieldBegin("disks", ::apache::thrift::protocol::T_SET, 10);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->disks.size()));
      std::set<std::string> ::const_iterator _iter779;
      for (_iter779 = this->disks.begin(); _iter779 != this->disks.end(); ++_iter779)
      {
        xfer += oprot->writeString((*_iter779));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.connection_id) {
    xfer += oprot->writeFieldBegin("connection_id", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeString(this->connection_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.original_size) {
    xfer += oprot->writeFieldBegin("original_size", ::apache::thrift::protocol::T_MAP, 12);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->original_size.size()));
      std::map<std::string, int64_t> ::const_iterator _iter780;
      for (_iter780 = this->original_size.begin(); _iter780 != this->original_size.end(); ++_iter780)
      {
        xfer += oprot->writeString(_iter780->first);
        xfer += oprot->writeI64(_iter780->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.backup_progress) {
    xfer += oprot->writeFieldBegin("backup_progress", ::apache::thrift::protocol::T_MAP, 13);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->backup_progress.size()));
      std::map<std::string, int64_t> ::const_iterator _iter781;
      for (_iter781 = this->backup_progress.begin(); _iter781 != this->backup_progress.end(); ++_iter781)
      {
        xfer += oprot->writeString(_iter781->first);
        xfer += oprot->writeI64(_iter781->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.snapshot_mapping) {
    xfer += oprot->writeFieldBegin("snapshot_mapping", ::apache::thrift::protocol::T_MAP, 14);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->snapshot_mapping.size()));
      std::map<std::string, std::string> ::const_iterator _iter782;
      for (_iter782 = this->snapshot_mapping.begin(); _iter782 != this->snapshot_mapping.end(); ++_iter782)
      {
        xfer += oprot->writeString(_iter782->first);
        xfer += oprot->writeString(_iter782->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.backup_size) {
    xfer += oprot->writeFieldBegin("backup_size", ::apache::thrift::protocol::T_MAP, 15);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->backup_size.size()));
      std::map<std::string, int64_t> ::const_iterator _iter783;
      for (_iter783 = this->backup_size.begin(); _iter783 != this->backup_size.end(); ++_iter783)
      {
        xfer += oprot->writeString(_iter783->first);
        xfer += oprot->writeI64(_iter783->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.backup_image_offset) {
    xfer += oprot->writeFieldBegin("backup_image_offset", ::apache::thrift::protocol::T_MAP, 16);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->backup_image_offset.size()));
      std::map<std::string, int64_t> ::const_iterator _iter784;
      for (_iter784 = this->backup_image_offset.begin(); _iter784 != this->backup_image_offset.end(); ++_iter784)
      {
        xfer += oprot->writeString(_iter784->first);
        xfer += oprot->writeI64(_iter784->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cbt_info) {
    xfer += oprot->writeFieldBegin("cbt_info", ::apache::thrift::protocol::T_STRING, 17);
    xfer += oprot->writeString(this->cbt_info);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.histories) {
    xfer += oprot->writeFieldBegin("histories", ::apache::thrift::protocol::T_LIST, 18);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->histories.size()));
      std::vector<job_history> ::const_iterator _iter785;
      for (_iter785 = this->histories.begin(); _iter785 != this->histories.end(); ++_iter785)
      {
        xfer += (*_iter785).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.snapshot_time) {
    xfer += oprot->writeFieldBegin("snapshot_time", ::apache::thrift::protocol::T_STRING, 19);
    xfer += oprot->writeString(this->snapshot_time);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.snapshot_info) {
    xfer += oprot->writeFieldBegin("snapshot_info", ::apache::thrift::protocol::T_STRING, 20);
    xfer += oprot->writeString(this->snapshot_info);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.boot_disk) {
    xfer += oprot->writeFieldBegin("boot_disk", ::apache::thrift::protocol::T_STRING, 21);
    xfer += oprot->writeString(this->boot_disk);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.system_disks) {
    xfer += oprot->writeFieldBegin("system_disks", ::apache::thrift::protocol::T_LIST, 22);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->system_disks.size()));
      std::vector<std::string> ::const_iterator _iter786;
      for (_iter786 = this->system_disks.begin(); _iter786 != this->system_disks.end(); ++_iter786)
      {
        xfer += oprot->writeString((*_iter786));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_pending_rerun) {
    xfer += oprot->writeFieldBegin("is_pending_rerun", ::apache::thrift::protocol::T_BOOL, 23);
    xfer += oprot->writeBool(this->is_pending_rerun);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_cdr) {
    xfer += oprot->writeFieldBegin("is_cdr", ::apache::thrift::protocol::T_BOOL, 24);
    xfer += oprot->writeBool(this->is_cdr);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.virtual_disk_infos) {
    xfer += oprot->writeFieldBegin("virtual_disk_infos", ::apache::thrift::protocol::T_LIST, 25);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->virtual_disk_infos.size()));
      std::vector<virtual_disk_info_ex> ::const_iterator _iter787;
      for (_iter787 = this->virtual_disk_infos.begin(); _iter787 != this->virtual_disk_infos.end(); ++_iter787)
      {
        xfer += (*_iter787).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.excluded_paths) {
    xfer += oprot->writeFieldBegin("excluded_paths", ::apache::thrift::protocol::T_SET, 26);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->excluded_paths.size()));
      std::set<std::string> ::const_iterator _iter788;
      for (_iter788 = this->excluded_paths.begin(); _iter788 != this->excluded_paths.end(); ++_iter788)
      {
        xfer += oprot->writeString((*_iter788));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(replica_job_detail &a, replica_job_detail &b) {
  using ::std::swap;
  swap(a.replica_id, b.replica_id);
  swap(a.host, b.host);
  swap(a.id, b.id);
  swap(a.type, b.type);
  swap(a.state, b.state);
  swap(a.is_error, b.is_error);
  swap(a.created_time, b.created_time);
  swap(a.updated_time, b.updated_time);
  swap(a.virtual_machine_id, b.virtual_machine_id);
  swap(a.disks, b.disks);
  swap(a.connection_id, b.connection_id);
  swap(a.original_size, b.original_size);
  swap(a.backup_progress, b.backup_progress);
  swap(a.snapshot_mapping, b.snapshot_mapping);
  swap(a.backup_size, b.backup_size);
  swap(a.backup_image_offset, b.backup_image_offset);
  swap(a.cbt_info, b.cbt_info);
  swap(a.histories, b.histories);
  swap(a.snapshot_time, b.snapshot_time);
  swap(a.snapshot_info, b.snapshot_info);
  swap(a.boot_disk, b.boot_disk);
  swap(a.system_disks, b.system_disks);
  swap(a.is_pending_rerun, b.is_pending_rerun);
  swap(a.is_cdr, b.is_cdr);
  swap(a.virtual_disk_infos, b.virtual_disk_infos);
  swap(a.excluded_paths, b.excluded_paths);
  swap(a.__isset, b.__isset);
}

replica_job_detail::replica_job_detail(const replica_job_detail& other789) {
  replica_id = other789.replica_id;
  host = other789.host;
  id = other789.id;
  type = other789.type;
  state = other789.state;
  is_error = other789.is_error;
  created_time = other789.created_time;
  updated_time = other789.updated_time;
  virtual_machine_id = other789.virtual_machine_id;
  disks = other789.disks;
  connection_id = other789.connection_id;
  original_size = other789.original_size;
  backup_progress = other789.backup_progress;
  snapshot_mapping = other789.snapshot_mapping;
  backup_size = other789.backup_size;
  backup_image_offset = other789.backup_image_offset;
  cbt_info = other789.cbt_info;
  histories = other789.histories;
  snapshot_time = other789.snapshot_time;
  snapshot_info = other789.snapshot_info;
  boot_disk = other789.boot_disk;
  system_disks = other789.system_disks;
  is_pending_rerun = other789.is_pending_rerun;
  is_cdr = other789.is_cdr;
  virtual_disk_infos = other789.virtual_disk_infos;
  excluded_paths = other789.excluded_paths;
  __isset = other789.__isset;
}
replica_job_detail& replica_job_detail::operator=(const replica_job_detail& other790) {
  replica_id = other790.replica_id;
  host = other790.host;
  id = other790.id;
  type = other790.type;
  state = other790.state;
  is_error = other790.is_error;
  created_time = other790.created_time;
  updated_time = other790.updated_time;
  virtual_machine_id = other790.virtual_machine_id;
  disks = other790.disks;
  connection_id = other790.connection_id;
  original_size = other790.original_size;
  backup_progress = other790.backup_progress;
  snapshot_mapping = other790.snapshot_mapping;
  backup_size = other790.backup_size;
  backup_image_offset = other790.backup_image_offset;
  cbt_info = other790.cbt_info;
  histories = other790.histories;
  snapshot_time = other790.snapshot_time;
  snapshot_info = other790.snapshot_info;
  boot_disk = other790.boot_disk;
  system_disks = other790.system_disks;
  is_pending_rerun = other790.is_pending_rerun;
  is_cdr = other790.is_cdr;
  virtual_disk_infos = other790.virtual_disk_infos;
  excluded_paths = other790.excluded_paths;
  __isset = other790.__isset;
  return *this;
}
void replica_job_detail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "replica_job_detail(";
  out << "replica_id="; (__isset.replica_id ? (out << to_string(replica_id)) : (out << "<null>"));
  out << ", " << "host="; (__isset.host ? (out << to_string(host)) : (out << "<null>"));
  out << ", " << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "type="; (__isset.type ? (out << to_string(type)) : (out << "<null>"));
  out << ", " << "state="; (__isset.state ? (out << to_string(state)) : (out << "<null>"));
  out << ", " << "is_error="; (__isset.is_error ? (out << to_string(is_error)) : (out << "<null>"));
  out << ", " << "created_time="; (__isset.created_time ? (out << to_string(created_time)) : (out << "<null>"));
  out << ", " << "updated_time="; (__isset.updated_time ? (out << to_string(updated_time)) : (out << "<null>"));
  out << ", " << "virtual_machine_id="; (__isset.virtual_machine_id ? (out << to_string(virtual_machine_id)) : (out << "<null>"));
  out << ", " << "disks="; (__isset.disks ? (out << to_string(disks)) : (out << "<null>"));
  out << ", " << "connection_id="; (__isset.connection_id ? (out << to_string(connection_id)) : (out << "<null>"));
  out << ", " << "original_size="; (__isset.original_size ? (out << to_string(original_size)) : (out << "<null>"));
  out << ", " << "backup_progress="; (__isset.backup_progress ? (out << to_string(backup_progress)) : (out << "<null>"));
  out << ", " << "snapshot_mapping="; (__isset.snapshot_mapping ? (out << to_string(snapshot_mapping)) : (out << "<null>"));
  out << ", " << "backup_size="; (__isset.backup_size ? (out << to_string(backup_size)) : (out << "<null>"));
  out << ", " << "backup_image_offset="; (__isset.backup_image_offset ? (out << to_string(backup_image_offset)) : (out << "<null>"));
  out << ", " << "cbt_info="; (__isset.cbt_info ? (out << to_string(cbt_info)) : (out << "<null>"));
  out << ", " << "histories="; (__isset.histories ? (out << to_string(histories)) : (out << "<null>"));
  out << ", " << "snapshot_time="; (__isset.snapshot_time ? (out << to_string(snapshot_time)) : (out << "<null>"));
  out << ", " << "snapshot_info="; (__isset.snapshot_info ? (out << to_string(snapshot_info)) : (out << "<null>"));
  out << ", " << "boot_disk="; (__isset.boot_disk ? (out << to_string(boot_disk)) : (out << "<null>"));
  out << ", " << "system_disks="; (__isset.system_disks ? (out << to_string(system_disks)) : (out << "<null>"));
  out << ", " << "is_pending_rerun="; (__isset.is_pending_rerun ? (out << to_string(is_pending_rerun)) : (out << "<null>"));
  out << ", " << "is_cdr="; (__isset.is_cdr ? (out << to_string(is_cdr)) : (out << "<null>"));
  out << ", " << "virtual_disk_infos="; (__isset.virtual_disk_infos ? (out << to_string(virtual_disk_infos)) : (out << "<null>"));
  out << ", " << "excluded_paths="; (__isset.excluded_paths ? (out << to_string(excluded_paths)) : (out << "<null>"));
  out << ")";
}


service_info::~service_info() throw() {
}


void service_info::__set_id(const std::string& val) {
  this->id = val;
}

void service_info::__set_version(const std::string& val) {
  this->version = val;
}

void service_info::__set_path(const std::string& val) {
  this->path = val;
}
std::ostream& operator<<(std::ostream& out, const service_info& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t service_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->path);
          this->__isset.path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t service_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("service_info");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(service_info &a, service_info &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.version, b.version);
  swap(a.path, b.path);
  swap(a.__isset, b.__isset);
}

service_info::service_info(const service_info& other791) {
  id = other791.id;
  version = other791.version;
  path = other791.path;
  __isset = other791.__isset;
}
service_info& service_info::operator=(const service_info& other792) {
  id = other792.id;
  version = other792.version;
  path = other792.path;
  __isset = other792.__isset;
  return *this;
}
void service_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "service_info(";
  out << "id=" << to_string(id);
  out << ", " << "version=" << to_string(version);
  out << ", " << "path=" << to_string(path);
  out << ")";
}


vmware_snapshot::~vmware_snapshot() throw() {
}


void vmware_snapshot::__set_id(const std::string& val) {
  this->id = val;
__isset.id = true;
}

void vmware_snapshot::__set_name(const std::string& val) {
  this->name = val;
__isset.name = true;
}

void vmware_snapshot::__set_datetime(const std::string& val) {
  this->datetime = val;
__isset.datetime = true;
}
std::ostream& operator<<(std::ostream& out, const vmware_snapshot& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t vmware_snapshot::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->datetime);
          this->__isset.datetime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t vmware_snapshot::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("vmware_snapshot");

  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.datetime) {
    xfer += oprot->writeFieldBegin("datetime", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->datetime);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(vmware_snapshot &a, vmware_snapshot &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.name, b.name);
  swap(a.datetime, b.datetime);
  swap(a.__isset, b.__isset);
}

vmware_snapshot::vmware_snapshot(const vmware_snapshot& other793) {
  id = other793.id;
  name = other793.name;
  datetime = other793.datetime;
  __isset = other793.__isset;
}
vmware_snapshot& vmware_snapshot::operator=(const vmware_snapshot& other794) {
  id = other794.id;
  name = other794.name;
  datetime = other794.datetime;
  __isset = other794.__isset;
  return *this;
}
void vmware_snapshot::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "vmware_snapshot(";
  out << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
  out << ", " << "datetime="; (__isset.datetime ? (out << to_string(datetime)) : (out << "<null>"));
  out << ")";
}


take_snapshots_parameters::~take_snapshots_parameters() throw() {
}


void take_snapshots_parameters::__set_disks(const std::set<std::string> & val) {
  this->disks = val;
}

void take_snapshots_parameters::__set_pre_script(const std::string& val) {
  this->pre_script = val;
}

void take_snapshots_parameters::__set_post_script(const std::string& val) {
  this->post_script = val;
}

void take_snapshots_parameters::__set_excluded_paths(const std::set<std::string> & val) {
  this->excluded_paths = val;
}
std::ostream& operator<<(std::ostream& out, const take_snapshots_parameters& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t take_snapshots_parameters::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->disks.clear();
            uint32_t _size795;
            ::apache::thrift::protocol::TType _etype798;
            xfer += iprot->readSetBegin(_etype798, _size795);
            uint32_t _i799;
            for (_i799 = 0; _i799 < _size795; ++_i799)
            {
              std::string _elem800;
              xfer += iprot->readString(_elem800);
              this->disks.insert(_elem800);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.disks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pre_script);
          this->__isset.pre_script = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->post_script);
          this->__isset.post_script = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->excluded_paths.clear();
            uint32_t _size801;
            ::apache::thrift::protocol::TType _etype804;
            xfer += iprot->readSetBegin(_etype804, _size801);
            uint32_t _i805;
            for (_i805 = 0; _i805 < _size801; ++_i805)
            {
              std::string _elem806;
              xfer += iprot->readString(_elem806);
              this->excluded_paths.insert(_elem806);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.excluded_paths = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t take_snapshots_parameters::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("take_snapshots_parameters");

  xfer += oprot->writeFieldBegin("disks", ::apache::thrift::protocol::T_SET, 1);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->disks.size()));
    std::set<std::string> ::const_iterator _iter807;
    for (_iter807 = this->disks.begin(); _iter807 != this->disks.end(); ++_iter807)
    {
      xfer += oprot->writeString((*_iter807));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pre_script", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->pre_script);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("post_script", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->post_script);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("excluded_paths", ::apache::thrift::protocol::T_SET, 4);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->excluded_paths.size()));
    std::set<std::string> ::const_iterator _iter808;
    for (_iter808 = this->excluded_paths.begin(); _iter808 != this->excluded_paths.end(); ++_iter808)
    {
      xfer += oprot->writeString((*_iter808));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(take_snapshots_parameters &a, take_snapshots_parameters &b) {
  using ::std::swap;
  swap(a.disks, b.disks);
  swap(a.pre_script, b.pre_script);
  swap(a.post_script, b.post_script);
  swap(a.excluded_paths, b.excluded_paths);
  swap(a.__isset, b.__isset);
}

take_snapshots_parameters::take_snapshots_parameters(const take_snapshots_parameters& other809) {
  disks = other809.disks;
  pre_script = other809.pre_script;
  post_script = other809.post_script;
  excluded_paths = other809.excluded_paths;
  __isset = other809.__isset;
}
take_snapshots_parameters& take_snapshots_parameters::operator=(const take_snapshots_parameters& other810) {
  disks = other810.disks;
  pre_script = other810.pre_script;
  post_script = other810.post_script;
  excluded_paths = other810.excluded_paths;
  __isset = other810.__isset;
  return *this;
}
void take_snapshots_parameters::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "take_snapshots_parameters(";
  out << "disks=" << to_string(disks);
  out << ", " << "pre_script=" << to_string(pre_script);
  out << ", " << "post_script=" << to_string(post_script);
  out << ", " << "excluded_paths=" << to_string(excluded_paths);
  out << ")";
}


local_folder::~local_folder() throw() {
}


void local_folder::__set_path(const std::string& val) {
  this->path = val;
__isset.path = true;
}
std::ostream& operator<<(std::ostream& out, const local_folder& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t local_folder::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->path);
          this->__isset.path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t local_folder::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("local_folder");

  if (this->__isset.path) {
    xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->path);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(local_folder &a, local_folder &b) {
  using ::std::swap;
  swap(a.path, b.path);
  swap(a.__isset, b.__isset);
}

local_folder::local_folder(const local_folder& other811) {
  path = other811.path;
  __isset = other811.__isset;
}
local_folder& local_folder::operator=(const local_folder& other812) {
  path = other812.path;
  __isset = other812.__isset;
  return *this;
}
void local_folder::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "local_folder(";
  out << "path="; (__isset.path ? (out << to_string(path)) : (out << "<null>"));
  out << ")";
}


network_folder::~network_folder() throw() {
}


void network_folder::__set_path(const std::string& val) {
  this->path = val;
__isset.path = true;
}

void network_folder::__set_username(const std::string& val) {
  this->username = val;
__isset.username = true;
}

void network_folder::__set_password(const std::string& val) {
  this->password = val;
__isset.password = true;
}

void network_folder::__set_port(const int32_t val) {
  this->port = val;
__isset.port = true;
}

void network_folder::__set_proxy_host(const std::string& val) {
  this->proxy_host = val;
__isset.proxy_host = true;
}

void network_folder::__set_proxy_port(const int32_t val) {
  this->proxy_port = val;
__isset.proxy_port = true;
}

void network_folder::__set_proxy_username(const std::string& val) {
  this->proxy_username = val;
__isset.proxy_username = true;
}

void network_folder::__set_proxy_password(const std::string& val) {
  this->proxy_password = val;
__isset.proxy_password = true;
}

void network_folder::__set_s3_region(const aws_region::type val) {
  this->s3_region = val;
__isset.s3_region = true;
}

void network_folder::__set_timeout(const int32_t val) {
  this->timeout = val;
__isset.timeout = true;
}
std::ostream& operator<<(std::ostream& out, const network_folder& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t network_folder::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->path);
          this->__isset.path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->username);
          this->__isset.username = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->password);
          this->__isset.password = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->port);
          this->__isset.port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->proxy_host);
          this->__isset.proxy_host = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->proxy_port);
          this->__isset.proxy_port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->proxy_username);
          this->__isset.proxy_username = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->proxy_password);
          this->__isset.proxy_password = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast813;
          xfer += iprot->readI32(ecast813);
          this->s3_region = (aws_region::type)ecast813;
          this->__isset.s3_region = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->timeout);
          this->__isset.timeout = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t network_folder::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("network_folder");

  if (this->__isset.path) {
    xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->path);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.username) {
    xfer += oprot->writeFieldBegin("username", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->username);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.password) {
    xfer += oprot->writeFieldBegin("password", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->password);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.port) {
    xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->port);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.proxy_host) {
    xfer += oprot->writeFieldBegin("proxy_host", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->proxy_host);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.proxy_port) {
    xfer += oprot->writeFieldBegin("proxy_port", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(this->proxy_port);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.proxy_username) {
    xfer += oprot->writeFieldBegin("proxy_username", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->proxy_username);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.proxy_password) {
    xfer += oprot->writeFieldBegin("proxy_password", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->proxy_password);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.s3_region) {
    xfer += oprot->writeFieldBegin("s3_region", ::apache::thrift::protocol::T_I32, 9);
    xfer += oprot->writeI32((int32_t)this->s3_region);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timeout) {
    xfer += oprot->writeFieldBegin("timeout", ::apache::thrift::protocol::T_I32, 10);
    xfer += oprot->writeI32(this->timeout);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(network_folder &a, network_folder &b) {
  using ::std::swap;
  swap(a.path, b.path);
  swap(a.username, b.username);
  swap(a.password, b.password);
  swap(a.port, b.port);
  swap(a.proxy_host, b.proxy_host);
  swap(a.proxy_port, b.proxy_port);
  swap(a.proxy_username, b.proxy_username);
  swap(a.proxy_password, b.proxy_password);
  swap(a.s3_region, b.s3_region);
  swap(a.timeout, b.timeout);
  swap(a.__isset, b.__isset);
}

network_folder::network_folder(const network_folder& other814) {
  path = other814.path;
  username = other814.username;
  password = other814.password;
  port = other814.port;
  proxy_host = other814.proxy_host;
  proxy_port = other814.proxy_port;
  proxy_username = other814.proxy_username;
  proxy_password = other814.proxy_password;
  s3_region = other814.s3_region;
  timeout = other814.timeout;
  __isset = other814.__isset;
}
network_folder& network_folder::operator=(const network_folder& other815) {
  path = other815.path;
  username = other815.username;
  password = other815.password;
  port = other815.port;
  proxy_host = other815.proxy_host;
  proxy_port = other815.proxy_port;
  proxy_username = other815.proxy_username;
  proxy_password = other815.proxy_password;
  s3_region = other815.s3_region;
  timeout = other815.timeout;
  __isset = other815.__isset;
  return *this;
}
void network_folder::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "network_folder(";
  out << "path="; (__isset.path ? (out << to_string(path)) : (out << "<null>"));
  out << ", " << "username="; (__isset.username ? (out << to_string(username)) : (out << "<null>"));
  out << ", " << "password="; (__isset.password ? (out << to_string(password)) : (out << "<null>"));
  out << ", " << "port="; (__isset.port ? (out << to_string(port)) : (out << "<null>"));
  out << ", " << "proxy_host="; (__isset.proxy_host ? (out << to_string(proxy_host)) : (out << "<null>"));
  out << ", " << "proxy_port="; (__isset.proxy_port ? (out << to_string(proxy_port)) : (out << "<null>"));
  out << ", " << "proxy_username="; (__isset.proxy_username ? (out << to_string(proxy_username)) : (out << "<null>"));
  out << ", " << "proxy_password="; (__isset.proxy_password ? (out << to_string(proxy_password)) : (out << "<null>"));
  out << ", " << "s3_region="; (__isset.s3_region ? (out << to_string(s3_region)) : (out << "<null>"));
  out << ", " << "timeout="; (__isset.timeout ? (out << to_string(timeout)) : (out << "<null>"));
  out << ")";
}


_detail::~_detail() throw() {
}


void _detail::__set_local(const local_folder& val) {
  this->local = val;
}

void _detail::__set_remote(const network_folder& val) {
  this->remote = val;
}
std::ostream& operator<<(std::ostream& out, const _detail& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t _detail::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->local.read(iprot);
          this->__isset.local = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->remote.read(iprot);
          this->__isset.remote = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t _detail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("_detail");

  xfer += oprot->writeFieldBegin("local", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->local.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("remote", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->remote.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(_detail &a, _detail &b) {
  using ::std::swap;
  swap(a.local, b.local);
  swap(a.remote, b.remote);
  swap(a.__isset, b.__isset);
}

_detail::_detail(const _detail& other816) {
  local = other816.local;
  remote = other816.remote;
  __isset = other816.__isset;
}
_detail& _detail::operator=(const _detail& other817) {
  local = other817.local;
  remote = other817.remote;
  __isset = other817.__isset;
  return *this;
}
void _detail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "_detail(";
  out << "local=" << to_string(local);
  out << ", " << "remote=" << to_string(remote);
  out << ")";
}


connection::~connection() throw() {
}


void connection::__set_type(const connection_type::type val) {
  this->type = val;
__isset.type = true;
}

void connection::__set_id(const std::string& val) {
  this->id = val;
__isset.id = true;
}

void connection::__set_options(const std::map<std::string, std::string> & val) {
  this->options = val;
__isset.options = true;
}

void connection::__set_compressed(const bool val) {
  this->compressed = val;
__isset.compressed = true;
}

void connection::__set_checksum(const bool val) {
  this->checksum = val;
__isset.checksum = true;
}

void connection::__set_encrypted(const bool val) {
  this->encrypted = val;
__isset.encrypted = true;
}

void connection::__set_detail(const _detail& val) {
  this->detail = val;
__isset.detail = true;
}
std::ostream& operator<<(std::ostream& out, const connection& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t connection::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast818;
          xfer += iprot->readI32(ecast818);
          this->type = (connection_type::type)ecast818;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->options.clear();
            uint32_t _size819;
            ::apache::thrift::protocol::TType _ktype820;
            ::apache::thrift::protocol::TType _vtype821;
            xfer += iprot->readMapBegin(_ktype820, _vtype821, _size819);
            uint32_t _i823;
            for (_i823 = 0; _i823 < _size819; ++_i823)
            {
              std::string _key824;
              xfer += iprot->readString(_key824);
              std::string& _val825 = this->options[_key824];
              xfer += iprot->readString(_val825);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->compressed);
          this->__isset.compressed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->checksum);
          this->__isset.checksum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->encrypted);
          this->__isset.encrypted = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->detail.read(iprot);
          this->__isset.detail = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t connection::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("connection");

  if (this->__isset.type) {
    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32((int32_t)this->type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.options) {
    xfer += oprot->writeFieldBegin("options", ::apache::thrift::protocol::T_MAP, 3);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->options.size()));
      std::map<std::string, std::string> ::const_iterator _iter826;
      for (_iter826 = this->options.begin(); _iter826 != this->options.end(); ++_iter826)
      {
        xfer += oprot->writeString(_iter826->first);
        xfer += oprot->writeString(_iter826->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.compressed) {
    xfer += oprot->writeFieldBegin("compressed", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->compressed);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.checksum) {
    xfer += oprot->writeFieldBegin("checksum", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->checksum);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.encrypted) {
    xfer += oprot->writeFieldBegin("encrypted", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->encrypted);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.detail) {
    xfer += oprot->writeFieldBegin("detail", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->detail.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(connection &a, connection &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.id, b.id);
  swap(a.options, b.options);
  swap(a.compressed, b.compressed);
  swap(a.checksum, b.checksum);
  swap(a.encrypted, b.encrypted);
  swap(a.detail, b.detail);
  swap(a.__isset, b.__isset);
}

connection::connection(const connection& other827) {
  type = other827.type;
  id = other827.id;
  options = other827.options;
  compressed = other827.compressed;
  checksum = other827.checksum;
  encrypted = other827.encrypted;
  detail = other827.detail;
  __isset = other827.__isset;
}
connection& connection::operator=(const connection& other828) {
  type = other828.type;
  id = other828.id;
  options = other828.options;
  compressed = other828.compressed;
  checksum = other828.checksum;
  encrypted = other828.encrypted;
  detail = other828.detail;
  __isset = other828.__isset;
  return *this;
}
void connection::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "connection(";
  out << "type="; (__isset.type ? (out << to_string(type)) : (out << "<null>"));
  out << ", " << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "options="; (__isset.options ? (out << to_string(options)) : (out << "<null>"));
  out << ", " << "compressed="; (__isset.compressed ? (out << to_string(compressed)) : (out << "<null>"));
  out << ", " << "checksum="; (__isset.checksum ? (out << to_string(checksum)) : (out << "<null>"));
  out << ", " << "encrypted="; (__isset.encrypted ? (out << to_string(encrypted)) : (out << "<null>"));
  out << ", " << "detail="; (__isset.detail ? (out << to_string(detail)) : (out << "<null>"));
  out << ")";
}


image_map_info::~image_map_info() throw() {
}


void image_map_info::__set_image(const std::string& val) {
  this->image = val;
__isset.image = true;
}

void image_map_info::__set_base_image(const std::string& val) {
  this->base_image = val;
__isset.base_image = true;
}

void image_map_info::__set_connection_ids(const std::set<std::string> & val) {
  this->connection_ids = val;
__isset.connection_ids = true;
}
std::ostream& operator<<(std::ostream& out, const image_map_info& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t image_map_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->image);
          this->__isset.image = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->base_image);
          this->__isset.base_image = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->connection_ids.clear();
            uint32_t _size829;
            ::apache::thrift::protocol::TType _etype832;
            xfer += iprot->readSetBegin(_etype832, _size829);
            uint32_t _i833;
            for (_i833 = 0; _i833 < _size829; ++_i833)
            {
              std::string _elem834;
              xfer += iprot->readString(_elem834);
              this->connection_ids.insert(_elem834);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.connection_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t image_map_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("image_map_info");

  if (this->__isset.image) {
    xfer += oprot->writeFieldBegin("image", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->image);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.base_image) {
    xfer += oprot->writeFieldBegin("base_image", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->base_image);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.connection_ids) {
    xfer += oprot->writeFieldBegin("connection_ids", ::apache::thrift::protocol::T_SET, 3);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->connection_ids.size()));
      std::set<std::string> ::const_iterator _iter835;
      for (_iter835 = this->connection_ids.begin(); _iter835 != this->connection_ids.end(); ++_iter835)
      {
        xfer += oprot->writeString((*_iter835));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(image_map_info &a, image_map_info &b) {
  using ::std::swap;
  swap(a.image, b.image);
  swap(a.base_image, b.base_image);
  swap(a.connection_ids, b.connection_ids);
  swap(a.__isset, b.__isset);
}

image_map_info::image_map_info(const image_map_info& other836) {
  image = other836.image;
  base_image = other836.base_image;
  connection_ids = other836.connection_ids;
  __isset = other836.__isset;
}
image_map_info& image_map_info::operator=(const image_map_info& other837) {
  image = other837.image;
  base_image = other837.base_image;
  connection_ids = other837.connection_ids;
  __isset = other837.__isset;
  return *this;
}
void image_map_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "image_map_info(";
  out << "image="; (__isset.image ? (out << to_string(image)) : (out << "<null>"));
  out << ", " << "base_image="; (__isset.base_image ? (out << to_string(base_image)) : (out << "<null>"));
  out << ", " << "connection_ids="; (__isset.connection_ids ? (out << to_string(connection_ids)) : (out << "<null>"));
  out << ")";
}


create_image_info::~create_image_info() throw() {
}


void create_image_info::__set_name(const std::string& val) {
  this->name = val;
__isset.name = true;
}

void create_image_info::__set_base(const std::string& val) {
  this->base = val;
__isset.base = true;
}

void create_image_info::__set_parent(const std::string& val) {
  this->parent = val;
__isset.parent = true;
}

void create_image_info::__set_connection_ids(const std::set<std::string> & val) {
  this->connection_ids = val;
__isset.connection_ids = true;
}

void create_image_info::__set_size(const int64_t val) {
  this->size = val;
__isset.size = true;
}

void create_image_info::__set_block_size(const int32_t val) {
  this->block_size = val;
__isset.block_size = true;
}

void create_image_info::__set_checksum_verify(const bool val) {
  this->checksum_verify = val;
__isset.checksum_verify = true;
}

void create_image_info::__set_comment(const std::string& val) {
  this->comment = val;
__isset.comment = true;
}

void create_image_info::__set_version(const create_image_option::type val) {
  this->version = val;
__isset.version = true;
}

void create_image_info::__set_compressed(const bool val) {
  this->compressed = val;
__isset.compressed = true;
}

void create_image_info::__set_checksum(const bool val) {
  this->checksum = val;
__isset.checksum = true;
}

void create_image_info::__set_cdr(const bool val) {
  this->cdr = val;
__isset.cdr = true;
}

void create_image_info::__set_mode(const int8_t val) {
  this->mode = val;
__isset.mode = true;
}
std::ostream& operator<<(std::ostream& out, const create_image_info& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t create_image_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->base);
          this->__isset.base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->parent);
          this->__isset.parent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->connection_ids.clear();
            uint32_t _size838;
            ::apache::thrift::protocol::TType _etype841;
            xfer += iprot->readSetBegin(_etype841, _size838);
            uint32_t _i842;
            for (_i842 = 0; _i842 < _size838; ++_i842)
            {
              std::string _elem843;
              xfer += iprot->readString(_elem843);
              this->connection_ids.insert(_elem843);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.connection_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->size);
          this->__isset.size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->block_size);
          this->__isset.block_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->checksum_verify);
          this->__isset.checksum_verify = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comment);
          this->__isset.comment = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast844;
          xfer += iprot->readI32(ecast844);
          this->version = (create_image_option::type)ecast844;
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->compressed);
          this->__isset.compressed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->checksum);
          this->__isset.checksum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->cdr);
          this->__isset.cdr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->mode);
          this->__isset.mode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t create_image_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("create_image_info");

  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.base) {
    xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->base);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.parent) {
    xfer += oprot->writeFieldBegin("parent", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->parent);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.connection_ids) {
    xfer += oprot->writeFieldBegin("connection_ids", ::apache::thrift::protocol::T_SET, 4);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->connection_ids.size()));
      std::set<std::string> ::const_iterator _iter845;
      for (_iter845 = this->connection_ids.begin(); _iter845 != this->connection_ids.end(); ++_iter845)
      {
        xfer += oprot->writeString((*_iter845));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.size) {
    xfer += oprot->writeFieldBegin("size", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.block_size) {
    xfer += oprot->writeFieldBegin("block_size", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(this->block_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.checksum_verify) {
    xfer += oprot->writeFieldBegin("checksum_verify", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->checksum_verify);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.comment) {
    xfer += oprot->writeFieldBegin("comment", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->comment);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.version) {
    xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_I32, 9);
    xfer += oprot->writeI32((int32_t)this->version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.compressed) {
    xfer += oprot->writeFieldBegin("compressed", ::apache::thrift::protocol::T_BOOL, 10);
    xfer += oprot->writeBool(this->compressed);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.checksum) {
    xfer += oprot->writeFieldBegin("checksum", ::apache::thrift::protocol::T_BOOL, 11);
    xfer += oprot->writeBool(this->checksum);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cdr) {
    xfer += oprot->writeFieldBegin("cdr", ::apache::thrift::protocol::T_BOOL, 12);
    xfer += oprot->writeBool(this->cdr);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mode) {
    xfer += oprot->writeFieldBegin("mode", ::apache::thrift::protocol::T_BYTE, 13);
    xfer += oprot->writeByte(this->mode);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(create_image_info &a, create_image_info &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.base, b.base);
  swap(a.parent, b.parent);
  swap(a.connection_ids, b.connection_ids);
  swap(a.size, b.size);
  swap(a.block_size, b.block_size);
  swap(a.checksum_verify, b.checksum_verify);
  swap(a.comment, b.comment);
  swap(a.version, b.version);
  swap(a.compressed, b.compressed);
  swap(a.checksum, b.checksum);
  swap(a.cdr, b.cdr);
  swap(a.mode, b.mode);
  swap(a.__isset, b.__isset);
}

create_image_info::create_image_info(const create_image_info& other846) {
  name = other846.name;
  base = other846.base;
  parent = other846.parent;
  connection_ids = other846.connection_ids;
  size = other846.size;
  block_size = other846.block_size;
  checksum_verify = other846.checksum_verify;
  comment = other846.comment;
  version = other846.version;
  compressed = other846.compressed;
  checksum = other846.checksum;
  cdr = other846.cdr;
  mode = other846.mode;
  __isset = other846.__isset;
}
create_image_info& create_image_info::operator=(const create_image_info& other847) {
  name = other847.name;
  base = other847.base;
  parent = other847.parent;
  connection_ids = other847.connection_ids;
  size = other847.size;
  block_size = other847.block_size;
  checksum_verify = other847.checksum_verify;
  comment = other847.comment;
  version = other847.version;
  compressed = other847.compressed;
  checksum = other847.checksum;
  cdr = other847.cdr;
  mode = other847.mode;
  __isset = other847.__isset;
  return *this;
}
void create_image_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "create_image_info(";
  out << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
  out << ", " << "base="; (__isset.base ? (out << to_string(base)) : (out << "<null>"));
  out << ", " << "parent="; (__isset.parent ? (out << to_string(parent)) : (out << "<null>"));
  out << ", " << "connection_ids="; (__isset.connection_ids ? (out << to_string(connection_ids)) : (out << "<null>"));
  out << ", " << "size="; (__isset.size ? (out << to_string(size)) : (out << "<null>"));
  out << ", " << "block_size="; (__isset.block_size ? (out << to_string(block_size)) : (out << "<null>"));
  out << ", " << "checksum_verify="; (__isset.checksum_verify ? (out << to_string(checksum_verify)) : (out << "<null>"));
  out << ", " << "comment="; (__isset.comment ? (out << to_string(comment)) : (out << "<null>"));
  out << ", " << "version="; (__isset.version ? (out << to_string(version)) : (out << "<null>"));
  out << ", " << "compressed="; (__isset.compressed ? (out << to_string(compressed)) : (out << "<null>"));
  out << ", " << "checksum="; (__isset.checksum ? (out << to_string(checksum)) : (out << "<null>"));
  out << ", " << "cdr="; (__isset.cdr ? (out << to_string(cdr)) : (out << "<null>"));
  out << ", " << "mode="; (__isset.mode ? (out << to_string(mode)) : (out << "<null>"));
  out << ")";
}


loader_job_detail::~loader_job_detail() throw() {
}


void loader_job_detail::__set_replica_id(const std::string& val) {
  this->replica_id = val;
__isset.replica_id = true;
}

void loader_job_detail::__set_id(const std::string& val) {
  this->id = val;
__isset.id = true;
}

void loader_job_detail::__set_state(const job_state::type val) {
  this->state = val;
__isset.state = true;
}

void loader_job_detail::__set_created_time(const std::string& val) {
  this->created_time = val;
__isset.created_time = true;
}

void loader_job_detail::__set_updated_time(const std::string& val) {
  this->updated_time = val;
__isset.updated_time = true;
}

void loader_job_detail::__set_progress(const std::map<std::string, int64_t> & val) {
  this->progress = val;
__isset.progress = true;
}

void loader_job_detail::__set_histories(const std::vector<job_history> & val) {
  this->histories = val;
__isset.histories = true;
}

void loader_job_detail::__set_connection_id(const std::string& val) {
  this->connection_id = val;
__isset.connection_id = true;
}

void loader_job_detail::__set_data(const std::map<std::string, int64_t> & val) {
  this->data = val;
__isset.data = true;
}

void loader_job_detail::__set_snapshot_id(const std::string& val) {
  this->snapshot_id = val;
__isset.snapshot_id = true;
}

void loader_job_detail::__set_duplicated_data(const std::map<std::string, int64_t> & val) {
  this->duplicated_data = val;
__isset.duplicated_data = true;
}

void loader_job_detail::__set_transport_data(const std::map<std::string, int64_t> & val) {
  this->transport_data = val;
__isset.transport_data = true;
}
std::ostream& operator<<(std::ostream& out, const loader_job_detail& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t loader_job_detail::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->replica_id);
          this->__isset.replica_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast848;
          xfer += iprot->readI32(ecast848);
          this->state = (job_state::type)ecast848;
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->created_time);
          this->__isset.created_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->updated_time);
          this->__isset.updated_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->progress.clear();
            uint32_t _size849;
            ::apache::thrift::protocol::TType _ktype850;
            ::apache::thrift::protocol::TType _vtype851;
            xfer += iprot->readMapBegin(_ktype850, _vtype851, _size849);
            uint32_t _i853;
            for (_i853 = 0; _i853 < _size849; ++_i853)
            {
              std::string _key854;
              xfer += iprot->readString(_key854);
              int64_t& _val855 = this->progress[_key854];
              xfer += iprot->readI64(_val855);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.progress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->histories.clear();
            uint32_t _size856;
            ::apache::thrift::protocol::TType _etype859;
            xfer += iprot->readListBegin(_etype859, _size856);
            this->histories.resize(_size856);
            uint32_t _i860;
            for (_i860 = 0; _i860 < _size856; ++_i860)
            {
              xfer += this->histories[_i860].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.histories = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->connection_id);
          this->__isset.connection_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->data.clear();
            uint32_t _size861;
            ::apache::thrift::protocol::TType _ktype862;
            ::apache::thrift::protocol::TType _vtype863;
            xfer += iprot->readMapBegin(_ktype862, _vtype863, _size861);
            uint32_t _i865;
            for (_i865 = 0; _i865 < _size861; ++_i865)
            {
              std::string _key866;
              xfer += iprot->readString(_key866);
              int64_t& _val867 = this->data[_key866];
              xfer += iprot->readI64(_val867);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->snapshot_id);
          this->__isset.snapshot_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->duplicated_data.clear();
            uint32_t _size868;
            ::apache::thrift::protocol::TType _ktype869;
            ::apache::thrift::protocol::TType _vtype870;
            xfer += iprot->readMapBegin(_ktype869, _vtype870, _size868);
            uint32_t _i872;
            for (_i872 = 0; _i872 < _size868; ++_i872)
            {
              std::string _key873;
              xfer += iprot->readString(_key873);
              int64_t& _val874 = this->duplicated_data[_key873];
              xfer += iprot->readI64(_val874);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.duplicated_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->transport_data.clear();
            uint32_t _size875;
            ::apache::thrift::protocol::TType _ktype876;
            ::apache::thrift::protocol::TType _vtype877;
            xfer += iprot->readMapBegin(_ktype876, _vtype877, _size875);
            uint32_t _i879;
            for (_i879 = 0; _i879 < _size875; ++_i879)
            {
              std::string _key880;
              xfer += iprot->readString(_key880);
              int64_t& _val881 = this->transport_data[_key880];
              xfer += iprot->readI64(_val881);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.transport_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t loader_job_detail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("loader_job_detail");

  if (this->__isset.replica_id) {
    xfer += oprot->writeFieldBegin("replica_id", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->replica_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.state) {
    xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32((int32_t)this->state);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.created_time) {
    xfer += oprot->writeFieldBegin("created_time", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->created_time);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.updated_time) {
    xfer += oprot->writeFieldBegin("updated_time", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->updated_time);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.progress) {
    xfer += oprot->writeFieldBegin("progress", ::apache::thrift::protocol::T_MAP, 6);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->progress.size()));
      std::map<std::string, int64_t> ::const_iterator _iter882;
      for (_iter882 = this->progress.begin(); _iter882 != this->progress.end(); ++_iter882)
      {
        xfer += oprot->writeString(_iter882->first);
        xfer += oprot->writeI64(_iter882->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.histories) {
    xfer += oprot->writeFieldBegin("histories", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->histories.size()));
      std::vector<job_history> ::const_iterator _iter883;
      for (_iter883 = this->histories.begin(); _iter883 != this->histories.end(); ++_iter883)
      {
        xfer += (*_iter883).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.connection_id) {
    xfer += oprot->writeFieldBegin("connection_id", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->connection_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.data) {
    xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_MAP, 9);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->data.size()));
      std::map<std::string, int64_t> ::const_iterator _iter884;
      for (_iter884 = this->data.begin(); _iter884 != this->data.end(); ++_iter884)
      {
        xfer += oprot->writeString(_iter884->first);
        xfer += oprot->writeI64(_iter884->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.snapshot_id) {
    xfer += oprot->writeFieldBegin("snapshot_id", ::apache::thrift::protocol::T_STRING, 10);
    xfer += oprot->writeString(this->snapshot_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.duplicated_data) {
    xfer += oprot->writeFieldBegin("duplicated_data", ::apache::thrift::protocol::T_MAP, 11);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->duplicated_data.size()));
      std::map<std::string, int64_t> ::const_iterator _iter885;
      for (_iter885 = this->duplicated_data.begin(); _iter885 != this->duplicated_data.end(); ++_iter885)
      {
        xfer += oprot->writeString(_iter885->first);
        xfer += oprot->writeI64(_iter885->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.transport_data) {
    xfer += oprot->writeFieldBegin("transport_data", ::apache::thrift::protocol::T_MAP, 12);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->transport_data.size()));
      std::map<std::string, int64_t> ::const_iterator _iter886;
      for (_iter886 = this->transport_data.begin(); _iter886 != this->transport_data.end(); ++_iter886)
      {
        xfer += oprot->writeString(_iter886->first);
        xfer += oprot->writeI64(_iter886->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(loader_job_detail &a, loader_job_detail &b) {
  using ::std::swap;
  swap(a.replica_id, b.replica_id);
  swap(a.id, b.id);
  swap(a.state, b.state);
  swap(a.created_time, b.created_time);
  swap(a.updated_time, b.updated_time);
  swap(a.progress, b.progress);
  swap(a.histories, b.histories);
  swap(a.connection_id, b.connection_id);
  swap(a.data, b.data);
  swap(a.snapshot_id, b.snapshot_id);
  swap(a.duplicated_data, b.duplicated_data);
  swap(a.transport_data, b.transport_data);
  swap(a.__isset, b.__isset);
}

loader_job_detail::loader_job_detail(const loader_job_detail& other887) {
  replica_id = other887.replica_id;
  id = other887.id;
  state = other887.state;
  created_time = other887.created_time;
  updated_time = other887.updated_time;
  progress = other887.progress;
  histories = other887.histories;
  connection_id = other887.connection_id;
  data = other887.data;
  snapshot_id = other887.snapshot_id;
  duplicated_data = other887.duplicated_data;
  transport_data = other887.transport_data;
  __isset = other887.__isset;
}
loader_job_detail& loader_job_detail::operator=(const loader_job_detail& other888) {
  replica_id = other888.replica_id;
  id = other888.id;
  state = other888.state;
  created_time = other888.created_time;
  updated_time = other888.updated_time;
  progress = other888.progress;
  histories = other888.histories;
  connection_id = other888.connection_id;
  data = other888.data;
  snapshot_id = other888.snapshot_id;
  duplicated_data = other888.duplicated_data;
  transport_data = other888.transport_data;
  __isset = other888.__isset;
  return *this;
}
void loader_job_detail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "loader_job_detail(";
  out << "replica_id="; (__isset.replica_id ? (out << to_string(replica_id)) : (out << "<null>"));
  out << ", " << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "state="; (__isset.state ? (out << to_string(state)) : (out << "<null>"));
  out << ", " << "created_time="; (__isset.created_time ? (out << to_string(created_time)) : (out << "<null>"));
  out << ", " << "updated_time="; (__isset.updated_time ? (out << to_string(updated_time)) : (out << "<null>"));
  out << ", " << "progress="; (__isset.progress ? (out << to_string(progress)) : (out << "<null>"));
  out << ", " << "histories="; (__isset.histories ? (out << to_string(histories)) : (out << "<null>"));
  out << ", " << "connection_id="; (__isset.connection_id ? (out << to_string(connection_id)) : (out << "<null>"));
  out << ", " << "data="; (__isset.data ? (out << to_string(data)) : (out << "<null>"));
  out << ", " << "snapshot_id="; (__isset.snapshot_id ? (out << to_string(snapshot_id)) : (out << "<null>"));
  out << ", " << "duplicated_data="; (__isset.duplicated_data ? (out << to_string(duplicated_data)) : (out << "<null>"));
  out << ", " << "transport_data="; (__isset.transport_data ? (out << to_string(transport_data)) : (out << "<null>"));
  out << ")";
}


upload_progress::~upload_progress() throw() {
}


void upload_progress::__set_size(const int64_t val) {
  this->size = val;
__isset.size = true;
}

void upload_progress::__set_progress(const int64_t val) {
  this->progress = val;
__isset.progress = true;
}

void upload_progress::__set_vhd_size(const int64_t val) {
  this->vhd_size = val;
__isset.vhd_size = true;
}

void upload_progress::__set_upload_id(const std::string& val) {
  this->upload_id = val;
__isset.upload_id = true;
}

void upload_progress::__set_completed(const bool val) {
  this->completed = val;
__isset.completed = true;
}
std::ostream& operator<<(std::ostream& out, const upload_progress& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t upload_progress::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->size);
          this->__isset.size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->progress);
          this->__isset.progress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->vhd_size);
          this->__isset.vhd_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->upload_id);
          this->__isset.upload_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->completed);
          this->__isset.completed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t upload_progress::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("upload_progress");

  if (this->__isset.size) {
    xfer += oprot->writeFieldBegin("size", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.progress) {
    xfer += oprot->writeFieldBegin("progress", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->progress);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vhd_size) {
    xfer += oprot->writeFieldBegin("vhd_size", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->vhd_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.upload_id) {
    xfer += oprot->writeFieldBegin("upload_id", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->upload_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.completed) {
    xfer += oprot->writeFieldBegin("completed", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->completed);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(upload_progress &a, upload_progress &b) {
  using ::std::swap;
  swap(a.size, b.size);
  swap(a.progress, b.progress);
  swap(a.vhd_size, b.vhd_size);
  swap(a.upload_id, b.upload_id);
  swap(a.completed, b.completed);
  swap(a.__isset, b.__isset);
}

upload_progress::upload_progress(const upload_progress& other889) {
  size = other889.size;
  progress = other889.progress;
  vhd_size = other889.vhd_size;
  upload_id = other889.upload_id;
  completed = other889.completed;
  __isset = other889.__isset;
}
upload_progress& upload_progress::operator=(const upload_progress& other890) {
  size = other890.size;
  progress = other890.progress;
  vhd_size = other890.vhd_size;
  upload_id = other890.upload_id;
  completed = other890.completed;
  __isset = other890.__isset;
  return *this;
}
void upload_progress::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "upload_progress(";
  out << "size="; (__isset.size ? (out << to_string(size)) : (out << "<null>"));
  out << ", " << "progress="; (__isset.progress ? (out << to_string(progress)) : (out << "<null>"));
  out << ", " << "vhd_size="; (__isset.vhd_size ? (out << to_string(vhd_size)) : (out << "<null>"));
  out << ", " << "upload_id="; (__isset.upload_id ? (out << to_string(upload_id)) : (out << "<null>"));
  out << ", " << "completed="; (__isset.completed ? (out << to_string(completed)) : (out << "<null>"));
  out << ")";
}


launcher_job_detail::~launcher_job_detail() throw() {
}


void launcher_job_detail::__set_replica_id(const std::string& val) {
  this->replica_id = val;
__isset.replica_id = true;
}

void launcher_job_detail::__set_id(const std::string& val) {
  this->id = val;
__isset.id = true;
}

void launcher_job_detail::__set_state(const job_state::type val) {
  this->state = val;
__isset.state = true;
}

void launcher_job_detail::__set_created_time(const std::string& val) {
  this->created_time = val;
__isset.created_time = true;
}

void launcher_job_detail::__set_updated_time(const std::string& val) {
  this->updated_time = val;
__isset.updated_time = true;
}

void launcher_job_detail::__set_boot_disk(const std::string& val) {
  this->boot_disk = val;
__isset.boot_disk = true;
}

void launcher_job_detail::__set_histories(const std::vector<job_history> & val) {
  this->histories = val;
__isset.histories = true;
}

void launcher_job_detail::__set_is_error(const bool val) {
  this->is_error = val;
__isset.is_error = true;
}

void launcher_job_detail::__set_is_windows_update(const bool val) {
  this->is_windows_update = val;
__isset.is_windows_update = true;
}

void launcher_job_detail::__set_platform(const std::string& val) {
  this->platform = val;
__isset.platform = true;
}

void launcher_job_detail::__set_architecture(const std::string& val) {
  this->architecture = val;
__isset.architecture = true;
}

void launcher_job_detail::__set_size(const int64_t val) {
  this->size = val;
__isset.size = true;
}

void launcher_job_detail::__set_progress(const int64_t val) {
  this->progress = val;
__isset.progress = true;
}

void launcher_job_detail::__set_vhd_size(const int64_t val) {
  this->vhd_size = val;
__isset.vhd_size = true;
}

void launcher_job_detail::__set_upload_id(const std::string& val) {
  this->upload_id = val;
__isset.upload_id = true;
}

void launcher_job_detail::__set_host_name(const std::string& val) {
  this->host_name = val;
__isset.host_name = true;
}

void launcher_job_detail::__set_vhd_upload_progress(const std::map<std::string, upload_progress> & val) {
  this->vhd_upload_progress = val;
__isset.vhd_upload_progress = true;
}

void launcher_job_detail::__set_virtual_machine_id(const std::string& val) {
  this->virtual_machine_id = val;
__isset.virtual_machine_id = true;
}
std::ostream& operator<<(std::ostream& out, const launcher_job_detail& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t launcher_job_detail::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->replica_id);
          this->__isset.replica_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast891;
          xfer += iprot->readI32(ecast891);
          this->state = (job_state::type)ecast891;
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->created_time);
          this->__isset.created_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->updated_time);
          this->__isset.updated_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->boot_disk);
          this->__isset.boot_disk = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->histories.clear();
            uint32_t _size892;
            ::apache::thrift::protocol::TType _etype895;
            xfer += iprot->readListBegin(_etype895, _size892);
            this->histories.resize(_size892);
            uint32_t _i896;
            for (_i896 = 0; _i896 < _size892; ++_i896)
            {
              xfer += this->histories[_i896].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.histories = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_error);
          this->__isset.is_error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_windows_update);
          this->__isset.is_windows_update = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->platform);
          this->__isset.platform = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->architecture);
          this->__isset.architecture = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->size);
          this->__isset.size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->progress);
          this->__isset.progress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->vhd_size);
          this->__isset.vhd_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->upload_id);
          this->__isset.upload_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host_name);
          this->__isset.host_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->vhd_upload_progress.clear();
            uint32_t _size897;
            ::apache::thrift::protocol::TType _ktype898;
            ::apache::thrift::protocol::TType _vtype899;
            xfer += iprot->readMapBegin(_ktype898, _vtype899, _size897);
            uint32_t _i901;
            for (_i901 = 0; _i901 < _size897; ++_i901)
            {
              std::string _key902;
              xfer += iprot->readString(_key902);
              upload_progress& _val903 = this->vhd_upload_progress[_key902];
              xfer += _val903.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.vhd_upload_progress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->virtual_machine_id);
          this->__isset.virtual_machine_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t launcher_job_detail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("launcher_job_detail");

  if (this->__isset.replica_id) {
    xfer += oprot->writeFieldBegin("replica_id", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->replica_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.state) {
    xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32((int32_t)this->state);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.created_time) {
    xfer += oprot->writeFieldBegin("created_time", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->created_time);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.updated_time) {
    xfer += oprot->writeFieldBegin("updated_time", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->updated_time);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.boot_disk) {
    xfer += oprot->writeFieldBegin("boot_disk", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->boot_disk);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.histories) {
    xfer += oprot->writeFieldBegin("histories", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->histories.size()));
      std::vector<job_history> ::const_iterator _iter904;
      for (_iter904 = this->histories.begin(); _iter904 != this->histories.end(); ++_iter904)
      {
        xfer += (*_iter904).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_error) {
    xfer += oprot->writeFieldBegin("is_error", ::apache::thrift::protocol::T_BOOL, 8);
    xfer += oprot->writeBool(this->is_error);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_windows_update) {
    xfer += oprot->writeFieldBegin("is_windows_update", ::apache::thrift::protocol::T_BOOL, 9);
    xfer += oprot->writeBool(this->is_windows_update);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.platform) {
    xfer += oprot->writeFieldBegin("platform", ::apache::thrift::protocol::T_STRING, 10);
    xfer += oprot->writeString(this->platform);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.architecture) {
    xfer += oprot->writeFieldBegin("architecture", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeString(this->architecture);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.size) {
    xfer += oprot->writeFieldBegin("size", ::apache::thrift::protocol::T_I64, 12);
    xfer += oprot->writeI64(this->size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.progress) {
    xfer += oprot->writeFieldBegin("progress", ::apache::thrift::protocol::T_I64, 13);
    xfer += oprot->writeI64(this->progress);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vhd_size) {
    xfer += oprot->writeFieldBegin("vhd_size", ::apache::thrift::protocol::T_I64, 14);
    xfer += oprot->writeI64(this->vhd_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.upload_id) {
    xfer += oprot->writeFieldBegin("upload_id", ::apache::thrift::protocol::T_STRING, 15);
    xfer += oprot->writeString(this->upload_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.host_name) {
    xfer += oprot->writeFieldBegin("host_name", ::apache::thrift::protocol::T_STRING, 16);
    xfer += oprot->writeString(this->host_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vhd_upload_progress) {
    xfer += oprot->writeFieldBegin("vhd_upload_progress", ::apache::thrift::protocol::T_MAP, 17);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->vhd_upload_progress.size()));
      std::map<std::string, upload_progress> ::const_iterator _iter905;
      for (_iter905 = this->vhd_upload_progress.begin(); _iter905 != this->vhd_upload_progress.end(); ++_iter905)
      {
        xfer += oprot->writeString(_iter905->first);
        xfer += _iter905->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.virtual_machine_id) {
    xfer += oprot->writeFieldBegin("virtual_machine_id", ::apache::thrift::protocol::T_STRING, 18);
    xfer += oprot->writeString(this->virtual_machine_id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(launcher_job_detail &a, launcher_job_detail &b) {
  using ::std::swap;
  swap(a.replica_id, b.replica_id);
  swap(a.id, b.id);
  swap(a.state, b.state);
  swap(a.created_time, b.created_time);
  swap(a.updated_time, b.updated_time);
  swap(a.boot_disk, b.boot_disk);
  swap(a.histories, b.histories);
  swap(a.is_error, b.is_error);
  swap(a.is_windows_update, b.is_windows_update);
  swap(a.platform, b.platform);
  swap(a.architecture, b.architecture);
  swap(a.size, b.size);
  swap(a.progress, b.progress);
  swap(a.vhd_size, b.vhd_size);
  swap(a.upload_id, b.upload_id);
  swap(a.host_name, b.host_name);
  swap(a.vhd_upload_progress, b.vhd_upload_progress);
  swap(a.virtual_machine_id, b.virtual_machine_id);
  swap(a.__isset, b.__isset);
}

launcher_job_detail::launcher_job_detail(const launcher_job_detail& other906) {
  replica_id = other906.replica_id;
  id = other906.id;
  state = other906.state;
  created_time = other906.created_time;
  updated_time = other906.updated_time;
  boot_disk = other906.boot_disk;
  histories = other906.histories;
  is_error = other906.is_error;
  is_windows_update = other906.is_windows_update;
  platform = other906.platform;
  architecture = other906.architecture;
  size = other906.size;
  progress = other906.progress;
  vhd_size = other906.vhd_size;
  upload_id = other906.upload_id;
  host_name = other906.host_name;
  vhd_upload_progress = other906.vhd_upload_progress;
  virtual_machine_id = other906.virtual_machine_id;
  __isset = other906.__isset;
}
launcher_job_detail& launcher_job_detail::operator=(const launcher_job_detail& other907) {
  replica_id = other907.replica_id;
  id = other907.id;
  state = other907.state;
  created_time = other907.created_time;
  updated_time = other907.updated_time;
  boot_disk = other907.boot_disk;
  histories = other907.histories;
  is_error = other907.is_error;
  is_windows_update = other907.is_windows_update;
  platform = other907.platform;
  architecture = other907.architecture;
  size = other907.size;
  progress = other907.progress;
  vhd_size = other907.vhd_size;
  upload_id = other907.upload_id;
  host_name = other907.host_name;
  vhd_upload_progress = other907.vhd_upload_progress;
  virtual_machine_id = other907.virtual_machine_id;
  __isset = other907.__isset;
  return *this;
}
void launcher_job_detail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "launcher_job_detail(";
  out << "replica_id="; (__isset.replica_id ? (out << to_string(replica_id)) : (out << "<null>"));
  out << ", " << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "state="; (__isset.state ? (out << to_string(state)) : (out << "<null>"));
  out << ", " << "created_time="; (__isset.created_time ? (out << to_string(created_time)) : (out << "<null>"));
  out << ", " << "updated_time="; (__isset.updated_time ? (out << to_string(updated_time)) : (out << "<null>"));
  out << ", " << "boot_disk="; (__isset.boot_disk ? (out << to_string(boot_disk)) : (out << "<null>"));
  out << ", " << "histories="; (__isset.histories ? (out << to_string(histories)) : (out << "<null>"));
  out << ", " << "is_error="; (__isset.is_error ? (out << to_string(is_error)) : (out << "<null>"));
  out << ", " << "is_windows_update="; (__isset.is_windows_update ? (out << to_string(is_windows_update)) : (out << "<null>"));
  out << ", " << "platform="; (__isset.platform ? (out << to_string(platform)) : (out << "<null>"));
  out << ", " << "architecture="; (__isset.architecture ? (out << to_string(architecture)) : (out << "<null>"));
  out << ", " << "size="; (__isset.size ? (out << to_string(size)) : (out << "<null>"));
  out << ", " << "progress="; (__isset.progress ? (out << to_string(progress)) : (out << "<null>"));
  out << ", " << "vhd_size="; (__isset.vhd_size ? (out << to_string(vhd_size)) : (out << "<null>"));
  out << ", " << "upload_id="; (__isset.upload_id ? (out << to_string(upload_id)) : (out << "<null>"));
  out << ", " << "host_name="; (__isset.host_name ? (out << to_string(host_name)) : (out << "<null>"));
  out << ", " << "vhd_upload_progress="; (__isset.vhd_upload_progress ? (out << to_string(vhd_upload_progress)) : (out << "<null>"));
  out << ", " << "virtual_machine_id="; (__isset.virtual_machine_id ? (out << to_string(virtual_machine_id)) : (out << "<null>"));
  out << ")";
}


job_detail::~job_detail() throw() {
}


void job_detail::__set_scheduler(const replica_job_detail& val) {
  this->scheduler = val;
__isset.scheduler = true;
}

void job_detail::__set_launcher(const launcher_job_detail& val) {
  this->launcher = val;
__isset.launcher = true;
}

void job_detail::__set_loader(const loader_job_detail& val) {
  this->loader = val;
__isset.loader = true;
}
std::ostream& operator<<(std::ostream& out, const job_detail& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t job_detail::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->scheduler.read(iprot);
          this->__isset.scheduler = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->launcher.read(iprot);
          this->__isset.launcher = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->loader.read(iprot);
          this->__isset.loader = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t job_detail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("job_detail");

  if (this->__isset.scheduler) {
    xfer += oprot->writeFieldBegin("scheduler", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->scheduler.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.launcher) {
    xfer += oprot->writeFieldBegin("launcher", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->launcher.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.loader) {
    xfer += oprot->writeFieldBegin("loader", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->loader.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(job_detail &a, job_detail &b) {
  using ::std::swap;
  swap(a.scheduler, b.scheduler);
  swap(a.launcher, b.launcher);
  swap(a.loader, b.loader);
  swap(a.__isset, b.__isset);
}

job_detail::job_detail(const job_detail& other908) {
  scheduler = other908.scheduler;
  launcher = other908.launcher;
  loader = other908.loader;
  __isset = other908.__isset;
}
job_detail& job_detail::operator=(const job_detail& other909) {
  scheduler = other909.scheduler;
  launcher = other909.launcher;
  loader = other909.loader;
  __isset = other909.__isset;
  return *this;
}
void job_detail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "job_detail(";
  out << "scheduler="; (__isset.scheduler ? (out << to_string(scheduler)) : (out << "<null>"));
  out << ", " << "launcher="; (__isset.launcher ? (out << to_string(launcher)) : (out << "<null>"));
  out << ", " << "loader="; (__isset.loader ? (out << to_string(loader)) : (out << "<null>"));
  out << ")";
}


replica_job_create_detail::~replica_job_create_detail() throw() {
}


void replica_job_create_detail::__set_host(const std::string& val) {
  this->host = val;
__isset.host = true;
}

void replica_job_create_detail::__set_addr(const std::set<std::string> & val) {
  this->addr = val;
__isset.addr = true;
}

void replica_job_create_detail::__set_username(const std::string& val) {
  this->username = val;
__isset.username = true;
}

void replica_job_create_detail::__set_password(const std::string& val) {
  this->password = val;
__isset.password = true;
}

void replica_job_create_detail::__set_type(const job_type::type val) {
  this->type = val;
__isset.type = true;
}

void replica_job_create_detail::__set_virtual_machine_id(const std::string& val) {
  this->virtual_machine_id = val;
__isset.virtual_machine_id = true;
}

void replica_job_create_detail::__set_disks(const std::set<std::string> & val) {
  this->disks = val;
__isset.disks = true;
}

void replica_job_create_detail::__set_targets(const std::map<std::string, std::string> & val) {
  this->targets = val;
__isset.targets = true;
}

void replica_job_create_detail::__set_carriers(const std::map<std::string, std::set<std::string> > & val) {
  this->carriers = val;
__isset.carriers = true;
}

void replica_job_create_detail::__set_full_replicas(const std::set<std::string> & val) {
  this->full_replicas = val;
__isset.full_replicas = true;
}

void replica_job_create_detail::__set_disk_ids(const std::map<std::string, std::string> & val) {
  this->disk_ids = val;
__isset.disk_ids = true;
}

void replica_job_create_detail::__set_cbt_info(const std::string& val) {
  this->cbt_info = val;
__isset.cbt_info = true;
}

void replica_job_create_detail::__set_snapshot_info(const std::string& val) {
  this->snapshot_info = val;
__isset.snapshot_info = true;
}

void replica_job_create_detail::__set_checksum_verify(const bool val) {
  this->checksum_verify = val;
__isset.checksum_verify = true;
}

void replica_job_create_detail::__set_always_retry(const bool val) {
  this->always_retry = val;
__isset.always_retry = true;
}

void replica_job_create_detail::__set_timeout(const int32_t val) {
  this->timeout = val;
__isset.timeout = true;
}

void replica_job_create_detail::__set_is_encrypted(const bool val) {
  this->is_encrypted = val;
__isset.is_encrypted = true;
}

void replica_job_create_detail::__set_is_paused(const bool val) {
  this->is_paused = val;
__isset.is_paused = true;
}

void replica_job_create_detail::__set_worker_thread_number(const int32_t val) {
  this->worker_thread_number = val;
__isset.worker_thread_number = true;
}

void replica_job_create_detail::__set_block_mode_enable(const bool val) {
  this->block_mode_enable = val;
__isset.block_mode_enable = true;
}

void replica_job_create_detail::__set_file_system_filter_enable(const bool val) {
  this->file_system_filter_enable = val;
__isset.file_system_filter_enable = true;
}

void replica_job_create_detail::__set_min_transport_size(const int32_t val) {
  this->min_transport_size = val;
__isset.min_transport_size = true;
}

void replica_job_create_detail::__set_full_min_transport_size(const int32_t val) {
  this->full_min_transport_size = val;
__isset.full_min_transport_size = true;
}

void replica_job_create_detail::__set_is_full_replica(const bool val) {
  this->is_full_replica = val;
__isset.is_full_replica = true;
}

void replica_job_create_detail::__set_buffer_size(const int32_t val) {
  this->buffer_size = val;
__isset.buffer_size = true;
}

void replica_job_create_detail::__set_is_compressed(const bool val) {
  this->is_compressed = val;
__isset.is_compressed = true;
}

void replica_job_create_detail::__set_is_checksum(const bool val) {
  this->is_checksum = val;
__isset.is_checksum = true;
}

void replica_job_create_detail::__set_time(const std::string& val) {
  this->time = val;
__isset.time = true;
}

void replica_job_create_detail::__set_priority_carrier(const std::map<std::string, std::string> & val) {
  this->priority_carrier = val;
__isset.priority_carrier = true;
}

void replica_job_create_detail::__set_is_only_single_system_disk(const bool val) {
  this->is_only_single_system_disk = val;
__isset.is_only_single_system_disk = true;
}

void replica_job_create_detail::__set_is_continuous_data_replication(const bool val) {
  this->is_continuous_data_replication = val;
__isset.is_continuous_data_replication = true;
}

void replica_job_create_detail::__set_pre_snapshot_script(const std::string& val) {
  this->pre_snapshot_script = val;
__isset.pre_snapshot_script = true;
}

void replica_job_create_detail::__set_post_snapshot_script(const std::string& val) {
  this->post_snapshot_script = val;
__isset.post_snapshot_script = true;
}

void replica_job_create_detail::__set_is_compressed_by_packer(const bool val) {
  this->is_compressed_by_packer = val;
__isset.is_compressed_by_packer = true;
}

void replica_job_create_detail::__set_excluded_paths(const std::set<std::string> & val) {
  this->excluded_paths = val;
__isset.excluded_paths = true;
}

void replica_job_create_detail::__set_previous_excluded_paths(const std::set<std::string> & val) {
  this->previous_excluded_paths = val;
__isset.previous_excluded_paths = true;
}
std::ostream& operator<<(std::ostream& out, const replica_job_create_detail& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t replica_job_create_detail::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host);
          this->__isset.host = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->addr.clear();
            uint32_t _size910;
            ::apache::thrift::protocol::TType _etype913;
            xfer += iprot->readSetBegin(_etype913, _size910);
            uint32_t _i914;
            for (_i914 = 0; _i914 < _size910; ++_i914)
            {
              std::string _elem915;
              xfer += iprot->readString(_elem915);
              this->addr.insert(_elem915);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->username);
          this->__isset.username = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->password);
          this->__isset.password = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast916;
          xfer += iprot->readI32(ecast916);
          this->type = (job_type::type)ecast916;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->virtual_machine_id);
          this->__isset.virtual_machine_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->disks.clear();
            uint32_t _size917;
            ::apache::thrift::protocol::TType _etype920;
            xfer += iprot->readSetBegin(_etype920, _size917);
            uint32_t _i921;
            for (_i921 = 0; _i921 < _size917; ++_i921)
            {
              std::string _elem922;
              xfer += iprot->readString(_elem922);
              this->disks.insert(_elem922);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.disks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->targets.clear();
            uint32_t _size923;
            ::apache::thrift::protocol::TType _ktype924;
            ::apache::thrift::protocol::TType _vtype925;
            xfer += iprot->readMapBegin(_ktype924, _vtype925, _size923);
            uint32_t _i927;
            for (_i927 = 0; _i927 < _size923; ++_i927)
            {
              std::string _key928;
              xfer += iprot->readString(_key928);
              std::string& _val929 = this->targets[_key928];
              xfer += iprot->readString(_val929);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.targets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->carriers.clear();
            uint32_t _size930;
            ::apache::thrift::protocol::TType _ktype931;
            ::apache::thrift::protocol::TType _vtype932;
            xfer += iprot->readMapBegin(_ktype931, _vtype932, _size930);
            uint32_t _i934;
            for (_i934 = 0; _i934 < _size930; ++_i934)
            {
              std::string _key935;
              xfer += iprot->readString(_key935);
              std::set<std::string> & _val936 = this->carriers[_key935];
              {
                _val936.clear();
                uint32_t _size937;
                ::apache::thrift::protocol::TType _etype940;
                xfer += iprot->readSetBegin(_etype940, _size937);
                uint32_t _i941;
                for (_i941 = 0; _i941 < _size937; ++_i941)
                {
                  std::string _elem942;
                  xfer += iprot->readString(_elem942);
                  _val936.insert(_elem942);
                }
                xfer += iprot->readSetEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.carriers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->full_replicas.clear();
            uint32_t _size943;
            ::apache::thrift::protocol::TType _etype946;
            xfer += iprot->readSetBegin(_etype946, _size943);
            uint32_t _i947;
            for (_i947 = 0; _i947 < _size943; ++_i947)
            {
              std::string _elem948;
              xfer += iprot->readString(_elem948);
              this->full_replicas.insert(_elem948);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.full_replicas = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->disk_ids.clear();
            uint32_t _size949;
            ::apache::thrift::protocol::TType _ktype950;
            ::apache::thrift::protocol::TType _vtype951;
            xfer += iprot->readMapBegin(_ktype950, _vtype951, _size949);
            uint32_t _i953;
            for (_i953 = 0; _i953 < _size949; ++_i953)
            {
              std::string _key954;
              xfer += iprot->readString(_key954);
              std::string& _val955 = this->disk_ids[_key954];
              xfer += iprot->readString(_val955);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.disk_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cbt_info);
          this->__isset.cbt_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->snapshot_info);
          this->__isset.snapshot_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->checksum_verify);
          this->__isset.checksum_verify = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->always_retry);
          this->__isset.always_retry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->timeout);
          this->__isset.timeout = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_encrypted);
          this->__isset.is_encrypted = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_paused);
          this->__isset.is_paused = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->worker_thread_number);
          this->__isset.worker_thread_number = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->block_mode_enable);
          this->__isset.block_mode_enable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->file_system_filter_enable);
          this->__isset.file_system_filter_enable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->min_transport_size);
          this->__isset.min_transport_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->full_min_transport_size);
          this->__isset.full_min_transport_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_full_replica);
          this->__isset.is_full_replica = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->buffer_size);
          this->__isset.buffer_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 26:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_compressed);
          this->__isset.is_compressed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 27:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_checksum);
          this->__isset.is_checksum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 28:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->time);
          this->__isset.time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 29:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->priority_carrier.clear();
            uint32_t _size956;
            ::apache::thrift::protocol::TType _ktype957;
            ::apache::thrift::protocol::TType _vtype958;
            xfer += iprot->readMapBegin(_ktype957, _vtype958, _size956);
            uint32_t _i960;
            for (_i960 = 0; _i960 < _size956; ++_i960)
            {
              std::string _key961;
              xfer += iprot->readString(_key961);
              std::string& _val962 = this->priority_carrier[_key961];
              xfer += iprot->readString(_val962);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.priority_carrier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_only_single_system_disk);
          this->__isset.is_only_single_system_disk = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 31:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_continuous_data_replication);
          this->__isset.is_continuous_data_replication = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 32:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pre_snapshot_script);
          this->__isset.pre_snapshot_script = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 33:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->post_snapshot_script);
          this->__isset.post_snapshot_script = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 34:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_compressed_by_packer);
          this->__isset.is_compressed_by_packer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 35:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->excluded_paths.clear();
            uint32_t _size963;
            ::apache::thrift::protocol::TType _etype966;
            xfer += iprot->readSetBegin(_etype966, _size963);
            uint32_t _i967;
            for (_i967 = 0; _i967 < _size963; ++_i967)
            {
              std::string _elem968;
              xfer += iprot->readString(_elem968);
              this->excluded_paths.insert(_elem968);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.excluded_paths = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 36:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->previous_excluded_paths.clear();
            uint32_t _size969;
            ::apache::thrift::protocol::TType _etype972;
            xfer += iprot->readSetBegin(_etype972, _size969);
            uint32_t _i973;
            for (_i973 = 0; _i973 < _size969; ++_i973)
            {
              std::string _elem974;
              xfer += iprot->readString(_elem974);
              this->previous_excluded_paths.insert(_elem974);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.previous_excluded_paths = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t replica_job_create_detail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("replica_job_create_detail");

  if (this->__isset.host) {
    xfer += oprot->writeFieldBegin("host", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->host);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.addr) {
    xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_SET, 2);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->addr.size()));
      std::set<std::string> ::const_iterator _iter975;
      for (_iter975 = this->addr.begin(); _iter975 != this->addr.end(); ++_iter975)
      {
        xfer += oprot->writeString((*_iter975));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.username) {
    xfer += oprot->writeFieldBegin("username", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->username);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.password) {
    xfer += oprot->writeFieldBegin("password", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->password);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.type) {
    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32((int32_t)this->type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.virtual_machine_id) {
    xfer += oprot->writeFieldBegin("virtual_machine_id", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->virtual_machine_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.disks) {
    xfer += oprot->writeFieldBegin("disks", ::apache::thrift::protocol::T_SET, 7);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->disks.size()));
      std::set<std::string> ::const_iterator _iter976;
      for (_iter976 = this->disks.begin(); _iter976 != this->disks.end(); ++_iter976)
      {
        xfer += oprot->writeString((*_iter976));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.targets) {
    xfer += oprot->writeFieldBegin("targets", ::apache::thrift::protocol::T_MAP, 8);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->targets.size()));
      std::map<std::string, std::string> ::const_iterator _iter977;
      for (_iter977 = this->targets.begin(); _iter977 != this->targets.end(); ++_iter977)
      {
        xfer += oprot->writeString(_iter977->first);
        xfer += oprot->writeString(_iter977->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.carriers) {
    xfer += oprot->writeFieldBegin("carriers", ::apache::thrift::protocol::T_MAP, 9);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_SET, static_cast<uint32_t>(this->carriers.size()));
      std::map<std::string, std::set<std::string> > ::const_iterator _iter978;
      for (_iter978 = this->carriers.begin(); _iter978 != this->carriers.end(); ++_iter978)
      {
        xfer += oprot->writeString(_iter978->first);
        {
          xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter978->second.size()));
          std::set<std::string> ::const_iterator _iter979;
          for (_iter979 = _iter978->second.begin(); _iter979 != _iter978->second.end(); ++_iter979)
          {
            xfer += oprot->writeString((*_iter979));
          }
          xfer += oprot->writeSetEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.full_replicas) {
    xfer += oprot->writeFieldBegin("full_replicas", ::apache::thrift::protocol::T_SET, 10);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->full_replicas.size()));
      std::set<std::string> ::const_iterator _iter980;
      for (_iter980 = this->full_replicas.begin(); _iter980 != this->full_replicas.end(); ++_iter980)
      {
        xfer += oprot->writeString((*_iter980));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.disk_ids) {
    xfer += oprot->writeFieldBegin("disk_ids", ::apache::thrift::protocol::T_MAP, 11);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->disk_ids.size()));
      std::map<std::string, std::string> ::const_iterator _iter981;
      for (_iter981 = this->disk_ids.begin(); _iter981 != this->disk_ids.end(); ++_iter981)
      {
        xfer += oprot->writeString(_iter981->first);
        xfer += oprot->writeString(_iter981->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cbt_info) {
    xfer += oprot->writeFieldBegin("cbt_info", ::apache::thrift::protocol::T_STRING, 12);
    xfer += oprot->writeString(this->cbt_info);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.snapshot_info) {
    xfer += oprot->writeFieldBegin("snapshot_info", ::apache::thrift::protocol::T_STRING, 13);
    xfer += oprot->writeString(this->snapshot_info);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.checksum_verify) {
    xfer += oprot->writeFieldBegin("checksum_verify", ::apache::thrift::protocol::T_BOOL, 14);
    xfer += oprot->writeBool(this->checksum_verify);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.always_retry) {
    xfer += oprot->writeFieldBegin("always_retry", ::apache::thrift::protocol::T_BOOL, 15);
    xfer += oprot->writeBool(this->always_retry);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timeout) {
    xfer += oprot->writeFieldBegin("timeout", ::apache::thrift::protocol::T_I32, 16);
    xfer += oprot->writeI32(this->timeout);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_encrypted) {
    xfer += oprot->writeFieldBegin("is_encrypted", ::apache::thrift::protocol::T_BOOL, 17);
    xfer += oprot->writeBool(this->is_encrypted);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_paused) {
    xfer += oprot->writeFieldBegin("is_paused", ::apache::thrift::protocol::T_BOOL, 18);
    xfer += oprot->writeBool(this->is_paused);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.worker_thread_number) {
    xfer += oprot->writeFieldBegin("worker_thread_number", ::apache::thrift::protocol::T_I32, 19);
    xfer += oprot->writeI32(this->worker_thread_number);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.block_mode_enable) {
    xfer += oprot->writeFieldBegin("block_mode_enable", ::apache::thrift::protocol::T_BOOL, 20);
    xfer += oprot->writeBool(this->block_mode_enable);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.file_system_filter_enable) {
    xfer += oprot->writeFieldBegin("file_system_filter_enable", ::apache::thrift::protocol::T_BOOL, 21);
    xfer += oprot->writeBool(this->file_system_filter_enable);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.min_transport_size) {
    xfer += oprot->writeFieldBegin("min_transport_size", ::apache::thrift::protocol::T_I32, 22);
    xfer += oprot->writeI32(this->min_transport_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.full_min_transport_size) {
    xfer += oprot->writeFieldBegin("full_min_transport_size", ::apache::thrift::protocol::T_I32, 23);
    xfer += oprot->writeI32(this->full_min_transport_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_full_replica) {
    xfer += oprot->writeFieldBegin("is_full_replica", ::apache::thrift::protocol::T_BOOL, 24);
    xfer += oprot->writeBool(this->is_full_replica);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.buffer_size) {
    xfer += oprot->writeFieldBegin("buffer_size", ::apache::thrift::protocol::T_I32, 25);
    xfer += oprot->writeI32(this->buffer_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_compressed) {
    xfer += oprot->writeFieldBegin("is_compressed", ::apache::thrift::protocol::T_BOOL, 26);
    xfer += oprot->writeBool(this->is_compressed);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_checksum) {
    xfer += oprot->writeFieldBegin("is_checksum", ::apache::thrift::protocol::T_BOOL, 27);
    xfer += oprot->writeBool(this->is_checksum);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.time) {
    xfer += oprot->writeFieldBegin("time", ::apache::thrift::protocol::T_STRING, 28);
    xfer += oprot->writeString(this->time);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.priority_carrier) {
    xfer += oprot->writeFieldBegin("priority_carrier", ::apache::thrift::protocol::T_MAP, 29);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->priority_carrier.size()));
      std::map<std::string, std::string> ::const_iterator _iter982;
      for (_iter982 = this->priority_carrier.begin(); _iter982 != this->priority_carrier.end(); ++_iter982)
      {
        xfer += oprot->writeString(_iter982->first);
        xfer += oprot->writeString(_iter982->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_only_single_system_disk) {
    xfer += oprot->writeFieldBegin("is_only_single_system_disk", ::apache::thrift::protocol::T_BOOL, 30);
    xfer += oprot->writeBool(this->is_only_single_system_disk);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_continuous_data_replication) {
    xfer += oprot->writeFieldBegin("is_continuous_data_replication", ::apache::thrift::protocol::T_BOOL, 31);
    xfer += oprot->writeBool(this->is_continuous_data_replication);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.pre_snapshot_script) {
    xfer += oprot->writeFieldBegin("pre_snapshot_script", ::apache::thrift::protocol::T_STRING, 32);
    xfer += oprot->writeString(this->pre_snapshot_script);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.post_snapshot_script) {
    xfer += oprot->writeFieldBegin("post_snapshot_script", ::apache::thrift::protocol::T_STRING, 33);
    xfer += oprot->writeString(this->post_snapshot_script);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_compressed_by_packer) {
    xfer += oprot->writeFieldBegin("is_compressed_by_packer", ::apache::thrift::protocol::T_BOOL, 34);
    xfer += oprot->writeBool(this->is_compressed_by_packer);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.excluded_paths) {
    xfer += oprot->writeFieldBegin("excluded_paths", ::apache::thrift::protocol::T_SET, 35);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->excluded_paths.size()));
      std::set<std::string> ::const_iterator _iter983;
      for (_iter983 = this->excluded_paths.begin(); _iter983 != this->excluded_paths.end(); ++_iter983)
      {
        xfer += oprot->writeString((*_iter983));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.previous_excluded_paths) {
    xfer += oprot->writeFieldBegin("previous_excluded_paths", ::apache::thrift::protocol::T_SET, 36);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->previous_excluded_paths.size()));
      std::set<std::string> ::const_iterator _iter984;
      for (_iter984 = this->previous_excluded_paths.begin(); _iter984 != this->previous_excluded_paths.end(); ++_iter984)
      {
        xfer += oprot->writeString((*_iter984));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(replica_job_create_detail &a, replica_job_create_detail &b) {
  using ::std::swap;
  swap(a.host, b.host);
  swap(a.addr, b.addr);
  swap(a.username, b.username);
  swap(a.password, b.password);
  swap(a.type, b.type);
  swap(a.virtual_machine_id, b.virtual_machine_id);
  swap(a.disks, b.disks);
  swap(a.targets, b.targets);
  swap(a.carriers, b.carriers);
  swap(a.full_replicas, b.full_replicas);
  swap(a.disk_ids, b.disk_ids);
  swap(a.cbt_info, b.cbt_info);
  swap(a.snapshot_info, b.snapshot_info);
  swap(a.checksum_verify, b.checksum_verify);
  swap(a.always_retry, b.always_retry);
  swap(a.timeout, b.timeout);
  swap(a.is_encrypted, b.is_encrypted);
  swap(a.is_paused, b.is_paused);
  swap(a.worker_thread_number, b.worker_thread_number);
  swap(a.block_mode_enable, b.block_mode_enable);
  swap(a.file_system_filter_enable, b.file_system_filter_enable);
  swap(a.min_transport_size, b.min_transport_size);
  swap(a.full_min_transport_size, b.full_min_transport_size);
  swap(a.is_full_replica, b.is_full_replica);
  swap(a.buffer_size, b.buffer_size);
  swap(a.is_compressed, b.is_compressed);
  swap(a.is_checksum, b.is_checksum);
  swap(a.time, b.time);
  swap(a.priority_carrier, b.priority_carrier);
  swap(a.is_only_single_system_disk, b.is_only_single_system_disk);
  swap(a.is_continuous_data_replication, b.is_continuous_data_replication);
  swap(a.pre_snapshot_script, b.pre_snapshot_script);
  swap(a.post_snapshot_script, b.post_snapshot_script);
  swap(a.is_compressed_by_packer, b.is_compressed_by_packer);
  swap(a.excluded_paths, b.excluded_paths);
  swap(a.previous_excluded_paths, b.previous_excluded_paths);
  swap(a.__isset, b.__isset);
}

replica_job_create_detail::replica_job_create_detail(const replica_job_create_detail& other985) {
  host = other985.host;
  addr = other985.addr;
  username = other985.username;
  password = other985.password;
  type = other985.type;
  virtual_machine_id = other985.virtual_machine_id;
  disks = other985.disks;
  targets = other985.targets;
  carriers = other985.carriers;
  full_replicas = other985.full_replicas;
  disk_ids = other985.disk_ids;
  cbt_info = other985.cbt_info;
  snapshot_info = other985.snapshot_info;
  checksum_verify = other985.checksum_verify;
  always_retry = other985.always_retry;
  timeout = other985.timeout;
  is_encrypted = other985.is_encrypted;
  is_paused = other985.is_paused;
  worker_thread_number = other985.worker_thread_number;
  block_mode_enable = other985.block_mode_enable;
  file_system_filter_enable = other985.file_system_filter_enable;
  min_transport_size = other985.min_transport_size;
  full_min_transport_size = other985.full_min_transport_size;
  is_full_replica = other985.is_full_replica;
  buffer_size = other985.buffer_size;
  is_compressed = other985.is_compressed;
  is_checksum = other985.is_checksum;
  time = other985.time;
  priority_carrier = other985.priority_carrier;
  is_only_single_system_disk = other985.is_only_single_system_disk;
  is_continuous_data_replication = other985.is_continuous_data_replication;
  pre_snapshot_script = other985.pre_snapshot_script;
  post_snapshot_script = other985.post_snapshot_script;
  is_compressed_by_packer = other985.is_compressed_by_packer;
  excluded_paths = other985.excluded_paths;
  previous_excluded_paths = other985.previous_excluded_paths;
  __isset = other985.__isset;
}
replica_job_create_detail& replica_job_create_detail::operator=(const replica_job_create_detail& other986) {
  host = other986.host;
  addr = other986.addr;
  username = other986.username;
  password = other986.password;
  type = other986.type;
  virtual_machine_id = other986.virtual_machine_id;
  disks = other986.disks;
  targets = other986.targets;
  carriers = other986.carriers;
  full_replicas = other986.full_replicas;
  disk_ids = other986.disk_ids;
  cbt_info = other986.cbt_info;
  snapshot_info = other986.snapshot_info;
  checksum_verify = other986.checksum_verify;
  always_retry = other986.always_retry;
  timeout = other986.timeout;
  is_encrypted = other986.is_encrypted;
  is_paused = other986.is_paused;
  worker_thread_number = other986.worker_thread_number;
  block_mode_enable = other986.block_mode_enable;
  file_system_filter_enable = other986.file_system_filter_enable;
  min_transport_size = other986.min_transport_size;
  full_min_transport_size = other986.full_min_transport_size;
  is_full_replica = other986.is_full_replica;
  buffer_size = other986.buffer_size;
  is_compressed = other986.is_compressed;
  is_checksum = other986.is_checksum;
  time = other986.time;
  priority_carrier = other986.priority_carrier;
  is_only_single_system_disk = other986.is_only_single_system_disk;
  is_continuous_data_replication = other986.is_continuous_data_replication;
  pre_snapshot_script = other986.pre_snapshot_script;
  post_snapshot_script = other986.post_snapshot_script;
  is_compressed_by_packer = other986.is_compressed_by_packer;
  excluded_paths = other986.excluded_paths;
  previous_excluded_paths = other986.previous_excluded_paths;
  __isset = other986.__isset;
  return *this;
}
void replica_job_create_detail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "replica_job_create_detail(";
  out << "host="; (__isset.host ? (out << to_string(host)) : (out << "<null>"));
  out << ", " << "addr="; (__isset.addr ? (out << to_string(addr)) : (out << "<null>"));
  out << ", " << "username="; (__isset.username ? (out << to_string(username)) : (out << "<null>"));
  out << ", " << "password="; (__isset.password ? (out << to_string(password)) : (out << "<null>"));
  out << ", " << "type="; (__isset.type ? (out << to_string(type)) : (out << "<null>"));
  out << ", " << "virtual_machine_id="; (__isset.virtual_machine_id ? (out << to_string(virtual_machine_id)) : (out << "<null>"));
  out << ", " << "disks="; (__isset.disks ? (out << to_string(disks)) : (out << "<null>"));
  out << ", " << "targets="; (__isset.targets ? (out << to_string(targets)) : (out << "<null>"));
  out << ", " << "carriers="; (__isset.carriers ? (out << to_string(carriers)) : (out << "<null>"));
  out << ", " << "full_replicas="; (__isset.full_replicas ? (out << to_string(full_replicas)) : (out << "<null>"));
  out << ", " << "disk_ids="; (__isset.disk_ids ? (out << to_string(disk_ids)) : (out << "<null>"));
  out << ", " << "cbt_info="; (__isset.cbt_info ? (out << to_string(cbt_info)) : (out << "<null>"));
  out << ", " << "snapshot_info="; (__isset.snapshot_info ? (out << to_string(snapshot_info)) : (out << "<null>"));
  out << ", " << "checksum_verify="; (__isset.checksum_verify ? (out << to_string(checksum_verify)) : (out << "<null>"));
  out << ", " << "always_retry="; (__isset.always_retry ? (out << to_string(always_retry)) : (out << "<null>"));
  out << ", " << "timeout="; (__isset.timeout ? (out << to_string(timeout)) : (out << "<null>"));
  out << ", " << "is_encrypted="; (__isset.is_encrypted ? (out << to_string(is_encrypted)) : (out << "<null>"));
  out << ", " << "is_paused="; (__isset.is_paused ? (out << to_string(is_paused)) : (out << "<null>"));
  out << ", " << "worker_thread_number="; (__isset.worker_thread_number ? (out << to_string(worker_thread_number)) : (out << "<null>"));
  out << ", " << "block_mode_enable="; (__isset.block_mode_enable ? (out << to_string(block_mode_enable)) : (out << "<null>"));
  out << ", " << "file_system_filter_enable="; (__isset.file_system_filter_enable ? (out << to_string(file_system_filter_enable)) : (out << "<null>"));
  out << ", " << "min_transport_size="; (__isset.min_transport_size ? (out << to_string(min_transport_size)) : (out << "<null>"));
  out << ", " << "full_min_transport_size="; (__isset.full_min_transport_size ? (out << to_string(full_min_transport_size)) : (out << "<null>"));
  out << ", " << "is_full_replica="; (__isset.is_full_replica ? (out << to_string(is_full_replica)) : (out << "<null>"));
  out << ", " << "buffer_size="; (__isset.buffer_size ? (out << to_string(buffer_size)) : (out << "<null>"));
  out << ", " << "is_compressed="; (__isset.is_compressed ? (out << to_string(is_compressed)) : (out << "<null>"));
  out << ", " << "is_checksum="; (__isset.is_checksum ? (out << to_string(is_checksum)) : (out << "<null>"));
  out << ", " << "time="; (__isset.time ? (out << to_string(time)) : (out << "<null>"));
  out << ", " << "priority_carrier="; (__isset.priority_carrier ? (out << to_string(priority_carrier)) : (out << "<null>"));
  out << ", " << "is_only_single_system_disk="; (__isset.is_only_single_system_disk ? (out << to_string(is_only_single_system_disk)) : (out << "<null>"));
  out << ", " << "is_continuous_data_replication="; (__isset.is_continuous_data_replication ? (out << to_string(is_continuous_data_replication)) : (out << "<null>"));
  out << ", " << "pre_snapshot_script="; (__isset.pre_snapshot_script ? (out << to_string(pre_snapshot_script)) : (out << "<null>"));
  out << ", " << "post_snapshot_script="; (__isset.post_snapshot_script ? (out << to_string(post_snapshot_script)) : (out << "<null>"));
  out << ", " << "is_compressed_by_packer="; (__isset.is_compressed_by_packer ? (out << to_string(is_compressed_by_packer)) : (out << "<null>"));
  out << ", " << "excluded_paths="; (__isset.excluded_paths ? (out << to_string(excluded_paths)) : (out << "<null>"));
  out << ", " << "previous_excluded_paths="; (__isset.previous_excluded_paths ? (out << to_string(previous_excluded_paths)) : (out << "<null>"));
  out << ")";
}


vmware_connection_info::~vmware_connection_info() throw() {
}


void vmware_connection_info::__set_host(const std::string& val) {
  this->host = val;
__isset.host = true;
}

void vmware_connection_info::__set_username(const std::string& val) {
  this->username = val;
__isset.username = true;
}

void vmware_connection_info::__set_password(const std::string& val) {
  this->password = val;
__isset.password = true;
}

void vmware_connection_info::__set_esx(const std::string& val) {
  this->esx = val;
__isset.esx = true;
}

void vmware_connection_info::__set_datastore(const std::string& val) {
  this->datastore = val;
__isset.datastore = true;
}

void vmware_connection_info::__set_folder_path(const std::string& val) {
  this->folder_path = val;
__isset.folder_path = true;
}
std::ostream& operator<<(std::ostream& out, const vmware_connection_info& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t vmware_connection_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host);
          this->__isset.host = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->username);
          this->__isset.username = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->password);
          this->__isset.password = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->esx);
          this->__isset.esx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->datastore);
          this->__isset.datastore = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->folder_path);
          this->__isset.folder_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t vmware_connection_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("vmware_connection_info");

  if (this->__isset.host) {
    xfer += oprot->writeFieldBegin("host", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->host);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.username) {
    xfer += oprot->writeFieldBegin("username", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->username);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.password) {
    xfer += oprot->writeFieldBegin("password", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->password);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.esx) {
    xfer += oprot->writeFieldBegin("esx", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->esx);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.datastore) {
    xfer += oprot->writeFieldBegin("datastore", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->datastore);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.folder_path) {
    xfer += oprot->writeFieldBegin("folder_path", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->folder_path);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(vmware_connection_info &a, vmware_connection_info &b) {
  using ::std::swap;
  swap(a.host, b.host);
  swap(a.username, b.username);
  swap(a.password, b.password);
  swap(a.esx, b.esx);
  swap(a.datastore, b.datastore);
  swap(a.folder_path, b.folder_path);
  swap(a.__isset, b.__isset);
}

vmware_connection_info::vmware_connection_info(const vmware_connection_info& other987) {
  host = other987.host;
  username = other987.username;
  password = other987.password;
  esx = other987.esx;
  datastore = other987.datastore;
  folder_path = other987.folder_path;
  __isset = other987.__isset;
}
vmware_connection_info& vmware_connection_info::operator=(const vmware_connection_info& other988) {
  host = other988.host;
  username = other988.username;
  password = other988.password;
  esx = other988.esx;
  datastore = other988.datastore;
  folder_path = other988.folder_path;
  __isset = other988.__isset;
  return *this;
}
void vmware_connection_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "vmware_connection_info(";
  out << "host="; (__isset.host ? (out << to_string(host)) : (out << "<null>"));
  out << ", " << "username="; (__isset.username ? (out << to_string(username)) : (out << "<null>"));
  out << ", " << "password="; (__isset.password ? (out << to_string(password)) : (out << "<null>"));
  out << ", " << "esx="; (__isset.esx ? (out << to_string(esx)) : (out << "<null>"));
  out << ", " << "datastore="; (__isset.datastore ? (out << to_string(datastore)) : (out << "<null>"));
  out << ", " << "folder_path="; (__isset.folder_path ? (out << to_string(folder_path)) : (out << "<null>"));
  out << ")";
}


vmware_options::~vmware_options() throw() {
}


void vmware_options::__set_connection(const vmware_connection_info& val) {
  this->connection = val;
__isset.connection = true;
}

void vmware_options::__set_virtual_machine_id(const std::string& val) {
  this->virtual_machine_id = val;
__isset.virtual_machine_id = true;
}

void vmware_options::__set_virtual_machine_snapshot(const std::string& val) {
  this->virtual_machine_snapshot = val;
__isset.virtual_machine_snapshot = true;
}

void vmware_options::__set_number_of_cpus(const int32_t val) {
  this->number_of_cpus = val;
__isset.number_of_cpus = true;
}

void vmware_options::__set_number_of_memory_in_mb(const int32_t val) {
  this->number_of_memory_in_mb = val;
__isset.number_of_memory_in_mb = true;
}

void vmware_options::__set_vm_name(const std::string& val) {
  this->vm_name = val;
__isset.vm_name = true;
}

void vmware_options::__set_network_connections(const std::vector<std::string> & val) {
  this->network_connections = val;
__isset.network_connections = true;
}

void vmware_options::__set_network_adapters(const std::vector<std::string> & val) {
  this->network_adapters = val;
__isset.network_adapters = true;
}

void vmware_options::__set_scsi_adapters(const std::map<hv_controller_type::type, std::vector<std::string> > & val) {
  this->scsi_adapters = val;
__isset.scsi_adapters = true;
}

void vmware_options::__set_guest_id(const std::string& val) {
  this->guest_id = val;
__isset.guest_id = true;
}

void vmware_options::__set_firmware(const hv_vm_firmware::type val) {
  this->firmware = val;
__isset.firmware = true;
}

void vmware_options::__set_install_vm_tools(const bool val) {
  this->install_vm_tools = val;
__isset.install_vm_tools = true;
}

void vmware_options::__set_mac_addresses(const std::vector<std::string> & val) {
  this->mac_addresses = val;
__isset.mac_addresses = true;
}
std::ostream& operator<<(std::ostream& out, const vmware_options& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t vmware_options::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->connection.read(iprot);
          this->__isset.connection = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->virtual_machine_id);
          this->__isset.virtual_machine_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->virtual_machine_snapshot);
          this->__isset.virtual_machine_snapshot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->number_of_cpus);
          this->__isset.number_of_cpus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->number_of_memory_in_mb);
          this->__isset.number_of_memory_in_mb = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->vm_name);
          this->__isset.vm_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->network_connections.clear();
            uint32_t _size989;
            ::apache::thrift::protocol::TType _etype992;
            xfer += iprot->readListBegin(_etype992, _size989);
            this->network_connections.resize(_size989);
            uint32_t _i993;
            for (_i993 = 0; _i993 < _size989; ++_i993)
            {
              xfer += iprot->readString(this->network_connections[_i993]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.network_connections = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->network_adapters.clear();
            uint32_t _size994;
            ::apache::thrift::protocol::TType _etype997;
            xfer += iprot->readListBegin(_etype997, _size994);
            this->network_adapters.resize(_size994);
            uint32_t _i998;
            for (_i998 = 0; _i998 < _size994; ++_i998)
            {
              xfer += iprot->readString(this->network_adapters[_i998]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.network_adapters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->scsi_adapters.clear();
            uint32_t _size999;
            ::apache::thrift::protocol::TType _ktype1000;
            ::apache::thrift::protocol::TType _vtype1001;
            xfer += iprot->readMapBegin(_ktype1000, _vtype1001, _size999);
            uint32_t _i1003;
            for (_i1003 = 0; _i1003 < _size999; ++_i1003)
            {
              hv_controller_type::type _key1004;
              int32_t ecast1006;
              xfer += iprot->readI32(ecast1006);
              _key1004 = (hv_controller_type::type)ecast1006;
              std::vector<std::string> & _val1005 = this->scsi_adapters[_key1004];
              {
                _val1005.clear();
                uint32_t _size1007;
                ::apache::thrift::protocol::TType _etype1010;
                xfer += iprot->readListBegin(_etype1010, _size1007);
                _val1005.resize(_size1007);
                uint32_t _i1011;
                for (_i1011 = 0; _i1011 < _size1007; ++_i1011)
                {
                  xfer += iprot->readString(_val1005[_i1011]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.scsi_adapters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guest_id);
          this->__isset.guest_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1012;
          xfer += iprot->readI32(ecast1012);
          this->firmware = (hv_vm_firmware::type)ecast1012;
          this->__isset.firmware = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->install_vm_tools);
          this->__isset.install_vm_tools = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->mac_addresses.clear();
            uint32_t _size1013;
            ::apache::thrift::protocol::TType _etype1016;
            xfer += iprot->readListBegin(_etype1016, _size1013);
            this->mac_addresses.resize(_size1013);
            uint32_t _i1017;
            for (_i1017 = 0; _i1017 < _size1013; ++_i1017)
            {
              xfer += iprot->readString(this->mac_addresses[_i1017]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.mac_addresses = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t vmware_options::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("vmware_options");

  if (this->__isset.connection) {
    xfer += oprot->writeFieldBegin("connection", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->connection.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.virtual_machine_id) {
    xfer += oprot->writeFieldBegin("virtual_machine_id", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->virtual_machine_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.virtual_machine_snapshot) {
    xfer += oprot->writeFieldBegin("virtual_machine_snapshot", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->virtual_machine_snapshot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.number_of_cpus) {
    xfer += oprot->writeFieldBegin("number_of_cpus", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->number_of_cpus);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.number_of_memory_in_mb) {
    xfer += oprot->writeFieldBegin("number_of_memory_in_mb", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->number_of_memory_in_mb);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vm_name) {
    xfer += oprot->writeFieldBegin("vm_name", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->vm_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.network_connections) {
    xfer += oprot->writeFieldBegin("network_connections", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->network_connections.size()));
      std::vector<std::string> ::const_iterator _iter1018;
      for (_iter1018 = this->network_connections.begin(); _iter1018 != this->network_connections.end(); ++_iter1018)
      {
        xfer += oprot->writeString((*_iter1018));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.network_adapters) {
    xfer += oprot->writeFieldBegin("network_adapters", ::apache::thrift::protocol::T_LIST, 8);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->network_adapters.size()));
      std::vector<std::string> ::const_iterator _iter1019;
      for (_iter1019 = this->network_adapters.begin(); _iter1019 != this->network_adapters.end(); ++_iter1019)
      {
        xfer += oprot->writeString((*_iter1019));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.scsi_adapters) {
    xfer += oprot->writeFieldBegin("scsi_adapters", ::apache::thrift::protocol::T_MAP, 9);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->scsi_adapters.size()));
      std::map<hv_controller_type::type, std::vector<std::string> > ::const_iterator _iter1020;
      for (_iter1020 = this->scsi_adapters.begin(); _iter1020 != this->scsi_adapters.end(); ++_iter1020)
      {
        xfer += oprot->writeI32((int32_t)_iter1020->first);
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter1020->second.size()));
          std::vector<std::string> ::const_iterator _iter1021;
          for (_iter1021 = _iter1020->second.begin(); _iter1021 != _iter1020->second.end(); ++_iter1021)
          {
            xfer += oprot->writeString((*_iter1021));
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.guest_id) {
    xfer += oprot->writeFieldBegin("guest_id", ::apache::thrift::protocol::T_STRING, 10);
    xfer += oprot->writeString(this->guest_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.firmware) {
    xfer += oprot->writeFieldBegin("firmware", ::apache::thrift::protocol::T_I32, 11);
    xfer += oprot->writeI32((int32_t)this->firmware);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.install_vm_tools) {
    xfer += oprot->writeFieldBegin("install_vm_tools", ::apache::thrift::protocol::T_BOOL, 12);
    xfer += oprot->writeBool(this->install_vm_tools);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mac_addresses) {
    xfer += oprot->writeFieldBegin("mac_addresses", ::apache::thrift::protocol::T_LIST, 13);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->mac_addresses.size()));
      std::vector<std::string> ::const_iterator _iter1022;
      for (_iter1022 = this->mac_addresses.begin(); _iter1022 != this->mac_addresses.end(); ++_iter1022)
      {
        xfer += oprot->writeString((*_iter1022));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(vmware_options &a, vmware_options &b) {
  using ::std::swap;
  swap(a.connection, b.connection);
  swap(a.virtual_machine_id, b.virtual_machine_id);
  swap(a.virtual_machine_snapshot, b.virtual_machine_snapshot);
  swap(a.number_of_cpus, b.number_of_cpus);
  swap(a.number_of_memory_in_mb, b.number_of_memory_in_mb);
  swap(a.vm_name, b.vm_name);
  swap(a.network_connections, b.network_connections);
  swap(a.network_adapters, b.network_adapters);
  swap(a.scsi_adapters, b.scsi_adapters);
  swap(a.guest_id, b.guest_id);
  swap(a.firmware, b.firmware);
  swap(a.install_vm_tools, b.install_vm_tools);
  swap(a.mac_addresses, b.mac_addresses);
  swap(a.__isset, b.__isset);
}

vmware_options::vmware_options(const vmware_options& other1023) {
  connection = other1023.connection;
  virtual_machine_id = other1023.virtual_machine_id;
  virtual_machine_snapshot = other1023.virtual_machine_snapshot;
  number_of_cpus = other1023.number_of_cpus;
  number_of_memory_in_mb = other1023.number_of_memory_in_mb;
  vm_name = other1023.vm_name;
  network_connections = other1023.network_connections;
  network_adapters = other1023.network_adapters;
  scsi_adapters = other1023.scsi_adapters;
  guest_id = other1023.guest_id;
  firmware = other1023.firmware;
  install_vm_tools = other1023.install_vm_tools;
  mac_addresses = other1023.mac_addresses;
  __isset = other1023.__isset;
}
vmware_options& vmware_options::operator=(const vmware_options& other1024) {
  connection = other1024.connection;
  virtual_machine_id = other1024.virtual_machine_id;
  virtual_machine_snapshot = other1024.virtual_machine_snapshot;
  number_of_cpus = other1024.number_of_cpus;
  number_of_memory_in_mb = other1024.number_of_memory_in_mb;
  vm_name = other1024.vm_name;
  network_connections = other1024.network_connections;
  network_adapters = other1024.network_adapters;
  scsi_adapters = other1024.scsi_adapters;
  guest_id = other1024.guest_id;
  firmware = other1024.firmware;
  install_vm_tools = other1024.install_vm_tools;
  mac_addresses = other1024.mac_addresses;
  __isset = other1024.__isset;
  return *this;
}
void vmware_options::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "vmware_options(";
  out << "connection="; (__isset.connection ? (out << to_string(connection)) : (out << "<null>"));
  out << ", " << "virtual_machine_id="; (__isset.virtual_machine_id ? (out << to_string(virtual_machine_id)) : (out << "<null>"));
  out << ", " << "virtual_machine_snapshot="; (__isset.virtual_machine_snapshot ? (out << to_string(virtual_machine_snapshot)) : (out << "<null>"));
  out << ", " << "number_of_cpus="; (__isset.number_of_cpus ? (out << to_string(number_of_cpus)) : (out << "<null>"));
  out << ", " << "number_of_memory_in_mb="; (__isset.number_of_memory_in_mb ? (out << to_string(number_of_memory_in_mb)) : (out << "<null>"));
  out << ", " << "vm_name="; (__isset.vm_name ? (out << to_string(vm_name)) : (out << "<null>"));
  out << ", " << "network_connections="; (__isset.network_connections ? (out << to_string(network_connections)) : (out << "<null>"));
  out << ", " << "network_adapters="; (__isset.network_adapters ? (out << to_string(network_adapters)) : (out << "<null>"));
  out << ", " << "scsi_adapters="; (__isset.scsi_adapters ? (out << to_string(scsi_adapters)) : (out << "<null>"));
  out << ", " << "guest_id="; (__isset.guest_id ? (out << to_string(guest_id)) : (out << "<null>"));
  out << ", " << "firmware="; (__isset.firmware ? (out << to_string(firmware)) : (out << "<null>"));
  out << ", " << "install_vm_tools="; (__isset.install_vm_tools ? (out << to_string(install_vm_tools)) : (out << "<null>"));
  out << ", " << "mac_addresses="; (__isset.mac_addresses ? (out << to_string(mac_addresses)) : (out << "<null>"));
  out << ")";
}


aliyun_options::~aliyun_options() throw() {
}


void aliyun_options::__set_access_key(const std::string& val) {
  this->access_key = val;
__isset.access_key = true;
}

void aliyun_options::__set_secret_key(const std::string& val) {
  this->secret_key = val;
__isset.secret_key = true;
}

void aliyun_options::__set_objectname(const std::string& val) {
  this->objectname = val;
__isset.objectname = true;
}

void aliyun_options::__set_bucketname(const std::string& val) {
  this->bucketname = val;
__isset.bucketname = true;
}

void aliyun_options::__set_region(const std::string& val) {
  this->region = val;
__isset.region = true;
}

void aliyun_options::__set_max_size(const int32_t val) {
  this->max_size = val;
__isset.max_size = true;
}

void aliyun_options::__set_file_system_filter_enable(const bool val) {
  this->file_system_filter_enable = val;
__isset.file_system_filter_enable = true;
}

void aliyun_options::__set_number_of_upload_threads(const int16_t val) {
  this->number_of_upload_threads = val;
__isset.number_of_upload_threads = true;
}

void aliyun_options::__set_disks_object_name_mapping(const std::map<std::string, std::string> & val) {
  this->disks_object_name_mapping = val;
__isset.disks_object_name_mapping = true;
}
std::ostream& operator<<(std::ostream& out, const aliyun_options& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t aliyun_options::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->access_key);
          this->__isset.access_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->secret_key);
          this->__isset.secret_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->objectname);
          this->__isset.objectname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->bucketname);
          this->__isset.bucketname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->region);
          this->__isset.region = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->max_size);
          this->__isset.max_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->file_system_filter_enable);
          this->__isset.file_system_filter_enable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->number_of_upload_threads);
          this->__isset.number_of_upload_threads = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->disks_object_name_mapping.clear();
            uint32_t _size1025;
            ::apache::thrift::protocol::TType _ktype1026;
            ::apache::thrift::protocol::TType _vtype1027;
            xfer += iprot->readMapBegin(_ktype1026, _vtype1027, _size1025);
            uint32_t _i1029;
            for (_i1029 = 0; _i1029 < _size1025; ++_i1029)
            {
              std::string _key1030;
              xfer += iprot->readString(_key1030);
              std::string& _val1031 = this->disks_object_name_mapping[_key1030];
              xfer += iprot->readString(_val1031);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.disks_object_name_mapping = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t aliyun_options::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("aliyun_options");

  if (this->__isset.access_key) {
    xfer += oprot->writeFieldBegin("access_key", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->access_key);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.secret_key) {
    xfer += oprot->writeFieldBegin("secret_key", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->secret_key);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.objectname) {
    xfer += oprot->writeFieldBegin("objectname", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->objectname);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.bucketname) {
    xfer += oprot->writeFieldBegin("bucketname", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->bucketname);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.region) {
    xfer += oprot->writeFieldBegin("region", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->region);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.max_size) {
    xfer += oprot->writeFieldBegin("max_size", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(this->max_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.file_system_filter_enable) {
    xfer += oprot->writeFieldBegin("file_system_filter_enable", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->file_system_filter_enable);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.number_of_upload_threads) {
    xfer += oprot->writeFieldBegin("number_of_upload_threads", ::apache::thrift::protocol::T_I16, 8);
    xfer += oprot->writeI16(this->number_of_upload_threads);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.disks_object_name_mapping) {
    xfer += oprot->writeFieldBegin("disks_object_name_mapping", ::apache::thrift::protocol::T_MAP, 9);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->disks_object_name_mapping.size()));
      std::map<std::string, std::string> ::const_iterator _iter1032;
      for (_iter1032 = this->disks_object_name_mapping.begin(); _iter1032 != this->disks_object_name_mapping.end(); ++_iter1032)
      {
        xfer += oprot->writeString(_iter1032->first);
        xfer += oprot->writeString(_iter1032->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(aliyun_options &a, aliyun_options &b) {
  using ::std::swap;
  swap(a.access_key, b.access_key);
  swap(a.secret_key, b.secret_key);
  swap(a.objectname, b.objectname);
  swap(a.bucketname, b.bucketname);
  swap(a.region, b.region);
  swap(a.max_size, b.max_size);
  swap(a.file_system_filter_enable, b.file_system_filter_enable);
  swap(a.number_of_upload_threads, b.number_of_upload_threads);
  swap(a.disks_object_name_mapping, b.disks_object_name_mapping);
  swap(a.__isset, b.__isset);
}

aliyun_options::aliyun_options(const aliyun_options& other1033) {
  access_key = other1033.access_key;
  secret_key = other1033.secret_key;
  objectname = other1033.objectname;
  bucketname = other1033.bucketname;
  region = other1033.region;
  max_size = other1033.max_size;
  file_system_filter_enable = other1033.file_system_filter_enable;
  number_of_upload_threads = other1033.number_of_upload_threads;
  disks_object_name_mapping = other1033.disks_object_name_mapping;
  __isset = other1033.__isset;
}
aliyun_options& aliyun_options::operator=(const aliyun_options& other1034) {
  access_key = other1034.access_key;
  secret_key = other1034.secret_key;
  objectname = other1034.objectname;
  bucketname = other1034.bucketname;
  region = other1034.region;
  max_size = other1034.max_size;
  file_system_filter_enable = other1034.file_system_filter_enable;
  number_of_upload_threads = other1034.number_of_upload_threads;
  disks_object_name_mapping = other1034.disks_object_name_mapping;
  __isset = other1034.__isset;
  return *this;
}
void aliyun_options::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "aliyun_options(";
  out << "access_key="; (__isset.access_key ? (out << to_string(access_key)) : (out << "<null>"));
  out << ", " << "secret_key="; (__isset.secret_key ? (out << to_string(secret_key)) : (out << "<null>"));
  out << ", " << "objectname="; (__isset.objectname ? (out << to_string(objectname)) : (out << "<null>"));
  out << ", " << "bucketname="; (__isset.bucketname ? (out << to_string(bucketname)) : (out << "<null>"));
  out << ", " << "region="; (__isset.region ? (out << to_string(region)) : (out << "<null>"));
  out << ", " << "max_size="; (__isset.max_size ? (out << to_string(max_size)) : (out << "<null>"));
  out << ", " << "file_system_filter_enable="; (__isset.file_system_filter_enable ? (out << to_string(file_system_filter_enable)) : (out << "<null>"));
  out << ", " << "number_of_upload_threads="; (__isset.number_of_upload_threads ? (out << to_string(number_of_upload_threads)) : (out << "<null>"));
  out << ", " << "disks_object_name_mapping="; (__isset.disks_object_name_mapping ? (out << to_string(disks_object_name_mapping)) : (out << "<null>"));
  out << ")";
}


tencent_options::~tencent_options() throw() {
}


void tencent_options::__set_access_key(const std::string& val) {
  this->access_key = val;
__isset.access_key = true;
}

void tencent_options::__set_secret_key(const std::string& val) {
  this->secret_key = val;
__isset.secret_key = true;
}

void tencent_options::__set_objectname(const std::string& val) {
  this->objectname = val;
__isset.objectname = true;
}

void tencent_options::__set_bucketname(const std::string& val) {
  this->bucketname = val;
__isset.bucketname = true;
}

void tencent_options::__set_region(const std::string& val) {
  this->region = val;
__isset.region = true;
}

void tencent_options::__set_max_size(const int32_t val) {
  this->max_size = val;
__isset.max_size = true;
}

void tencent_options::__set_file_system_filter_enable(const bool val) {
  this->file_system_filter_enable = val;
__isset.file_system_filter_enable = true;
}

void tencent_options::__set_number_of_upload_threads(const int16_t val) {
  this->number_of_upload_threads = val;
__isset.number_of_upload_threads = true;
}

void tencent_options::__set_disks_object_name_mapping(const std::map<std::string, std::string> & val) {
  this->disks_object_name_mapping = val;
__isset.disks_object_name_mapping = true;
}
std::ostream& operator<<(std::ostream& out, const tencent_options& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t tencent_options::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->access_key);
          this->__isset.access_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->secret_key);
          this->__isset.secret_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->objectname);
          this->__isset.objectname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->bucketname);
          this->__isset.bucketname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->region);
          this->__isset.region = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->max_size);
          this->__isset.max_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->file_system_filter_enable);
          this->__isset.file_system_filter_enable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->number_of_upload_threads);
          this->__isset.number_of_upload_threads = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->disks_object_name_mapping.clear();
            uint32_t _size1035;
            ::apache::thrift::protocol::TType _ktype1036;
            ::apache::thrift::protocol::TType _vtype1037;
            xfer += iprot->readMapBegin(_ktype1036, _vtype1037, _size1035);
            uint32_t _i1039;
            for (_i1039 = 0; _i1039 < _size1035; ++_i1039)
            {
              std::string _key1040;
              xfer += iprot->readString(_key1040);
              std::string& _val1041 = this->disks_object_name_mapping[_key1040];
              xfer += iprot->readString(_val1041);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.disks_object_name_mapping = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t tencent_options::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("tencent_options");

  if (this->__isset.access_key) {
    xfer += oprot->writeFieldBegin("access_key", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->access_key);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.secret_key) {
    xfer += oprot->writeFieldBegin("secret_key", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->secret_key);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.objectname) {
    xfer += oprot->writeFieldBegin("objectname", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->objectname);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.bucketname) {
    xfer += oprot->writeFieldBegin("bucketname", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->bucketname);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.region) {
    xfer += oprot->writeFieldBegin("region", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->region);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.max_size) {
    xfer += oprot->writeFieldBegin("max_size", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(this->max_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.file_system_filter_enable) {
    xfer += oprot->writeFieldBegin("file_system_filter_enable", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->file_system_filter_enable);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.number_of_upload_threads) {
    xfer += oprot->writeFieldBegin("number_of_upload_threads", ::apache::thrift::protocol::T_I16, 8);
    xfer += oprot->writeI16(this->number_of_upload_threads);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.disks_object_name_mapping) {
    xfer += oprot->writeFieldBegin("disks_object_name_mapping", ::apache::thrift::protocol::T_MAP, 9);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->disks_object_name_mapping.size()));
      std::map<std::string, std::string> ::const_iterator _iter1042;
      for (_iter1042 = this->disks_object_name_mapping.begin(); _iter1042 != this->disks_object_name_mapping.end(); ++_iter1042)
      {
        xfer += oprot->writeString(_iter1042->first);
        xfer += oprot->writeString(_iter1042->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(tencent_options &a, tencent_options &b) {
  using ::std::swap;
  swap(a.access_key, b.access_key);
  swap(a.secret_key, b.secret_key);
  swap(a.objectname, b.objectname);
  swap(a.bucketname, b.bucketname);
  swap(a.region, b.region);
  swap(a.max_size, b.max_size);
  swap(a.file_system_filter_enable, b.file_system_filter_enable);
  swap(a.number_of_upload_threads, b.number_of_upload_threads);
  swap(a.disks_object_name_mapping, b.disks_object_name_mapping);
  swap(a.__isset, b.__isset);
}

tencent_options::tencent_options(const tencent_options& other1043) {
  access_key = other1043.access_key;
  secret_key = other1043.secret_key;
  objectname = other1043.objectname;
  bucketname = other1043.bucketname;
  region = other1043.region;
  max_size = other1043.max_size;
  file_system_filter_enable = other1043.file_system_filter_enable;
  number_of_upload_threads = other1043.number_of_upload_threads;
  disks_object_name_mapping = other1043.disks_object_name_mapping;
  __isset = other1043.__isset;
}
tencent_options& tencent_options::operator=(const tencent_options& other1044) {
  access_key = other1044.access_key;
  secret_key = other1044.secret_key;
  objectname = other1044.objectname;
  bucketname = other1044.bucketname;
  region = other1044.region;
  max_size = other1044.max_size;
  file_system_filter_enable = other1044.file_system_filter_enable;
  number_of_upload_threads = other1044.number_of_upload_threads;
  disks_object_name_mapping = other1044.disks_object_name_mapping;
  __isset = other1044.__isset;
  return *this;
}
void tencent_options::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "tencent_options(";
  out << "access_key="; (__isset.access_key ? (out << to_string(access_key)) : (out << "<null>"));
  out << ", " << "secret_key="; (__isset.secret_key ? (out << to_string(secret_key)) : (out << "<null>"));
  out << ", " << "objectname="; (__isset.objectname ? (out << to_string(objectname)) : (out << "<null>"));
  out << ", " << "bucketname="; (__isset.bucketname ? (out << to_string(bucketname)) : (out << "<null>"));
  out << ", " << "region="; (__isset.region ? (out << to_string(region)) : (out << "<null>"));
  out << ", " << "max_size="; (__isset.max_size ? (out << to_string(max_size)) : (out << "<null>"));
  out << ", " << "file_system_filter_enable="; (__isset.file_system_filter_enable ? (out << to_string(file_system_filter_enable)) : (out << "<null>"));
  out << ", " << "number_of_upload_threads="; (__isset.number_of_upload_threads ? (out << to_string(number_of_upload_threads)) : (out << "<null>"));
  out << ", " << "disks_object_name_mapping="; (__isset.disks_object_name_mapping ? (out << to_string(disks_object_name_mapping)) : (out << "<null>"));
  out << ")";
}


extra_options::~extra_options() throw() {
}


void extra_options::__set_aliyun(const aliyun_options& val) {
  this->aliyun = val;
__isset.aliyun = true;
}

void extra_options::__set_tencent(const tencent_options& val) {
  this->tencent = val;
__isset.tencent = true;
}
std::ostream& operator<<(std::ostream& out, const extra_options& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t extra_options::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->aliyun.read(iprot);
          this->__isset.aliyun = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tencent.read(iprot);
          this->__isset.tencent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t extra_options::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("extra_options");

  if (this->__isset.aliyun) {
    xfer += oprot->writeFieldBegin("aliyun", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->aliyun.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tencent) {
    xfer += oprot->writeFieldBegin("tencent", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->tencent.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(extra_options &a, extra_options &b) {
  using ::std::swap;
  swap(a.aliyun, b.aliyun);
  swap(a.tencent, b.tencent);
  swap(a.__isset, b.__isset);
}

extra_options::extra_options(const extra_options& other1045) {
  aliyun = other1045.aliyun;
  tencent = other1045.tencent;
  __isset = other1045.__isset;
}
extra_options& extra_options::operator=(const extra_options& other1046) {
  aliyun = other1046.aliyun;
  tencent = other1046.tencent;
  __isset = other1046.__isset;
  return *this;
}
void extra_options::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "extra_options(";
  out << "aliyun="; (__isset.aliyun ? (out << to_string(aliyun)) : (out << "<null>"));
  out << ", " << "tencent="; (__isset.tencent ? (out << to_string(tencent)) : (out << "<null>"));
  out << ")";
}


vhd_snapshot::~vhd_snapshot() throw() {
}


void vhd_snapshot::__set_id(const std::string& val) {
  this->id = val;
__isset.id = true;
}

void vhd_snapshot::__set_datetime(const std::string& val) {
  this->datetime = val;
__isset.datetime = true;
}

void vhd_snapshot::__set_name(const std::string& val) {
  this->name = val;
__isset.name = true;
}
std::ostream& operator<<(std::ostream& out, const vhd_snapshot& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t vhd_snapshot::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->datetime);
          this->__isset.datetime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t vhd_snapshot::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("vhd_snapshot");

  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.datetime) {
    xfer += oprot->writeFieldBegin("datetime", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->datetime);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(vhd_snapshot &a, vhd_snapshot &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.datetime, b.datetime);
  swap(a.name, b.name);
  swap(a.__isset, b.__isset);
}

vhd_snapshot::vhd_snapshot(const vhd_snapshot& other1047) {
  id = other1047.id;
  datetime = other1047.datetime;
  name = other1047.name;
  __isset = other1047.__isset;
}
vhd_snapshot& vhd_snapshot::operator=(const vhd_snapshot& other1048) {
  id = other1048.id;
  datetime = other1048.datetime;
  name = other1048.name;
  __isset = other1048.__isset;
  return *this;
}
void vhd_snapshot::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "vhd_snapshot(";
  out << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "datetime="; (__isset.datetime ? (out << to_string(datetime)) : (out << "<null>"));
  out << ", " << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
  out << ")";
}


cascading::~cascading() throw() {
}


void cascading::__set_level(const int32_t val) {
  this->level = val;
__isset.level = true;
}

void cascading::__set_machine_id(const std::string& val) {
  this->machine_id = val;
__isset.machine_id = true;
}

void cascading::__set_connection_info(const connection& val) {
  this->connection_info = val;
__isset.connection_info = true;
}

void cascading::__set_branches(const std::map<std::string, cascading> & val) {
  this->branches = val;
__isset.branches = true;
}
std::ostream& operator<<(std::ostream& out, const cascading& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t cascading::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->level);
          this->__isset.level = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->machine_id);
          this->__isset.machine_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->connection_info.read(iprot);
          this->__isset.connection_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->branches.clear();
            uint32_t _size1049;
            ::apache::thrift::protocol::TType _ktype1050;
            ::apache::thrift::protocol::TType _vtype1051;
            xfer += iprot->readMapBegin(_ktype1050, _vtype1051, _size1049);
            uint32_t _i1053;
            for (_i1053 = 0; _i1053 < _size1049; ++_i1053)
            {
              std::string _key1054;
              xfer += iprot->readString(_key1054);
              cascading& _val1055 = this->branches[_key1054];
              xfer += _val1055.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.branches = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t cascading::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("cascading");

  if (this->__isset.level) {
    xfer += oprot->writeFieldBegin("level", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->level);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.machine_id) {
    xfer += oprot->writeFieldBegin("machine_id", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->machine_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.connection_info) {
    xfer += oprot->writeFieldBegin("connection_info", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->connection_info.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.branches) {
    xfer += oprot->writeFieldBegin("branches", ::apache::thrift::protocol::T_MAP, 4);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->branches.size()));
      std::map<std::string, cascading> ::const_iterator _iter1056;
      for (_iter1056 = this->branches.begin(); _iter1056 != this->branches.end(); ++_iter1056)
      {
        xfer += oprot->writeString(_iter1056->first);
        xfer += _iter1056->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(cascading &a, cascading &b) {
  using ::std::swap;
  swap(a.level, b.level);
  swap(a.machine_id, b.machine_id);
  swap(a.connection_info, b.connection_info);
  swap(a.branches, b.branches);
  swap(a.__isset, b.__isset);
}

cascading::cascading(const cascading& other1057) {
  level = other1057.level;
  machine_id = other1057.machine_id;
  connection_info = other1057.connection_info;
  branches = other1057.branches;
  __isset = other1057.__isset;
}
cascading& cascading::operator=(const cascading& other1058) {
  level = other1058.level;
  machine_id = other1058.machine_id;
  connection_info = other1058.connection_info;
  branches = other1058.branches;
  __isset = other1058.__isset;
  return *this;
}
void cascading::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "cascading(";
  out << "level="; (__isset.level ? (out << to_string(level)) : (out << "<null>"));
  out << ", " << "machine_id="; (__isset.machine_id ? (out << to_string(machine_id)) : (out << "<null>"));
  out << ", " << "connection_info="; (__isset.connection_info ? (out << to_string(connection_info)) : (out << "<null>"));
  out << ", " << "branches="; (__isset.branches ? (out << to_string(branches)) : (out << "<null>"));
  out << ")";
}


loader_job_create_detail::~loader_job_create_detail() throw() {
}


void loader_job_create_detail::__set_replica_id(const std::string& val) {
  this->replica_id = val;
__isset.replica_id = true;
}

void loader_job_create_detail::__set_disks_lun_mapping(const std::map<std::string, std::string> & val) {
  this->disks_lun_mapping = val;
__isset.disks_lun_mapping = true;
}

void loader_job_create_detail::__set_snapshots(const std::vector<std::string> & val) {
  this->snapshots = val;
__isset.snapshots = true;
}

void loader_job_create_detail::__set_disks_snapshot_mapping(const std::map<std::string, std::map<std::string, std::string> > & val) {
  this->disks_snapshot_mapping = val;
__isset.disks_snapshot_mapping = true;
}

void loader_job_create_detail::__set_connection_id(const std::string& val) {
  this->connection_id = val;
__isset.connection_id = true;
}

void loader_job_create_detail::__set_block_mode_enable(const bool val) {
  this->block_mode_enable = val;
__isset.block_mode_enable = true;
}

void loader_job_create_detail::__set_purge_data(const bool val) {
  this->purge_data = val;
__isset.purge_data = true;
}

void loader_job_create_detail::__set_remap(const bool val) {
  this->remap = val;
__isset.remap = true;
}

void loader_job_create_detail::__set_detect_type(const disk_detect_type::type val) {
  this->detect_type = val;
__isset.detect_type = true;
}

void loader_job_create_detail::__set_worker_thread_number(const int32_t val) {
  this->worker_thread_number = val;
__isset.worker_thread_number = true;
}

void loader_job_create_detail::__set_host_name(const std::string& val) {
  this->host_name = val;
__isset.host_name = true;
}

void loader_job_create_detail::__set_export_disk_type(const virtual_disk_type::type val) {
  this->export_disk_type = val;
__isset.export_disk_type = true;
}

void loader_job_create_detail::__set_export_path(const std::string& val) {
  this->export_path = val;
__isset.export_path = true;
}

void loader_job_create_detail::__set_disks_size_mapping(const std::map<std::string, int64_t> & val) {
  this->disks_size_mapping = val;
__isset.disks_size_mapping = true;
}

void loader_job_create_detail::__set_keep_alive(const bool val) {
  this->keep_alive = val;
__isset.keep_alive = true;
}

void loader_job_create_detail::__set_time(const std::string& val) {
  this->time = val;
__isset.time = true;
}

void loader_job_create_detail::__set_is_continuous_data_replication(const bool val) {
  this->is_continuous_data_replication = val;
__isset.is_continuous_data_replication = true;
}

void loader_job_create_detail::__set_azure_storage_connection_string(const std::string& val) {
  this->azure_storage_connection_string = val;
__isset.azure_storage_connection_string = true;
}

void loader_job_create_detail::__set_vmware_connection(const vmware_connection_info& val) {
  this->vmware_connection = val;
__isset.vmware_connection = true;
}

void loader_job_create_detail::__set_thin_provisioned(const bool val) {
  this->thin_provisioned = val;
__isset.thin_provisioned = true;
}

void loader_job_create_detail::__set_is_paused(const bool val) {
  this->is_paused = val;
__isset.is_paused = true;
}

void loader_job_create_detail::__set_cascadings(const cascading& val) {
  this->cascadings = val;
__isset.cascadings = true;
}
std::ostream& operator<<(std::ostream& out, const loader_job_create_detail& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t loader_job_create_detail::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->replica_id);
          this->__isset.replica_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->disks_lun_mapping.clear();
            uint32_t _size1059;
            ::apache::thrift::protocol::TType _ktype1060;
            ::apache::thrift::protocol::TType _vtype1061;
            xfer += iprot->readMapBegin(_ktype1060, _vtype1061, _size1059);
            uint32_t _i1063;
            for (_i1063 = 0; _i1063 < _size1059; ++_i1063)
            {
              std::string _key1064;
              xfer += iprot->readString(_key1064);
              std::string& _val1065 = this->disks_lun_mapping[_key1064];
              xfer += iprot->readString(_val1065);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.disks_lun_mapping = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->snapshots.clear();
            uint32_t _size1066;
            ::apache::thrift::protocol::TType _etype1069;
            xfer += iprot->readListBegin(_etype1069, _size1066);
            this->snapshots.resize(_size1066);
            uint32_t _i1070;
            for (_i1070 = 0; _i1070 < _size1066; ++_i1070)
            {
              xfer += iprot->readString(this->snapshots[_i1070]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.snapshots = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->disks_snapshot_mapping.clear();
            uint32_t _size1071;
            ::apache::thrift::protocol::TType _ktype1072;
            ::apache::thrift::protocol::TType _vtype1073;
            xfer += iprot->readMapBegin(_ktype1072, _vtype1073, _size1071);
            uint32_t _i1075;
            for (_i1075 = 0; _i1075 < _size1071; ++_i1075)
            {
              std::string _key1076;
              xfer += iprot->readString(_key1076);
              std::map<std::string, std::string> & _val1077 = this->disks_snapshot_mapping[_key1076];
              {
                _val1077.clear();
                uint32_t _size1078;
                ::apache::thrift::protocol::TType _ktype1079;
                ::apache::thrift::protocol::TType _vtype1080;
                xfer += iprot->readMapBegin(_ktype1079, _vtype1080, _size1078);
                uint32_t _i1082;
                for (_i1082 = 0; _i1082 < _size1078; ++_i1082)
                {
                  std::string _key1083;
                  xfer += iprot->readString(_key1083);
                  std::string& _val1084 = _val1077[_key1083];
                  xfer += iprot->readString(_val1084);
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.disks_snapshot_mapping = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->connection_id);
          this->__isset.connection_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->block_mode_enable);
          this->__isset.block_mode_enable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->purge_data);
          this->__isset.purge_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->remap);
          this->__isset.remap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1085;
          xfer += iprot->readI32(ecast1085);
          this->detect_type = (disk_detect_type::type)ecast1085;
          this->__isset.detect_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->worker_thread_number);
          this->__isset.worker_thread_number = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host_name);
          this->__isset.host_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1086;
          xfer += iprot->readI32(ecast1086);
          this->export_disk_type = (virtual_disk_type::type)ecast1086;
          this->__isset.export_disk_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->export_path);
          this->__isset.export_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->disks_size_mapping.clear();
            uint32_t _size1087;
            ::apache::thrift::protocol::TType _ktype1088;
            ::apache::thrift::protocol::TType _vtype1089;
            xfer += iprot->readMapBegin(_ktype1088, _vtype1089, _size1087);
            uint32_t _i1091;
            for (_i1091 = 0; _i1091 < _size1087; ++_i1091)
            {
              std::string _key1092;
              xfer += iprot->readString(_key1092);
              int64_t& _val1093 = this->disks_size_mapping[_key1092];
              xfer += iprot->readI64(_val1093);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.disks_size_mapping = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->keep_alive);
          this->__isset.keep_alive = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->time);
          this->__isset.time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_continuous_data_replication);
          this->__isset.is_continuous_data_replication = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->azure_storage_connection_string);
          this->__isset.azure_storage_connection_string = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->vmware_connection.read(iprot);
          this->__isset.vmware_connection = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->thin_provisioned);
          this->__isset.thin_provisioned = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_paused);
          this->__isset.is_paused = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cascadings.read(iprot);
          this->__isset.cascadings = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t loader_job_create_detail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("loader_job_create_detail");

  if (this->__isset.replica_id) {
    xfer += oprot->writeFieldBegin("replica_id", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->replica_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.disks_lun_mapping) {
    xfer += oprot->writeFieldBegin("disks_lun_mapping", ::apache::thrift::protocol::T_MAP, 2);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->disks_lun_mapping.size()));
      std::map<std::string, std::string> ::const_iterator _iter1094;
      for (_iter1094 = this->disks_lun_mapping.begin(); _iter1094 != this->disks_lun_mapping.end(); ++_iter1094)
      {
        xfer += oprot->writeString(_iter1094->first);
        xfer += oprot->writeString(_iter1094->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.snapshots) {
    xfer += oprot->writeFieldBegin("snapshots", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->snapshots.size()));
      std::vector<std::string> ::const_iterator _iter1095;
      for (_iter1095 = this->snapshots.begin(); _iter1095 != this->snapshots.end(); ++_iter1095)
      {
        xfer += oprot->writeString((*_iter1095));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.disks_snapshot_mapping) {
    xfer += oprot->writeFieldBegin("disks_snapshot_mapping", ::apache::thrift::protocol::T_MAP, 4);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->disks_snapshot_mapping.size()));
      std::map<std::string, std::map<std::string, std::string> > ::const_iterator _iter1096;
      for (_iter1096 = this->disks_snapshot_mapping.begin(); _iter1096 != this->disks_snapshot_mapping.end(); ++_iter1096)
      {
        xfer += oprot->writeString(_iter1096->first);
        {
          xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter1096->second.size()));
          std::map<std::string, std::string> ::const_iterator _iter1097;
          for (_iter1097 = _iter1096->second.begin(); _iter1097 != _iter1096->second.end(); ++_iter1097)
          {
            xfer += oprot->writeString(_iter1097->first);
            xfer += oprot->writeString(_iter1097->second);
          }
          xfer += oprot->writeMapEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.connection_id) {
    xfer += oprot->writeFieldBegin("connection_id", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->connection_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.block_mode_enable) {
    xfer += oprot->writeFieldBegin("block_mode_enable", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->block_mode_enable);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.purge_data) {
    xfer += oprot->writeFieldBegin("purge_data", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->purge_data);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.remap) {
    xfer += oprot->writeFieldBegin("remap", ::apache::thrift::protocol::T_BOOL, 8);
    xfer += oprot->writeBool(this->remap);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.detect_type) {
    xfer += oprot->writeFieldBegin("detect_type", ::apache::thrift::protocol::T_I32, 9);
    xfer += oprot->writeI32((int32_t)this->detect_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.worker_thread_number) {
    xfer += oprot->writeFieldBegin("worker_thread_number", ::apache::thrift::protocol::T_I32, 10);
    xfer += oprot->writeI32(this->worker_thread_number);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.host_name) {
    xfer += oprot->writeFieldBegin("host_name", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeString(this->host_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.export_disk_type) {
    xfer += oprot->writeFieldBegin("export_disk_type", ::apache::thrift::protocol::T_I32, 12);
    xfer += oprot->writeI32((int32_t)this->export_disk_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.export_path) {
    xfer += oprot->writeFieldBegin("export_path", ::apache::thrift::protocol::T_STRING, 13);
    xfer += oprot->writeString(this->export_path);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.disks_size_mapping) {
    xfer += oprot->writeFieldBegin("disks_size_mapping", ::apache::thrift::protocol::T_MAP, 14);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->disks_size_mapping.size()));
      std::map<std::string, int64_t> ::const_iterator _iter1098;
      for (_iter1098 = this->disks_size_mapping.begin(); _iter1098 != this->disks_size_mapping.end(); ++_iter1098)
      {
        xfer += oprot->writeString(_iter1098->first);
        xfer += oprot->writeI64(_iter1098->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.keep_alive) {
    xfer += oprot->writeFieldBegin("keep_alive", ::apache::thrift::protocol::T_BOOL, 15);
    xfer += oprot->writeBool(this->keep_alive);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.time) {
    xfer += oprot->writeFieldBegin("time", ::apache::thrift::protocol::T_STRING, 16);
    xfer += oprot->writeString(this->time);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_continuous_data_replication) {
    xfer += oprot->writeFieldBegin("is_continuous_data_replication", ::apache::thrift::protocol::T_BOOL, 17);
    xfer += oprot->writeBool(this->is_continuous_data_replication);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.azure_storage_connection_string) {
    xfer += oprot->writeFieldBegin("azure_storage_connection_string", ::apache::thrift::protocol::T_STRING, 18);
    xfer += oprot->writeString(this->azure_storage_connection_string);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vmware_connection) {
    xfer += oprot->writeFieldBegin("vmware_connection", ::apache::thrift::protocol::T_STRUCT, 19);
    xfer += this->vmware_connection.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.thin_provisioned) {
    xfer += oprot->writeFieldBegin("thin_provisioned", ::apache::thrift::protocol::T_BOOL, 20);
    xfer += oprot->writeBool(this->thin_provisioned);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_paused) {
    xfer += oprot->writeFieldBegin("is_paused", ::apache::thrift::protocol::T_BOOL, 21);
    xfer += oprot->writeBool(this->is_paused);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cascadings) {
    xfer += oprot->writeFieldBegin("cascadings", ::apache::thrift::protocol::T_STRUCT, 22);
    xfer += this->cascadings.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(loader_job_create_detail &a, loader_job_create_detail &b) {
  using ::std::swap;
  swap(a.replica_id, b.replica_id);
  swap(a.disks_lun_mapping, b.disks_lun_mapping);
  swap(a.snapshots, b.snapshots);
  swap(a.disks_snapshot_mapping, b.disks_snapshot_mapping);
  swap(a.connection_id, b.connection_id);
  swap(a.block_mode_enable, b.block_mode_enable);
  swap(a.purge_data, b.purge_data);
  swap(a.remap, b.remap);
  swap(a.detect_type, b.detect_type);
  swap(a.worker_thread_number, b.worker_thread_number);
  swap(a.host_name, b.host_name);
  swap(a.export_disk_type, b.export_disk_type);
  swap(a.export_path, b.export_path);
  swap(a.disks_size_mapping, b.disks_size_mapping);
  swap(a.keep_alive, b.keep_alive);
  swap(a.time, b.time);
  swap(a.is_continuous_data_replication, b.is_continuous_data_replication);
  swap(a.azure_storage_connection_string, b.azure_storage_connection_string);
  swap(a.vmware_connection, b.vmware_connection);
  swap(a.thin_provisioned, b.thin_provisioned);
  swap(a.is_paused, b.is_paused);
  swap(a.cascadings, b.cascadings);
  swap(a.__isset, b.__isset);
}

loader_job_create_detail::loader_job_create_detail(const loader_job_create_detail& other1099) {
  replica_id = other1099.replica_id;
  disks_lun_mapping = other1099.disks_lun_mapping;
  snapshots = other1099.snapshots;
  disks_snapshot_mapping = other1099.disks_snapshot_mapping;
  connection_id = other1099.connection_id;
  block_mode_enable = other1099.block_mode_enable;
  purge_data = other1099.purge_data;
  remap = other1099.remap;
  detect_type = other1099.detect_type;
  worker_thread_number = other1099.worker_thread_number;
  host_name = other1099.host_name;
  export_disk_type = other1099.export_disk_type;
  export_path = other1099.export_path;
  disks_size_mapping = other1099.disks_size_mapping;
  keep_alive = other1099.keep_alive;
  time = other1099.time;
  is_continuous_data_replication = other1099.is_continuous_data_replication;
  azure_storage_connection_string = other1099.azure_storage_connection_string;
  vmware_connection = other1099.vmware_connection;
  thin_provisioned = other1099.thin_provisioned;
  is_paused = other1099.is_paused;
  cascadings = other1099.cascadings;
  __isset = other1099.__isset;
}
loader_job_create_detail& loader_job_create_detail::operator=(const loader_job_create_detail& other1100) {
  replica_id = other1100.replica_id;
  disks_lun_mapping = other1100.disks_lun_mapping;
  snapshots = other1100.snapshots;
  disks_snapshot_mapping = other1100.disks_snapshot_mapping;
  connection_id = other1100.connection_id;
  block_mode_enable = other1100.block_mode_enable;
  purge_data = other1100.purge_data;
  remap = other1100.remap;
  detect_type = other1100.detect_type;
  worker_thread_number = other1100.worker_thread_number;
  host_name = other1100.host_name;
  export_disk_type = other1100.export_disk_type;
  export_path = other1100.export_path;
  disks_size_mapping = other1100.disks_size_mapping;
  keep_alive = other1100.keep_alive;
  time = other1100.time;
  is_continuous_data_replication = other1100.is_continuous_data_replication;
  azure_storage_connection_string = other1100.azure_storage_connection_string;
  vmware_connection = other1100.vmware_connection;
  thin_provisioned = other1100.thin_provisioned;
  is_paused = other1100.is_paused;
  cascadings = other1100.cascadings;
  __isset = other1100.__isset;
  return *this;
}
void loader_job_create_detail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "loader_job_create_detail(";
  out << "replica_id="; (__isset.replica_id ? (out << to_string(replica_id)) : (out << "<null>"));
  out << ", " << "disks_lun_mapping="; (__isset.disks_lun_mapping ? (out << to_string(disks_lun_mapping)) : (out << "<null>"));
  out << ", " << "snapshots="; (__isset.snapshots ? (out << to_string(snapshots)) : (out << "<null>"));
  out << ", " << "disks_snapshot_mapping="; (__isset.disks_snapshot_mapping ? (out << to_string(disks_snapshot_mapping)) : (out << "<null>"));
  out << ", " << "connection_id="; (__isset.connection_id ? (out << to_string(connection_id)) : (out << "<null>"));
  out << ", " << "block_mode_enable="; (__isset.block_mode_enable ? (out << to_string(block_mode_enable)) : (out << "<null>"));
  out << ", " << "purge_data="; (__isset.purge_data ? (out << to_string(purge_data)) : (out << "<null>"));
  out << ", " << "remap="; (__isset.remap ? (out << to_string(remap)) : (out << "<null>"));
  out << ", " << "detect_type="; (__isset.detect_type ? (out << to_string(detect_type)) : (out << "<null>"));
  out << ", " << "worker_thread_number="; (__isset.worker_thread_number ? (out << to_string(worker_thread_number)) : (out << "<null>"));
  out << ", " << "host_name="; (__isset.host_name ? (out << to_string(host_name)) : (out << "<null>"));
  out << ", " << "export_disk_type="; (__isset.export_disk_type ? (out << to_string(export_disk_type)) : (out << "<null>"));
  out << ", " << "export_path="; (__isset.export_path ? (out << to_string(export_path)) : (out << "<null>"));
  out << ", " << "disks_size_mapping="; (__isset.disks_size_mapping ? (out << to_string(disks_size_mapping)) : (out << "<null>"));
  out << ", " << "keep_alive="; (__isset.keep_alive ? (out << to_string(keep_alive)) : (out << "<null>"));
  out << ", " << "time="; (__isset.time ? (out << to_string(time)) : (out << "<null>"));
  out << ", " << "is_continuous_data_replication="; (__isset.is_continuous_data_replication ? (out << to_string(is_continuous_data_replication)) : (out << "<null>"));
  out << ", " << "azure_storage_connection_string="; (__isset.azure_storage_connection_string ? (out << to_string(azure_storage_connection_string)) : (out << "<null>"));
  out << ", " << "vmware_connection="; (__isset.vmware_connection ? (out << to_string(vmware_connection)) : (out << "<null>"));
  out << ", " << "thin_provisioned="; (__isset.thin_provisioned ? (out << to_string(thin_provisioned)) : (out << "<null>"));
  out << ", " << "is_paused="; (__isset.is_paused ? (out << to_string(is_paused)) : (out << "<null>"));
  out << ", " << "cascadings="; (__isset.cascadings ? (out << to_string(cascadings)) : (out << "<null>"));
  out << ")";
}


launcher_job_create_detail::~launcher_job_create_detail() throw() {
}


void launcher_job_create_detail::__set_replica_id(const std::string& val) {
  this->replica_id = val;
__isset.replica_id = true;
}

void launcher_job_create_detail::__set_disks_lun_mapping(const std::map<std::string, std::string> & val) {
  this->disks_lun_mapping = val;
__isset.disks_lun_mapping = true;
}

void launcher_job_create_detail::__set_is_sysvol_authoritative_restore(const bool val) {
  this->is_sysvol_authoritative_restore = val;
__isset.is_sysvol_authoritative_restore = true;
}

void launcher_job_create_detail::__set_is_enable_debug(const bool val) {
  this->is_enable_debug = val;
__isset.is_enable_debug = true;
}

void launcher_job_create_detail::__set_is_disable_machine_password_change(const bool val) {
  this->is_disable_machine_password_change = val;
__isset.is_disable_machine_password_change = true;
}

void launcher_job_create_detail::__set_is_force_normal_boot(const bool val) {
  this->is_force_normal_boot = val;
__isset.is_force_normal_boot = true;
}

void launcher_job_create_detail::__set_network_infos(const std::set<network_info> & val) {
  this->network_infos = val;
__isset.network_infos = true;
}

void launcher_job_create_detail::__set_config(const std::string& val) {
  this->config = val;
__isset.config = true;
}

void launcher_job_create_detail::__set_gpt_to_mbr(const bool val) {
  this->gpt_to_mbr = val;
__isset.gpt_to_mbr = true;
}

void launcher_job_create_detail::__set_detect_type(const disk_detect_type::type val) {
  this->detect_type = val;
__isset.detect_type = true;
}

void launcher_job_create_detail::__set_skip_system_injection(const bool val) {
  this->skip_system_injection = val;
__isset.skip_system_injection = true;
}

void launcher_job_create_detail::__set_reboot_winpe(const bool val) {
  this->reboot_winpe = val;
__isset.reboot_winpe = true;
}

void launcher_job_create_detail::__set_callbacks(const std::set<std::string> & val) {
  this->callbacks = val;
__isset.callbacks = true;
}

void launcher_job_create_detail::__set_callback_timeout(const int32_t val) {
  this->callback_timeout = val;
__isset.callback_timeout = true;
}

void launcher_job_create_detail::__set_host_name(const std::string& val) {
  this->host_name = val;
__isset.host_name = true;
}

void launcher_job_create_detail::__set_export_disk_type(const virtual_disk_type::type val) {
  this->export_disk_type = val;
__isset.export_disk_type = true;
}

void launcher_job_create_detail::__set_export_path(const std::string& val) {
  this->export_path = val;
__isset.export_path = true;
}

void launcher_job_create_detail::__set_target_type(const conversion_type::type val) {
  this->target_type = val;
__isset.target_type = true;
}

void launcher_job_create_detail::__set_os_type(const hv_guest_os_type::type val) {
  this->os_type = val;
__isset.os_type = true;
}

void launcher_job_create_detail::__set_is_update_ex(const bool val) {
  this->is_update_ex = val;
__isset.is_update_ex = true;
}

void launcher_job_create_detail::__set_options_type(const extra_options_type::type val) {
  this->options_type = val;
__isset.options_type = true;
}

void launcher_job_create_detail::__set_options(const extra_options& val) {
  this->options = val;
__isset.options = true;
}

void launcher_job_create_detail::__set_pre_scripts(const std::set<std::string> & val) {
  this->pre_scripts = val;
__isset.pre_scripts = true;
}

void launcher_job_create_detail::__set_post_scripts(const std::set<std::string> & val) {
  this->post_scripts = val;
__isset.post_scripts = true;
}

void launcher_job_create_detail::__set_vmware(const vmware_options& val) {
  this->vmware = val;
__isset.vmware = true;
}

void launcher_job_create_detail::__set_mode(const recovery_type::type val) {
  this->mode = val;
__isset.mode = true;
}
std::ostream& operator<<(std::ostream& out, const launcher_job_create_detail& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t launcher_job_create_detail::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->replica_id);
          this->__isset.replica_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->disks_lun_mapping.clear();
            uint32_t _size1101;
            ::apache::thrift::protocol::TType _ktype1102;
            ::apache::thrift::protocol::TType _vtype1103;
            xfer += iprot->readMapBegin(_ktype1102, _vtype1103, _size1101);
            uint32_t _i1105;
            for (_i1105 = 0; _i1105 < _size1101; ++_i1105)
            {
              std::string _key1106;
              xfer += iprot->readString(_key1106);
              std::string& _val1107 = this->disks_lun_mapping[_key1106];
              xfer += iprot->readString(_val1107);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.disks_lun_mapping = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_sysvol_authoritative_restore);
          this->__isset.is_sysvol_authoritative_restore = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_enable_debug);
          this->__isset.is_enable_debug = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_disable_machine_password_change);
          this->__isset.is_disable_machine_password_change = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_force_normal_boot);
          this->__isset.is_force_normal_boot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->network_infos.clear();
            uint32_t _size1108;
            ::apache::thrift::protocol::TType _etype1111;
            xfer += iprot->readSetBegin(_etype1111, _size1108);
            uint32_t _i1112;
            for (_i1112 = 0; _i1112 < _size1108; ++_i1112)
            {
              network_info _elem1113;
              xfer += _elem1113.read(iprot);
              this->network_infos.insert(_elem1113);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.network_infos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->config);
          this->__isset.config = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->gpt_to_mbr);
          this->__isset.gpt_to_mbr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1114;
          xfer += iprot->readI32(ecast1114);
          this->detect_type = (disk_detect_type::type)ecast1114;
          this->__isset.detect_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->skip_system_injection);
          this->__isset.skip_system_injection = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->reboot_winpe);
          this->__isset.reboot_winpe = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->callbacks.clear();
            uint32_t _size1115;
            ::apache::thrift::protocol::TType _etype1118;
            xfer += iprot->readSetBegin(_etype1118, _size1115);
            uint32_t _i1119;
            for (_i1119 = 0; _i1119 < _size1115; ++_i1119)
            {
              std::string _elem1120;
              xfer += iprot->readString(_elem1120);
              this->callbacks.insert(_elem1120);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.callbacks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->callback_timeout);
          this->__isset.callback_timeout = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host_name);
          this->__isset.host_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1121;
          xfer += iprot->readI32(ecast1121);
          this->export_disk_type = (virtual_disk_type::type)ecast1121;
          this->__isset.export_disk_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->export_path);
          this->__isset.export_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1122;
          xfer += iprot->readI32(ecast1122);
          this->target_type = (conversion_type::type)ecast1122;
          this->__isset.target_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1123;
          xfer += iprot->readI32(ecast1123);
          this->os_type = (hv_guest_os_type::type)ecast1123;
          this->__isset.os_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_update_ex);
          this->__isset.is_update_ex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1124;
          xfer += iprot->readI32(ecast1124);
          this->options_type = (extra_options_type::type)ecast1124;
          this->__isset.options_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->options.read(iprot);
          this->__isset.options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->pre_scripts.clear();
            uint32_t _size1125;
            ::apache::thrift::protocol::TType _etype1128;
            xfer += iprot->readSetBegin(_etype1128, _size1125);
            uint32_t _i1129;
            for (_i1129 = 0; _i1129 < _size1125; ++_i1129)
            {
              std::string _elem1130;
              xfer += iprot->readString(_elem1130);
              this->pre_scripts.insert(_elem1130);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.pre_scripts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->post_scripts.clear();
            uint32_t _size1131;
            ::apache::thrift::protocol::TType _etype1134;
            xfer += iprot->readSetBegin(_etype1134, _size1131);
            uint32_t _i1135;
            for (_i1135 = 0; _i1135 < _size1131; ++_i1135)
            {
              std::string _elem1136;
              xfer += iprot->readString(_elem1136);
              this->post_scripts.insert(_elem1136);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.post_scripts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->vmware.read(iprot);
          this->__isset.vmware = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 26:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1137;
          xfer += iprot->readI32(ecast1137);
          this->mode = (recovery_type::type)ecast1137;
          this->__isset.mode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t launcher_job_create_detail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("launcher_job_create_detail");

  if (this->__isset.replica_id) {
    xfer += oprot->writeFieldBegin("replica_id", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->replica_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.disks_lun_mapping) {
    xfer += oprot->writeFieldBegin("disks_lun_mapping", ::apache::thrift::protocol::T_MAP, 2);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->disks_lun_mapping.size()));
      std::map<std::string, std::string> ::const_iterator _iter1138;
      for (_iter1138 = this->disks_lun_mapping.begin(); _iter1138 != this->disks_lun_mapping.end(); ++_iter1138)
      {
        xfer += oprot->writeString(_iter1138->first);
        xfer += oprot->writeString(_iter1138->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_sysvol_authoritative_restore) {
    xfer += oprot->writeFieldBegin("is_sysvol_authoritative_restore", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->is_sysvol_authoritative_restore);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_enable_debug) {
    xfer += oprot->writeFieldBegin("is_enable_debug", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->is_enable_debug);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_disable_machine_password_change) {
    xfer += oprot->writeFieldBegin("is_disable_machine_password_change", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->is_disable_machine_password_change);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_force_normal_boot) {
    xfer += oprot->writeFieldBegin("is_force_normal_boot", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->is_force_normal_boot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.network_infos) {
    xfer += oprot->writeFieldBegin("network_infos", ::apache::thrift::protocol::T_SET, 7);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->network_infos.size()));
      std::set<network_info> ::const_iterator _iter1139;
      for (_iter1139 = this->network_infos.begin(); _iter1139 != this->network_infos.end(); ++_iter1139)
      {
        xfer += (*_iter1139).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.config) {
    xfer += oprot->writeFieldBegin("config", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->config);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.gpt_to_mbr) {
    xfer += oprot->writeFieldBegin("gpt_to_mbr", ::apache::thrift::protocol::T_BOOL, 9);
    xfer += oprot->writeBool(this->gpt_to_mbr);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.detect_type) {
    xfer += oprot->writeFieldBegin("detect_type", ::apache::thrift::protocol::T_I32, 10);
    xfer += oprot->writeI32((int32_t)this->detect_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.skip_system_injection) {
    xfer += oprot->writeFieldBegin("skip_system_injection", ::apache::thrift::protocol::T_BOOL, 11);
    xfer += oprot->writeBool(this->skip_system_injection);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.reboot_winpe) {
    xfer += oprot->writeFieldBegin("reboot_winpe", ::apache::thrift::protocol::T_BOOL, 12);
    xfer += oprot->writeBool(this->reboot_winpe);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.callbacks) {
    xfer += oprot->writeFieldBegin("callbacks", ::apache::thrift::protocol::T_SET, 13);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->callbacks.size()));
      std::set<std::string> ::const_iterator _iter1140;
      for (_iter1140 = this->callbacks.begin(); _iter1140 != this->callbacks.end(); ++_iter1140)
      {
        xfer += oprot->writeString((*_iter1140));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.callback_timeout) {
    xfer += oprot->writeFieldBegin("callback_timeout", ::apache::thrift::protocol::T_I32, 14);
    xfer += oprot->writeI32(this->callback_timeout);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.host_name) {
    xfer += oprot->writeFieldBegin("host_name", ::apache::thrift::protocol::T_STRING, 15);
    xfer += oprot->writeString(this->host_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.export_disk_type) {
    xfer += oprot->writeFieldBegin("export_disk_type", ::apache::thrift::protocol::T_I32, 16);
    xfer += oprot->writeI32((int32_t)this->export_disk_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.export_path) {
    xfer += oprot->writeFieldBegin("export_path", ::apache::thrift::protocol::T_STRING, 17);
    xfer += oprot->writeString(this->export_path);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.target_type) {
    xfer += oprot->writeFieldBegin("target_type", ::apache::thrift::protocol::T_I32, 18);
    xfer += oprot->writeI32((int32_t)this->target_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.os_type) {
    xfer += oprot->writeFieldBegin("os_type", ::apache::thrift::protocol::T_I32, 19);
    xfer += oprot->writeI32((int32_t)this->os_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_update_ex) {
    xfer += oprot->writeFieldBegin("is_update_ex", ::apache::thrift::protocol::T_BOOL, 20);
    xfer += oprot->writeBool(this->is_update_ex);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.options_type) {
    xfer += oprot->writeFieldBegin("options_type", ::apache::thrift::protocol::T_I32, 21);
    xfer += oprot->writeI32((int32_t)this->options_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.options) {
    xfer += oprot->writeFieldBegin("options", ::apache::thrift::protocol::T_STRUCT, 22);
    xfer += this->options.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.pre_scripts) {
    xfer += oprot->writeFieldBegin("pre_scripts", ::apache::thrift::protocol::T_SET, 23);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->pre_scripts.size()));
      std::set<std::string> ::const_iterator _iter1141;
      for (_iter1141 = this->pre_scripts.begin(); _iter1141 != this->pre_scripts.end(); ++_iter1141)
      {
        xfer += oprot->writeString((*_iter1141));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.post_scripts) {
    xfer += oprot->writeFieldBegin("post_scripts", ::apache::thrift::protocol::T_SET, 24);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->post_scripts.size()));
      std::set<std::string> ::const_iterator _iter1142;
      for (_iter1142 = this->post_scripts.begin(); _iter1142 != this->post_scripts.end(); ++_iter1142)
      {
        xfer += oprot->writeString((*_iter1142));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vmware) {
    xfer += oprot->writeFieldBegin("vmware", ::apache::thrift::protocol::T_STRUCT, 25);
    xfer += this->vmware.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mode) {
    xfer += oprot->writeFieldBegin("mode", ::apache::thrift::protocol::T_I32, 26);
    xfer += oprot->writeI32((int32_t)this->mode);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(launcher_job_create_detail &a, launcher_job_create_detail &b) {
  using ::std::swap;
  swap(a.replica_id, b.replica_id);
  swap(a.disks_lun_mapping, b.disks_lun_mapping);
  swap(a.is_sysvol_authoritative_restore, b.is_sysvol_authoritative_restore);
  swap(a.is_enable_debug, b.is_enable_debug);
  swap(a.is_disable_machine_password_change, b.is_disable_machine_password_change);
  swap(a.is_force_normal_boot, b.is_force_normal_boot);
  swap(a.network_infos, b.network_infos);
  swap(a.config, b.config);
  swap(a.gpt_to_mbr, b.gpt_to_mbr);
  swap(a.detect_type, b.detect_type);
  swap(a.skip_system_injection, b.skip_system_injection);
  swap(a.reboot_winpe, b.reboot_winpe);
  swap(a.callbacks, b.callbacks);
  swap(a.callback_timeout, b.callback_timeout);
  swap(a.host_name, b.host_name);
  swap(a.export_disk_type, b.export_disk_type);
  swap(a.export_path, b.export_path);
  swap(a.target_type, b.target_type);
  swap(a.os_type, b.os_type);
  swap(a.is_update_ex, b.is_update_ex);
  swap(a.options_type, b.options_type);
  swap(a.options, b.options);
  swap(a.pre_scripts, b.pre_scripts);
  swap(a.post_scripts, b.post_scripts);
  swap(a.vmware, b.vmware);
  swap(a.mode, b.mode);
  swap(a.__isset, b.__isset);
}

launcher_job_create_detail::launcher_job_create_detail(const launcher_job_create_detail& other1143) {
  replica_id = other1143.replica_id;
  disks_lun_mapping = other1143.disks_lun_mapping;
  is_sysvol_authoritative_restore = other1143.is_sysvol_authoritative_restore;
  is_enable_debug = other1143.is_enable_debug;
  is_disable_machine_password_change = other1143.is_disable_machine_password_change;
  is_force_normal_boot = other1143.is_force_normal_boot;
  network_infos = other1143.network_infos;
  config = other1143.config;
  gpt_to_mbr = other1143.gpt_to_mbr;
  detect_type = other1143.detect_type;
  skip_system_injection = other1143.skip_system_injection;
  reboot_winpe = other1143.reboot_winpe;
  callbacks = other1143.callbacks;
  callback_timeout = other1143.callback_timeout;
  host_name = other1143.host_name;
  export_disk_type = other1143.export_disk_type;
  export_path = other1143.export_path;
  target_type = other1143.target_type;
  os_type = other1143.os_type;
  is_update_ex = other1143.is_update_ex;
  options_type = other1143.options_type;
  options = other1143.options;
  pre_scripts = other1143.pre_scripts;
  post_scripts = other1143.post_scripts;
  vmware = other1143.vmware;
  mode = other1143.mode;
  __isset = other1143.__isset;
}
launcher_job_create_detail& launcher_job_create_detail::operator=(const launcher_job_create_detail& other1144) {
  replica_id = other1144.replica_id;
  disks_lun_mapping = other1144.disks_lun_mapping;
  is_sysvol_authoritative_restore = other1144.is_sysvol_authoritative_restore;
  is_enable_debug = other1144.is_enable_debug;
  is_disable_machine_password_change = other1144.is_disable_machine_password_change;
  is_force_normal_boot = other1144.is_force_normal_boot;
  network_infos = other1144.network_infos;
  config = other1144.config;
  gpt_to_mbr = other1144.gpt_to_mbr;
  detect_type = other1144.detect_type;
  skip_system_injection = other1144.skip_system_injection;
  reboot_winpe = other1144.reboot_winpe;
  callbacks = other1144.callbacks;
  callback_timeout = other1144.callback_timeout;
  host_name = other1144.host_name;
  export_disk_type = other1144.export_disk_type;
  export_path = other1144.export_path;
  target_type = other1144.target_type;
  os_type = other1144.os_type;
  is_update_ex = other1144.is_update_ex;
  options_type = other1144.options_type;
  options = other1144.options;
  pre_scripts = other1144.pre_scripts;
  post_scripts = other1144.post_scripts;
  vmware = other1144.vmware;
  mode = other1144.mode;
  __isset = other1144.__isset;
  return *this;
}
void launcher_job_create_detail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "launcher_job_create_detail(";
  out << "replica_id="; (__isset.replica_id ? (out << to_string(replica_id)) : (out << "<null>"));
  out << ", " << "disks_lun_mapping="; (__isset.disks_lun_mapping ? (out << to_string(disks_lun_mapping)) : (out << "<null>"));
  out << ", " << "is_sysvol_authoritative_restore="; (__isset.is_sysvol_authoritative_restore ? (out << to_string(is_sysvol_authoritative_restore)) : (out << "<null>"));
  out << ", " << "is_enable_debug="; (__isset.is_enable_debug ? (out << to_string(is_enable_debug)) : (out << "<null>"));
  out << ", " << "is_disable_machine_password_change="; (__isset.is_disable_machine_password_change ? (out << to_string(is_disable_machine_password_change)) : (out << "<null>"));
  out << ", " << "is_force_normal_boot="; (__isset.is_force_normal_boot ? (out << to_string(is_force_normal_boot)) : (out << "<null>"));
  out << ", " << "network_infos="; (__isset.network_infos ? (out << to_string(network_infos)) : (out << "<null>"));
  out << ", " << "config="; (__isset.config ? (out << to_string(config)) : (out << "<null>"));
  out << ", " << "gpt_to_mbr="; (__isset.gpt_to_mbr ? (out << to_string(gpt_to_mbr)) : (out << "<null>"));
  out << ", " << "detect_type="; (__isset.detect_type ? (out << to_string(detect_type)) : (out << "<null>"));
  out << ", " << "skip_system_injection="; (__isset.skip_system_injection ? (out << to_string(skip_system_injection)) : (out << "<null>"));
  out << ", " << "reboot_winpe="; (__isset.reboot_winpe ? (out << to_string(reboot_winpe)) : (out << "<null>"));
  out << ", " << "callbacks="; (__isset.callbacks ? (out << to_string(callbacks)) : (out << "<null>"));
  out << ", " << "callback_timeout="; (__isset.callback_timeout ? (out << to_string(callback_timeout)) : (out << "<null>"));
  out << ", " << "host_name="; (__isset.host_name ? (out << to_string(host_name)) : (out << "<null>"));
  out << ", " << "export_disk_type="; (__isset.export_disk_type ? (out << to_string(export_disk_type)) : (out << "<null>"));
  out << ", " << "export_path="; (__isset.export_path ? (out << to_string(export_path)) : (out << "<null>"));
  out << ", " << "target_type="; (__isset.target_type ? (out << to_string(target_type)) : (out << "<null>"));
  out << ", " << "os_type="; (__isset.os_type ? (out << to_string(os_type)) : (out << "<null>"));
  out << ", " << "is_update_ex="; (__isset.is_update_ex ? (out << to_string(is_update_ex)) : (out << "<null>"));
  out << ", " << "options_type="; (__isset.options_type ? (out << to_string(options_type)) : (out << "<null>"));
  out << ", " << "options="; (__isset.options ? (out << to_string(options)) : (out << "<null>"));
  out << ", " << "pre_scripts="; (__isset.pre_scripts ? (out << to_string(pre_scripts)) : (out << "<null>"));
  out << ", " << "post_scripts="; (__isset.post_scripts ? (out << to_string(post_scripts)) : (out << "<null>"));
  out << ", " << "vmware="; (__isset.vmware ? (out << to_string(vmware)) : (out << "<null>"));
  out << ", " << "mode="; (__isset.mode ? (out << to_string(mode)) : (out << "<null>"));
  out << ")";
}


register_service_info::~register_service_info() throw() {
}


void register_service_info::__set_mgmt_addr(const std::string& val) {
  this->mgmt_addr = val;
__isset.mgmt_addr = true;
}

void register_service_info::__set_username(const std::string& val) {
  this->username = val;
__isset.username = true;
}

void register_service_info::__set_password(const std::string& val) {
  this->password = val;
__isset.password = true;
}

void register_service_info::__set_service_types(const std::set<std::string> & val) {
  this->service_types = val;
__isset.service_types = true;
}

void register_service_info::__set_version(const std::string& val) {
  this->version = val;
__isset.version = true;
}

void register_service_info::__set_path(const std::string& val) {
  this->path = val;
__isset.path = true;
}
std::ostream& operator<<(std::ostream& out, const register_service_info& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t register_service_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->mgmt_addr);
          this->__isset.mgmt_addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->username);
          this->__isset.username = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->password);
          this->__isset.password = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->service_types.clear();
            uint32_t _size1145;
            ::apache::thrift::protocol::TType _etype1148;
            xfer += iprot->readSetBegin(_etype1148, _size1145);
            uint32_t _i1149;
            for (_i1149 = 0; _i1149 < _size1145; ++_i1149)
            {
              std::string _elem1150;
              xfer += iprot->readString(_elem1150);
              this->service_types.insert(_elem1150);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.service_types = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->path);
          this->__isset.path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t register_service_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("register_service_info");

  if (this->__isset.mgmt_addr) {
    xfer += oprot->writeFieldBegin("mgmt_addr", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->mgmt_addr);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.username) {
    xfer += oprot->writeFieldBegin("username", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->username);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.password) {
    xfer += oprot->writeFieldBegin("password", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->password);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.service_types) {
    xfer += oprot->writeFieldBegin("service_types", ::apache::thrift::protocol::T_SET, 4);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->service_types.size()));
      std::set<std::string> ::const_iterator _iter1151;
      for (_iter1151 = this->service_types.begin(); _iter1151 != this->service_types.end(); ++_iter1151)
      {
        xfer += oprot->writeString((*_iter1151));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.version) {
    xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.path) {
    xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->path);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(register_service_info &a, register_service_info &b) {
  using ::std::swap;
  swap(a.mgmt_addr, b.mgmt_addr);
  swap(a.username, b.username);
  swap(a.password, b.password);
  swap(a.service_types, b.service_types);
  swap(a.version, b.version);
  swap(a.path, b.path);
  swap(a.__isset, b.__isset);
}

register_service_info::register_service_info(const register_service_info& other1152) {
  mgmt_addr = other1152.mgmt_addr;
  username = other1152.username;
  password = other1152.password;
  service_types = other1152.service_types;
  version = other1152.version;
  path = other1152.path;
  __isset = other1152.__isset;
}
register_service_info& register_service_info::operator=(const register_service_info& other1153) {
  mgmt_addr = other1153.mgmt_addr;
  username = other1153.username;
  password = other1153.password;
  service_types = other1153.service_types;
  version = other1153.version;
  path = other1153.path;
  __isset = other1153.__isset;
  return *this;
}
void register_service_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "register_service_info(";
  out << "mgmt_addr="; (__isset.mgmt_addr ? (out << to_string(mgmt_addr)) : (out << "<null>"));
  out << ", " << "username="; (__isset.username ? (out << to_string(username)) : (out << "<null>"));
  out << ", " << "password="; (__isset.password ? (out << to_string(password)) : (out << "<null>"));
  out << ", " << "service_types="; (__isset.service_types ? (out << to_string(service_types)) : (out << "<null>"));
  out << ", " << "version="; (__isset.version ? (out << to_string(version)) : (out << "<null>"));
  out << ", " << "path="; (__isset.path ? (out << to_string(path)) : (out << "<null>"));
  out << ")";
}


register_physical_packer_info::~register_physical_packer_info() throw() {
}


void register_physical_packer_info::__set_mgmt_addr(const std::string& val) {
  this->mgmt_addr = val;
__isset.mgmt_addr = true;
}

void register_physical_packer_info::__set_username(const std::string& val) {
  this->username = val;
__isset.username = true;
}

void register_physical_packer_info::__set_password(const std::string& val) {
  this->password = val;
__isset.password = true;
}

void register_physical_packer_info::__set_packer_addr(const std::string& val) {
  this->packer_addr = val;
__isset.packer_addr = true;
}

void register_physical_packer_info::__set_version(const std::string& val) {
  this->version = val;
__isset.version = true;
}

void register_physical_packer_info::__set_path(const std::string& val) {
  this->path = val;
__isset.path = true;
}
std::ostream& operator<<(std::ostream& out, const register_physical_packer_info& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t register_physical_packer_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->mgmt_addr);
          this->__isset.mgmt_addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->username);
          this->__isset.username = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->password);
          this->__isset.password = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->packer_addr);
          this->__isset.packer_addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->path);
          this->__isset.path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t register_physical_packer_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("register_physical_packer_info");

  if (this->__isset.mgmt_addr) {
    xfer += oprot->writeFieldBegin("mgmt_addr", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->mgmt_addr);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.username) {
    xfer += oprot->writeFieldBegin("username", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->username);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.password) {
    xfer += oprot->writeFieldBegin("password", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->password);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.packer_addr) {
    xfer += oprot->writeFieldBegin("packer_addr", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->packer_addr);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.version) {
    xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.path) {
    xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->path);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(register_physical_packer_info &a, register_physical_packer_info &b) {
  using ::std::swap;
  swap(a.mgmt_addr, b.mgmt_addr);
  swap(a.username, b.username);
  swap(a.password, b.password);
  swap(a.packer_addr, b.packer_addr);
  swap(a.version, b.version);
  swap(a.path, b.path);
  swap(a.__isset, b.__isset);
}

register_physical_packer_info::register_physical_packer_info(const register_physical_packer_info& other1154) {
  mgmt_addr = other1154.mgmt_addr;
  username = other1154.username;
  password = other1154.password;
  packer_addr = other1154.packer_addr;
  version = other1154.version;
  path = other1154.path;
  __isset = other1154.__isset;
}
register_physical_packer_info& register_physical_packer_info::operator=(const register_physical_packer_info& other1155) {
  mgmt_addr = other1155.mgmt_addr;
  username = other1155.username;
  password = other1155.password;
  packer_addr = other1155.packer_addr;
  version = other1155.version;
  path = other1155.path;
  __isset = other1155.__isset;
  return *this;
}
void register_physical_packer_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "register_physical_packer_info(";
  out << "mgmt_addr="; (__isset.mgmt_addr ? (out << to_string(mgmt_addr)) : (out << "<null>"));
  out << ", " << "username="; (__isset.username ? (out << to_string(username)) : (out << "<null>"));
  out << ", " << "password="; (__isset.password ? (out << to_string(password)) : (out << "<null>"));
  out << ", " << "packer_addr="; (__isset.packer_addr ? (out << to_string(packer_addr)) : (out << "<null>"));
  out << ", " << "version="; (__isset.version ? (out << to_string(version)) : (out << "<null>"));
  out << ", " << "path="; (__isset.path ? (out << to_string(path)) : (out << "<null>"));
  out << ")";
}


command_empty::~command_empty() throw() {
}

std::ostream& operator<<(std::ostream& out, const command_empty& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t command_empty::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t command_empty::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("command_empty");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(command_empty &a, command_empty &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

command_empty::command_empty(const command_empty& other1156) : TException() {
  (void) other1156;
}
command_empty& command_empty::operator=(const command_empty& other1157) {
  (void) other1157;
  return *this;
}
void command_empty::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "command_empty(";
  out << ")";
}

const char* command_empty::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: command_empty";
  }
}


invalid_session::~invalid_session() throw() {
}

std::ostream& operator<<(std::ostream& out, const invalid_session& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t invalid_session::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t invalid_session::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("invalid_session");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(invalid_session &a, invalid_session &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

invalid_session::invalid_session(const invalid_session& other1158) : TException() {
  (void) other1158;
}
invalid_session& invalid_session::operator=(const invalid_session& other1159) {
  (void) other1159;
  return *this;
}
void invalid_session::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "invalid_session(";
  out << ")";
}

const char* invalid_session::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: invalid_session";
  }
}


transport_message::~transport_message() throw() {
}


void transport_message::__set_id(const int64_t val) {
  this->id = val;
}

void transport_message::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const transport_message& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t transport_message::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t transport_message::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("transport_message");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(transport_message &a, transport_message &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

transport_message::transport_message(const transport_message& other1160) {
  id = other1160.id;
  message = other1160.message;
  __isset = other1160.__isset;
}
transport_message& transport_message::operator=(const transport_message& other1161) {
  id = other1161.id;
  message = other1161.message;
  __isset = other1161.__isset;
  return *this;
}
void transport_message::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "transport_message(";
  out << "id=" << to_string(id);
  out << ", " << "message=" << to_string(message);
  out << ")";
}


register_return::~register_return() throw() {
}


void register_return::__set_message(const std::string& val) {
  this->message = val;
__isset.message = true;
}

void register_return::__set_session(const std::string& val) {
  this->session = val;
__isset.session = true;
}
std::ostream& operator<<(std::ostream& out, const register_return& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t register_return::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session);
          this->__isset.session = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t register_return::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("register_return");

  if (this->__isset.message) {
    xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->message);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.session) {
    xfer += oprot->writeFieldBegin("session", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->session);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(register_return &a, register_return &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.session, b.session);
  swap(a.__isset, b.__isset);
}

register_return::register_return(const register_return& other1162) {
  message = other1162.message;
  session = other1162.session;
  __isset = other1162.__isset;
}
register_return& register_return::operator=(const register_return& other1163) {
  message = other1163.message;
  session = other1163.session;
  __isset = other1163.__isset;
  return *this;
}
void register_return::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "register_return(";
  out << "message="; (__isset.message ? (out << to_string(message)) : (out << "<null>"));
  out << ", " << "session="; (__isset.session ? (out << to_string(session)) : (out << "<null>"));
  out << ")";
}


license_info::~license_info() throw() {
}


void license_info::__set_key(const std::string& val) {
  this->key = val;
__isset.key = true;
}

void license_info::__set_activated(const std::string& val) {
  this->activated = val;
__isset.activated = true;
}

void license_info::__set_count(const int32_t val) {
  this->count = val;
__isset.count = true;
}

void license_info::__set_expired_date(const std::string& val) {
  this->expired_date = val;
__isset.expired_date = true;
}

void license_info::__set_consumed(const int32_t val) {
  this->consumed = val;
__isset.consumed = true;
}

void license_info::__set_is_active(const bool val) {
  this->is_active = val;
__isset.is_active = true;
}

void license_info::__set_name(const std::string& val) {
  this->name = val;
__isset.name = true;
}

void license_info::__set_email(const std::string& val) {
  this->email = val;
__isset.email = true;
}

void license_info::__set_status(const std::string& val) {
  this->status = val;
__isset.status = true;
}
std::ostream& operator<<(std::ostream& out, const license_info& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t license_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->activated);
          this->__isset.activated = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->count);
          this->__isset.count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->expired_date);
          this->__isset.expired_date = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->consumed);
          this->__isset.consumed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_active);
          this->__isset.is_active = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->email);
          this->__isset.email = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->status);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t license_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("license_info");

  if (this->__isset.key) {
    xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->key);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.activated) {
    xfer += oprot->writeFieldBegin("activated", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->activated);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.count) {
    xfer += oprot->writeFieldBegin("count", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->count);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.expired_date) {
    xfer += oprot->writeFieldBegin("expired_date", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->expired_date);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.consumed) {
    xfer += oprot->writeFieldBegin("consumed", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->consumed);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_active) {
    xfer += oprot->writeFieldBegin("is_active", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->is_active);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.email) {
    xfer += oprot->writeFieldBegin("email", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->email);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.status) {
    xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->status);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(license_info &a, license_info &b) {
  using ::std::swap;
  swap(a.key, b.key);
  swap(a.activated, b.activated);
  swap(a.count, b.count);
  swap(a.expired_date, b.expired_date);
  swap(a.consumed, b.consumed);
  swap(a.is_active, b.is_active);
  swap(a.name, b.name);
  swap(a.email, b.email);
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

license_info::license_info(const license_info& other1164) {
  key = other1164.key;
  activated = other1164.activated;
  count = other1164.count;
  expired_date = other1164.expired_date;
  consumed = other1164.consumed;
  is_active = other1164.is_active;
  name = other1164.name;
  email = other1164.email;
  status = other1164.status;
  __isset = other1164.__isset;
}
license_info& license_info::operator=(const license_info& other1165) {
  key = other1165.key;
  activated = other1165.activated;
  count = other1165.count;
  expired_date = other1165.expired_date;
  consumed = other1165.consumed;
  is_active = other1165.is_active;
  name = other1165.name;
  email = other1165.email;
  status = other1165.status;
  __isset = other1165.__isset;
  return *this;
}
void license_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "license_info(";
  out << "key="; (__isset.key ? (out << to_string(key)) : (out << "<null>"));
  out << ", " << "activated="; (__isset.activated ? (out << to_string(activated)) : (out << "<null>"));
  out << ", " << "count="; (__isset.count ? (out << to_string(count)) : (out << "<null>"));
  out << ", " << "expired_date="; (__isset.expired_date ? (out << to_string(expired_date)) : (out << "<null>"));
  out << ", " << "consumed="; (__isset.consumed ? (out << to_string(consumed)) : (out << "<null>"));
  out << ", " << "is_active="; (__isset.is_active ? (out << to_string(is_active)) : (out << "<null>"));
  out << ", " << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
  out << ", " << "email="; (__isset.email ? (out << to_string(email)) : (out << "<null>"));
  out << ", " << "status="; (__isset.status ? (out << to_string(status)) : (out << "<null>"));
  out << ")";
}


workload_history::~workload_history() throw() {
}


void workload_history::__set_machine_id(const std::string& val) {
  this->machine_id = val;
__isset.machine_id = true;
}

void workload_history::__set_name(const std::string& val) {
  this->name = val;
__isset.name = true;
}

void workload_history::__set_type(const std::string& val) {
  this->type = val;
__isset.type = true;
}

void workload_history::__set_histories(const std::vector<int32_t> & val) {
  this->histories = val;
__isset.histories = true;
}
std::ostream& operator<<(std::ostream& out, const workload_history& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t workload_history::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->machine_id);
          this->__isset.machine_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->histories.clear();
            uint32_t _size1166;
            ::apache::thrift::protocol::TType _etype1169;
            xfer += iprot->readListBegin(_etype1169, _size1166);
            this->histories.resize(_size1166);
            uint32_t _i1170;
            for (_i1170 = 0; _i1170 < _size1166; ++_i1170)
            {
              xfer += iprot->readI32(this->histories[_i1170]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.histories = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t workload_history::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("workload_history");

  if (this->__isset.machine_id) {
    xfer += oprot->writeFieldBegin("machine_id", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->machine_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.type) {
    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.histories) {
    xfer += oprot->writeFieldBegin("histories", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->histories.size()));
      std::vector<int32_t> ::const_iterator _iter1171;
      for (_iter1171 = this->histories.begin(); _iter1171 != this->histories.end(); ++_iter1171)
      {
        xfer += oprot->writeI32((*_iter1171));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(workload_history &a, workload_history &b) {
  using ::std::swap;
  swap(a.machine_id, b.machine_id);
  swap(a.name, b.name);
  swap(a.type, b.type);
  swap(a.histories, b.histories);
  swap(a.__isset, b.__isset);
}

workload_history::workload_history(const workload_history& other1172) {
  machine_id = other1172.machine_id;
  name = other1172.name;
  type = other1172.type;
  histories = other1172.histories;
  __isset = other1172.__isset;
}
workload_history& workload_history::operator=(const workload_history& other1173) {
  machine_id = other1173.machine_id;
  name = other1173.name;
  type = other1173.type;
  histories = other1173.histories;
  __isset = other1173.__isset;
  return *this;
}
void workload_history::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "workload_history(";
  out << "machine_id="; (__isset.machine_id ? (out << to_string(machine_id)) : (out << "<null>"));
  out << ", " << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
  out << ", " << "type="; (__isset.type ? (out << to_string(type)) : (out << "<null>"));
  out << ", " << "histories="; (__isset.histories ? (out << to_string(histories)) : (out << "<null>"));
  out << ")";
}


license_infos::~license_infos() throw() {
}


void license_infos::__set_licenses(const std::vector<license_info> & val) {
  this->licenses = val;
__isset.licenses = true;
}

void license_infos::__set_histories(const std::vector<workload_history> & val) {
  this->histories = val;
__isset.histories = true;
}
std::ostream& operator<<(std::ostream& out, const license_infos& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t license_infos::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->licenses.clear();
            uint32_t _size1174;
            ::apache::thrift::protocol::TType _etype1177;
            xfer += iprot->readListBegin(_etype1177, _size1174);
            this->licenses.resize(_size1174);
            uint32_t _i1178;
            for (_i1178 = 0; _i1178 < _size1174; ++_i1178)
            {
              xfer += this->licenses[_i1178].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.licenses = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->histories.clear();
            uint32_t _size1179;
            ::apache::thrift::protocol::TType _etype1182;
            xfer += iprot->readListBegin(_etype1182, _size1179);
            this->histories.resize(_size1179);
            uint32_t _i1183;
            for (_i1183 = 0; _i1183 < _size1179; ++_i1183)
            {
              xfer += this->histories[_i1183].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.histories = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t license_infos::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("license_infos");

  if (this->__isset.licenses) {
    xfer += oprot->writeFieldBegin("licenses", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->licenses.size()));
      std::vector<license_info> ::const_iterator _iter1184;
      for (_iter1184 = this->licenses.begin(); _iter1184 != this->licenses.end(); ++_iter1184)
      {
        xfer += (*_iter1184).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.histories) {
    xfer += oprot->writeFieldBegin("histories", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->histories.size()));
      std::vector<workload_history> ::const_iterator _iter1185;
      for (_iter1185 = this->histories.begin(); _iter1185 != this->histories.end(); ++_iter1185)
      {
        xfer += (*_iter1185).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(license_infos &a, license_infos &b) {
  using ::std::swap;
  swap(a.licenses, b.licenses);
  swap(a.histories, b.histories);
  swap(a.__isset, b.__isset);
}

license_infos::license_infos(const license_infos& other1186) {
  licenses = other1186.licenses;
  histories = other1186.histories;
  __isset = other1186.__isset;
}
license_infos& license_infos::operator=(const license_infos& other1187) {
  licenses = other1187.licenses;
  histories = other1187.histories;
  __isset = other1187.__isset;
  return *this;
}
void license_infos::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "license_infos(";
  out << "licenses="; (__isset.licenses ? (out << to_string(licenses)) : (out << "<null>"));
  out << ", " << "histories="; (__isset.histories ? (out << to_string(histories)) : (out << "<null>"));
  out << ")";
}


running_task::~running_task() throw() {
}


void running_task::__set_id(const std::string& val) {
  this->id = val;
__isset.id = true;
}

void running_task::__set_triggers(const std::vector<job_trigger> & val) {
  this->triggers = val;
__isset.triggers = true;
}

void running_task::__set_mgmt_addr(const std::string& val) {
  this->mgmt_addr = val;
__isset.mgmt_addr = true;
}

void running_task::__set_mgmt_port(const int32_t val) {
  this->mgmt_port = val;
__isset.mgmt_port = true;
}

void running_task::__set_is_ssl(const bool val) {
  this->is_ssl = val;
__isset.is_ssl = true;
}

void running_task::__set_parameters(const std::string& val) {
  this->parameters = val;
__isset.parameters = true;
}
std::ostream& operator<<(std::ostream& out, const running_task& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t running_task::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->triggers.clear();
            uint32_t _size1188;
            ::apache::thrift::protocol::TType _etype1191;
            xfer += iprot->readListBegin(_etype1191, _size1188);
            this->triggers.resize(_size1188);
            uint32_t _i1192;
            for (_i1192 = 0; _i1192 < _size1188; ++_i1192)
            {
              xfer += this->triggers[_i1192].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.triggers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->mgmt_addr);
          this->__isset.mgmt_addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->mgmt_port);
          this->__isset.mgmt_port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_ssl);
          this->__isset.is_ssl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->parameters);
          this->__isset.parameters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t running_task::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("running_task");

  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.triggers) {
    xfer += oprot->writeFieldBegin("triggers", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->triggers.size()));
      std::vector<job_trigger> ::const_iterator _iter1193;
      for (_iter1193 = this->triggers.begin(); _iter1193 != this->triggers.end(); ++_iter1193)
      {
        xfer += (*_iter1193).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mgmt_addr) {
    xfer += oprot->writeFieldBegin("mgmt_addr", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->mgmt_addr);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mgmt_port) {
    xfer += oprot->writeFieldBegin("mgmt_port", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->mgmt_port);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_ssl) {
    xfer += oprot->writeFieldBegin("is_ssl", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->is_ssl);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.parameters) {
    xfer += oprot->writeFieldBegin("parameters", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->parameters);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(running_task &a, running_task &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.triggers, b.triggers);
  swap(a.mgmt_addr, b.mgmt_addr);
  swap(a.mgmt_port, b.mgmt_port);
  swap(a.is_ssl, b.is_ssl);
  swap(a.parameters, b.parameters);
  swap(a.__isset, b.__isset);
}

running_task::running_task(const running_task& other1194) {
  id = other1194.id;
  triggers = other1194.triggers;
  mgmt_addr = other1194.mgmt_addr;
  mgmt_port = other1194.mgmt_port;
  is_ssl = other1194.is_ssl;
  parameters = other1194.parameters;
  __isset = other1194.__isset;
}
running_task& running_task::operator=(const running_task& other1195) {
  id = other1195.id;
  triggers = other1195.triggers;
  mgmt_addr = other1195.mgmt_addr;
  mgmt_port = other1195.mgmt_port;
  is_ssl = other1195.is_ssl;
  parameters = other1195.parameters;
  __isset = other1195.__isset;
  return *this;
}
void running_task::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "running_task(";
  out << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "triggers="; (__isset.triggers ? (out << to_string(triggers)) : (out << "<null>"));
  out << ", " << "mgmt_addr="; (__isset.mgmt_addr ? (out << to_string(mgmt_addr)) : (out << "<null>"));
  out << ", " << "mgmt_port="; (__isset.mgmt_port ? (out << to_string(mgmt_port)) : (out << "<null>"));
  out << ", " << "is_ssl="; (__isset.is_ssl ? (out << to_string(is_ssl)) : (out << "<null>"));
  out << ", " << "parameters="; (__isset.parameters ? (out << to_string(parameters)) : (out << "<null>"));
  out << ")";
}

}} // namespace
