/**
 * Autogenerated by Thrift Compiler (0.12.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef carrier_service_H
#define carrier_service_H

#include <thrift/transport/TBufferTransports.h>
#include <thrift/stdcxx.h>
namespace apache { namespace thrift { namespace async {
class TAsyncChannel;
}}}
#include <thrift/TDispatchProcessor.h>
#include <thrift/async/TAsyncDispatchProcessor.h>
#include <thrift/async/TConcurrentClientSyncInfo.h>
#include "saasame_types.h"
#include "common_connection_service.h"

namespace saasame { namespace transport {

#ifdef _MSC_VER
  #pragma warning( push )
  #pragma warning (disable : 4250 ) //inheriting methods via dominance 
#endif

class carrier_serviceIf : virtual public common_connection_serviceIf {
 public:
  virtual ~carrier_serviceIf() {}
  virtual void create(std::string& _return, const std::string& session_id, const create_image_info& image) = 0;
  virtual void create_ex(std::string& _return, const std::string& session_id, const std::set<std::string> & connection_ids, const std::string& base_name, const std::string& name, const int64_t size, const int32_t block_size, const std::string& parent, const bool checksum_verify) = 0;
  virtual void open(std::string& _return, const std::string& session_id, const std::set<std::string> & connection_ids, const std::string& base_name, const std::string& name) = 0;
  virtual void read(std::string& _return, const std::string& session_id, const std::string& image_id, const int64_t start, const int32_t number_of_bytes_to_read) = 0;
  virtual int32_t write(const std::string& session_id, const std::string& image_id, const int64_t start, const std::string& buffer, const int32_t number_of_bytes_to_write) = 0;
  virtual int32_t write_ex(const std::string& session_id, const std::string& image_id, const int64_t start, const std::string& buffer, const int32_t number_of_bytes_to_write, const bool is_compressed) = 0;
  virtual bool close(const std::string& session_id, const std::string& image_id, const bool is_cancel) = 0;
  virtual bool remove_base_image(const std::string& session_id, const std::set<std::string> & base_images) = 0;
  virtual bool remove_snapshot_image(const std::string& session_id, const std::map<std::string, image_map_info> & images) = 0;
  virtual bool verify_management(const std::string& management, const int32_t port, const bool is_ssl) = 0;
  virtual bool set_buffer_size(const std::string& session_id, const int32_t size) = 0;
  virtual bool is_buffer_free(const std::string& session_id, const std::string& image_id) = 0;
  virtual bool is_image_replicated(const std::string& session_id, const std::set<std::string> & connection_ids, const std::string& image_name) = 0;
};

class carrier_serviceIfFactory : virtual public common_connection_serviceIfFactory {
 public:
  typedef carrier_serviceIf Handler;

  virtual ~carrier_serviceIfFactory() {}

  virtual carrier_serviceIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler(common_serviceIf* /* handler */) = 0;
};

class carrier_serviceIfSingletonFactory : virtual public carrier_serviceIfFactory {
 public:
  carrier_serviceIfSingletonFactory(const ::apache::thrift::stdcxx::shared_ptr<carrier_serviceIf>& iface) : iface_(iface) {}
  virtual ~carrier_serviceIfSingletonFactory() {}

  virtual carrier_serviceIf* getHandler(const ::apache::thrift::TConnectionInfo&) {
    return iface_.get();
  }
  virtual void releaseHandler(common_serviceIf* /* handler */) {}

 protected:
  ::apache::thrift::stdcxx::shared_ptr<carrier_serviceIf> iface_;
};

class carrier_serviceNull : virtual public carrier_serviceIf , virtual public common_connection_serviceNull {
 public:
  virtual ~carrier_serviceNull() {}
  void create(std::string& /* _return */, const std::string& /* session_id */, const create_image_info& /* image */) {
    return;
  }
  void create_ex(std::string& /* _return */, const std::string& /* session_id */, const std::set<std::string> & /* connection_ids */, const std::string& /* base_name */, const std::string& /* name */, const int64_t /* size */, const int32_t /* block_size */, const std::string& /* parent */, const bool /* checksum_verify */) {
    return;
  }
  void open(std::string& /* _return */, const std::string& /* session_id */, const std::set<std::string> & /* connection_ids */, const std::string& /* base_name */, const std::string& /* name */) {
    return;
  }
  void read(std::string& /* _return */, const std::string& /* session_id */, const std::string& /* image_id */, const int64_t /* start */, const int32_t /* number_of_bytes_to_read */) {
    return;
  }
  int32_t write(const std::string& /* session_id */, const std::string& /* image_id */, const int64_t /* start */, const std::string& /* buffer */, const int32_t /* number_of_bytes_to_write */) {
    int32_t _return = 0;
    return _return;
  }
  int32_t write_ex(const std::string& /* session_id */, const std::string& /* image_id */, const int64_t /* start */, const std::string& /* buffer */, const int32_t /* number_of_bytes_to_write */, const bool /* is_compressed */) {
    int32_t _return = 0;
    return _return;
  }
  bool close(const std::string& /* session_id */, const std::string& /* image_id */, const bool /* is_cancel */) {
    bool _return = false;
    return _return;
  }
  bool remove_base_image(const std::string& /* session_id */, const std::set<std::string> & /* base_images */) {
    bool _return = false;
    return _return;
  }
  bool remove_snapshot_image(const std::string& /* session_id */, const std::map<std::string, image_map_info> & /* images */) {
    bool _return = false;
    return _return;
  }
  bool verify_management(const std::string& /* management */, const int32_t /* port */, const bool /* is_ssl */) {
    bool _return = false;
    return _return;
  }
  bool set_buffer_size(const std::string& /* session_id */, const int32_t /* size */) {
    bool _return = false;
    return _return;
  }
  bool is_buffer_free(const std::string& /* session_id */, const std::string& /* image_id */) {
    bool _return = false;
    return _return;
  }
  bool is_image_replicated(const std::string& /* session_id */, const std::set<std::string> & /* connection_ids */, const std::string& /* image_name */) {
    bool _return = false;
    return _return;
  }
};

typedef struct _carrier_service_create_args__isset {
  _carrier_service_create_args__isset() : session_id(false), image(false) {}
  bool session_id :1;
  bool image :1;
} _carrier_service_create_args__isset;

class carrier_service_create_args {
 public:

  carrier_service_create_args(const carrier_service_create_args&);
  carrier_service_create_args& operator=(const carrier_service_create_args&);
  carrier_service_create_args() : session_id() {
  }

  virtual ~carrier_service_create_args() throw();
  std::string session_id;
  create_image_info image;

  _carrier_service_create_args__isset __isset;

  void __set_session_id(const std::string& val);

  void __set_image(const create_image_info& val);

  bool operator == (const carrier_service_create_args & rhs) const
  {
    if (!(session_id == rhs.session_id))
      return false;
    if (!(image == rhs.image))
      return false;
    return true;
  }
  bool operator != (const carrier_service_create_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const carrier_service_create_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class carrier_service_create_pargs {
 public:


  virtual ~carrier_service_create_pargs() throw();
  const std::string* session_id;
  const create_image_info* image;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _carrier_service_create_result__isset {
  _carrier_service_create_result__isset() : success(false), ouch(false) {}
  bool success :1;
  bool ouch :1;
} _carrier_service_create_result__isset;

class carrier_service_create_result {
 public:

  carrier_service_create_result(const carrier_service_create_result&);
  carrier_service_create_result& operator=(const carrier_service_create_result&);
  carrier_service_create_result() : success() {
  }

  virtual ~carrier_service_create_result() throw();
  std::string success;
  invalid_operation ouch;

  _carrier_service_create_result__isset __isset;

  void __set_success(const std::string& val);

  void __set_ouch(const invalid_operation& val);

  bool operator == (const carrier_service_create_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ouch == rhs.ouch))
      return false;
    return true;
  }
  bool operator != (const carrier_service_create_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const carrier_service_create_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _carrier_service_create_presult__isset {
  _carrier_service_create_presult__isset() : success(false), ouch(false) {}
  bool success :1;
  bool ouch :1;
} _carrier_service_create_presult__isset;

class carrier_service_create_presult {
 public:


  virtual ~carrier_service_create_presult() throw();
  std::string* success;
  invalid_operation ouch;

  _carrier_service_create_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _carrier_service_create_ex_args__isset {
  _carrier_service_create_ex_args__isset() : session_id(false), connection_ids(false), base_name(false), name(false), size(false), block_size(false), parent(false), checksum_verify(false) {}
  bool session_id :1;
  bool connection_ids :1;
  bool base_name :1;
  bool name :1;
  bool size :1;
  bool block_size :1;
  bool parent :1;
  bool checksum_verify :1;
} _carrier_service_create_ex_args__isset;

class carrier_service_create_ex_args {
 public:

  carrier_service_create_ex_args(const carrier_service_create_ex_args&);
  carrier_service_create_ex_args& operator=(const carrier_service_create_ex_args&);
  carrier_service_create_ex_args() : session_id(), base_name(), name(), size(0), block_size(0), parent(), checksum_verify(0) {
  }

  virtual ~carrier_service_create_ex_args() throw();
  std::string session_id;
  std::set<std::string>  connection_ids;
  std::string base_name;
  std::string name;
  int64_t size;
  int32_t block_size;
  std::string parent;
  bool checksum_verify;

  _carrier_service_create_ex_args__isset __isset;

  void __set_session_id(const std::string& val);

  void __set_connection_ids(const std::set<std::string> & val);

  void __set_base_name(const std::string& val);

  void __set_name(const std::string& val);

  void __set_size(const int64_t val);

  void __set_block_size(const int32_t val);

  void __set_parent(const std::string& val);

  void __set_checksum_verify(const bool val);

  bool operator == (const carrier_service_create_ex_args & rhs) const
  {
    if (!(session_id == rhs.session_id))
      return false;
    if (!(connection_ids == rhs.connection_ids))
      return false;
    if (!(base_name == rhs.base_name))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(size == rhs.size))
      return false;
    if (!(block_size == rhs.block_size))
      return false;
    if (!(parent == rhs.parent))
      return false;
    if (!(checksum_verify == rhs.checksum_verify))
      return false;
    return true;
  }
  bool operator != (const carrier_service_create_ex_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const carrier_service_create_ex_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class carrier_service_create_ex_pargs {
 public:


  virtual ~carrier_service_create_ex_pargs() throw();
  const std::string* session_id;
  const std::set<std::string> * connection_ids;
  const std::string* base_name;
  const std::string* name;
  const int64_t* size;
  const int32_t* block_size;
  const std::string* parent;
  const bool* checksum_verify;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _carrier_service_create_ex_result__isset {
  _carrier_service_create_ex_result__isset() : success(false), ouch(false) {}
  bool success :1;
  bool ouch :1;
} _carrier_service_create_ex_result__isset;

class carrier_service_create_ex_result {
 public:

  carrier_service_create_ex_result(const carrier_service_create_ex_result&);
  carrier_service_create_ex_result& operator=(const carrier_service_create_ex_result&);
  carrier_service_create_ex_result() : success() {
  }

  virtual ~carrier_service_create_ex_result() throw();
  std::string success;
  invalid_operation ouch;

  _carrier_service_create_ex_result__isset __isset;

  void __set_success(const std::string& val);

  void __set_ouch(const invalid_operation& val);

  bool operator == (const carrier_service_create_ex_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ouch == rhs.ouch))
      return false;
    return true;
  }
  bool operator != (const carrier_service_create_ex_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const carrier_service_create_ex_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _carrier_service_create_ex_presult__isset {
  _carrier_service_create_ex_presult__isset() : success(false), ouch(false) {}
  bool success :1;
  bool ouch :1;
} _carrier_service_create_ex_presult__isset;

class carrier_service_create_ex_presult {
 public:


  virtual ~carrier_service_create_ex_presult() throw();
  std::string* success;
  invalid_operation ouch;

  _carrier_service_create_ex_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _carrier_service_open_args__isset {
  _carrier_service_open_args__isset() : session_id(false), connection_ids(false), base_name(false), name(false) {}
  bool session_id :1;
  bool connection_ids :1;
  bool base_name :1;
  bool name :1;
} _carrier_service_open_args__isset;

class carrier_service_open_args {
 public:

  carrier_service_open_args(const carrier_service_open_args&);
  carrier_service_open_args& operator=(const carrier_service_open_args&);
  carrier_service_open_args() : session_id(), base_name(), name() {
  }

  virtual ~carrier_service_open_args() throw();
  std::string session_id;
  std::set<std::string>  connection_ids;
  std::string base_name;
  std::string name;

  _carrier_service_open_args__isset __isset;

  void __set_session_id(const std::string& val);

  void __set_connection_ids(const std::set<std::string> & val);

  void __set_base_name(const std::string& val);

  void __set_name(const std::string& val);

  bool operator == (const carrier_service_open_args & rhs) const
  {
    if (!(session_id == rhs.session_id))
      return false;
    if (!(connection_ids == rhs.connection_ids))
      return false;
    if (!(base_name == rhs.base_name))
      return false;
    if (!(name == rhs.name))
      return false;
    return true;
  }
  bool operator != (const carrier_service_open_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const carrier_service_open_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class carrier_service_open_pargs {
 public:


  virtual ~carrier_service_open_pargs() throw();
  const std::string* session_id;
  const std::set<std::string> * connection_ids;
  const std::string* base_name;
  const std::string* name;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _carrier_service_open_result__isset {
  _carrier_service_open_result__isset() : success(false), ouch(false) {}
  bool success :1;
  bool ouch :1;
} _carrier_service_open_result__isset;

class carrier_service_open_result {
 public:

  carrier_service_open_result(const carrier_service_open_result&);
  carrier_service_open_result& operator=(const carrier_service_open_result&);
  carrier_service_open_result() : success() {
  }

  virtual ~carrier_service_open_result() throw();
  std::string success;
  invalid_operation ouch;

  _carrier_service_open_result__isset __isset;

  void __set_success(const std::string& val);

  void __set_ouch(const invalid_operation& val);

  bool operator == (const carrier_service_open_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ouch == rhs.ouch))
      return false;
    return true;
  }
  bool operator != (const carrier_service_open_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const carrier_service_open_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _carrier_service_open_presult__isset {
  _carrier_service_open_presult__isset() : success(false), ouch(false) {}
  bool success :1;
  bool ouch :1;
} _carrier_service_open_presult__isset;

class carrier_service_open_presult {
 public:


  virtual ~carrier_service_open_presult() throw();
  std::string* success;
  invalid_operation ouch;

  _carrier_service_open_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _carrier_service_read_args__isset {
  _carrier_service_read_args__isset() : session_id(false), image_id(false), start(false), number_of_bytes_to_read(false) {}
  bool session_id :1;
  bool image_id :1;
  bool start :1;
  bool number_of_bytes_to_read :1;
} _carrier_service_read_args__isset;

class carrier_service_read_args {
 public:

  carrier_service_read_args(const carrier_service_read_args&);
  carrier_service_read_args& operator=(const carrier_service_read_args&);
  carrier_service_read_args() : session_id(), image_id(), start(0), number_of_bytes_to_read(0) {
  }

  virtual ~carrier_service_read_args() throw();
  std::string session_id;
  std::string image_id;
  int64_t start;
  int32_t number_of_bytes_to_read;

  _carrier_service_read_args__isset __isset;

  void __set_session_id(const std::string& val);

  void __set_image_id(const std::string& val);

  void __set_start(const int64_t val);

  void __set_number_of_bytes_to_read(const int32_t val);

  bool operator == (const carrier_service_read_args & rhs) const
  {
    if (!(session_id == rhs.session_id))
      return false;
    if (!(image_id == rhs.image_id))
      return false;
    if (!(start == rhs.start))
      return false;
    if (!(number_of_bytes_to_read == rhs.number_of_bytes_to_read))
      return false;
    return true;
  }
  bool operator != (const carrier_service_read_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const carrier_service_read_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class carrier_service_read_pargs {
 public:


  virtual ~carrier_service_read_pargs() throw();
  const std::string* session_id;
  const std::string* image_id;
  const int64_t* start;
  const int32_t* number_of_bytes_to_read;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _carrier_service_read_result__isset {
  _carrier_service_read_result__isset() : success(false), ouch(false) {}
  bool success :1;
  bool ouch :1;
} _carrier_service_read_result__isset;

class carrier_service_read_result {
 public:

  carrier_service_read_result(const carrier_service_read_result&);
  carrier_service_read_result& operator=(const carrier_service_read_result&);
  carrier_service_read_result() : success() {
  }

  virtual ~carrier_service_read_result() throw();
  std::string success;
  invalid_operation ouch;

  _carrier_service_read_result__isset __isset;

  void __set_success(const std::string& val);

  void __set_ouch(const invalid_operation& val);

  bool operator == (const carrier_service_read_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ouch == rhs.ouch))
      return false;
    return true;
  }
  bool operator != (const carrier_service_read_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const carrier_service_read_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _carrier_service_read_presult__isset {
  _carrier_service_read_presult__isset() : success(false), ouch(false) {}
  bool success :1;
  bool ouch :1;
} _carrier_service_read_presult__isset;

class carrier_service_read_presult {
 public:


  virtual ~carrier_service_read_presult() throw();
  std::string* success;
  invalid_operation ouch;

  _carrier_service_read_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _carrier_service_write_args__isset {
  _carrier_service_write_args__isset() : session_id(false), image_id(false), start(false), buffer(false), number_of_bytes_to_write(false) {}
  bool session_id :1;
  bool image_id :1;
  bool start :1;
  bool buffer :1;
  bool number_of_bytes_to_write :1;
} _carrier_service_write_args__isset;

class carrier_service_write_args {
 public:

  carrier_service_write_args(const carrier_service_write_args&);
  carrier_service_write_args& operator=(const carrier_service_write_args&);
  carrier_service_write_args() : session_id(), image_id(), start(0), buffer(), number_of_bytes_to_write(0) {
  }

  virtual ~carrier_service_write_args() throw();
  std::string session_id;
  std::string image_id;
  int64_t start;
  std::string buffer;
  int32_t number_of_bytes_to_write;

  _carrier_service_write_args__isset __isset;

  void __set_session_id(const std::string& val);

  void __set_image_id(const std::string& val);

  void __set_start(const int64_t val);

  void __set_buffer(const std::string& val);

  void __set_number_of_bytes_to_write(const int32_t val);

  bool operator == (const carrier_service_write_args & rhs) const
  {
    if (!(session_id == rhs.session_id))
      return false;
    if (!(image_id == rhs.image_id))
      return false;
    if (!(start == rhs.start))
      return false;
    if (!(buffer == rhs.buffer))
      return false;
    if (!(number_of_bytes_to_write == rhs.number_of_bytes_to_write))
      return false;
    return true;
  }
  bool operator != (const carrier_service_write_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const carrier_service_write_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class carrier_service_write_pargs {
 public:


  virtual ~carrier_service_write_pargs() throw();
  const std::string* session_id;
  const std::string* image_id;
  const int64_t* start;
  const std::string* buffer;
  const int32_t* number_of_bytes_to_write;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _carrier_service_write_result__isset {
  _carrier_service_write_result__isset() : success(false), ouch(false) {}
  bool success :1;
  bool ouch :1;
} _carrier_service_write_result__isset;

class carrier_service_write_result {
 public:

  carrier_service_write_result(const carrier_service_write_result&);
  carrier_service_write_result& operator=(const carrier_service_write_result&);
  carrier_service_write_result() : success(0) {
  }

  virtual ~carrier_service_write_result() throw();
  int32_t success;
  invalid_operation ouch;

  _carrier_service_write_result__isset __isset;

  void __set_success(const int32_t val);

  void __set_ouch(const invalid_operation& val);

  bool operator == (const carrier_service_write_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ouch == rhs.ouch))
      return false;
    return true;
  }
  bool operator != (const carrier_service_write_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const carrier_service_write_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _carrier_service_write_presult__isset {
  _carrier_service_write_presult__isset() : success(false), ouch(false) {}
  bool success :1;
  bool ouch :1;
} _carrier_service_write_presult__isset;

class carrier_service_write_presult {
 public:


  virtual ~carrier_service_write_presult() throw();
  int32_t* success;
  invalid_operation ouch;

  _carrier_service_write_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _carrier_service_write_ex_args__isset {
  _carrier_service_write_ex_args__isset() : session_id(false), image_id(false), start(false), buffer(false), number_of_bytes_to_write(false), is_compressed(false) {}
  bool session_id :1;
  bool image_id :1;
  bool start :1;
  bool buffer :1;
  bool number_of_bytes_to_write :1;
  bool is_compressed :1;
} _carrier_service_write_ex_args__isset;

class carrier_service_write_ex_args {
 public:

  carrier_service_write_ex_args(const carrier_service_write_ex_args&);
  carrier_service_write_ex_args& operator=(const carrier_service_write_ex_args&);
  carrier_service_write_ex_args() : session_id(), image_id(), start(0), buffer(), number_of_bytes_to_write(0), is_compressed(0) {
  }

  virtual ~carrier_service_write_ex_args() throw();
  std::string session_id;
  std::string image_id;
  int64_t start;
  std::string buffer;
  int32_t number_of_bytes_to_write;
  bool is_compressed;

  _carrier_service_write_ex_args__isset __isset;

  void __set_session_id(const std::string& val);

  void __set_image_id(const std::string& val);

  void __set_start(const int64_t val);

  void __set_buffer(const std::string& val);

  void __set_number_of_bytes_to_write(const int32_t val);

  void __set_is_compressed(const bool val);

  bool operator == (const carrier_service_write_ex_args & rhs) const
  {
    if (!(session_id == rhs.session_id))
      return false;
    if (!(image_id == rhs.image_id))
      return false;
    if (!(start == rhs.start))
      return false;
    if (!(buffer == rhs.buffer))
      return false;
    if (!(number_of_bytes_to_write == rhs.number_of_bytes_to_write))
      return false;
    if (!(is_compressed == rhs.is_compressed))
      return false;
    return true;
  }
  bool operator != (const carrier_service_write_ex_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const carrier_service_write_ex_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class carrier_service_write_ex_pargs {
 public:


  virtual ~carrier_service_write_ex_pargs() throw();
  const std::string* session_id;
  const std::string* image_id;
  const int64_t* start;
  const std::string* buffer;
  const int32_t* number_of_bytes_to_write;
  const bool* is_compressed;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _carrier_service_write_ex_result__isset {
  _carrier_service_write_ex_result__isset() : success(false), ouch(false) {}
  bool success :1;
  bool ouch :1;
} _carrier_service_write_ex_result__isset;

class carrier_service_write_ex_result {
 public:

  carrier_service_write_ex_result(const carrier_service_write_ex_result&);
  carrier_service_write_ex_result& operator=(const carrier_service_write_ex_result&);
  carrier_service_write_ex_result() : success(0) {
  }

  virtual ~carrier_service_write_ex_result() throw();
  int32_t success;
  invalid_operation ouch;

  _carrier_service_write_ex_result__isset __isset;

  void __set_success(const int32_t val);

  void __set_ouch(const invalid_operation& val);

  bool operator == (const carrier_service_write_ex_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ouch == rhs.ouch))
      return false;
    return true;
  }
  bool operator != (const carrier_service_write_ex_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const carrier_service_write_ex_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _carrier_service_write_ex_presult__isset {
  _carrier_service_write_ex_presult__isset() : success(false), ouch(false) {}
  bool success :1;
  bool ouch :1;
} _carrier_service_write_ex_presult__isset;

class carrier_service_write_ex_presult {
 public:


  virtual ~carrier_service_write_ex_presult() throw();
  int32_t* success;
  invalid_operation ouch;

  _carrier_service_write_ex_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _carrier_service_close_args__isset {
  _carrier_service_close_args__isset() : session_id(false), image_id(false), is_cancel(false) {}
  bool session_id :1;
  bool image_id :1;
  bool is_cancel :1;
} _carrier_service_close_args__isset;

class carrier_service_close_args {
 public:

  carrier_service_close_args(const carrier_service_close_args&);
  carrier_service_close_args& operator=(const carrier_service_close_args&);
  carrier_service_close_args() : session_id(), image_id(), is_cancel(0) {
  }

  virtual ~carrier_service_close_args() throw();
  std::string session_id;
  std::string image_id;
  bool is_cancel;

  _carrier_service_close_args__isset __isset;

  void __set_session_id(const std::string& val);

  void __set_image_id(const std::string& val);

  void __set_is_cancel(const bool val);

  bool operator == (const carrier_service_close_args & rhs) const
  {
    if (!(session_id == rhs.session_id))
      return false;
    if (!(image_id == rhs.image_id))
      return false;
    if (!(is_cancel == rhs.is_cancel))
      return false;
    return true;
  }
  bool operator != (const carrier_service_close_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const carrier_service_close_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class carrier_service_close_pargs {
 public:


  virtual ~carrier_service_close_pargs() throw();
  const std::string* session_id;
  const std::string* image_id;
  const bool* is_cancel;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _carrier_service_close_result__isset {
  _carrier_service_close_result__isset() : success(false), ouch(false) {}
  bool success :1;
  bool ouch :1;
} _carrier_service_close_result__isset;

class carrier_service_close_result {
 public:

  carrier_service_close_result(const carrier_service_close_result&);
  carrier_service_close_result& operator=(const carrier_service_close_result&);
  carrier_service_close_result() : success(0) {
  }

  virtual ~carrier_service_close_result() throw();
  bool success;
  invalid_operation ouch;

  _carrier_service_close_result__isset __isset;

  void __set_success(const bool val);

  void __set_ouch(const invalid_operation& val);

  bool operator == (const carrier_service_close_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ouch == rhs.ouch))
      return false;
    return true;
  }
  bool operator != (const carrier_service_close_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const carrier_service_close_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _carrier_service_close_presult__isset {
  _carrier_service_close_presult__isset() : success(false), ouch(false) {}
  bool success :1;
  bool ouch :1;
} _carrier_service_close_presult__isset;

class carrier_service_close_presult {
 public:


  virtual ~carrier_service_close_presult() throw();
  bool* success;
  invalid_operation ouch;

  _carrier_service_close_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _carrier_service_remove_base_image_args__isset {
  _carrier_service_remove_base_image_args__isset() : session_id(false), base_images(false) {}
  bool session_id :1;
  bool base_images :1;
} _carrier_service_remove_base_image_args__isset;

class carrier_service_remove_base_image_args {
 public:

  carrier_service_remove_base_image_args(const carrier_service_remove_base_image_args&);
  carrier_service_remove_base_image_args& operator=(const carrier_service_remove_base_image_args&);
  carrier_service_remove_base_image_args() : session_id() {
  }

  virtual ~carrier_service_remove_base_image_args() throw();
  std::string session_id;
  std::set<std::string>  base_images;

  _carrier_service_remove_base_image_args__isset __isset;

  void __set_session_id(const std::string& val);

  void __set_base_images(const std::set<std::string> & val);

  bool operator == (const carrier_service_remove_base_image_args & rhs) const
  {
    if (!(session_id == rhs.session_id))
      return false;
    if (!(base_images == rhs.base_images))
      return false;
    return true;
  }
  bool operator != (const carrier_service_remove_base_image_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const carrier_service_remove_base_image_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class carrier_service_remove_base_image_pargs {
 public:


  virtual ~carrier_service_remove_base_image_pargs() throw();
  const std::string* session_id;
  const std::set<std::string> * base_images;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _carrier_service_remove_base_image_result__isset {
  _carrier_service_remove_base_image_result__isset() : success(false), ouch(false) {}
  bool success :1;
  bool ouch :1;
} _carrier_service_remove_base_image_result__isset;

class carrier_service_remove_base_image_result {
 public:

  carrier_service_remove_base_image_result(const carrier_service_remove_base_image_result&);
  carrier_service_remove_base_image_result& operator=(const carrier_service_remove_base_image_result&);
  carrier_service_remove_base_image_result() : success(0) {
  }

  virtual ~carrier_service_remove_base_image_result() throw();
  bool success;
  invalid_operation ouch;

  _carrier_service_remove_base_image_result__isset __isset;

  void __set_success(const bool val);

  void __set_ouch(const invalid_operation& val);

  bool operator == (const carrier_service_remove_base_image_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ouch == rhs.ouch))
      return false;
    return true;
  }
  bool operator != (const carrier_service_remove_base_image_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const carrier_service_remove_base_image_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _carrier_service_remove_base_image_presult__isset {
  _carrier_service_remove_base_image_presult__isset() : success(false), ouch(false) {}
  bool success :1;
  bool ouch :1;
} _carrier_service_remove_base_image_presult__isset;

class carrier_service_remove_base_image_presult {
 public:


  virtual ~carrier_service_remove_base_image_presult() throw();
  bool* success;
  invalid_operation ouch;

  _carrier_service_remove_base_image_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _carrier_service_remove_snapshot_image_args__isset {
  _carrier_service_remove_snapshot_image_args__isset() : session_id(false), images(false) {}
  bool session_id :1;
  bool images :1;
} _carrier_service_remove_snapshot_image_args__isset;

class carrier_service_remove_snapshot_image_args {
 public:

  carrier_service_remove_snapshot_image_args(const carrier_service_remove_snapshot_image_args&);
  carrier_service_remove_snapshot_image_args& operator=(const carrier_service_remove_snapshot_image_args&);
  carrier_service_remove_snapshot_image_args() : session_id() {
  }

  virtual ~carrier_service_remove_snapshot_image_args() throw();
  std::string session_id;
  std::map<std::string, image_map_info>  images;

  _carrier_service_remove_snapshot_image_args__isset __isset;

  void __set_session_id(const std::string& val);

  void __set_images(const std::map<std::string, image_map_info> & val);

  bool operator == (const carrier_service_remove_snapshot_image_args & rhs) const
  {
    if (!(session_id == rhs.session_id))
      return false;
    if (!(images == rhs.images))
      return false;
    return true;
  }
  bool operator != (const carrier_service_remove_snapshot_image_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const carrier_service_remove_snapshot_image_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class carrier_service_remove_snapshot_image_pargs {
 public:


  virtual ~carrier_service_remove_snapshot_image_pargs() throw();
  const std::string* session_id;
  const std::map<std::string, image_map_info> * images;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _carrier_service_remove_snapshot_image_result__isset {
  _carrier_service_remove_snapshot_image_result__isset() : success(false), ouch(false) {}
  bool success :1;
  bool ouch :1;
} _carrier_service_remove_snapshot_image_result__isset;

class carrier_service_remove_snapshot_image_result {
 public:

  carrier_service_remove_snapshot_image_result(const carrier_service_remove_snapshot_image_result&);
  carrier_service_remove_snapshot_image_result& operator=(const carrier_service_remove_snapshot_image_result&);
  carrier_service_remove_snapshot_image_result() : success(0) {
  }

  virtual ~carrier_service_remove_snapshot_image_result() throw();
  bool success;
  invalid_operation ouch;

  _carrier_service_remove_snapshot_image_result__isset __isset;

  void __set_success(const bool val);

  void __set_ouch(const invalid_operation& val);

  bool operator == (const carrier_service_remove_snapshot_image_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ouch == rhs.ouch))
      return false;
    return true;
  }
  bool operator != (const carrier_service_remove_snapshot_image_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const carrier_service_remove_snapshot_image_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _carrier_service_remove_snapshot_image_presult__isset {
  _carrier_service_remove_snapshot_image_presult__isset() : success(false), ouch(false) {}
  bool success :1;
  bool ouch :1;
} _carrier_service_remove_snapshot_image_presult__isset;

class carrier_service_remove_snapshot_image_presult {
 public:


  virtual ~carrier_service_remove_snapshot_image_presult() throw();
  bool* success;
  invalid_operation ouch;

  _carrier_service_remove_snapshot_image_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _carrier_service_verify_management_args__isset {
  _carrier_service_verify_management_args__isset() : management(false), port(false), is_ssl(false) {}
  bool management :1;
  bool port :1;
  bool is_ssl :1;
} _carrier_service_verify_management_args__isset;

class carrier_service_verify_management_args {
 public:

  carrier_service_verify_management_args(const carrier_service_verify_management_args&);
  carrier_service_verify_management_args& operator=(const carrier_service_verify_management_args&);
  carrier_service_verify_management_args() : management(), port(0), is_ssl(0) {
  }

  virtual ~carrier_service_verify_management_args() throw();
  std::string management;
  int32_t port;
  bool is_ssl;

  _carrier_service_verify_management_args__isset __isset;

  void __set_management(const std::string& val);

  void __set_port(const int32_t val);

  void __set_is_ssl(const bool val);

  bool operator == (const carrier_service_verify_management_args & rhs) const
  {
    if (!(management == rhs.management))
      return false;
    if (!(port == rhs.port))
      return false;
    if (!(is_ssl == rhs.is_ssl))
      return false;
    return true;
  }
  bool operator != (const carrier_service_verify_management_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const carrier_service_verify_management_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class carrier_service_verify_management_pargs {
 public:


  virtual ~carrier_service_verify_management_pargs() throw();
  const std::string* management;
  const int32_t* port;
  const bool* is_ssl;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _carrier_service_verify_management_result__isset {
  _carrier_service_verify_management_result__isset() : success(false) {}
  bool success :1;
} _carrier_service_verify_management_result__isset;

class carrier_service_verify_management_result {
 public:

  carrier_service_verify_management_result(const carrier_service_verify_management_result&);
  carrier_service_verify_management_result& operator=(const carrier_service_verify_management_result&);
  carrier_service_verify_management_result() : success(0) {
  }

  virtual ~carrier_service_verify_management_result() throw();
  bool success;

  _carrier_service_verify_management_result__isset __isset;

  void __set_success(const bool val);

  bool operator == (const carrier_service_verify_management_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const carrier_service_verify_management_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const carrier_service_verify_management_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _carrier_service_verify_management_presult__isset {
  _carrier_service_verify_management_presult__isset() : success(false) {}
  bool success :1;
} _carrier_service_verify_management_presult__isset;

class carrier_service_verify_management_presult {
 public:


  virtual ~carrier_service_verify_management_presult() throw();
  bool* success;

  _carrier_service_verify_management_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _carrier_service_set_buffer_size_args__isset {
  _carrier_service_set_buffer_size_args__isset() : session_id(false), size(false) {}
  bool session_id :1;
  bool size :1;
} _carrier_service_set_buffer_size_args__isset;

class carrier_service_set_buffer_size_args {
 public:

  carrier_service_set_buffer_size_args(const carrier_service_set_buffer_size_args&);
  carrier_service_set_buffer_size_args& operator=(const carrier_service_set_buffer_size_args&);
  carrier_service_set_buffer_size_args() : session_id(), size(0) {
  }

  virtual ~carrier_service_set_buffer_size_args() throw();
  std::string session_id;
  int32_t size;

  _carrier_service_set_buffer_size_args__isset __isset;

  void __set_session_id(const std::string& val);

  void __set_size(const int32_t val);

  bool operator == (const carrier_service_set_buffer_size_args & rhs) const
  {
    if (!(session_id == rhs.session_id))
      return false;
    if (!(size == rhs.size))
      return false;
    return true;
  }
  bool operator != (const carrier_service_set_buffer_size_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const carrier_service_set_buffer_size_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class carrier_service_set_buffer_size_pargs {
 public:


  virtual ~carrier_service_set_buffer_size_pargs() throw();
  const std::string* session_id;
  const int32_t* size;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _carrier_service_set_buffer_size_result__isset {
  _carrier_service_set_buffer_size_result__isset() : success(false) {}
  bool success :1;
} _carrier_service_set_buffer_size_result__isset;

class carrier_service_set_buffer_size_result {
 public:

  carrier_service_set_buffer_size_result(const carrier_service_set_buffer_size_result&);
  carrier_service_set_buffer_size_result& operator=(const carrier_service_set_buffer_size_result&);
  carrier_service_set_buffer_size_result() : success(0) {
  }

  virtual ~carrier_service_set_buffer_size_result() throw();
  bool success;

  _carrier_service_set_buffer_size_result__isset __isset;

  void __set_success(const bool val);

  bool operator == (const carrier_service_set_buffer_size_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const carrier_service_set_buffer_size_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const carrier_service_set_buffer_size_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _carrier_service_set_buffer_size_presult__isset {
  _carrier_service_set_buffer_size_presult__isset() : success(false) {}
  bool success :1;
} _carrier_service_set_buffer_size_presult__isset;

class carrier_service_set_buffer_size_presult {
 public:


  virtual ~carrier_service_set_buffer_size_presult() throw();
  bool* success;

  _carrier_service_set_buffer_size_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _carrier_service_is_buffer_free_args__isset {
  _carrier_service_is_buffer_free_args__isset() : session_id(false), image_id(false) {}
  bool session_id :1;
  bool image_id :1;
} _carrier_service_is_buffer_free_args__isset;

class carrier_service_is_buffer_free_args {
 public:

  carrier_service_is_buffer_free_args(const carrier_service_is_buffer_free_args&);
  carrier_service_is_buffer_free_args& operator=(const carrier_service_is_buffer_free_args&);
  carrier_service_is_buffer_free_args() : session_id(), image_id() {
  }

  virtual ~carrier_service_is_buffer_free_args() throw();
  std::string session_id;
  std::string image_id;

  _carrier_service_is_buffer_free_args__isset __isset;

  void __set_session_id(const std::string& val);

  void __set_image_id(const std::string& val);

  bool operator == (const carrier_service_is_buffer_free_args & rhs) const
  {
    if (!(session_id == rhs.session_id))
      return false;
    if (!(image_id == rhs.image_id))
      return false;
    return true;
  }
  bool operator != (const carrier_service_is_buffer_free_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const carrier_service_is_buffer_free_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class carrier_service_is_buffer_free_pargs {
 public:


  virtual ~carrier_service_is_buffer_free_pargs() throw();
  const std::string* session_id;
  const std::string* image_id;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _carrier_service_is_buffer_free_result__isset {
  _carrier_service_is_buffer_free_result__isset() : success(false), ouch(false) {}
  bool success :1;
  bool ouch :1;
} _carrier_service_is_buffer_free_result__isset;

class carrier_service_is_buffer_free_result {
 public:

  carrier_service_is_buffer_free_result(const carrier_service_is_buffer_free_result&);
  carrier_service_is_buffer_free_result& operator=(const carrier_service_is_buffer_free_result&);
  carrier_service_is_buffer_free_result() : success(0) {
  }

  virtual ~carrier_service_is_buffer_free_result() throw();
  bool success;
  invalid_operation ouch;

  _carrier_service_is_buffer_free_result__isset __isset;

  void __set_success(const bool val);

  void __set_ouch(const invalid_operation& val);

  bool operator == (const carrier_service_is_buffer_free_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ouch == rhs.ouch))
      return false;
    return true;
  }
  bool operator != (const carrier_service_is_buffer_free_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const carrier_service_is_buffer_free_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _carrier_service_is_buffer_free_presult__isset {
  _carrier_service_is_buffer_free_presult__isset() : success(false), ouch(false) {}
  bool success :1;
  bool ouch :1;
} _carrier_service_is_buffer_free_presult__isset;

class carrier_service_is_buffer_free_presult {
 public:


  virtual ~carrier_service_is_buffer_free_presult() throw();
  bool* success;
  invalid_operation ouch;

  _carrier_service_is_buffer_free_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _carrier_service_is_image_replicated_args__isset {
  _carrier_service_is_image_replicated_args__isset() : session_id(false), connection_ids(false), image_name(false) {}
  bool session_id :1;
  bool connection_ids :1;
  bool image_name :1;
} _carrier_service_is_image_replicated_args__isset;

class carrier_service_is_image_replicated_args {
 public:

  carrier_service_is_image_replicated_args(const carrier_service_is_image_replicated_args&);
  carrier_service_is_image_replicated_args& operator=(const carrier_service_is_image_replicated_args&);
  carrier_service_is_image_replicated_args() : session_id(), image_name() {
  }

  virtual ~carrier_service_is_image_replicated_args() throw();
  std::string session_id;
  std::set<std::string>  connection_ids;
  std::string image_name;

  _carrier_service_is_image_replicated_args__isset __isset;

  void __set_session_id(const std::string& val);

  void __set_connection_ids(const std::set<std::string> & val);

  void __set_image_name(const std::string& val);

  bool operator == (const carrier_service_is_image_replicated_args & rhs) const
  {
    if (!(session_id == rhs.session_id))
      return false;
    if (!(connection_ids == rhs.connection_ids))
      return false;
    if (!(image_name == rhs.image_name))
      return false;
    return true;
  }
  bool operator != (const carrier_service_is_image_replicated_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const carrier_service_is_image_replicated_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class carrier_service_is_image_replicated_pargs {
 public:


  virtual ~carrier_service_is_image_replicated_pargs() throw();
  const std::string* session_id;
  const std::set<std::string> * connection_ids;
  const std::string* image_name;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _carrier_service_is_image_replicated_result__isset {
  _carrier_service_is_image_replicated_result__isset() : success(false), ouch(false) {}
  bool success :1;
  bool ouch :1;
} _carrier_service_is_image_replicated_result__isset;

class carrier_service_is_image_replicated_result {
 public:

  carrier_service_is_image_replicated_result(const carrier_service_is_image_replicated_result&);
  carrier_service_is_image_replicated_result& operator=(const carrier_service_is_image_replicated_result&);
  carrier_service_is_image_replicated_result() : success(0) {
  }

  virtual ~carrier_service_is_image_replicated_result() throw();
  bool success;
  invalid_operation ouch;

  _carrier_service_is_image_replicated_result__isset __isset;

  void __set_success(const bool val);

  void __set_ouch(const invalid_operation& val);

  bool operator == (const carrier_service_is_image_replicated_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ouch == rhs.ouch))
      return false;
    return true;
  }
  bool operator != (const carrier_service_is_image_replicated_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const carrier_service_is_image_replicated_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _carrier_service_is_image_replicated_presult__isset {
  _carrier_service_is_image_replicated_presult__isset() : success(false), ouch(false) {}
  bool success :1;
  bool ouch :1;
} _carrier_service_is_image_replicated_presult__isset;

class carrier_service_is_image_replicated_presult {
 public:


  virtual ~carrier_service_is_image_replicated_presult() throw();
  bool* success;
  invalid_operation ouch;

  _carrier_service_is_image_replicated_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class carrier_serviceClient : virtual public carrier_serviceIf, public common_connection_serviceClient {
 public:
  carrier_serviceClient(apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) :
    common_connection_serviceClient(prot, prot) {}
  carrier_serviceClient(apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) :    common_connection_serviceClient(iprot, oprot) {}
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void create(std::string& _return, const std::string& session_id, const create_image_info& image);
  void send_create(const std::string& session_id, const create_image_info& image);
  void recv_create(std::string& _return);
  void create_ex(std::string& _return, const std::string& session_id, const std::set<std::string> & connection_ids, const std::string& base_name, const std::string& name, const int64_t size, const int32_t block_size, const std::string& parent, const bool checksum_verify);
  void send_create_ex(const std::string& session_id, const std::set<std::string> & connection_ids, const std::string& base_name, const std::string& name, const int64_t size, const int32_t block_size, const std::string& parent, const bool checksum_verify);
  void recv_create_ex(std::string& _return);
  void open(std::string& _return, const std::string& session_id, const std::set<std::string> & connection_ids, const std::string& base_name, const std::string& name);
  void send_open(const std::string& session_id, const std::set<std::string> & connection_ids, const std::string& base_name, const std::string& name);
  void recv_open(std::string& _return);
  void read(std::string& _return, const std::string& session_id, const std::string& image_id, const int64_t start, const int32_t number_of_bytes_to_read);
  void send_read(const std::string& session_id, const std::string& image_id, const int64_t start, const int32_t number_of_bytes_to_read);
  void recv_read(std::string& _return);
  int32_t write(const std::string& session_id, const std::string& image_id, const int64_t start, const std::string& buffer, const int32_t number_of_bytes_to_write);
  void send_write(const std::string& session_id, const std::string& image_id, const int64_t start, const std::string& buffer, const int32_t number_of_bytes_to_write);
  int32_t recv_write();
  int32_t write_ex(const std::string& session_id, const std::string& image_id, const int64_t start, const std::string& buffer, const int32_t number_of_bytes_to_write, const bool is_compressed);
  void send_write_ex(const std::string& session_id, const std::string& image_id, const int64_t start, const std::string& buffer, const int32_t number_of_bytes_to_write, const bool is_compressed);
  int32_t recv_write_ex();
  bool close(const std::string& session_id, const std::string& image_id, const bool is_cancel);
  void send_close(const std::string& session_id, const std::string& image_id, const bool is_cancel);
  bool recv_close();
  bool remove_base_image(const std::string& session_id, const std::set<std::string> & base_images);
  void send_remove_base_image(const std::string& session_id, const std::set<std::string> & base_images);
  bool recv_remove_base_image();
  bool remove_snapshot_image(const std::string& session_id, const std::map<std::string, image_map_info> & images);
  void send_remove_snapshot_image(const std::string& session_id, const std::map<std::string, image_map_info> & images);
  bool recv_remove_snapshot_image();
  bool verify_management(const std::string& management, const int32_t port, const bool is_ssl);
  void send_verify_management(const std::string& management, const int32_t port, const bool is_ssl);
  bool recv_verify_management();
  bool set_buffer_size(const std::string& session_id, const int32_t size);
  void send_set_buffer_size(const std::string& session_id, const int32_t size);
  bool recv_set_buffer_size();
  bool is_buffer_free(const std::string& session_id, const std::string& image_id);
  void send_is_buffer_free(const std::string& session_id, const std::string& image_id);
  bool recv_is_buffer_free();
  bool is_image_replicated(const std::string& session_id, const std::set<std::string> & connection_ids, const std::string& image_name);
  void send_is_image_replicated(const std::string& session_id, const std::set<std::string> & connection_ids, const std::string& image_name);
  bool recv_is_image_replicated();
};

class carrier_serviceProcessor : public common_connection_serviceProcessor {
 protected:
  ::apache::thrift::stdcxx::shared_ptr<carrier_serviceIf> iface_;
  virtual bool dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext);
 private:
  typedef  void (carrier_serviceProcessor::*ProcessFunction)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*, void*);
  typedef std::map<std::string, ProcessFunction> ProcessMap;
  ProcessMap processMap_;
  void process_create(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_create_ex(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_open(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_read(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_write(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_write_ex(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_close(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_remove_base_image(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_remove_snapshot_image(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_verify_management(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_set_buffer_size(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_is_buffer_free(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_is_image_replicated(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  carrier_serviceProcessor(::apache::thrift::stdcxx::shared_ptr<carrier_serviceIf> iface) :
    common_connection_serviceProcessor(iface),
    iface_(iface) {
    processMap_["create"] = &carrier_serviceProcessor::process_create;
    processMap_["create_ex"] = &carrier_serviceProcessor::process_create_ex;
    processMap_["open"] = &carrier_serviceProcessor::process_open;
    processMap_["read"] = &carrier_serviceProcessor::process_read;
    processMap_["write"] = &carrier_serviceProcessor::process_write;
    processMap_["write_ex"] = &carrier_serviceProcessor::process_write_ex;
    processMap_["close"] = &carrier_serviceProcessor::process_close;
    processMap_["remove_base_image"] = &carrier_serviceProcessor::process_remove_base_image;
    processMap_["remove_snapshot_image"] = &carrier_serviceProcessor::process_remove_snapshot_image;
    processMap_["verify_management"] = &carrier_serviceProcessor::process_verify_management;
    processMap_["set_buffer_size"] = &carrier_serviceProcessor::process_set_buffer_size;
    processMap_["is_buffer_free"] = &carrier_serviceProcessor::process_is_buffer_free;
    processMap_["is_image_replicated"] = &carrier_serviceProcessor::process_is_image_replicated;
  }

  virtual ~carrier_serviceProcessor() {}
};

class carrier_serviceProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  carrier_serviceProcessorFactory(const ::apache::thrift::stdcxx::shared_ptr< carrier_serviceIfFactory >& handlerFactory) :
      handlerFactory_(handlerFactory) {}

  ::apache::thrift::stdcxx::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo);

 protected:
  ::apache::thrift::stdcxx::shared_ptr< carrier_serviceIfFactory > handlerFactory_;
};

class carrier_serviceMultiface : virtual public carrier_serviceIf, public common_connection_serviceMultiface {
 public:
  carrier_serviceMultiface(std::vector<apache::thrift::stdcxx::shared_ptr<carrier_serviceIf> >& ifaces) : ifaces_(ifaces) {
    std::vector<apache::thrift::stdcxx::shared_ptr<carrier_serviceIf> >::iterator iter;
    for (iter = ifaces.begin(); iter != ifaces.end(); ++iter) {
      common_connection_serviceMultiface::add(*iter);
    }
  }
  virtual ~carrier_serviceMultiface() {}
 protected:
  std::vector<apache::thrift::stdcxx::shared_ptr<carrier_serviceIf> > ifaces_;
  carrier_serviceMultiface() {}
  void add(::apache::thrift::stdcxx::shared_ptr<carrier_serviceIf> iface) {
    common_connection_serviceMultiface::add(iface);
    ifaces_.push_back(iface);
  }
 public:
  void create(std::string& _return, const std::string& session_id, const create_image_info& image) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->create(_return, session_id, image);
    }
    ifaces_[i]->create(_return, session_id, image);
    return;
  }

  void create_ex(std::string& _return, const std::string& session_id, const std::set<std::string> & connection_ids, const std::string& base_name, const std::string& name, const int64_t size, const int32_t block_size, const std::string& parent, const bool checksum_verify) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->create_ex(_return, session_id, connection_ids, base_name, name, size, block_size, parent, checksum_verify);
    }
    ifaces_[i]->create_ex(_return, session_id, connection_ids, base_name, name, size, block_size, parent, checksum_verify);
    return;
  }

  void open(std::string& _return, const std::string& session_id, const std::set<std::string> & connection_ids, const std::string& base_name, const std::string& name) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->open(_return, session_id, connection_ids, base_name, name);
    }
    ifaces_[i]->open(_return, session_id, connection_ids, base_name, name);
    return;
  }

  void read(std::string& _return, const std::string& session_id, const std::string& image_id, const int64_t start, const int32_t number_of_bytes_to_read) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->read(_return, session_id, image_id, start, number_of_bytes_to_read);
    }
    ifaces_[i]->read(_return, session_id, image_id, start, number_of_bytes_to_read);
    return;
  }

  int32_t write(const std::string& session_id, const std::string& image_id, const int64_t start, const std::string& buffer, const int32_t number_of_bytes_to_write) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->write(session_id, image_id, start, buffer, number_of_bytes_to_write);
    }
    return ifaces_[i]->write(session_id, image_id, start, buffer, number_of_bytes_to_write);
  }

  int32_t write_ex(const std::string& session_id, const std::string& image_id, const int64_t start, const std::string& buffer, const int32_t number_of_bytes_to_write, const bool is_compressed) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->write_ex(session_id, image_id, start, buffer, number_of_bytes_to_write, is_compressed);
    }
    return ifaces_[i]->write_ex(session_id, image_id, start, buffer, number_of_bytes_to_write, is_compressed);
  }

  bool close(const std::string& session_id, const std::string& image_id, const bool is_cancel) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->close(session_id, image_id, is_cancel);
    }
    return ifaces_[i]->close(session_id, image_id, is_cancel);
  }

  bool remove_base_image(const std::string& session_id, const std::set<std::string> & base_images) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->remove_base_image(session_id, base_images);
    }
    return ifaces_[i]->remove_base_image(session_id, base_images);
  }

  bool remove_snapshot_image(const std::string& session_id, const std::map<std::string, image_map_info> & images) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->remove_snapshot_image(session_id, images);
    }
    return ifaces_[i]->remove_snapshot_image(session_id, images);
  }

  bool verify_management(const std::string& management, const int32_t port, const bool is_ssl) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->verify_management(management, port, is_ssl);
    }
    return ifaces_[i]->verify_management(management, port, is_ssl);
  }

  bool set_buffer_size(const std::string& session_id, const int32_t size) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->set_buffer_size(session_id, size);
    }
    return ifaces_[i]->set_buffer_size(session_id, size);
  }

  bool is_buffer_free(const std::string& session_id, const std::string& image_id) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->is_buffer_free(session_id, image_id);
    }
    return ifaces_[i]->is_buffer_free(session_id, image_id);
  }

  bool is_image_replicated(const std::string& session_id, const std::set<std::string> & connection_ids, const std::string& image_name) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->is_image_replicated(session_id, connection_ids, image_name);
    }
    return ifaces_[i]->is_image_replicated(session_id, connection_ids, image_name);
  }

};

// The 'concurrent' client is a thread safe client that correctly handles
// out of order responses.  It is slower than the regular client, so should
// only be used when you need to share a connection among multiple threads
class carrier_serviceConcurrentClient : virtual public carrier_serviceIf, public common_connection_serviceConcurrentClient {
 public:
  carrier_serviceConcurrentClient(apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) :
    common_connection_serviceConcurrentClient(prot, prot) {}
  carrier_serviceConcurrentClient(apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) :    common_connection_serviceConcurrentClient(iprot, oprot) {}
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void create(std::string& _return, const std::string& session_id, const create_image_info& image);
  int32_t send_create(const std::string& session_id, const create_image_info& image);
  void recv_create(std::string& _return, const int32_t seqid);
  void create_ex(std::string& _return, const std::string& session_id, const std::set<std::string> & connection_ids, const std::string& base_name, const std::string& name, const int64_t size, const int32_t block_size, const std::string& parent, const bool checksum_verify);
  int32_t send_create_ex(const std::string& session_id, const std::set<std::string> & connection_ids, const std::string& base_name, const std::string& name, const int64_t size, const int32_t block_size, const std::string& parent, const bool checksum_verify);
  void recv_create_ex(std::string& _return, const int32_t seqid);
  void open(std::string& _return, const std::string& session_id, const std::set<std::string> & connection_ids, const std::string& base_name, const std::string& name);
  int32_t send_open(const std::string& session_id, const std::set<std::string> & connection_ids, const std::string& base_name, const std::string& name);
  void recv_open(std::string& _return, const int32_t seqid);
  void read(std::string& _return, const std::string& session_id, const std::string& image_id, const int64_t start, const int32_t number_of_bytes_to_read);
  int32_t send_read(const std::string& session_id, const std::string& image_id, const int64_t start, const int32_t number_of_bytes_to_read);
  void recv_read(std::string& _return, const int32_t seqid);
  int32_t write(const std::string& session_id, const std::string& image_id, const int64_t start, const std::string& buffer, const int32_t number_of_bytes_to_write);
  int32_t send_write(const std::string& session_id, const std::string& image_id, const int64_t start, const std::string& buffer, const int32_t number_of_bytes_to_write);
  int32_t recv_write(const int32_t seqid);
  int32_t write_ex(const std::string& session_id, const std::string& image_id, const int64_t start, const std::string& buffer, const int32_t number_of_bytes_to_write, const bool is_compressed);
  int32_t send_write_ex(const std::string& session_id, const std::string& image_id, const int64_t start, const std::string& buffer, const int32_t number_of_bytes_to_write, const bool is_compressed);
  int32_t recv_write_ex(const int32_t seqid);
  bool close(const std::string& session_id, const std::string& image_id, const bool is_cancel);
  int32_t send_close(const std::string& session_id, const std::string& image_id, const bool is_cancel);
  bool recv_close(const int32_t seqid);
  bool remove_base_image(const std::string& session_id, const std::set<std::string> & base_images);
  int32_t send_remove_base_image(const std::string& session_id, const std::set<std::string> & base_images);
  bool recv_remove_base_image(const int32_t seqid);
  bool remove_snapshot_image(const std::string& session_id, const std::map<std::string, image_map_info> & images);
  int32_t send_remove_snapshot_image(const std::string& session_id, const std::map<std::string, image_map_info> & images);
  bool recv_remove_snapshot_image(const int32_t seqid);
  bool verify_management(const std::string& management, const int32_t port, const bool is_ssl);
  int32_t send_verify_management(const std::string& management, const int32_t port, const bool is_ssl);
  bool recv_verify_management(const int32_t seqid);
  bool set_buffer_size(const std::string& session_id, const int32_t size);
  int32_t send_set_buffer_size(const std::string& session_id, const int32_t size);
  bool recv_set_buffer_size(const int32_t seqid);
  bool is_buffer_free(const std::string& session_id, const std::string& image_id);
  int32_t send_is_buffer_free(const std::string& session_id, const std::string& image_id);
  bool recv_is_buffer_free(const int32_t seqid);
  bool is_image_replicated(const std::string& session_id, const std::set<std::string> & connection_ids, const std::string& image_name);
  int32_t send_is_image_replicated(const std::string& session_id, const std::set<std::string> & connection_ids, const std::string& image_name);
  bool recv_is_image_replicated(const int32_t seqid);
};

class carrier_serviceCobClient;

class carrier_serviceCobClIf : virtual public common_connection_serviceCobClIf {
 public:
  virtual ~carrier_serviceCobClIf() {}
  virtual void create(::apache::thrift::stdcxx::function<void(carrier_serviceCobClient* client)> cob, const std::string& session_id, const create_image_info& image) = 0;
  virtual void create_ex(::apache::thrift::stdcxx::function<void(carrier_serviceCobClient* client)> cob, const std::string& session_id, const std::set<std::string> & connection_ids, const std::string& base_name, const std::string& name, const int64_t size, const int32_t block_size, const std::string& parent, const bool checksum_verify) = 0;
  virtual void open(::apache::thrift::stdcxx::function<void(carrier_serviceCobClient* client)> cob, const std::string& session_id, const std::set<std::string> & connection_ids, const std::string& base_name, const std::string& name) = 0;
  virtual void read(::apache::thrift::stdcxx::function<void(carrier_serviceCobClient* client)> cob, const std::string& session_id, const std::string& image_id, const int64_t start, const int32_t number_of_bytes_to_read) = 0;
  virtual void write(::apache::thrift::stdcxx::function<void(carrier_serviceCobClient* client)> cob, const std::string& session_id, const std::string& image_id, const int64_t start, const std::string& buffer, const int32_t number_of_bytes_to_write) = 0;
  virtual void write_ex(::apache::thrift::stdcxx::function<void(carrier_serviceCobClient* client)> cob, const std::string& session_id, const std::string& image_id, const int64_t start, const std::string& buffer, const int32_t number_of_bytes_to_write, const bool is_compressed) = 0;
  virtual void close(::apache::thrift::stdcxx::function<void(carrier_serviceCobClient* client)> cob, const std::string& session_id, const std::string& image_id, const bool is_cancel) = 0;
  virtual void remove_base_image(::apache::thrift::stdcxx::function<void(carrier_serviceCobClient* client)> cob, const std::string& session_id, const std::set<std::string> & base_images) = 0;
  virtual void remove_snapshot_image(::apache::thrift::stdcxx::function<void(carrier_serviceCobClient* client)> cob, const std::string& session_id, const std::map<std::string, image_map_info> & images) = 0;
  virtual void verify_management(::apache::thrift::stdcxx::function<void(carrier_serviceCobClient* client)> cob, const std::string& management, const int32_t port, const bool is_ssl) = 0;
  virtual void set_buffer_size(::apache::thrift::stdcxx::function<void(carrier_serviceCobClient* client)> cob, const std::string& session_id, const int32_t size) = 0;
  virtual void is_buffer_free(::apache::thrift::stdcxx::function<void(carrier_serviceCobClient* client)> cob, const std::string& session_id, const std::string& image_id) = 0;
  virtual void is_image_replicated(::apache::thrift::stdcxx::function<void(carrier_serviceCobClient* client)> cob, const std::string& session_id, const std::set<std::string> & connection_ids, const std::string& image_name) = 0;
};

class carrier_serviceCobSvIf : virtual public common_connection_serviceCobSvIf {
 public:
  virtual ~carrier_serviceCobSvIf() {}
  virtual void create(::apache::thrift::stdcxx::function<void(std::string const& _return)> cob, ::apache::thrift::stdcxx::function<void(::apache::thrift::TDelayedException* _throw)> /* exn_cob */, const std::string& session_id, const create_image_info& image) = 0;
  virtual void create_ex(::apache::thrift::stdcxx::function<void(std::string const& _return)> cob, ::apache::thrift::stdcxx::function<void(::apache::thrift::TDelayedException* _throw)> /* exn_cob */, const std::string& session_id, const std::set<std::string> & connection_ids, const std::string& base_name, const std::string& name, const int64_t size, const int32_t block_size, const std::string& parent, const bool checksum_verify) = 0;
  virtual void open(::apache::thrift::stdcxx::function<void(std::string const& _return)> cob, ::apache::thrift::stdcxx::function<void(::apache::thrift::TDelayedException* _throw)> /* exn_cob */, const std::string& session_id, const std::set<std::string> & connection_ids, const std::string& base_name, const std::string& name) = 0;
  virtual void read(::apache::thrift::stdcxx::function<void(std::string const& _return)> cob, ::apache::thrift::stdcxx::function<void(::apache::thrift::TDelayedException* _throw)> /* exn_cob */, const std::string& session_id, const std::string& image_id, const int64_t start, const int32_t number_of_bytes_to_read) = 0;
  virtual void write(::apache::thrift::stdcxx::function<void(int32_t const& _return)> cob, ::apache::thrift::stdcxx::function<void(::apache::thrift::TDelayedException* _throw)> /* exn_cob */, const std::string& session_id, const std::string& image_id, const int64_t start, const std::string& buffer, const int32_t number_of_bytes_to_write) = 0;
  virtual void write_ex(::apache::thrift::stdcxx::function<void(int32_t const& _return)> cob, ::apache::thrift::stdcxx::function<void(::apache::thrift::TDelayedException* _throw)> /* exn_cob */, const std::string& session_id, const std::string& image_id, const int64_t start, const std::string& buffer, const int32_t number_of_bytes_to_write, const bool is_compressed) = 0;
  virtual void close(::apache::thrift::stdcxx::function<void(bool const& _return)> cob, ::apache::thrift::stdcxx::function<void(::apache::thrift::TDelayedException* _throw)> /* exn_cob */, const std::string& session_id, const std::string& image_id, const bool is_cancel) = 0;
  virtual void remove_base_image(::apache::thrift::stdcxx::function<void(bool const& _return)> cob, ::apache::thrift::stdcxx::function<void(::apache::thrift::TDelayedException* _throw)> /* exn_cob */, const std::string& session_id, const std::set<std::string> & base_images) = 0;
  virtual void remove_snapshot_image(::apache::thrift::stdcxx::function<void(bool const& _return)> cob, ::apache::thrift::stdcxx::function<void(::apache::thrift::TDelayedException* _throw)> /* exn_cob */, const std::string& session_id, const std::map<std::string, image_map_info> & images) = 0;
  virtual void verify_management(::apache::thrift::stdcxx::function<void(bool const& _return)> cob, const std::string& management, const int32_t port, const bool is_ssl) = 0;
  virtual void set_buffer_size(::apache::thrift::stdcxx::function<void(bool const& _return)> cob, const std::string& session_id, const int32_t size) = 0;
  virtual void is_buffer_free(::apache::thrift::stdcxx::function<void(bool const& _return)> cob, ::apache::thrift::stdcxx::function<void(::apache::thrift::TDelayedException* _throw)> /* exn_cob */, const std::string& session_id, const std::string& image_id) = 0;
  virtual void is_image_replicated(::apache::thrift::stdcxx::function<void(bool const& _return)> cob, ::apache::thrift::stdcxx::function<void(::apache::thrift::TDelayedException* _throw)> /* exn_cob */, const std::string& session_id, const std::set<std::string> & connection_ids, const std::string& image_name) = 0;
};

class carrier_serviceCobSvIfFactory : virtual public common_connection_serviceCobSvIfFactory {
 public:
  typedef carrier_serviceCobSvIf Handler;

  virtual ~carrier_serviceCobSvIfFactory() {}

  virtual carrier_serviceCobSvIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler(common_serviceCobSvIf* /* handler */) = 0;
};

class carrier_serviceCobSvIfSingletonFactory : virtual public carrier_serviceCobSvIfFactory {
 public:
  carrier_serviceCobSvIfSingletonFactory(const ::apache::thrift::stdcxx::shared_ptr<carrier_serviceCobSvIf>& iface) : iface_(iface) {}
  virtual ~carrier_serviceCobSvIfSingletonFactory() {}

  virtual carrier_serviceCobSvIf* getHandler(const ::apache::thrift::TConnectionInfo&) {
    return iface_.get();
  }
  virtual void releaseHandler(common_serviceCobSvIf* /* handler */) {}

 protected:
  ::apache::thrift::stdcxx::shared_ptr<carrier_serviceCobSvIf> iface_;
};

class carrier_serviceCobSvNull : virtual public carrier_serviceCobSvIf , virtual public common_connection_serviceCobSvNull {
 public:
  virtual ~carrier_serviceCobSvNull() {}
  void create(::apache::thrift::stdcxx::function<void(std::string const& _return)> cob, ::apache::thrift::stdcxx::function<void(::apache::thrift::TDelayedException* _throw)> /* exn_cob */, const std::string& /* session_id */, const create_image_info& /* image */) {
    std::string _return;
    return cob(_return);
  }
  void create_ex(::apache::thrift::stdcxx::function<void(std::string const& _return)> cob, ::apache::thrift::stdcxx::function<void(::apache::thrift::TDelayedException* _throw)> /* exn_cob */, const std::string& /* session_id */, const std::set<std::string> & /* connection_ids */, const std::string& /* base_name */, const std::string& /* name */, const int64_t /* size */, const int32_t /* block_size */, const std::string& /* parent */, const bool /* checksum_verify */) {
    std::string _return;
    return cob(_return);
  }
  void open(::apache::thrift::stdcxx::function<void(std::string const& _return)> cob, ::apache::thrift::stdcxx::function<void(::apache::thrift::TDelayedException* _throw)> /* exn_cob */, const std::string& /* session_id */, const std::set<std::string> & /* connection_ids */, const std::string& /* base_name */, const std::string& /* name */) {
    std::string _return;
    return cob(_return);
  }
  void read(::apache::thrift::stdcxx::function<void(std::string const& _return)> cob, ::apache::thrift::stdcxx::function<void(::apache::thrift::TDelayedException* _throw)> /* exn_cob */, const std::string& /* session_id */, const std::string& /* image_id */, const int64_t /* start */, const int32_t /* number_of_bytes_to_read */) {
    std::string _return;
    return cob(_return);
  }
  void write(::apache::thrift::stdcxx::function<void(int32_t const& _return)> cob, ::apache::thrift::stdcxx::function<void(::apache::thrift::TDelayedException* _throw)> /* exn_cob */, const std::string& /* session_id */, const std::string& /* image_id */, const int64_t /* start */, const std::string& /* buffer */, const int32_t /* number_of_bytes_to_write */) {
    int32_t _return = 0;
    return cob(_return);
  }
  void write_ex(::apache::thrift::stdcxx::function<void(int32_t const& _return)> cob, ::apache::thrift::stdcxx::function<void(::apache::thrift::TDelayedException* _throw)> /* exn_cob */, const std::string& /* session_id */, const std::string& /* image_id */, const int64_t /* start */, const std::string& /* buffer */, const int32_t /* number_of_bytes_to_write */, const bool /* is_compressed */) {
    int32_t _return = 0;
    return cob(_return);
  }
  void close(::apache::thrift::stdcxx::function<void(bool const& _return)> cob, ::apache::thrift::stdcxx::function<void(::apache::thrift::TDelayedException* _throw)> /* exn_cob */, const std::string& /* session_id */, const std::string& /* image_id */, const bool /* is_cancel */) {
    bool _return = false;
    return cob(_return);
  }
  void remove_base_image(::apache::thrift::stdcxx::function<void(bool const& _return)> cob, ::apache::thrift::stdcxx::function<void(::apache::thrift::TDelayedException* _throw)> /* exn_cob */, const std::string& /* session_id */, const std::set<std::string> & /* base_images */) {
    bool _return = false;
    return cob(_return);
  }
  void remove_snapshot_image(::apache::thrift::stdcxx::function<void(bool const& _return)> cob, ::apache::thrift::stdcxx::function<void(::apache::thrift::TDelayedException* _throw)> /* exn_cob */, const std::string& /* session_id */, const std::map<std::string, image_map_info> & /* images */) {
    bool _return = false;
    return cob(_return);
  }
  void verify_management(::apache::thrift::stdcxx::function<void(bool const& _return)> cob, const std::string& /* management */, const int32_t /* port */, const bool /* is_ssl */) {
    bool _return = false;
    return cob(_return);
  }
  void set_buffer_size(::apache::thrift::stdcxx::function<void(bool const& _return)> cob, const std::string& /* session_id */, const int32_t /* size */) {
    bool _return = false;
    return cob(_return);
  }
  void is_buffer_free(::apache::thrift::stdcxx::function<void(bool const& _return)> cob, ::apache::thrift::stdcxx::function<void(::apache::thrift::TDelayedException* _throw)> /* exn_cob */, const std::string& /* session_id */, const std::string& /* image_id */) {
    bool _return = false;
    return cob(_return);
  }
  void is_image_replicated(::apache::thrift::stdcxx::function<void(bool const& _return)> cob, ::apache::thrift::stdcxx::function<void(::apache::thrift::TDelayedException* _throw)> /* exn_cob */, const std::string& /* session_id */, const std::set<std::string> & /* connection_ids */, const std::string& /* image_name */) {
    bool _return = false;
    return cob(_return);
  }
};

class carrier_serviceCobClient : virtual public carrier_serviceCobClIf, public common_connection_serviceCobClient {
 public:
  carrier_serviceCobClient(apache::thrift::stdcxx::shared_ptr< ::apache::thrift::async::TAsyncChannel> channel, ::apache::thrift::protocol::TProtocolFactory* protocolFactory) :
    common_connection_serviceCobClient(channel, protocolFactory) {}
  ::apache::thrift::stdcxx::shared_ptr< ::apache::thrift::async::TAsyncChannel> getChannel() {
    return channel_;
  }
  virtual void completed__(bool /* success */) {}
  void create(::apache::thrift::stdcxx::function<void(carrier_serviceCobClient* client)> cob, const std::string& session_id, const create_image_info& image);
  void send_create(const std::string& session_id, const create_image_info& image);
  void recv_create(std::string& _return);
  void create_ex(::apache::thrift::stdcxx::function<void(carrier_serviceCobClient* client)> cob, const std::string& session_id, const std::set<std::string> & connection_ids, const std::string& base_name, const std::string& name, const int64_t size, const int32_t block_size, const std::string& parent, const bool checksum_verify);
  void send_create_ex(const std::string& session_id, const std::set<std::string> & connection_ids, const std::string& base_name, const std::string& name, const int64_t size, const int32_t block_size, const std::string& parent, const bool checksum_verify);
  void recv_create_ex(std::string& _return);
  void open(::apache::thrift::stdcxx::function<void(carrier_serviceCobClient* client)> cob, const std::string& session_id, const std::set<std::string> & connection_ids, const std::string& base_name, const std::string& name);
  void send_open(const std::string& session_id, const std::set<std::string> & connection_ids, const std::string& base_name, const std::string& name);
  void recv_open(std::string& _return);
  void read(::apache::thrift::stdcxx::function<void(carrier_serviceCobClient* client)> cob, const std::string& session_id, const std::string& image_id, const int64_t start, const int32_t number_of_bytes_to_read);
  void send_read(const std::string& session_id, const std::string& image_id, const int64_t start, const int32_t number_of_bytes_to_read);
  void recv_read(std::string& _return);
  void write(::apache::thrift::stdcxx::function<void(carrier_serviceCobClient* client)> cob, const std::string& session_id, const std::string& image_id, const int64_t start, const std::string& buffer, const int32_t number_of_bytes_to_write);
  void send_write(const std::string& session_id, const std::string& image_id, const int64_t start, const std::string& buffer, const int32_t number_of_bytes_to_write);
  int32_t recv_write();
  void write_ex(::apache::thrift::stdcxx::function<void(carrier_serviceCobClient* client)> cob, const std::string& session_id, const std::string& image_id, const int64_t start, const std::string& buffer, const int32_t number_of_bytes_to_write, const bool is_compressed);
  void send_write_ex(const std::string& session_id, const std::string& image_id, const int64_t start, const std::string& buffer, const int32_t number_of_bytes_to_write, const bool is_compressed);
  int32_t recv_write_ex();
  void close(::apache::thrift::stdcxx::function<void(carrier_serviceCobClient* client)> cob, const std::string& session_id, const std::string& image_id, const bool is_cancel);
  void send_close(const std::string& session_id, const std::string& image_id, const bool is_cancel);
  bool recv_close();
  void remove_base_image(::apache::thrift::stdcxx::function<void(carrier_serviceCobClient* client)> cob, const std::string& session_id, const std::set<std::string> & base_images);
  void send_remove_base_image(const std::string& session_id, const std::set<std::string> & base_images);
  bool recv_remove_base_image();
  void remove_snapshot_image(::apache::thrift::stdcxx::function<void(carrier_serviceCobClient* client)> cob, const std::string& session_id, const std::map<std::string, image_map_info> & images);
  void send_remove_snapshot_image(const std::string& session_id, const std::map<std::string, image_map_info> & images);
  bool recv_remove_snapshot_image();
  void verify_management(::apache::thrift::stdcxx::function<void(carrier_serviceCobClient* client)> cob, const std::string& management, const int32_t port, const bool is_ssl);
  void send_verify_management(const std::string& management, const int32_t port, const bool is_ssl);
  bool recv_verify_management();
  void set_buffer_size(::apache::thrift::stdcxx::function<void(carrier_serviceCobClient* client)> cob, const std::string& session_id, const int32_t size);
  void send_set_buffer_size(const std::string& session_id, const int32_t size);
  bool recv_set_buffer_size();
  void is_buffer_free(::apache::thrift::stdcxx::function<void(carrier_serviceCobClient* client)> cob, const std::string& session_id, const std::string& image_id);
  void send_is_buffer_free(const std::string& session_id, const std::string& image_id);
  bool recv_is_buffer_free();
  void is_image_replicated(::apache::thrift::stdcxx::function<void(carrier_serviceCobClient* client)> cob, const std::string& session_id, const std::set<std::string> & connection_ids, const std::string& image_name);
  void send_is_image_replicated(const std::string& session_id, const std::set<std::string> & connection_ids, const std::string& image_name);
  bool recv_is_image_replicated();
};

class carrier_serviceAsyncProcessor : public common_connection_serviceAsyncProcessor {
 protected:
  ::apache::thrift::stdcxx::shared_ptr<carrier_serviceCobSvIf> iface_;
  virtual void dispatchCall(::apache::thrift::stdcxx::function<void(bool ok)> cob, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid);
 private:
  typedef  void (carrier_serviceAsyncProcessor::*ProcessFunction)(::apache::thrift::stdcxx::function<void(bool ok)>, int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*);
  typedef std::map<std::string, ProcessFunction> ProcessMap;
  ProcessMap processMap_;
  void process_create(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void return_create(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::string& _return);
  void throw_create(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw);
  void process_create_ex(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void return_create_ex(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::string& _return);
  void throw_create_ex(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw);
  void process_open(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void return_open(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::string& _return);
  void throw_open(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw);
  void process_read(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void return_read(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::string& _return);
  void throw_read(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw);
  void process_write(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void return_write(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const int32_t& _return);
  void throw_write(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw);
  void process_write_ex(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void return_write_ex(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const int32_t& _return);
  void throw_write_ex(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw);
  void process_close(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void return_close(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const bool& _return);
  void throw_close(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw);
  void process_remove_base_image(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void return_remove_base_image(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const bool& _return);
  void throw_remove_base_image(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw);
  void process_remove_snapshot_image(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void return_remove_snapshot_image(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const bool& _return);
  void throw_remove_snapshot_image(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw);
  void process_verify_management(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void return_verify_management(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const bool& _return);
  void throw_verify_management(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw);
  void process_set_buffer_size(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void return_set_buffer_size(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const bool& _return);
  void throw_set_buffer_size(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw);
  void process_is_buffer_free(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void return_is_buffer_free(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const bool& _return);
  void throw_is_buffer_free(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw);
  void process_is_image_replicated(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void return_is_image_replicated(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const bool& _return);
  void throw_is_image_replicated(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw);
 public:
  carrier_serviceAsyncProcessor(::apache::thrift::stdcxx::shared_ptr<carrier_serviceCobSvIf> iface) :
    common_connection_serviceAsyncProcessor(iface),
    iface_(iface) {
    processMap_["create"] = &carrier_serviceAsyncProcessor::process_create;
    processMap_["create_ex"] = &carrier_serviceAsyncProcessor::process_create_ex;
    processMap_["open"] = &carrier_serviceAsyncProcessor::process_open;
    processMap_["read"] = &carrier_serviceAsyncProcessor::process_read;
    processMap_["write"] = &carrier_serviceAsyncProcessor::process_write;
    processMap_["write_ex"] = &carrier_serviceAsyncProcessor::process_write_ex;
    processMap_["close"] = &carrier_serviceAsyncProcessor::process_close;
    processMap_["remove_base_image"] = &carrier_serviceAsyncProcessor::process_remove_base_image;
    processMap_["remove_snapshot_image"] = &carrier_serviceAsyncProcessor::process_remove_snapshot_image;
    processMap_["verify_management"] = &carrier_serviceAsyncProcessor::process_verify_management;
    processMap_["set_buffer_size"] = &carrier_serviceAsyncProcessor::process_set_buffer_size;
    processMap_["is_buffer_free"] = &carrier_serviceAsyncProcessor::process_is_buffer_free;
    processMap_["is_image_replicated"] = &carrier_serviceAsyncProcessor::process_is_image_replicated;
  }

  virtual ~carrier_serviceAsyncProcessor() {}
};

class carrier_serviceAsyncProcessorFactory : public ::apache::thrift::async::TAsyncProcessorFactory {
 public:
  carrier_serviceAsyncProcessorFactory(const ::apache::thrift::stdcxx::shared_ptr< carrier_serviceCobSvIfFactory >& handlerFactory) :
      handlerFactory_(handlerFactory) {}

  ::apache::thrift::stdcxx::shared_ptr< ::apache::thrift::async::TAsyncProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo);

 protected:
  ::apache::thrift::stdcxx::shared_ptr< carrier_serviceCobSvIfFactory > handlerFactory_;
};

#ifdef _MSC_VER
  #pragma warning( pop )
#endif

}} // namespace

#endif
