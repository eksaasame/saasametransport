/**
 * Autogenerated by Thrift Compiler (0.10.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "saasame_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace saasame { namespace transport {

int _kenumerate_disk_filter_styleValues[] = {
  enumerate_disk_filter_style::ALL_DISK,
  enumerate_disk_filter_style::UNINITIALIZED_DISK
};
const char* _kenumerate_disk_filter_styleNames[] = {
  "ALL_DISK",
  "UNINITIALIZED_DISK"
};
const std::map<int, const char*> _enumerate_disk_filter_style_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kenumerate_disk_filter_styleValues, _kenumerate_disk_filter_styleNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kmachine_detail_filterValues[] = {
  machine_detail_filter::FULL,
  machine_detail_filter::SIMPLE
};
const char* _kmachine_detail_filterNames[] = {
  "FULL",
  "SIMPLE"
};
const std::map<int, const char*> _machine_detail_filter_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kmachine_detail_filterValues, _kmachine_detail_filterNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kpartition_styleValues[] = {
  partition_style::PARTITION_UNKNOWN,
  partition_style::PARTITION_MBR,
  partition_style::PARTITION_GPT
};
const char* _kpartition_styleNames[] = {
  "PARTITION_UNKNOWN",
  "PARTITION_MBR",
  "PARTITION_GPT"
};
const std::map<int, const char*> _partition_style_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kpartition_styleValues, _kpartition_styleNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kdrive_typeValues[] = {
  drive_type::DT_UNKNOWN,
  drive_type::DT_NO_ROOT_PATH,
  drive_type::DT_REMOVABLE,
  drive_type::DT_FIXED,
  drive_type::DT_REMOTE,
  drive_type::DT_CDROM,
  drive_type::DT_RAMDISK
};
const char* _kdrive_typeNames[] = {
  "DT_UNKNOWN",
  "DT_NO_ROOT_PATH",
  "DT_REMOVABLE",
  "DT_FIXED",
  "DT_REMOTE",
  "DT_CDROM",
  "DT_RAMDISK"
};
const std::map<int, const char*> _drive_type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kdrive_typeValues, _kdrive_typeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kbus_typeValues[] = {
  bus_type::Unknown,
  bus_type::SCSI,
  bus_type::ATAPI,
  bus_type::ATA,
  bus_type::IEEE_1394,
  bus_type::SSA,
  bus_type::Fibre_Channel,
  bus_type::USB,
  bus_type::RAID,
  bus_type::iSCSI,
  bus_type::SAS,
  bus_type::SATA,
  bus_type::SD,
  bus_type::MMC,
  bus_type::Virtual,
  bus_type::File_Backed_Virtual,
  bus_type::Storage_Spaces,
  bus_type::NVMe
};
const char* _kbus_typeNames[] = {
  "Unknown",
  "SCSI",
  "ATAPI",
  "ATA",
  "IEEE_1394",
  "SSA",
  "Fibre_Channel",
  "USB",
  "RAID",
  "iSCSI",
  "SAS",
  "SATA",
  "SD",
  "MMC",
  "Virtual",
  "File_Backed_Virtual",
  "Storage_Spaces",
  "NVMe"
};
const std::map<int, const char*> _bus_type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(18, _kbus_typeValues, _kbus_typeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _khv_vm_tools_statusValues[] = {
  hv_vm_tools_status::HV_VMTOOLS_UNKNOWN,
  hv_vm_tools_status::HV_VMTOOLS_OK,
  hv_vm_tools_status::HV_VMTOOLS_NOTINSTALLED,
  hv_vm_tools_status::HV_VMTOOLS_OLD,
  hv_vm_tools_status::HV_VMTOOLS_NOTRUNNING,
  hv_vm_tools_status::HV_VMTOOLS_NEEDUPGRADE,
  hv_vm_tools_status::HV_VMTOOLS_UNMANAGED,
  hv_vm_tools_status::HV_VMTOOLS_NEW,
  hv_vm_tools_status::HV_VMTOOLS_BLACKLISTED
};
const char* _khv_vm_tools_statusNames[] = {
  "HV_VMTOOLS_UNKNOWN",
  "HV_VMTOOLS_OK",
  "HV_VMTOOLS_NOTINSTALLED",
  "HV_VMTOOLS_OLD",
  "HV_VMTOOLS_NOTRUNNING",
  "HV_VMTOOLS_NEEDUPGRADE",
  "HV_VMTOOLS_UNMANAGED",
  "HV_VMTOOLS_NEW",
  "HV_VMTOOLS_BLACKLISTED"
};
const std::map<int, const char*> _hv_vm_tools_status_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(9, _khv_vm_tools_statusValues, _khv_vm_tools_statusNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _khv_vm_power_stateValues[] = {
  hv_vm_power_state::HV_VMPOWER_UNKNOWN,
  hv_vm_power_state::HV_VMPOWER_ON,
  hv_vm_power_state::HV_VMPOWER_OFF,
  hv_vm_power_state::HV_VMPOWER_SUSPENDED
};
const char* _khv_vm_power_stateNames[] = {
  "HV_VMPOWER_UNKNOWN",
  "HV_VMPOWER_ON",
  "HV_VMPOWER_OFF",
  "HV_VMPOWER_SUSPENDED"
};
const std::map<int, const char*> _hv_vm_power_state_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _khv_vm_power_stateValues, _khv_vm_power_stateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _khv_vm_connection_stateValues[] = {
  hv_vm_connection_state::HV_VMCONNECT_UNKNOWN,
  hv_vm_connection_state::HV_VMCONNECT_CONNECTED,
  hv_vm_connection_state::HV_VMCONNECT_DISCONNECTED,
  hv_vm_connection_state::HV_VMCONNECT_INACCESSIBLE,
  hv_vm_connection_state::HV_VMCONNECT_INVALID,
  hv_vm_connection_state::HV_VMCONNECT_ORPHANED
};
const char* _khv_vm_connection_stateNames[] = {
  "HV_VMCONNECT_UNKNOWN",
  "HV_VMCONNECT_CONNECTED",
  "HV_VMCONNECT_DISCONNECTED",
  "HV_VMCONNECT_INACCESSIBLE",
  "HV_VMCONNECT_INVALID",
  "HV_VMCONNECT_ORPHANED"
};
const std::map<int, const char*> _hv_vm_connection_state_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _khv_vm_connection_stateValues, _khv_vm_connection_stateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _khv_host_power_stateValues[] = {
  hv_host_power_state::HV_HOSTPOWER_UNKNOWN,
  hv_host_power_state::HV_HOSTPOWER_ON,
  hv_host_power_state::HV_HOSTPOWER_OFF,
  hv_host_power_state::HV_HOSTPOWER_STANDBY
};
const char* _khv_host_power_stateNames[] = {
  "HV_HOSTPOWER_UNKNOWN",
  "HV_HOSTPOWER_ON",
  "HV_HOSTPOWER_OFF",
  "HV_HOSTPOWER_STANDBY"
};
const std::map<int, const char*> _hv_host_power_state_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _khv_host_power_stateValues, _khv_host_power_stateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _khv_connection_typeValues[] = {
  hv_connection_type::HV_CONNECTION_TYPE_UNKNOWN,
  hv_connection_type::HV_CONNECTION_TYPE_VCENTER,
  hv_connection_type::HV_CONNECTION_TYPE_HOST
};
const char* _khv_connection_typeNames[] = {
  "HV_CONNECTION_TYPE_UNKNOWN",
  "HV_CONNECTION_TYPE_VCENTER",
  "HV_CONNECTION_TYPE_HOST"
};
const std::map<int, const char*> _hv_connection_type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _khv_connection_typeValues, _khv_connection_typeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _khv_guest_os_typeValues[] = {
  hv_guest_os_type::HV_OS_UNKNOWN,
  hv_guest_os_type::HV_OS_WINDOWS,
  hv_guest_os_type::HV_OS_LINUX
};
const char* _khv_guest_os_typeNames[] = {
  "HV_OS_UNKNOWN",
  "HV_OS_WINDOWS",
  "HV_OS_LINUX"
};
const std::map<int, const char*> _hv_guest_os_type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _khv_guest_os_typeValues, _khv_guest_os_typeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _khv_vm_firmwareValues[] = {
  hv_vm_firmware::HV_VM_FIRMWARE_BIOS,
  hv_vm_firmware::HV_VM_FIRMWARE_EFI
};
const char* _khv_vm_firmwareNames[] = {
  "HV_VM_FIRMWARE_BIOS",
  "HV_VM_FIRMWARE_EFI"
};
const std::map<int, const char*> _hv_vm_firmware_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _khv_vm_firmwareValues, _khv_vm_firmwareNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kjob_typeValues[] = {
  job_type::physical_packer_job_type,
  job_type::virtual_packer_job_type,
  job_type::physical_transport_type,
  job_type::virtual_transport_type,
  job_type::loader_job_type,
  job_type::launcher_job_type,
  job_type::winpe_packer_job_type,
  job_type::winpe_transport_job_type
};
const char* _kjob_typeNames[] = {
  "physical_packer_job_type",
  "virtual_packer_job_type",
  "physical_transport_type",
  "virtual_transport_type",
  "loader_job_type",
  "launcher_job_type",
  "winpe_packer_job_type",
  "winpe_transport_job_type"
};
const std::map<int, const char*> _job_type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(8, _kjob_typeValues, _kjob_typeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kjob_trigger_typeValues[] = {
  job_trigger_type::runonce_trigger,
  job_trigger_type::interval_trigger
};
const char* _kjob_trigger_typeNames[] = {
  "runonce_trigger",
  "interval_trigger"
};
const std::map<int, const char*> _job_trigger_type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kjob_trigger_typeValues, _kjob_trigger_typeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kjob_stateValues[] = {
  job_state::job_state_none,
  job_state::job_state_initialed,
  job_state::job_state_replicating,
  job_state::job_state_replicated,
  job_state::job_state_converting,
  job_state::job_state_finished,
  job_state::job_state_sche_completed,
  job_state::job_state_recover,
  job_state::job_state_resizing,
  job_state::job_state_uploading,
  job_state::job_state_upload_completed,
  job_state::job_state_discard
};
const char* _kjob_stateNames[] = {
  "job_state_none",
  "job_state_initialed",
  "job_state_replicating",
  "job_state_replicated",
  "job_state_converting",
  "job_state_finished",
  "job_state_sche_completed",
  "job_state_recover",
  "job_state_resizing",
  "job_state_uploading",
  "job_state_upload_completed",
  "job_state_discard"
};
const std::map<int, const char*> _job_state_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(12, _kjob_stateValues, _kjob_stateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kerror_codesValues[] = {
  error_codes::SAASAME_S_OK,
  error_codes::SAASAME_NOERROR,
  error_codes::SAASAME_E_FAIL,
  error_codes::SAASAME_E_INITIAL_FAIL,
  error_codes::SAASAME_E_DISK_FULL,
  error_codes::SAASAME_E_INVALID_ARG,
  error_codes::SAASAME_E_INVALID_AUTHENTICATION,
  error_codes::SAASAME_E_INTERNAL_FAIL,
  error_codes::SAASAME_E_CANNOT_CONNECT_TO_HOST,
  error_codes::SAASAME_E_QUEUE_FULL,
  error_codes::SAASAME_E_INVALID_LICENSE_KEY,
  error_codes::SAASAME_E_INVALID_LICENSE,
  error_codes::SAASAME_E_JOB_CREATE_FAIL,
  error_codes::SAASAME_E_JOB_REMOVE_FAIL,
  error_codes::SAASAME_E_JOB_NOTFOUND,
  error_codes::SAASAME_E_JOB_CONFIG_NOTFOUND,
  error_codes::SAASAME_E_JOB_STATUS_NOTFOUND,
  error_codes::SAASAME_E_JOB_CANCELLED,
  error_codes::SAASAME_E_JOB_CONVERT_FAIL,
  error_codes::SAASAME_E_JOB_REPLICATE_FAIL,
  error_codes::SAASAME_E_JOB_ID_DUPLICATED,
  error_codes::SAASAME_E_JOB_INTERRUPTED,
  error_codes::SAASAME_E_JOB_RUNNING,
  error_codes::SAASAME_E_JOB_RESPONSE,
  error_codes::SAASAME_E_PHYSICAL_CONFIG_FAILED,
  error_codes::SAASAME_E_VIRTUAL_VM_NOTFOUND,
  error_codes::SAASAME_E_IMAGE_NOTFOUND,
  error_codes::SAASAME_E_IMAGE_CREATE_FAIL,
  error_codes::SAASAME_E_IMAGE_OPEN_FAIL,
  error_codes::SAASAME_E_IMAGE_READ,
  error_codes::SAASAME_E_IMAGE_WRITE,
  error_codes::SAASAME_E_IMAGE_OUTOFRANGE,
  error_codes::SAASAME_E_IMAGE_ATTACH_FAIL,
  error_codes::SAASAME_E_IMAGE_DETACH_FAIL,
  error_codes::SAASAME_E_IMAGE_PROPERTY_FAIL,
  error_codes::SAASAME_E_SNAPSHOT_CREATE_FAIL,
  error_codes::SAASAME_E_SNAPSHOT_REMOVE_FAIL,
  error_codes::SAASAME_E_SNAPSHOT_NOTFOUND,
  error_codes::SAASAME_E_SNAPSHOT_INVALID
};
const char* _kerror_codesNames[] = {
  "SAASAME_S_OK",
  "SAASAME_NOERROR",
  "SAASAME_E_FAIL",
  "SAASAME_E_INITIAL_FAIL",
  "SAASAME_E_DISK_FULL",
  "SAASAME_E_INVALID_ARG",
  "SAASAME_E_INVALID_AUTHENTICATION",
  "SAASAME_E_INTERNAL_FAIL",
  "SAASAME_E_CANNOT_CONNECT_TO_HOST",
  "SAASAME_E_QUEUE_FULL",
  "SAASAME_E_INVALID_LICENSE_KEY",
  "SAASAME_E_INVALID_LICENSE",
  "SAASAME_E_JOB_CREATE_FAIL",
  "SAASAME_E_JOB_REMOVE_FAIL",
  "SAASAME_E_JOB_NOTFOUND",
  "SAASAME_E_JOB_CONFIG_NOTFOUND",
  "SAASAME_E_JOB_STATUS_NOTFOUND",
  "SAASAME_E_JOB_CANCELLED",
  "SAASAME_E_JOB_CONVERT_FAIL",
  "SAASAME_E_JOB_REPLICATE_FAIL",
  "SAASAME_E_JOB_ID_DUPLICATED",
  "SAASAME_E_JOB_INTERRUPTED",
  "SAASAME_E_JOB_RUNNING",
  "SAASAME_E_JOB_RESPONSE",
  "SAASAME_E_PHYSICAL_CONFIG_FAILED",
  "SAASAME_E_VIRTUAL_VM_NOTFOUND",
  "SAASAME_E_IMAGE_NOTFOUND",
  "SAASAME_E_IMAGE_CREATE_FAIL",
  "SAASAME_E_IMAGE_OPEN_FAIL",
  "SAASAME_E_IMAGE_READ",
  "SAASAME_E_IMAGE_WRITE",
  "SAASAME_E_IMAGE_OUTOFRANGE",
  "SAASAME_E_IMAGE_ATTACH_FAIL",
  "SAASAME_E_IMAGE_DETACH_FAIL",
  "SAASAME_E_IMAGE_PROPERTY_FAIL",
  "SAASAME_E_SNAPSHOT_CREATE_FAIL",
  "SAASAME_E_SNAPSHOT_REMOVE_FAIL",
  "SAASAME_E_SNAPSHOT_NOTFOUND",
  "SAASAME_E_SNAPSHOT_INVALID"
};
const std::map<int, const char*> _error_codes_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(39, _kerror_codesValues, _kerror_codesNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kconnection_typeValues[] = {
  connection_type::LOCAL_FOLDER,
  connection_type::NFS_FOLDER,
  connection_type::CIFS_FOLDER,
  connection_type::WEBDAV,
  connection_type::S3_BUCKET,
  connection_type::WEBDAV_WITH_SSL,
  connection_type::WEBDAV_EX,
  connection_type::S3_BUCKET_EX,
  connection_type::LOCAL_FOLDER_EX
};
const char* _kconnection_typeNames[] = {
  "LOCAL_FOLDER",
  "NFS_FOLDER",
  "CIFS_FOLDER",
  "WEBDAV",
  "S3_BUCKET",
  "WEBDAV_WITH_SSL",
  "WEBDAV_EX",
  "S3_BUCKET_EX",
  "LOCAL_FOLDER_EX"
};
const std::map<int, const char*> _connection_type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(9, _kconnection_typeValues, _kconnection_typeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kaws_regionValues[] = {
  aws_region::US_EAST_1,
  aws_region::US_WEST_1,
  aws_region::US_WEST_2,
  aws_region::EU_WEST_1,
  aws_region::EU_CENTRAL_1,
  aws_region::AP_SOUTHEAST_1,
  aws_region::AP_SOUTHEAST_2,
  aws_region::AP_NORTHEAST_1,
  aws_region::AP_NORTHEAST_2,
  aws_region::SA_EAST_1
};
const char* _kaws_regionNames[] = {
  "US_EAST_1",
  "US_WEST_1",
  "US_WEST_2",
  "EU_WEST_1",
  "EU_CENTRAL_1",
  "AP_SOUTHEAST_1",
  "AP_SOUTHEAST_2",
  "AP_NORTHEAST_1",
  "AP_NORTHEAST_2",
  "SA_EAST_1"
};
const std::map<int, const char*> _aws_region_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(10, _kaws_regionValues, _kaws_regionNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kcreate_image_optionValues[] = {
  create_image_option::VERSION_1,
  create_image_option::VERSION_2
};
const char* _kcreate_image_optionNames[] = {
  "VERSION_1",
  "VERSION_2"
};
const std::map<int, const char*> _create_image_option_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kcreate_image_optionValues, _kcreate_image_optionNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kdisk_detect_typeValues[] = {
  disk_detect_type::SCSI_ADDRESS,
  disk_detect_type::LINUX_DEVICE_PATH,
  disk_detect_type::SERIAL_NUMBER,
  disk_detect_type::EXPORT_IMAGE,
  disk_detect_type::UNIQUE_ID,
  disk_detect_type::CUSTOMIZED_ID,
  disk_detect_type::AZURE_BLOB
};
const char* _kdisk_detect_typeNames[] = {
  "SCSI_ADDRESS",
  "LINUX_DEVICE_PATH",
  "SERIAL_NUMBER",
  "EXPORT_IMAGE",
  "UNIQUE_ID",
  "CUSTOMIZED_ID",
  "AZURE_BLOB"
};
const std::map<int, const char*> _disk_detect_type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kdisk_detect_typeValues, _kdisk_detect_typeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kvirtual_disk_typeValues[] = {
  virtual_disk_type::VHD,
  virtual_disk_type::VHDX
};
const char* _kvirtual_disk_typeNames[] = {
  "VHD",
  "VHDX"
};
const std::map<int, const char*> _virtual_disk_type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kvirtual_disk_typeValues, _kvirtual_disk_typeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kconversion_typeValues[] = {
  conversion_type::ANY_TO_ANY,
  conversion_type::OPENSTACK,
  conversion_type::XEN,
  conversion_type::VMWARE,
  conversion_type::HYPERV,
  conversion_type::AUTO
};
const char* _kconversion_typeNames[] = {
  "ANY_TO_ANY",
  "OPENSTACK",
  "XEN",
  "VMWARE",
  "HYPERV",
  "AUTO"
};
const std::map<int, const char*> _conversion_type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kconversion_typeValues, _kconversion_typeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kextra_options_typeValues[] = {
  extra_options_type::UNKNOWN,
  extra_options_type::ALIYUN,
  extra_options_type::TENCENT
};
const char* _kextra_options_typeNames[] = {
  "UNKNOWN",
  "ALIYUN",
  "TENCENT"
};
const std::map<int, const char*> _extra_options_type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kextra_options_typeValues, _kextra_options_typeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


disk_info::~disk_info() throw() {
}


void disk_info::__set_boot_from_disk(const bool val) {
  this->boot_from_disk = val;
__isset.boot_from_disk = true;
}

void disk_info::__set_bus_type(const bus_type::type val) {
  this->bus_type = val;
__isset.bus_type = true;
}

void disk_info::__set_cluster_owner(const std::string& val) {
  this->cluster_owner = val;
__isset.cluster_owner = true;
}

void disk_info::__set_cylinders(const int64_t val) {
  this->cylinders = val;
__isset.cylinders = true;
}

void disk_info::__set_friendly_name(const std::string& val) {
  this->friendly_name = val;
__isset.friendly_name = true;
}

void disk_info::__set_guid(const std::string& val) {
  this->guid = val;
__isset.guid = true;
}

void disk_info::__set_tracks_per_cylinder(const int32_t val) {
  this->tracks_per_cylinder = val;
__isset.tracks_per_cylinder = true;
}

void disk_info::__set_is_boot(const bool val) {
  this->is_boot = val;
__isset.is_boot = true;
}

void disk_info::__set_is_clustered(const bool val) {
  this->is_clustered = val;
__isset.is_clustered = true;
}

void disk_info::__set_is_offline(const bool val) {
  this->is_offline = val;
__isset.is_offline = true;
}

void disk_info::__set_is_readonly(const bool val) {
  this->is_readonly = val;
__isset.is_readonly = true;
}

void disk_info::__set_is_snapshot(const bool val) {
  this->is_snapshot = val;
__isset.is_snapshot = true;
}

void disk_info::__set_is_system(const bool val) {
  this->is_system = val;
__isset.is_system = true;
}

void disk_info::__set_location(const std::string& val) {
  this->location = val;
__isset.location = true;
}

void disk_info::__set_logical_sector_size(const int32_t val) {
  this->logical_sector_size = val;
__isset.logical_sector_size = true;
}

void disk_info::__set_manufacturer(const std::string& val) {
  this->manufacturer = val;
__isset.manufacturer = true;
}

void disk_info::__set_model(const std::string& val) {
  this->model = val;
__isset.model = true;
}

void disk_info::__set_number(const int32_t val) {
  this->number = val;
__isset.number = true;
}

void disk_info::__set_number_of_partitions(const int32_t val) {
  this->number_of_partitions = val;
__isset.number_of_partitions = true;
}

void disk_info::__set_offline_reason(const int16_t val) {
  this->offline_reason = val;
__isset.offline_reason = true;
}

void disk_info::__set_partition_style(const partition_style::type val) {
  this->partition_style = val;
__isset.partition_style = true;
}

void disk_info::__set_path(const std::string& val) {
  this->path = val;
__isset.path = true;
}

void disk_info::__set_physical_sector_size(const int32_t val) {
  this->physical_sector_size = val;
__isset.physical_sector_size = true;
}

void disk_info::__set_sectors_per_track(const int32_t val) {
  this->sectors_per_track = val;
__isset.sectors_per_track = true;
}

void disk_info::__set_serial_number(const std::string& val) {
  this->serial_number = val;
__isset.serial_number = true;
}

void disk_info::__set_signature(const int32_t val) {
  this->signature = val;
__isset.signature = true;
}

void disk_info::__set_size(const int64_t val) {
  this->size = val;
__isset.size = true;
}

void disk_info::__set_uri(const std::string& val) {
  this->uri = val;
__isset.uri = true;
}

void disk_info::__set_scsi_bus(const int32_t val) {
  this->scsi_bus = val;
__isset.scsi_bus = true;
}

void disk_info::__set_scsi_logical_unit(const int16_t val) {
  this->scsi_logical_unit = val;
__isset.scsi_logical_unit = true;
}

void disk_info::__set_scsi_port(const int16_t val) {
  this->scsi_port = val;
__isset.scsi_port = true;
}

void disk_info::__set_scsi_target_id(const int16_t val) {
  this->scsi_target_id = val;
__isset.scsi_target_id = true;
}

void disk_info::__set_unique_id(const std::string& val) {
  this->unique_id = val;
__isset.unique_id = true;
}

void disk_info::__set_unique_id_format(const int16_t val) {
  this->unique_id_format = val;
__isset.unique_id_format = true;
}

void disk_info::__set_customized_id(const std::string& val) {
  this->customized_id = val;
__isset.customized_id = true;
}

uint32_t disk_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->boot_from_disk);
          this->__isset.boot_from_disk = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->bus_type = (bus_type::type)ecast0;
          this->__isset.bus_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cluster_owner);
          this->__isset.cluster_owner = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cylinders);
          this->__isset.cylinders = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->friendly_name);
          this->__isset.friendly_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guid);
          this->__isset.guid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->tracks_per_cylinder);
          this->__isset.tracks_per_cylinder = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_boot);
          this->__isset.is_boot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_clustered);
          this->__isset.is_clustered = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_offline);
          this->__isset.is_offline = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_readonly);
          this->__isset.is_readonly = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_snapshot);
          this->__isset.is_snapshot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_system);
          this->__isset.is_system = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->location);
          this->__isset.location = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->logical_sector_size);
          this->__isset.logical_sector_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->manufacturer);
          this->__isset.manufacturer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->model);
          this->__isset.model = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->number);
          this->__isset.number = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->number_of_partitions);
          this->__isset.number_of_partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->offline_reason);
          this->__isset.offline_reason = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1;
          xfer += iprot->readI32(ecast1);
          this->partition_style = (partition_style::type)ecast1;
          this->__isset.partition_style = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->path);
          this->__isset.path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->physical_sector_size);
          this->__isset.physical_sector_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sectors_per_track);
          this->__isset.sectors_per_track = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->serial_number);
          this->__isset.serial_number = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 26:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->signature);
          this->__isset.signature = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 27:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->size);
          this->__isset.size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 28:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->uri);
          this->__isset.uri = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 29:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->scsi_bus);
          this->__isset.scsi_bus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->scsi_logical_unit);
          this->__isset.scsi_logical_unit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 31:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->scsi_port);
          this->__isset.scsi_port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 32:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->scsi_target_id);
          this->__isset.scsi_target_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 33:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->unique_id);
          this->__isset.unique_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 34:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->unique_id_format);
          this->__isset.unique_id_format = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 35:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->customized_id);
          this->__isset.customized_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t disk_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("disk_info");

  if (this->__isset.boot_from_disk) {
    xfer += oprot->writeFieldBegin("boot_from_disk", ::apache::thrift::protocol::T_BOOL, 1);
    xfer += oprot->writeBool(this->boot_from_disk);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.bus_type) {
    xfer += oprot->writeFieldBegin("bus_type", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32((int32_t)this->bus_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_owner) {
    xfer += oprot->writeFieldBegin("cluster_owner", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->cluster_owner);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cylinders) {
    xfer += oprot->writeFieldBegin("cylinders", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->cylinders);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.friendly_name) {
    xfer += oprot->writeFieldBegin("friendly_name", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->friendly_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.guid) {
    xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->guid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tracks_per_cylinder) {
    xfer += oprot->writeFieldBegin("tracks_per_cylinder", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32(this->tracks_per_cylinder);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_boot) {
    xfer += oprot->writeFieldBegin("is_boot", ::apache::thrift::protocol::T_BOOL, 8);
    xfer += oprot->writeBool(this->is_boot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_clustered) {
    xfer += oprot->writeFieldBegin("is_clustered", ::apache::thrift::protocol::T_BOOL, 9);
    xfer += oprot->writeBool(this->is_clustered);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_offline) {
    xfer += oprot->writeFieldBegin("is_offline", ::apache::thrift::protocol::T_BOOL, 10);
    xfer += oprot->writeBool(this->is_offline);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_readonly) {
    xfer += oprot->writeFieldBegin("is_readonly", ::apache::thrift::protocol::T_BOOL, 11);
    xfer += oprot->writeBool(this->is_readonly);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_snapshot) {
    xfer += oprot->writeFieldBegin("is_snapshot", ::apache::thrift::protocol::T_BOOL, 12);
    xfer += oprot->writeBool(this->is_snapshot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_system) {
    xfer += oprot->writeFieldBegin("is_system", ::apache::thrift::protocol::T_BOOL, 13);
    xfer += oprot->writeBool(this->is_system);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.location) {
    xfer += oprot->writeFieldBegin("location", ::apache::thrift::protocol::T_STRING, 14);
    xfer += oprot->writeString(this->location);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.logical_sector_size) {
    xfer += oprot->writeFieldBegin("logical_sector_size", ::apache::thrift::protocol::T_I32, 15);
    xfer += oprot->writeI32(this->logical_sector_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.manufacturer) {
    xfer += oprot->writeFieldBegin("manufacturer", ::apache::thrift::protocol::T_STRING, 16);
    xfer += oprot->writeString(this->manufacturer);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.model) {
    xfer += oprot->writeFieldBegin("model", ::apache::thrift::protocol::T_STRING, 17);
    xfer += oprot->writeString(this->model);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.number) {
    xfer += oprot->writeFieldBegin("number", ::apache::thrift::protocol::T_I32, 18);
    xfer += oprot->writeI32(this->number);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.number_of_partitions) {
    xfer += oprot->writeFieldBegin("number_of_partitions", ::apache::thrift::protocol::T_I32, 19);
    xfer += oprot->writeI32(this->number_of_partitions);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.offline_reason) {
    xfer += oprot->writeFieldBegin("offline_reason", ::apache::thrift::protocol::T_I16, 20);
    xfer += oprot->writeI16(this->offline_reason);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partition_style) {
    xfer += oprot->writeFieldBegin("partition_style", ::apache::thrift::protocol::T_I32, 21);
    xfer += oprot->writeI32((int32_t)this->partition_style);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.path) {
    xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_STRING, 22);
    xfer += oprot->writeString(this->path);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.physical_sector_size) {
    xfer += oprot->writeFieldBegin("physical_sector_size", ::apache::thrift::protocol::T_I32, 23);
    xfer += oprot->writeI32(this->physical_sector_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sectors_per_track) {
    xfer += oprot->writeFieldBegin("sectors_per_track", ::apache::thrift::protocol::T_I32, 24);
    xfer += oprot->writeI32(this->sectors_per_track);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.serial_number) {
    xfer += oprot->writeFieldBegin("serial_number", ::apache::thrift::protocol::T_STRING, 25);
    xfer += oprot->writeString(this->serial_number);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.signature) {
    xfer += oprot->writeFieldBegin("signature", ::apache::thrift::protocol::T_I32, 26);
    xfer += oprot->writeI32(this->signature);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.size) {
    xfer += oprot->writeFieldBegin("size", ::apache::thrift::protocol::T_I64, 27);
    xfer += oprot->writeI64(this->size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.uri) {
    xfer += oprot->writeFieldBegin("uri", ::apache::thrift::protocol::T_STRING, 28);
    xfer += oprot->writeString(this->uri);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.scsi_bus) {
    xfer += oprot->writeFieldBegin("scsi_bus", ::apache::thrift::protocol::T_I32, 29);
    xfer += oprot->writeI32(this->scsi_bus);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.scsi_logical_unit) {
    xfer += oprot->writeFieldBegin("scsi_logical_unit", ::apache::thrift::protocol::T_I16, 30);
    xfer += oprot->writeI16(this->scsi_logical_unit);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.scsi_port) {
    xfer += oprot->writeFieldBegin("scsi_port", ::apache::thrift::protocol::T_I16, 31);
    xfer += oprot->writeI16(this->scsi_port);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.scsi_target_id) {
    xfer += oprot->writeFieldBegin("scsi_target_id", ::apache::thrift::protocol::T_I16, 32);
    xfer += oprot->writeI16(this->scsi_target_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.unique_id) {
    xfer += oprot->writeFieldBegin("unique_id", ::apache::thrift::protocol::T_STRING, 33);
    xfer += oprot->writeString(this->unique_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.unique_id_format) {
    xfer += oprot->writeFieldBegin("unique_id_format", ::apache::thrift::protocol::T_I16, 34);
    xfer += oprot->writeI16(this->unique_id_format);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.customized_id) {
    xfer += oprot->writeFieldBegin("customized_id", ::apache::thrift::protocol::T_STRING, 35);
    xfer += oprot->writeString(this->customized_id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(disk_info &a, disk_info &b) {
  using ::std::swap;
  swap(a.boot_from_disk, b.boot_from_disk);
  swap(a.bus_type, b.bus_type);
  swap(a.cluster_owner, b.cluster_owner);
  swap(a.cylinders, b.cylinders);
  swap(a.friendly_name, b.friendly_name);
  swap(a.guid, b.guid);
  swap(a.tracks_per_cylinder, b.tracks_per_cylinder);
  swap(a.is_boot, b.is_boot);
  swap(a.is_clustered, b.is_clustered);
  swap(a.is_offline, b.is_offline);
  swap(a.is_readonly, b.is_readonly);
  swap(a.is_snapshot, b.is_snapshot);
  swap(a.is_system, b.is_system);
  swap(a.location, b.location);
  swap(a.logical_sector_size, b.logical_sector_size);
  swap(a.manufacturer, b.manufacturer);
  swap(a.model, b.model);
  swap(a.number, b.number);
  swap(a.number_of_partitions, b.number_of_partitions);
  swap(a.offline_reason, b.offline_reason);
  swap(a.partition_style, b.partition_style);
  swap(a.path, b.path);
  swap(a.physical_sector_size, b.physical_sector_size);
  swap(a.sectors_per_track, b.sectors_per_track);
  swap(a.serial_number, b.serial_number);
  swap(a.signature, b.signature);
  swap(a.size, b.size);
  swap(a.uri, b.uri);
  swap(a.scsi_bus, b.scsi_bus);
  swap(a.scsi_logical_unit, b.scsi_logical_unit);
  swap(a.scsi_port, b.scsi_port);
  swap(a.scsi_target_id, b.scsi_target_id);
  swap(a.unique_id, b.unique_id);
  swap(a.unique_id_format, b.unique_id_format);
  swap(a.customized_id, b.customized_id);
  swap(a.__isset, b.__isset);
}

disk_info::disk_info(const disk_info& other2) {
  boot_from_disk = other2.boot_from_disk;
  bus_type = other2.bus_type;
  cluster_owner = other2.cluster_owner;
  cylinders = other2.cylinders;
  friendly_name = other2.friendly_name;
  guid = other2.guid;
  tracks_per_cylinder = other2.tracks_per_cylinder;
  is_boot = other2.is_boot;
  is_clustered = other2.is_clustered;
  is_offline = other2.is_offline;
  is_readonly = other2.is_readonly;
  is_snapshot = other2.is_snapshot;
  is_system = other2.is_system;
  location = other2.location;
  logical_sector_size = other2.logical_sector_size;
  manufacturer = other2.manufacturer;
  model = other2.model;
  number = other2.number;
  number_of_partitions = other2.number_of_partitions;
  offline_reason = other2.offline_reason;
  partition_style = other2.partition_style;
  path = other2.path;
  physical_sector_size = other2.physical_sector_size;
  sectors_per_track = other2.sectors_per_track;
  serial_number = other2.serial_number;
  signature = other2.signature;
  size = other2.size;
  uri = other2.uri;
  scsi_bus = other2.scsi_bus;
  scsi_logical_unit = other2.scsi_logical_unit;
  scsi_port = other2.scsi_port;
  scsi_target_id = other2.scsi_target_id;
  unique_id = other2.unique_id;
  unique_id_format = other2.unique_id_format;
  customized_id = other2.customized_id;
  __isset = other2.__isset;
}
disk_info& disk_info::operator=(const disk_info& other3) {
  boot_from_disk = other3.boot_from_disk;
  bus_type = other3.bus_type;
  cluster_owner = other3.cluster_owner;
  cylinders = other3.cylinders;
  friendly_name = other3.friendly_name;
  guid = other3.guid;
  tracks_per_cylinder = other3.tracks_per_cylinder;
  is_boot = other3.is_boot;
  is_clustered = other3.is_clustered;
  is_offline = other3.is_offline;
  is_readonly = other3.is_readonly;
  is_snapshot = other3.is_snapshot;
  is_system = other3.is_system;
  location = other3.location;
  logical_sector_size = other3.logical_sector_size;
  manufacturer = other3.manufacturer;
  model = other3.model;
  number = other3.number;
  number_of_partitions = other3.number_of_partitions;
  offline_reason = other3.offline_reason;
  partition_style = other3.partition_style;
  path = other3.path;
  physical_sector_size = other3.physical_sector_size;
  sectors_per_track = other3.sectors_per_track;
  serial_number = other3.serial_number;
  signature = other3.signature;
  size = other3.size;
  uri = other3.uri;
  scsi_bus = other3.scsi_bus;
  scsi_logical_unit = other3.scsi_logical_unit;
  scsi_port = other3.scsi_port;
  scsi_target_id = other3.scsi_target_id;
  unique_id = other3.unique_id;
  unique_id_format = other3.unique_id_format;
  customized_id = other3.customized_id;
  __isset = other3.__isset;
  return *this;
}
void disk_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "disk_info(";
  out << "boot_from_disk="; (__isset.boot_from_disk ? (out << to_string(boot_from_disk)) : (out << "<null>"));
  out << ", " << "bus_type="; (__isset.bus_type ? (out << to_string(bus_type)) : (out << "<null>"));
  out << ", " << "cluster_owner="; (__isset.cluster_owner ? (out << to_string(cluster_owner)) : (out << "<null>"));
  out << ", " << "cylinders="; (__isset.cylinders ? (out << to_string(cylinders)) : (out << "<null>"));
  out << ", " << "friendly_name="; (__isset.friendly_name ? (out << to_string(friendly_name)) : (out << "<null>"));
  out << ", " << "guid="; (__isset.guid ? (out << to_string(guid)) : (out << "<null>"));
  out << ", " << "tracks_per_cylinder="; (__isset.tracks_per_cylinder ? (out << to_string(tracks_per_cylinder)) : (out << "<null>"));
  out << ", " << "is_boot="; (__isset.is_boot ? (out << to_string(is_boot)) : (out << "<null>"));
  out << ", " << "is_clustered="; (__isset.is_clustered ? (out << to_string(is_clustered)) : (out << "<null>"));
  out << ", " << "is_offline="; (__isset.is_offline ? (out << to_string(is_offline)) : (out << "<null>"));
  out << ", " << "is_readonly="; (__isset.is_readonly ? (out << to_string(is_readonly)) : (out << "<null>"));
  out << ", " << "is_snapshot="; (__isset.is_snapshot ? (out << to_string(is_snapshot)) : (out << "<null>"));
  out << ", " << "is_system="; (__isset.is_system ? (out << to_string(is_system)) : (out << "<null>"));
  out << ", " << "location="; (__isset.location ? (out << to_string(location)) : (out << "<null>"));
  out << ", " << "logical_sector_size="; (__isset.logical_sector_size ? (out << to_string(logical_sector_size)) : (out << "<null>"));
  out << ", " << "manufacturer="; (__isset.manufacturer ? (out << to_string(manufacturer)) : (out << "<null>"));
  out << ", " << "model="; (__isset.model ? (out << to_string(model)) : (out << "<null>"));
  out << ", " << "number="; (__isset.number ? (out << to_string(number)) : (out << "<null>"));
  out << ", " << "number_of_partitions="; (__isset.number_of_partitions ? (out << to_string(number_of_partitions)) : (out << "<null>"));
  out << ", " << "offline_reason="; (__isset.offline_reason ? (out << to_string(offline_reason)) : (out << "<null>"));
  out << ", " << "partition_style="; (__isset.partition_style ? (out << to_string(partition_style)) : (out << "<null>"));
  out << ", " << "path="; (__isset.path ? (out << to_string(path)) : (out << "<null>"));
  out << ", " << "physical_sector_size="; (__isset.physical_sector_size ? (out << to_string(physical_sector_size)) : (out << "<null>"));
  out << ", " << "sectors_per_track="; (__isset.sectors_per_track ? (out << to_string(sectors_per_track)) : (out << "<null>"));
  out << ", " << "serial_number="; (__isset.serial_number ? (out << to_string(serial_number)) : (out << "<null>"));
  out << ", " << "signature="; (__isset.signature ? (out << to_string(signature)) : (out << "<null>"));
  out << ", " << "size="; (__isset.size ? (out << to_string(size)) : (out << "<null>"));
  out << ", " << "uri="; (__isset.uri ? (out << to_string(uri)) : (out << "<null>"));
  out << ", " << "scsi_bus="; (__isset.scsi_bus ? (out << to_string(scsi_bus)) : (out << "<null>"));
  out << ", " << "scsi_logical_unit="; (__isset.scsi_logical_unit ? (out << to_string(scsi_logical_unit)) : (out << "<null>"));
  out << ", " << "scsi_port="; (__isset.scsi_port ? (out << to_string(scsi_port)) : (out << "<null>"));
  out << ", " << "scsi_target_id="; (__isset.scsi_target_id ? (out << to_string(scsi_target_id)) : (out << "<null>"));
  out << ", " << "unique_id="; (__isset.unique_id ? (out << to_string(unique_id)) : (out << "<null>"));
  out << ", " << "unique_id_format="; (__isset.unique_id_format ? (out << to_string(unique_id_format)) : (out << "<null>"));
  out << ", " << "customized_id="; (__isset.customized_id ? (out << to_string(customized_id)) : (out << "<null>"));
  out << ")";
}


partition_info::~partition_info() throw() {
}


void partition_info::__set_access_paths(const std::set<std::string> & val) {
  this->access_paths = val;
__isset.access_paths = true;
}

void partition_info::__set_disk_number(const int32_t val) {
  this->disk_number = val;
__isset.disk_number = true;
}

void partition_info::__set_drive_letter(const std::string& val) {
  this->drive_letter = val;
__isset.drive_letter = true;
}

void partition_info::__set_gpt_type(const std::string& val) {
  this->gpt_type = val;
__isset.gpt_type = true;
}

void partition_info::__set_guid(const std::string& val) {
  this->guid = val;
__isset.guid = true;
}

void partition_info::__set_is_active(const bool val) {
  this->is_active = val;
__isset.is_active = true;
}

void partition_info::__set_is_boot(const bool val) {
  this->is_boot = val;
__isset.is_boot = true;
}

void partition_info::__set_is_hidden(const bool val) {
  this->is_hidden = val;
__isset.is_hidden = true;
}

void partition_info::__set_is_offline(const bool val) {
  this->is_offline = val;
__isset.is_offline = true;
}

void partition_info::__set_is_readonly(const bool val) {
  this->is_readonly = val;
__isset.is_readonly = true;
}

void partition_info::__set_is_shadowcopy(const bool val) {
  this->is_shadowcopy = val;
__isset.is_shadowcopy = true;
}

void partition_info::__set_is_system(const bool val) {
  this->is_system = val;
__isset.is_system = true;
}

void partition_info::__set_mbr_type(const int16_t val) {
  this->mbr_type = val;
__isset.mbr_type = true;
}

void partition_info::__set_offset(const int64_t val) {
  this->offset = val;
__isset.offset = true;
}

void partition_info::__set_partition_number(const int32_t val) {
  this->partition_number = val;
__isset.partition_number = true;
}

void partition_info::__set_size(const int64_t val) {
  this->size = val;
__isset.size = true;
}

uint32_t partition_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->access_paths.clear();
            uint32_t _size4;
            ::apache::thrift::protocol::TType _etype7;
            xfer += iprot->readSetBegin(_etype7, _size4);
            uint32_t _i8;
            for (_i8 = 0; _i8 < _size4; ++_i8)
            {
              std::string _elem9;
              xfer += iprot->readString(_elem9);
              this->access_paths.insert(_elem9);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.access_paths = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->disk_number);
          this->__isset.disk_number = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->drive_letter);
          this->__isset.drive_letter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->gpt_type);
          this->__isset.gpt_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guid);
          this->__isset.guid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_active);
          this->__isset.is_active = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_boot);
          this->__isset.is_boot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_hidden);
          this->__isset.is_hidden = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_offline);
          this->__isset.is_offline = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_readonly);
          this->__isset.is_readonly = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_shadowcopy);
          this->__isset.is_shadowcopy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_system);
          this->__isset.is_system = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->mbr_type);
          this->__isset.mbr_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->offset);
          this->__isset.offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->partition_number);
          this->__isset.partition_number = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->size);
          this->__isset.size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t partition_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("partition_info");

  if (this->__isset.access_paths) {
    xfer += oprot->writeFieldBegin("access_paths", ::apache::thrift::protocol::T_SET, 1);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->access_paths.size()));
      std::set<std::string> ::const_iterator _iter10;
      for (_iter10 = this->access_paths.begin(); _iter10 != this->access_paths.end(); ++_iter10)
      {
        xfer += oprot->writeString((*_iter10));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.disk_number) {
    xfer += oprot->writeFieldBegin("disk_number", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->disk_number);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.drive_letter) {
    xfer += oprot->writeFieldBegin("drive_letter", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->drive_letter);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.gpt_type) {
    xfer += oprot->writeFieldBegin("gpt_type", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->gpt_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.guid) {
    xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->guid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_active) {
    xfer += oprot->writeFieldBegin("is_active", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->is_active);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_boot) {
    xfer += oprot->writeFieldBegin("is_boot", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->is_boot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_hidden) {
    xfer += oprot->writeFieldBegin("is_hidden", ::apache::thrift::protocol::T_BOOL, 8);
    xfer += oprot->writeBool(this->is_hidden);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_offline) {
    xfer += oprot->writeFieldBegin("is_offline", ::apache::thrift::protocol::T_BOOL, 9);
    xfer += oprot->writeBool(this->is_offline);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_readonly) {
    xfer += oprot->writeFieldBegin("is_readonly", ::apache::thrift::protocol::T_BOOL, 10);
    xfer += oprot->writeBool(this->is_readonly);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_shadowcopy) {
    xfer += oprot->writeFieldBegin("is_shadowcopy", ::apache::thrift::protocol::T_BOOL, 11);
    xfer += oprot->writeBool(this->is_shadowcopy);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_system) {
    xfer += oprot->writeFieldBegin("is_system", ::apache::thrift::protocol::T_BOOL, 12);
    xfer += oprot->writeBool(this->is_system);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mbr_type) {
    xfer += oprot->writeFieldBegin("mbr_type", ::apache::thrift::protocol::T_I16, 13);
    xfer += oprot->writeI16(this->mbr_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.offset) {
    xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I64, 14);
    xfer += oprot->writeI64(this->offset);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partition_number) {
    xfer += oprot->writeFieldBegin("partition_number", ::apache::thrift::protocol::T_I32, 15);
    xfer += oprot->writeI32(this->partition_number);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.size) {
    xfer += oprot->writeFieldBegin("size", ::apache::thrift::protocol::T_I64, 16);
    xfer += oprot->writeI64(this->size);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(partition_info &a, partition_info &b) {
  using ::std::swap;
  swap(a.access_paths, b.access_paths);
  swap(a.disk_number, b.disk_number);
  swap(a.drive_letter, b.drive_letter);
  swap(a.gpt_type, b.gpt_type);
  swap(a.guid, b.guid);
  swap(a.is_active, b.is_active);
  swap(a.is_boot, b.is_boot);
  swap(a.is_hidden, b.is_hidden);
  swap(a.is_offline, b.is_offline);
  swap(a.is_readonly, b.is_readonly);
  swap(a.is_shadowcopy, b.is_shadowcopy);
  swap(a.is_system, b.is_system);
  swap(a.mbr_type, b.mbr_type);
  swap(a.offset, b.offset);
  swap(a.partition_number, b.partition_number);
  swap(a.size, b.size);
  swap(a.__isset, b.__isset);
}

partition_info::partition_info(const partition_info& other11) {
  access_paths = other11.access_paths;
  disk_number = other11.disk_number;
  drive_letter = other11.drive_letter;
  gpt_type = other11.gpt_type;
  guid = other11.guid;
  is_active = other11.is_active;
  is_boot = other11.is_boot;
  is_hidden = other11.is_hidden;
  is_offline = other11.is_offline;
  is_readonly = other11.is_readonly;
  is_shadowcopy = other11.is_shadowcopy;
  is_system = other11.is_system;
  mbr_type = other11.mbr_type;
  offset = other11.offset;
  partition_number = other11.partition_number;
  size = other11.size;
  __isset = other11.__isset;
}
partition_info& partition_info::operator=(const partition_info& other12) {
  access_paths = other12.access_paths;
  disk_number = other12.disk_number;
  drive_letter = other12.drive_letter;
  gpt_type = other12.gpt_type;
  guid = other12.guid;
  is_active = other12.is_active;
  is_boot = other12.is_boot;
  is_hidden = other12.is_hidden;
  is_offline = other12.is_offline;
  is_readonly = other12.is_readonly;
  is_shadowcopy = other12.is_shadowcopy;
  is_system = other12.is_system;
  mbr_type = other12.mbr_type;
  offset = other12.offset;
  partition_number = other12.partition_number;
  size = other12.size;
  __isset = other12.__isset;
  return *this;
}
void partition_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "partition_info(";
  out << "access_paths="; (__isset.access_paths ? (out << to_string(access_paths)) : (out << "<null>"));
  out << ", " << "disk_number="; (__isset.disk_number ? (out << to_string(disk_number)) : (out << "<null>"));
  out << ", " << "drive_letter="; (__isset.drive_letter ? (out << to_string(drive_letter)) : (out << "<null>"));
  out << ", " << "gpt_type="; (__isset.gpt_type ? (out << to_string(gpt_type)) : (out << "<null>"));
  out << ", " << "guid="; (__isset.guid ? (out << to_string(guid)) : (out << "<null>"));
  out << ", " << "is_active="; (__isset.is_active ? (out << to_string(is_active)) : (out << "<null>"));
  out << ", " << "is_boot="; (__isset.is_boot ? (out << to_string(is_boot)) : (out << "<null>"));
  out << ", " << "is_hidden="; (__isset.is_hidden ? (out << to_string(is_hidden)) : (out << "<null>"));
  out << ", " << "is_offline="; (__isset.is_offline ? (out << to_string(is_offline)) : (out << "<null>"));
  out << ", " << "is_readonly="; (__isset.is_readonly ? (out << to_string(is_readonly)) : (out << "<null>"));
  out << ", " << "is_shadowcopy="; (__isset.is_shadowcopy ? (out << to_string(is_shadowcopy)) : (out << "<null>"));
  out << ", " << "is_system="; (__isset.is_system ? (out << to_string(is_system)) : (out << "<null>"));
  out << ", " << "mbr_type="; (__isset.mbr_type ? (out << to_string(mbr_type)) : (out << "<null>"));
  out << ", " << "offset="; (__isset.offset ? (out << to_string(offset)) : (out << "<null>"));
  out << ", " << "partition_number="; (__isset.partition_number ? (out << to_string(partition_number)) : (out << "<null>"));
  out << ", " << "size="; (__isset.size ? (out << to_string(size)) : (out << "<null>"));
  out << ")";
}


volume_info::~volume_info() throw() {
}


void volume_info::__set_access_paths(const std::set<std::string> & val) {
  this->access_paths = val;
__isset.access_paths = true;
}

void volume_info::__set_cluster_access_path(const std::string& val) {
  this->cluster_access_path = val;
__isset.cluster_access_path = true;
}

void volume_info::__set_drive_letter(const std::string& val) {
  this->drive_letter = val;
__isset.drive_letter = true;
}

void volume_info::__set_drive_type(const drive_type::type val) {
  this->drive_type = val;
__isset.drive_type = true;
}

void volume_info::__set_file_system(const std::string& val) {
  this->file_system = val;
__isset.file_system = true;
}

void volume_info::__set_file_system_catalogid(const std::string& val) {
  this->file_system_catalogid = val;
__isset.file_system_catalogid = true;
}

void volume_info::__set_file_system_label(const std::string& val) {
  this->file_system_label = val;
__isset.file_system_label = true;
}

void volume_info::__set_object_id(const std::string& val) {
  this->object_id = val;
__isset.object_id = true;
}

void volume_info::__set_path(const std::string& val) {
  this->path = val;
__isset.path = true;
}

void volume_info::__set_size(const int64_t val) {
  this->size = val;
__isset.size = true;
}

void volume_info::__set_size_remaining(const int64_t val) {
  this->size_remaining = val;
__isset.size_remaining = true;
}

uint32_t volume_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->access_paths.clear();
            uint32_t _size13;
            ::apache::thrift::protocol::TType _etype16;
            xfer += iprot->readSetBegin(_etype16, _size13);
            uint32_t _i17;
            for (_i17 = 0; _i17 < _size13; ++_i17)
            {
              std::string _elem18;
              xfer += iprot->readString(_elem18);
              this->access_paths.insert(_elem18);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.access_paths = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cluster_access_path);
          this->__isset.cluster_access_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->drive_letter);
          this->__isset.drive_letter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast19;
          xfer += iprot->readI32(ecast19);
          this->drive_type = (drive_type::type)ecast19;
          this->__isset.drive_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->file_system);
          this->__isset.file_system = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->file_system_catalogid);
          this->__isset.file_system_catalogid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->file_system_label);
          this->__isset.file_system_label = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->object_id);
          this->__isset.object_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->path);
          this->__isset.path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->size);
          this->__isset.size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->size_remaining);
          this->__isset.size_remaining = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t volume_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("volume_info");

  if (this->__isset.access_paths) {
    xfer += oprot->writeFieldBegin("access_paths", ::apache::thrift::protocol::T_SET, 1);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->access_paths.size()));
      std::set<std::string> ::const_iterator _iter20;
      for (_iter20 = this->access_paths.begin(); _iter20 != this->access_paths.end(); ++_iter20)
      {
        xfer += oprot->writeString((*_iter20));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_access_path) {
    xfer += oprot->writeFieldBegin("cluster_access_path", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->cluster_access_path);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.drive_letter) {
    xfer += oprot->writeFieldBegin("drive_letter", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->drive_letter);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.drive_type) {
    xfer += oprot->writeFieldBegin("drive_type", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32((int32_t)this->drive_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.file_system) {
    xfer += oprot->writeFieldBegin("file_system", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->file_system);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.file_system_catalogid) {
    xfer += oprot->writeFieldBegin("file_system_catalogid", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->file_system_catalogid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.file_system_label) {
    xfer += oprot->writeFieldBegin("file_system_label", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->file_system_label);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.object_id) {
    xfer += oprot->writeFieldBegin("object_id", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->object_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.path) {
    xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->path);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.size) {
    xfer += oprot->writeFieldBegin("size", ::apache::thrift::protocol::T_I64, 10);
    xfer += oprot->writeI64(this->size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.size_remaining) {
    xfer += oprot->writeFieldBegin("size_remaining", ::apache::thrift::protocol::T_I64, 11);
    xfer += oprot->writeI64(this->size_remaining);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(volume_info &a, volume_info &b) {
  using ::std::swap;
  swap(a.access_paths, b.access_paths);
  swap(a.cluster_access_path, b.cluster_access_path);
  swap(a.drive_letter, b.drive_letter);
  swap(a.drive_type, b.drive_type);
  swap(a.file_system, b.file_system);
  swap(a.file_system_catalogid, b.file_system_catalogid);
  swap(a.file_system_label, b.file_system_label);
  swap(a.object_id, b.object_id);
  swap(a.path, b.path);
  swap(a.size, b.size);
  swap(a.size_remaining, b.size_remaining);
  swap(a.__isset, b.__isset);
}

volume_info::volume_info(const volume_info& other21) {
  access_paths = other21.access_paths;
  cluster_access_path = other21.cluster_access_path;
  drive_letter = other21.drive_letter;
  drive_type = other21.drive_type;
  file_system = other21.file_system;
  file_system_catalogid = other21.file_system_catalogid;
  file_system_label = other21.file_system_label;
  object_id = other21.object_id;
  path = other21.path;
  size = other21.size;
  size_remaining = other21.size_remaining;
  __isset = other21.__isset;
}
volume_info& volume_info::operator=(const volume_info& other22) {
  access_paths = other22.access_paths;
  cluster_access_path = other22.cluster_access_path;
  drive_letter = other22.drive_letter;
  drive_type = other22.drive_type;
  file_system = other22.file_system;
  file_system_catalogid = other22.file_system_catalogid;
  file_system_label = other22.file_system_label;
  object_id = other22.object_id;
  path = other22.path;
  size = other22.size;
  size_remaining = other22.size_remaining;
  __isset = other22.__isset;
  return *this;
}
void volume_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "volume_info(";
  out << "access_paths="; (__isset.access_paths ? (out << to_string(access_paths)) : (out << "<null>"));
  out << ", " << "cluster_access_path="; (__isset.cluster_access_path ? (out << to_string(cluster_access_path)) : (out << "<null>"));
  out << ", " << "drive_letter="; (__isset.drive_letter ? (out << to_string(drive_letter)) : (out << "<null>"));
  out << ", " << "drive_type="; (__isset.drive_type ? (out << to_string(drive_type)) : (out << "<null>"));
  out << ", " << "file_system="; (__isset.file_system ? (out << to_string(file_system)) : (out << "<null>"));
  out << ", " << "file_system_catalogid="; (__isset.file_system_catalogid ? (out << to_string(file_system_catalogid)) : (out << "<null>"));
  out << ", " << "file_system_label="; (__isset.file_system_label ? (out << to_string(file_system_label)) : (out << "<null>"));
  out << ", " << "object_id="; (__isset.object_id ? (out << to_string(object_id)) : (out << "<null>"));
  out << ", " << "path="; (__isset.path ? (out << to_string(path)) : (out << "<null>"));
  out << ", " << "size="; (__isset.size ? (out << to_string(size)) : (out << "<null>"));
  out << ", " << "size_remaining="; (__isset.size_remaining ? (out << to_string(size_remaining)) : (out << "<null>"));
  out << ")";
}


network_info::~network_info() throw() {
}


void network_info::__set_adapter_name(const std::string& val) {
  this->adapter_name = val;
__isset.adapter_name = true;
}

void network_info::__set_description(const std::string& val) {
  this->description = val;
__isset.description = true;
}

void network_info::__set_dnss(const std::vector<std::string> & val) {
  this->dnss = val;
__isset.dnss = true;
}

void network_info::__set_gateways(const std::vector<std::string> & val) {
  this->gateways = val;
__isset.gateways = true;
}

void network_info::__set_ip_addresses(const std::vector<std::string> & val) {
  this->ip_addresses = val;
__isset.ip_addresses = true;
}

void network_info::__set_is_dhcp_v4(const bool val) {
  this->is_dhcp_v4 = val;
__isset.is_dhcp_v4 = true;
}

void network_info::__set_is_dhcp_v6(const bool val) {
  this->is_dhcp_v6 = val;
__isset.is_dhcp_v6 = true;
}

void network_info::__set_mac_address(const std::string& val) {
  this->mac_address = val;
__isset.mac_address = true;
}

void network_info::__set_subnet_masks(const std::vector<std::string> & val) {
  this->subnet_masks = val;
__isset.subnet_masks = true;
}

uint32_t network_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->adapter_name);
          this->__isset.adapter_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->description);
          this->__isset.description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->dnss.clear();
            uint32_t _size23;
            ::apache::thrift::protocol::TType _etype26;
            xfer += iprot->readListBegin(_etype26, _size23);
            this->dnss.resize(_size23);
            uint32_t _i27;
            for (_i27 = 0; _i27 < _size23; ++_i27)
            {
              xfer += iprot->readString(this->dnss[_i27]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.dnss = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->gateways.clear();
            uint32_t _size28;
            ::apache::thrift::protocol::TType _etype31;
            xfer += iprot->readListBegin(_etype31, _size28);
            this->gateways.resize(_size28);
            uint32_t _i32;
            for (_i32 = 0; _i32 < _size28; ++_i32)
            {
              xfer += iprot->readString(this->gateways[_i32]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.gateways = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->ip_addresses.clear();
            uint32_t _size33;
            ::apache::thrift::protocol::TType _etype36;
            xfer += iprot->readListBegin(_etype36, _size33);
            this->ip_addresses.resize(_size33);
            uint32_t _i37;
            for (_i37 = 0; _i37 < _size33; ++_i37)
            {
              xfer += iprot->readString(this->ip_addresses[_i37]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.ip_addresses = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_dhcp_v4);
          this->__isset.is_dhcp_v4 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_dhcp_v6);
          this->__isset.is_dhcp_v6 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->mac_address);
          this->__isset.mac_address = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->subnet_masks.clear();
            uint32_t _size38;
            ::apache::thrift::protocol::TType _etype41;
            xfer += iprot->readListBegin(_etype41, _size38);
            this->subnet_masks.resize(_size38);
            uint32_t _i42;
            for (_i42 = 0; _i42 < _size38; ++_i42)
            {
              xfer += iprot->readString(this->subnet_masks[_i42]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.subnet_masks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t network_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("network_info");

  if (this->__isset.adapter_name) {
    xfer += oprot->writeFieldBegin("adapter_name", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->adapter_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.description) {
    xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->description);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dnss) {
    xfer += oprot->writeFieldBegin("dnss", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->dnss.size()));
      std::vector<std::string> ::const_iterator _iter43;
      for (_iter43 = this->dnss.begin(); _iter43 != this->dnss.end(); ++_iter43)
      {
        xfer += oprot->writeString((*_iter43));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.gateways) {
    xfer += oprot->writeFieldBegin("gateways", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->gateways.size()));
      std::vector<std::string> ::const_iterator _iter44;
      for (_iter44 = this->gateways.begin(); _iter44 != this->gateways.end(); ++_iter44)
      {
        xfer += oprot->writeString((*_iter44));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ip_addresses) {
    xfer += oprot->writeFieldBegin("ip_addresses", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->ip_addresses.size()));
      std::vector<std::string> ::const_iterator _iter45;
      for (_iter45 = this->ip_addresses.begin(); _iter45 != this->ip_addresses.end(); ++_iter45)
      {
        xfer += oprot->writeString((*_iter45));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_dhcp_v4) {
    xfer += oprot->writeFieldBegin("is_dhcp_v4", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->is_dhcp_v4);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_dhcp_v6) {
    xfer += oprot->writeFieldBegin("is_dhcp_v6", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->is_dhcp_v6);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mac_address) {
    xfer += oprot->writeFieldBegin("mac_address", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->mac_address);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.subnet_masks) {
    xfer += oprot->writeFieldBegin("subnet_masks", ::apache::thrift::protocol::T_LIST, 9);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->subnet_masks.size()));
      std::vector<std::string> ::const_iterator _iter46;
      for (_iter46 = this->subnet_masks.begin(); _iter46 != this->subnet_masks.end(); ++_iter46)
      {
        xfer += oprot->writeString((*_iter46));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(network_info &a, network_info &b) {
  using ::std::swap;
  swap(a.adapter_name, b.adapter_name);
  swap(a.description, b.description);
  swap(a.dnss, b.dnss);
  swap(a.gateways, b.gateways);
  swap(a.ip_addresses, b.ip_addresses);
  swap(a.is_dhcp_v4, b.is_dhcp_v4);
  swap(a.is_dhcp_v6, b.is_dhcp_v6);
  swap(a.mac_address, b.mac_address);
  swap(a.subnet_masks, b.subnet_masks);
  swap(a.__isset, b.__isset);
}

network_info::network_info(const network_info& other47) {
  adapter_name = other47.adapter_name;
  description = other47.description;
  dnss = other47.dnss;
  gateways = other47.gateways;
  ip_addresses = other47.ip_addresses;
  is_dhcp_v4 = other47.is_dhcp_v4;
  is_dhcp_v6 = other47.is_dhcp_v6;
  mac_address = other47.mac_address;
  subnet_masks = other47.subnet_masks;
  __isset = other47.__isset;
}
network_info& network_info::operator=(const network_info& other48) {
  adapter_name = other48.adapter_name;
  description = other48.description;
  dnss = other48.dnss;
  gateways = other48.gateways;
  ip_addresses = other48.ip_addresses;
  is_dhcp_v4 = other48.is_dhcp_v4;
  is_dhcp_v6 = other48.is_dhcp_v6;
  mac_address = other48.mac_address;
  subnet_masks = other48.subnet_masks;
  __isset = other48.__isset;
  return *this;
}
void network_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "network_info(";
  out << "adapter_name="; (__isset.adapter_name ? (out << to_string(adapter_name)) : (out << "<null>"));
  out << ", " << "description="; (__isset.description ? (out << to_string(description)) : (out << "<null>"));
  out << ", " << "dnss="; (__isset.dnss ? (out << to_string(dnss)) : (out << "<null>"));
  out << ", " << "gateways="; (__isset.gateways ? (out << to_string(gateways)) : (out << "<null>"));
  out << ", " << "ip_addresses="; (__isset.ip_addresses ? (out << to_string(ip_addresses)) : (out << "<null>"));
  out << ", " << "is_dhcp_v4="; (__isset.is_dhcp_v4 ? (out << to_string(is_dhcp_v4)) : (out << "<null>"));
  out << ", " << "is_dhcp_v6="; (__isset.is_dhcp_v6 ? (out << to_string(is_dhcp_v6)) : (out << "<null>"));
  out << ", " << "mac_address="; (__isset.mac_address ? (out << to_string(mac_address)) : (out << "<null>"));
  out << ", " << "subnet_masks="; (__isset.subnet_masks ? (out << to_string(subnet_masks)) : (out << "<null>"));
  out << ")";
}


cluster_network::~cluster_network() throw() {
}


void cluster_network::__set_cluster_network_name(const std::string& val) {
  this->cluster_network_name = val;
__isset.cluster_network_name = true;
}

void cluster_network::__set_cluster_network_id(const std::string& val) {
  this->cluster_network_id = val;
__isset.cluster_network_id = true;
}

void cluster_network::__set_cluster_network_address(const std::string& val) {
  this->cluster_network_address = val;
__isset.cluster_network_address = true;
}

void cluster_network::__set_cluster_network_address_mask(const std::string& val) {
  this->cluster_network_address_mask = val;
__isset.cluster_network_address_mask = true;
}

void cluster_network::__set_network_infos(const std::set<network_info> & val) {
  this->network_infos = val;
__isset.network_infos = true;
}

uint32_t cluster_network::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cluster_network_name);
          this->__isset.cluster_network_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cluster_network_id);
          this->__isset.cluster_network_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cluster_network_address);
          this->__isset.cluster_network_address = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cluster_network_address_mask);
          this->__isset.cluster_network_address_mask = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->network_infos.clear();
            uint32_t _size49;
            ::apache::thrift::protocol::TType _etype52;
            xfer += iprot->readSetBegin(_etype52, _size49);
            uint32_t _i53;
            for (_i53 = 0; _i53 < _size49; ++_i53)
            {
              network_info _elem54;
              xfer += _elem54.read(iprot);
              this->network_infos.insert(_elem54);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.network_infos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t cluster_network::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("cluster_network");

  if (this->__isset.cluster_network_name) {
    xfer += oprot->writeFieldBegin("cluster_network_name", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->cluster_network_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_network_id) {
    xfer += oprot->writeFieldBegin("cluster_network_id", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->cluster_network_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_network_address) {
    xfer += oprot->writeFieldBegin("cluster_network_address", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->cluster_network_address);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_network_address_mask) {
    xfer += oprot->writeFieldBegin("cluster_network_address_mask", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->cluster_network_address_mask);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.network_infos) {
    xfer += oprot->writeFieldBegin("network_infos", ::apache::thrift::protocol::T_SET, 5);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->network_infos.size()));
      std::set<network_info> ::const_iterator _iter55;
      for (_iter55 = this->network_infos.begin(); _iter55 != this->network_infos.end(); ++_iter55)
      {
        xfer += (*_iter55).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(cluster_network &a, cluster_network &b) {
  using ::std::swap;
  swap(a.cluster_network_name, b.cluster_network_name);
  swap(a.cluster_network_id, b.cluster_network_id);
  swap(a.cluster_network_address, b.cluster_network_address);
  swap(a.cluster_network_address_mask, b.cluster_network_address_mask);
  swap(a.network_infos, b.network_infos);
  swap(a.__isset, b.__isset);
}

cluster_network::cluster_network(const cluster_network& other56) {
  cluster_network_name = other56.cluster_network_name;
  cluster_network_id = other56.cluster_network_id;
  cluster_network_address = other56.cluster_network_address;
  cluster_network_address_mask = other56.cluster_network_address_mask;
  network_infos = other56.network_infos;
  __isset = other56.__isset;
}
cluster_network& cluster_network::operator=(const cluster_network& other57) {
  cluster_network_name = other57.cluster_network_name;
  cluster_network_id = other57.cluster_network_id;
  cluster_network_address = other57.cluster_network_address;
  cluster_network_address_mask = other57.cluster_network_address_mask;
  network_infos = other57.network_infos;
  __isset = other57.__isset;
  return *this;
}
void cluster_network::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "cluster_network(";
  out << "cluster_network_name="; (__isset.cluster_network_name ? (out << to_string(cluster_network_name)) : (out << "<null>"));
  out << ", " << "cluster_network_id="; (__isset.cluster_network_id ? (out << to_string(cluster_network_id)) : (out << "<null>"));
  out << ", " << "cluster_network_address="; (__isset.cluster_network_address ? (out << to_string(cluster_network_address)) : (out << "<null>"));
  out << ", " << "cluster_network_address_mask="; (__isset.cluster_network_address_mask ? (out << to_string(cluster_network_address_mask)) : (out << "<null>"));
  out << ", " << "network_infos="; (__isset.network_infos ? (out << to_string(network_infos)) : (out << "<null>"));
  out << ")";
}


cluster_group::~cluster_group() throw() {
}


void cluster_group::__set_group_id(const std::string& val) {
  this->group_id = val;
__isset.group_id = true;
}

void cluster_group::__set_group_name(const std::string& val) {
  this->group_name = val;
__isset.group_name = true;
}

void cluster_group::__set_group_owner(const std::string& val) {
  this->group_owner = val;
__isset.group_owner = true;
}

void cluster_group::__set_cluster_disks(const std::set<disk_info> & val) {
  this->cluster_disks = val;
__isset.cluster_disks = true;
}

void cluster_group::__set_cluster_partitions(const std::set<volume_info> & val) {
  this->cluster_partitions = val;
__isset.cluster_partitions = true;
}

void cluster_group::__set_cluster_network_infos(const std::set<cluster_network> & val) {
  this->cluster_network_infos = val;
__isset.cluster_network_infos = true;
}

uint32_t cluster_group::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->group_id);
          this->__isset.group_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->group_name);
          this->__isset.group_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->group_owner);
          this->__isset.group_owner = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->cluster_disks.clear();
            uint32_t _size58;
            ::apache::thrift::protocol::TType _etype61;
            xfer += iprot->readSetBegin(_etype61, _size58);
            uint32_t _i62;
            for (_i62 = 0; _i62 < _size58; ++_i62)
            {
              disk_info _elem63;
              xfer += _elem63.read(iprot);
              this->cluster_disks.insert(_elem63);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.cluster_disks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->cluster_partitions.clear();
            uint32_t _size64;
            ::apache::thrift::protocol::TType _etype67;
            xfer += iprot->readSetBegin(_etype67, _size64);
            uint32_t _i68;
            for (_i68 = 0; _i68 < _size64; ++_i68)
            {
              volume_info _elem69;
              xfer += _elem69.read(iprot);
              this->cluster_partitions.insert(_elem69);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.cluster_partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->cluster_network_infos.clear();
            uint32_t _size70;
            ::apache::thrift::protocol::TType _etype73;
            xfer += iprot->readSetBegin(_etype73, _size70);
            uint32_t _i74;
            for (_i74 = 0; _i74 < _size70; ++_i74)
            {
              cluster_network _elem75;
              xfer += _elem75.read(iprot);
              this->cluster_network_infos.insert(_elem75);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.cluster_network_infos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t cluster_group::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("cluster_group");

  if (this->__isset.group_id) {
    xfer += oprot->writeFieldBegin("group_id", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->group_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.group_name) {
    xfer += oprot->writeFieldBegin("group_name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->group_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.group_owner) {
    xfer += oprot->writeFieldBegin("group_owner", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->group_owner);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_disks) {
    xfer += oprot->writeFieldBegin("cluster_disks", ::apache::thrift::protocol::T_SET, 4);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cluster_disks.size()));
      std::set<disk_info> ::const_iterator _iter76;
      for (_iter76 = this->cluster_disks.begin(); _iter76 != this->cluster_disks.end(); ++_iter76)
      {
        xfer += (*_iter76).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_partitions) {
    xfer += oprot->writeFieldBegin("cluster_partitions", ::apache::thrift::protocol::T_SET, 5);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cluster_partitions.size()));
      std::set<volume_info> ::const_iterator _iter77;
      for (_iter77 = this->cluster_partitions.begin(); _iter77 != this->cluster_partitions.end(); ++_iter77)
      {
        xfer += (*_iter77).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_network_infos) {
    xfer += oprot->writeFieldBegin("cluster_network_infos", ::apache::thrift::protocol::T_SET, 6);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cluster_network_infos.size()));
      std::set<cluster_network> ::const_iterator _iter78;
      for (_iter78 = this->cluster_network_infos.begin(); _iter78 != this->cluster_network_infos.end(); ++_iter78)
      {
        xfer += (*_iter78).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(cluster_group &a, cluster_group &b) {
  using ::std::swap;
  swap(a.group_id, b.group_id);
  swap(a.group_name, b.group_name);
  swap(a.group_owner, b.group_owner);
  swap(a.cluster_disks, b.cluster_disks);
  swap(a.cluster_partitions, b.cluster_partitions);
  swap(a.cluster_network_infos, b.cluster_network_infos);
  swap(a.__isset, b.__isset);
}

cluster_group::cluster_group(const cluster_group& other79) {
  group_id = other79.group_id;
  group_name = other79.group_name;
  group_owner = other79.group_owner;
  cluster_disks = other79.cluster_disks;
  cluster_partitions = other79.cluster_partitions;
  cluster_network_infos = other79.cluster_network_infos;
  __isset = other79.__isset;
}
cluster_group& cluster_group::operator=(const cluster_group& other80) {
  group_id = other80.group_id;
  group_name = other80.group_name;
  group_owner = other80.group_owner;
  cluster_disks = other80.cluster_disks;
  cluster_partitions = other80.cluster_partitions;
  cluster_network_infos = other80.cluster_network_infos;
  __isset = other80.__isset;
  return *this;
}
void cluster_group::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "cluster_group(";
  out << "group_id="; (__isset.group_id ? (out << to_string(group_id)) : (out << "<null>"));
  out << ", " << "group_name="; (__isset.group_name ? (out << to_string(group_name)) : (out << "<null>"));
  out << ", " << "group_owner="; (__isset.group_owner ? (out << to_string(group_owner)) : (out << "<null>"));
  out << ", " << "cluster_disks="; (__isset.cluster_disks ? (out << to_string(cluster_disks)) : (out << "<null>"));
  out << ", " << "cluster_partitions="; (__isset.cluster_partitions ? (out << to_string(cluster_partitions)) : (out << "<null>"));
  out << ", " << "cluster_network_infos="; (__isset.cluster_network_infos ? (out << to_string(cluster_network_infos)) : (out << "<null>"));
  out << ")";
}


cluster_info::~cluster_info() throw() {
}


void cluster_info::__set_cluster_name(const std::string& val) {
  this->cluster_name = val;
__isset.cluster_name = true;
}

void cluster_info::__set_quorum_disk(const disk_info& val) {
  this->quorum_disk = val;
__isset.quorum_disk = true;
}

void cluster_info::__set_cluster_nodes(const std::set<std::string> & val) {
  this->cluster_nodes = val;
__isset.cluster_nodes = true;
}

void cluster_info::__set_client_ids(const std::set<std::string> & val) {
  this->client_ids = val;
__isset.client_ids = true;
}

void cluster_info::__set_machine_ids(const std::set<std::string> & val) {
  this->machine_ids = val;
__isset.machine_ids = true;
}

void cluster_info::__set_cluster_network_infos(const std::set<cluster_network> & val) {
  this->cluster_network_infos = val;
__isset.cluster_network_infos = true;
}

void cluster_info::__set_cluster_groups(const std::set<cluster_group> & val) {
  this->cluster_groups = val;
__isset.cluster_groups = true;
}

uint32_t cluster_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cluster_name);
          this->__isset.cluster_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->quorum_disk.read(iprot);
          this->__isset.quorum_disk = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->cluster_nodes.clear();
            uint32_t _size81;
            ::apache::thrift::protocol::TType _etype84;
            xfer += iprot->readSetBegin(_etype84, _size81);
            uint32_t _i85;
            for (_i85 = 0; _i85 < _size81; ++_i85)
            {
              std::string _elem86;
              xfer += iprot->readString(_elem86);
              this->cluster_nodes.insert(_elem86);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.cluster_nodes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->client_ids.clear();
            uint32_t _size87;
            ::apache::thrift::protocol::TType _etype90;
            xfer += iprot->readSetBegin(_etype90, _size87);
            uint32_t _i91;
            for (_i91 = 0; _i91 < _size87; ++_i91)
            {
              std::string _elem92;
              xfer += iprot->readString(_elem92);
              this->client_ids.insert(_elem92);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.client_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->machine_ids.clear();
            uint32_t _size93;
            ::apache::thrift::protocol::TType _etype96;
            xfer += iprot->readSetBegin(_etype96, _size93);
            uint32_t _i97;
            for (_i97 = 0; _i97 < _size93; ++_i97)
            {
              std::string _elem98;
              xfer += iprot->readString(_elem98);
              this->machine_ids.insert(_elem98);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.machine_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->cluster_network_infos.clear();
            uint32_t _size99;
            ::apache::thrift::protocol::TType _etype102;
            xfer += iprot->readSetBegin(_etype102, _size99);
            uint32_t _i103;
            for (_i103 = 0; _i103 < _size99; ++_i103)
            {
              cluster_network _elem104;
              xfer += _elem104.read(iprot);
              this->cluster_network_infos.insert(_elem104);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.cluster_network_infos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->cluster_groups.clear();
            uint32_t _size105;
            ::apache::thrift::protocol::TType _etype108;
            xfer += iprot->readSetBegin(_etype108, _size105);
            uint32_t _i109;
            for (_i109 = 0; _i109 < _size105; ++_i109)
            {
              cluster_group _elem110;
              xfer += _elem110.read(iprot);
              this->cluster_groups.insert(_elem110);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.cluster_groups = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t cluster_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("cluster_info");

  if (this->__isset.cluster_name) {
    xfer += oprot->writeFieldBegin("cluster_name", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->cluster_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.quorum_disk) {
    xfer += oprot->writeFieldBegin("quorum_disk", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->quorum_disk.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_nodes) {
    xfer += oprot->writeFieldBegin("cluster_nodes", ::apache::thrift::protocol::T_SET, 3);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->cluster_nodes.size()));
      std::set<std::string> ::const_iterator _iter111;
      for (_iter111 = this->cluster_nodes.begin(); _iter111 != this->cluster_nodes.end(); ++_iter111)
      {
        xfer += oprot->writeString((*_iter111));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.client_ids) {
    xfer += oprot->writeFieldBegin("client_ids", ::apache::thrift::protocol::T_SET, 4);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->client_ids.size()));
      std::set<std::string> ::const_iterator _iter112;
      for (_iter112 = this->client_ids.begin(); _iter112 != this->client_ids.end(); ++_iter112)
      {
        xfer += oprot->writeString((*_iter112));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.machine_ids) {
    xfer += oprot->writeFieldBegin("machine_ids", ::apache::thrift::protocol::T_SET, 5);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->machine_ids.size()));
      std::set<std::string> ::const_iterator _iter113;
      for (_iter113 = this->machine_ids.begin(); _iter113 != this->machine_ids.end(); ++_iter113)
      {
        xfer += oprot->writeString((*_iter113));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_network_infos) {
    xfer += oprot->writeFieldBegin("cluster_network_infos", ::apache::thrift::protocol::T_SET, 6);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cluster_network_infos.size()));
      std::set<cluster_network> ::const_iterator _iter114;
      for (_iter114 = this->cluster_network_infos.begin(); _iter114 != this->cluster_network_infos.end(); ++_iter114)
      {
        xfer += (*_iter114).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_groups) {
    xfer += oprot->writeFieldBegin("cluster_groups", ::apache::thrift::protocol::T_SET, 7);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cluster_groups.size()));
      std::set<cluster_group> ::const_iterator _iter115;
      for (_iter115 = this->cluster_groups.begin(); _iter115 != this->cluster_groups.end(); ++_iter115)
      {
        xfer += (*_iter115).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(cluster_info &a, cluster_info &b) {
  using ::std::swap;
  swap(a.cluster_name, b.cluster_name);
  swap(a.quorum_disk, b.quorum_disk);
  swap(a.cluster_nodes, b.cluster_nodes);
  swap(a.client_ids, b.client_ids);
  swap(a.machine_ids, b.machine_ids);
  swap(a.cluster_network_infos, b.cluster_network_infos);
  swap(a.cluster_groups, b.cluster_groups);
  swap(a.__isset, b.__isset);
}

cluster_info::cluster_info(const cluster_info& other116) {
  cluster_name = other116.cluster_name;
  quorum_disk = other116.quorum_disk;
  cluster_nodes = other116.cluster_nodes;
  client_ids = other116.client_ids;
  machine_ids = other116.machine_ids;
  cluster_network_infos = other116.cluster_network_infos;
  cluster_groups = other116.cluster_groups;
  __isset = other116.__isset;
}
cluster_info& cluster_info::operator=(const cluster_info& other117) {
  cluster_name = other117.cluster_name;
  quorum_disk = other117.quorum_disk;
  cluster_nodes = other117.cluster_nodes;
  client_ids = other117.client_ids;
  machine_ids = other117.machine_ids;
  cluster_network_infos = other117.cluster_network_infos;
  cluster_groups = other117.cluster_groups;
  __isset = other117.__isset;
  return *this;
}
void cluster_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "cluster_info(";
  out << "cluster_name="; (__isset.cluster_name ? (out << to_string(cluster_name)) : (out << "<null>"));
  out << ", " << "quorum_disk="; (__isset.quorum_disk ? (out << to_string(quorum_disk)) : (out << "<null>"));
  out << ", " << "cluster_nodes="; (__isset.cluster_nodes ? (out << to_string(cluster_nodes)) : (out << "<null>"));
  out << ", " << "client_ids="; (__isset.client_ids ? (out << to_string(client_ids)) : (out << "<null>"));
  out << ", " << "machine_ids="; (__isset.machine_ids ? (out << to_string(machine_ids)) : (out << "<null>"));
  out << ", " << "cluster_network_infos="; (__isset.cluster_network_infos ? (out << to_string(cluster_network_infos)) : (out << "<null>"));
  out << ", " << "cluster_groups="; (__isset.cluster_groups ? (out << to_string(cluster_groups)) : (out << "<null>"));
  out << ")";
}


os_version_info::~os_version_info() throw() {
}


void os_version_info::__set_csd_version(const std::string& val) {
  this->csd_version = val;
__isset.csd_version = true;
}

void os_version_info::__set_build_number(const int32_t val) {
  this->build_number = val;
__isset.build_number = true;
}

void os_version_info::__set_major_version(const int32_t val) {
  this->major_version = val;
__isset.major_version = true;
}

void os_version_info::__set_minor_version(const int32_t val) {
  this->minor_version = val;
__isset.minor_version = true;
}

void os_version_info::__set_platform_id(const int32_t val) {
  this->platform_id = val;
__isset.platform_id = true;
}

void os_version_info::__set_product_type(const int16_t val) {
  this->product_type = val;
__isset.product_type = true;
}

void os_version_info::__set_servicepack_major(const int32_t val) {
  this->servicepack_major = val;
__isset.servicepack_major = true;
}

void os_version_info::__set_servicepack_minor(const int32_t val) {
  this->servicepack_minor = val;
__isset.servicepack_minor = true;
}

void os_version_info::__set_suite_mask(const int32_t val) {
  this->suite_mask = val;
__isset.suite_mask = true;
}

uint32_t os_version_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->csd_version);
          this->__isset.csd_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->build_number);
          this->__isset.build_number = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->major_version);
          this->__isset.major_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->minor_version);
          this->__isset.minor_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->platform_id);
          this->__isset.platform_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->product_type);
          this->__isset.product_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->servicepack_major);
          this->__isset.servicepack_major = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->servicepack_minor);
          this->__isset.servicepack_minor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->suite_mask);
          this->__isset.suite_mask = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t os_version_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("os_version_info");

  if (this->__isset.csd_version) {
    xfer += oprot->writeFieldBegin("csd_version", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->csd_version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.build_number) {
    xfer += oprot->writeFieldBegin("build_number", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->build_number);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.major_version) {
    xfer += oprot->writeFieldBegin("major_version", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->major_version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.minor_version) {
    xfer += oprot->writeFieldBegin("minor_version", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->minor_version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.platform_id) {
    xfer += oprot->writeFieldBegin("platform_id", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->platform_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.product_type) {
    xfer += oprot->writeFieldBegin("product_type", ::apache::thrift::protocol::T_I16, 6);
    xfer += oprot->writeI16(this->product_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.servicepack_major) {
    xfer += oprot->writeFieldBegin("servicepack_major", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32(this->servicepack_major);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.servicepack_minor) {
    xfer += oprot->writeFieldBegin("servicepack_minor", ::apache::thrift::protocol::T_I32, 8);
    xfer += oprot->writeI32(this->servicepack_minor);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.suite_mask) {
    xfer += oprot->writeFieldBegin("suite_mask", ::apache::thrift::protocol::T_I32, 9);
    xfer += oprot->writeI32(this->suite_mask);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(os_version_info &a, os_version_info &b) {
  using ::std::swap;
  swap(a.csd_version, b.csd_version);
  swap(a.build_number, b.build_number);
  swap(a.major_version, b.major_version);
  swap(a.minor_version, b.minor_version);
  swap(a.platform_id, b.platform_id);
  swap(a.product_type, b.product_type);
  swap(a.servicepack_major, b.servicepack_major);
  swap(a.servicepack_minor, b.servicepack_minor);
  swap(a.suite_mask, b.suite_mask);
  swap(a.__isset, b.__isset);
}

os_version_info::os_version_info(const os_version_info& other118) {
  csd_version = other118.csd_version;
  build_number = other118.build_number;
  major_version = other118.major_version;
  minor_version = other118.minor_version;
  platform_id = other118.platform_id;
  product_type = other118.product_type;
  servicepack_major = other118.servicepack_major;
  servicepack_minor = other118.servicepack_minor;
  suite_mask = other118.suite_mask;
  __isset = other118.__isset;
}
os_version_info& os_version_info::operator=(const os_version_info& other119) {
  csd_version = other119.csd_version;
  build_number = other119.build_number;
  major_version = other119.major_version;
  minor_version = other119.minor_version;
  platform_id = other119.platform_id;
  product_type = other119.product_type;
  servicepack_major = other119.servicepack_major;
  servicepack_minor = other119.servicepack_minor;
  suite_mask = other119.suite_mask;
  __isset = other119.__isset;
  return *this;
}
void os_version_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "os_version_info(";
  out << "csd_version="; (__isset.csd_version ? (out << to_string(csd_version)) : (out << "<null>"));
  out << ", " << "build_number="; (__isset.build_number ? (out << to_string(build_number)) : (out << "<null>"));
  out << ", " << "major_version="; (__isset.major_version ? (out << to_string(major_version)) : (out << "<null>"));
  out << ", " << "minor_version="; (__isset.minor_version ? (out << to_string(minor_version)) : (out << "<null>"));
  out << ", " << "platform_id="; (__isset.platform_id ? (out << to_string(platform_id)) : (out << "<null>"));
  out << ", " << "product_type="; (__isset.product_type ? (out << to_string(product_type)) : (out << "<null>"));
  out << ", " << "servicepack_major="; (__isset.servicepack_major ? (out << to_string(servicepack_major)) : (out << "<null>"));
  out << ", " << "servicepack_minor="; (__isset.servicepack_minor ? (out << to_string(servicepack_minor)) : (out << "<null>"));
  out << ", " << "suite_mask="; (__isset.suite_mask ? (out << to_string(suite_mask)) : (out << "<null>"));
  out << ")";
}


snapshot::~snapshot() throw() {
}


void snapshot::__set_snapshot_set_id(const std::string& val) {
  this->snapshot_set_id = val;
__isset.snapshot_set_id = true;
}

void snapshot::__set_snapshot_id(const std::string& val) {
  this->snapshot_id = val;
__isset.snapshot_id = true;
}

void snapshot::__set_original_volume_name(const std::string& val) {
  this->original_volume_name = val;
__isset.original_volume_name = true;
}

void snapshot::__set_snapshot_device_object(const std::string& val) {
  this->snapshot_device_object = val;
__isset.snapshot_device_object = true;
}

void snapshot::__set_creation_time_stamp(const std::string& val) {
  this->creation_time_stamp = val;
__isset.creation_time_stamp = true;
}

void snapshot::__set_snapshots_count(const int32_t val) {
  this->snapshots_count = val;
__isset.snapshots_count = true;
}

uint32_t snapshot::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->snapshot_set_id);
          this->__isset.snapshot_set_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->snapshot_id);
          this->__isset.snapshot_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->original_volume_name);
          this->__isset.original_volume_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->snapshot_device_object);
          this->__isset.snapshot_device_object = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->creation_time_stamp);
          this->__isset.creation_time_stamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->snapshots_count);
          this->__isset.snapshots_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t snapshot::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("snapshot");

  if (this->__isset.snapshot_set_id) {
    xfer += oprot->writeFieldBegin("snapshot_set_id", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->snapshot_set_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.snapshot_id) {
    xfer += oprot->writeFieldBegin("snapshot_id", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->snapshot_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.original_volume_name) {
    xfer += oprot->writeFieldBegin("original_volume_name", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->original_volume_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.snapshot_device_object) {
    xfer += oprot->writeFieldBegin("snapshot_device_object", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->snapshot_device_object);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.creation_time_stamp) {
    xfer += oprot->writeFieldBegin("creation_time_stamp", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->creation_time_stamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.snapshots_count) {
    xfer += oprot->writeFieldBegin("snapshots_count", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(this->snapshots_count);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(snapshot &a, snapshot &b) {
  using ::std::swap;
  swap(a.snapshot_set_id, b.snapshot_set_id);
  swap(a.snapshot_id, b.snapshot_id);
  swap(a.original_volume_name, b.original_volume_name);
  swap(a.snapshot_device_object, b.snapshot_device_object);
  swap(a.creation_time_stamp, b.creation_time_stamp);
  swap(a.snapshots_count, b.snapshots_count);
  swap(a.__isset, b.__isset);
}

snapshot::snapshot(const snapshot& other120) {
  snapshot_set_id = other120.snapshot_set_id;
  snapshot_id = other120.snapshot_id;
  original_volume_name = other120.original_volume_name;
  snapshot_device_object = other120.snapshot_device_object;
  creation_time_stamp = other120.creation_time_stamp;
  snapshots_count = other120.snapshots_count;
  __isset = other120.__isset;
}
snapshot& snapshot::operator=(const snapshot& other121) {
  snapshot_set_id = other121.snapshot_set_id;
  snapshot_id = other121.snapshot_id;
  original_volume_name = other121.original_volume_name;
  snapshot_device_object = other121.snapshot_device_object;
  creation_time_stamp = other121.creation_time_stamp;
  snapshots_count = other121.snapshots_count;
  __isset = other121.__isset;
  return *this;
}
void snapshot::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "snapshot(";
  out << "snapshot_set_id="; (__isset.snapshot_set_id ? (out << to_string(snapshot_set_id)) : (out << "<null>"));
  out << ", " << "snapshot_id="; (__isset.snapshot_id ? (out << to_string(snapshot_id)) : (out << "<null>"));
  out << ", " << "original_volume_name="; (__isset.original_volume_name ? (out << to_string(original_volume_name)) : (out << "<null>"));
  out << ", " << "snapshot_device_object="; (__isset.snapshot_device_object ? (out << to_string(snapshot_device_object)) : (out << "<null>"));
  out << ", " << "creation_time_stamp="; (__isset.creation_time_stamp ? (out << to_string(creation_time_stamp)) : (out << "<null>"));
  out << ", " << "snapshots_count="; (__isset.snapshots_count ? (out << to_string(snapshots_count)) : (out << "<null>"));
  out << ")";
}


snapshot_result::~snapshot_result() throw() {
}


void snapshot_result::__set_snapshots(const std::vector<snapshot> & val) {
  this->snapshots = val;
}

uint32_t snapshot_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->snapshots.clear();
            uint32_t _size122;
            ::apache::thrift::protocol::TType _etype125;
            xfer += iprot->readListBegin(_etype125, _size122);
            this->snapshots.resize(_size122);
            uint32_t _i126;
            for (_i126 = 0; _i126 < _size122; ++_i126)
            {
              xfer += this->snapshots[_i126].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.snapshots = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t snapshot_result::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("snapshot_result");

  xfer += oprot->writeFieldBegin("snapshots", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->snapshots.size()));
    std::vector<snapshot> ::const_iterator _iter127;
    for (_iter127 = this->snapshots.begin(); _iter127 != this->snapshots.end(); ++_iter127)
    {
      xfer += (*_iter127).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(snapshot_result &a, snapshot_result &b) {
  using ::std::swap;
  swap(a.snapshots, b.snapshots);
  swap(a.__isset, b.__isset);
}

snapshot_result::snapshot_result(const snapshot_result& other128) {
  snapshots = other128.snapshots;
  __isset = other128.__isset;
}
snapshot_result& snapshot_result::operator=(const snapshot_result& other129) {
  snapshots = other129.snapshots;
  __isset = other129.__isset;
  return *this;
}
void snapshot_result::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "snapshot_result(";
  out << "snapshots=" << to_string(snapshots);
  out << ")";
}


volume_bit_map::~volume_bit_map() throw() {
}


void volume_bit_map::__set_cluster_size(const int32_t val) {
  this->cluster_size = val;
__isset.cluster_size = true;
}

void volume_bit_map::__set_starting_lcn(const int64_t val) {
  this->starting_lcn = val;
__isset.starting_lcn = true;
}

void volume_bit_map::__set_total_number_of_clusters(const int64_t val) {
  this->total_number_of_clusters = val;
__isset.total_number_of_clusters = true;
}

void volume_bit_map::__set_bit_map(const std::string& val) {
  this->bit_map = val;
__isset.bit_map = true;
}

void volume_bit_map::__set_compressed(const bool val) {
  this->compressed = val;
__isset.compressed = true;
}

uint32_t volume_bit_map::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cluster_size);
          this->__isset.cluster_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->starting_lcn);
          this->__isset.starting_lcn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->total_number_of_clusters);
          this->__isset.total_number_of_clusters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->bit_map);
          this->__isset.bit_map = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->compressed);
          this->__isset.compressed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t volume_bit_map::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("volume_bit_map");

  if (this->__isset.cluster_size) {
    xfer += oprot->writeFieldBegin("cluster_size", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->cluster_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.starting_lcn) {
    xfer += oprot->writeFieldBegin("starting_lcn", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->starting_lcn);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.total_number_of_clusters) {
    xfer += oprot->writeFieldBegin("total_number_of_clusters", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->total_number_of_clusters);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.bit_map) {
    xfer += oprot->writeFieldBegin("bit_map", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeBinary(this->bit_map);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.compressed) {
    xfer += oprot->writeFieldBegin("compressed", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->compressed);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(volume_bit_map &a, volume_bit_map &b) {
  using ::std::swap;
  swap(a.cluster_size, b.cluster_size);
  swap(a.starting_lcn, b.starting_lcn);
  swap(a.total_number_of_clusters, b.total_number_of_clusters);
  swap(a.bit_map, b.bit_map);
  swap(a.compressed, b.compressed);
  swap(a.__isset, b.__isset);
}

volume_bit_map::volume_bit_map(const volume_bit_map& other130) {
  cluster_size = other130.cluster_size;
  starting_lcn = other130.starting_lcn;
  total_number_of_clusters = other130.total_number_of_clusters;
  bit_map = other130.bit_map;
  compressed = other130.compressed;
  __isset = other130.__isset;
}
volume_bit_map& volume_bit_map::operator=(const volume_bit_map& other131) {
  cluster_size = other131.cluster_size;
  starting_lcn = other131.starting_lcn;
  total_number_of_clusters = other131.total_number_of_clusters;
  bit_map = other131.bit_map;
  compressed = other131.compressed;
  __isset = other131.__isset;
  return *this;
}
void volume_bit_map::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "volume_bit_map(";
  out << "cluster_size="; (__isset.cluster_size ? (out << to_string(cluster_size)) : (out << "<null>"));
  out << ", " << "starting_lcn="; (__isset.starting_lcn ? (out << to_string(starting_lcn)) : (out << "<null>"));
  out << ", " << "total_number_of_clusters="; (__isset.total_number_of_clusters ? (out << to_string(total_number_of_clusters)) : (out << "<null>"));
  out << ", " << "bit_map="; (__isset.bit_map ? (out << to_string(bit_map)) : (out << "<null>"));
  out << ", " << "compressed="; (__isset.compressed ? (out << to_string(compressed)) : (out << "<null>"));
  out << ")";
}


replication_result::~replication_result() throw() {
}


void replication_result::__set_result(const std::string& val) {
  this->result = val;
__isset.result = true;
}

void replication_result::__set_compressed(const bool val) {
  this->compressed = val;
__isset.compressed = true;
}

uint32_t replication_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->compressed);
          this->__isset.compressed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t replication_result::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("replication_result");

  if (this->__isset.result) {
    xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeBinary(this->result);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.compressed) {
    xfer += oprot->writeFieldBegin("compressed", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->compressed);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(replication_result &a, replication_result &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.compressed, b.compressed);
  swap(a.__isset, b.__isset);
}

replication_result::replication_result(const replication_result& other132) {
  result = other132.result;
  compressed = other132.compressed;
  __isset = other132.__isset;
}
replication_result& replication_result::operator=(const replication_result& other133) {
  result = other133.result;
  compressed = other133.compressed;
  __isset = other133.__isset;
  return *this;
}
void replication_result::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "replication_result(";
  out << "result="; (__isset.result ? (out << to_string(result)) : (out << "<null>"));
  out << ", " << "compressed="; (__isset.compressed ? (out << to_string(compressed)) : (out << "<null>"));
  out << ")";
}


delete_snapshot_result::~delete_snapshot_result() throw() {
}


void delete_snapshot_result::__set_code(const int32_t val) {
  this->code = val;
__isset.code = true;
}

void delete_snapshot_result::__set_deleted_snapshots(const int32_t val) {
  this->deleted_snapshots = val;
__isset.deleted_snapshots = true;
}

void delete_snapshot_result::__set_non_deleted_snapshot_id(const std::string& val) {
  this->non_deleted_snapshot_id = val;
__isset.non_deleted_snapshot_id = true;
}

uint32_t delete_snapshot_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->code);
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->deleted_snapshots);
          this->__isset.deleted_snapshots = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->non_deleted_snapshot_id);
          this->__isset.non_deleted_snapshot_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t delete_snapshot_result::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("delete_snapshot_result");

  if (this->__isset.code) {
    xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->code);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.deleted_snapshots) {
    xfer += oprot->writeFieldBegin("deleted_snapshots", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->deleted_snapshots);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.non_deleted_snapshot_id) {
    xfer += oprot->writeFieldBegin("non_deleted_snapshot_id", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->non_deleted_snapshot_id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(delete_snapshot_result &a, delete_snapshot_result &b) {
  using ::std::swap;
  swap(a.code, b.code);
  swap(a.deleted_snapshots, b.deleted_snapshots);
  swap(a.non_deleted_snapshot_id, b.non_deleted_snapshot_id);
  swap(a.__isset, b.__isset);
}

delete_snapshot_result::delete_snapshot_result(const delete_snapshot_result& other134) {
  code = other134.code;
  deleted_snapshots = other134.deleted_snapshots;
  non_deleted_snapshot_id = other134.non_deleted_snapshot_id;
  __isset = other134.__isset;
}
delete_snapshot_result& delete_snapshot_result::operator=(const delete_snapshot_result& other135) {
  code = other135.code;
  deleted_snapshots = other135.deleted_snapshots;
  non_deleted_snapshot_id = other135.non_deleted_snapshot_id;
  __isset = other135.__isset;
  return *this;
}
void delete_snapshot_result::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "delete_snapshot_result(";
  out << "code="; (__isset.code ? (out << to_string(code)) : (out << "<null>"));
  out << ", " << "deleted_snapshots="; (__isset.deleted_snapshots ? (out << to_string(deleted_snapshots)) : (out << "<null>"));
  out << ", " << "non_deleted_snapshot_id="; (__isset.non_deleted_snapshot_id ? (out << to_string(non_deleted_snapshot_id)) : (out << "<null>"));
  out << ")";
}


physical_machine_info::~physical_machine_info() throw() {
}


void physical_machine_info::__set_architecture(const std::string& val) {
  this->architecture = val;
__isset.architecture = true;
}

void physical_machine_info::__set_client_id(const std::string& val) {
  this->client_id = val;
__isset.client_id = true;
}

void physical_machine_info::__set_client_name(const std::string& val) {
  this->client_name = val;
__isset.client_name = true;
}

void physical_machine_info::__set_domain(const std::string& val) {
  this->domain = val;
__isset.domain = true;
}

void physical_machine_info::__set_hal(const std::string& val) {
  this->hal = val;
__isset.hal = true;
}

void physical_machine_info::__set_initiator_name(const std::string& val) {
  this->initiator_name = val;
__isset.initiator_name = true;
}

void physical_machine_info::__set_is_oem(const bool val) {
  this->is_oem = val;
__isset.is_oem = true;
}

void physical_machine_info::__set_logical_processors(const int16_t val) {
  this->logical_processors = val;
__isset.logical_processors = true;
}

void physical_machine_info::__set_machine_id(const std::string& val) {
  this->machine_id = val;
__isset.machine_id = true;
}

void physical_machine_info::__set_manufacturer(const std::string& val) {
  this->manufacturer = val;
__isset.manufacturer = true;
}

void physical_machine_info::__set_os_name(const std::string& val) {
  this->os_name = val;
__isset.os_name = true;
}

void physical_machine_info::__set_os_type(const int32_t val) {
  this->os_type = val;
__isset.os_type = true;
}

void physical_machine_info::__set_os_system_info(const std::string& val) {
  this->os_system_info = val;
__isset.os_system_info = true;
}

void physical_machine_info::__set_physical_memory(const int64_t val) {
  this->physical_memory = val;
__isset.physical_memory = true;
}

void physical_machine_info::__set_processors(const int16_t val) {
  this->processors = val;
__isset.processors = true;
}

void physical_machine_info::__set_role(const int32_t val) {
  this->role = val;
__isset.role = true;
}

void physical_machine_info::__set_system_model(const std::string& val) {
  this->system_model = val;
__isset.system_model = true;
}

void physical_machine_info::__set_system_root(const std::string& val) {
  this->system_root = val;
__isset.system_root = true;
}

void physical_machine_info::__set_workgroup(const std::string& val) {
  this->workgroup = val;
__isset.workgroup = true;
}

void physical_machine_info::__set_os_version(const os_version_info& val) {
  this->os_version = val;
__isset.os_version = true;
}

void physical_machine_info::__set_cluster_infos(const std::set<cluster_info> & val) {
  this->cluster_infos = val;
__isset.cluster_infos = true;
}

void physical_machine_info::__set_disk_infos(const std::set<disk_info> & val) {
  this->disk_infos = val;
__isset.disk_infos = true;
}

void physical_machine_info::__set_network_infos(const std::set<network_info> & val) {
  this->network_infos = val;
__isset.network_infos = true;
}

void physical_machine_info::__set_partition_infos(const std::set<partition_info> & val) {
  this->partition_infos = val;
__isset.partition_infos = true;
}

void physical_machine_info::__set_volume_infos(const std::set<volume_info> & val) {
  this->volume_infos = val;
__isset.volume_infos = true;
}

void physical_machine_info::__set_is_vcbt_driver_installed(const bool val) {
  this->is_vcbt_driver_installed = val;
__isset.is_vcbt_driver_installed = true;
}

void physical_machine_info::__set_is_vcbt_enabled(const bool val) {
  this->is_vcbt_enabled = val;
__isset.is_vcbt_enabled = true;
}

void physical_machine_info::__set_current_vcbt_version(const std::string& val) {
  this->current_vcbt_version = val;
__isset.current_vcbt_version = true;
}

void physical_machine_info::__set_installed_vcbt_version(const std::string& val) {
  this->installed_vcbt_version = val;
__isset.installed_vcbt_version = true;
}

void physical_machine_info::__set_is_winpe(const bool val) {
  this->is_winpe = val;
__isset.is_winpe = true;
}

uint32_t physical_machine_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->architecture);
          this->__isset.architecture = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->client_id);
          this->__isset.client_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->client_name);
          this->__isset.client_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->domain);
          this->__isset.domain = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hal);
          this->__isset.hal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->initiator_name);
          this->__isset.initiator_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_oem);
          this->__isset.is_oem = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->logical_processors);
          this->__isset.logical_processors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->machine_id);
          this->__isset.machine_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->manufacturer);
          this->__isset.manufacturer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->os_name);
          this->__isset.os_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->os_type);
          this->__isset.os_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->os_system_info);
          this->__isset.os_system_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->physical_memory);
          this->__isset.physical_memory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->processors);
          this->__isset.processors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->role);
          this->__isset.role = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->system_model);
          this->__isset.system_model = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->system_root);
          this->__isset.system_root = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->workgroup);
          this->__isset.workgroup = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->os_version.read(iprot);
          this->__isset.os_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->cluster_infos.clear();
            uint32_t _size136;
            ::apache::thrift::protocol::TType _etype139;
            xfer += iprot->readSetBegin(_etype139, _size136);
            uint32_t _i140;
            for (_i140 = 0; _i140 < _size136; ++_i140)
            {
              cluster_info _elem141;
              xfer += _elem141.read(iprot);
              this->cluster_infos.insert(_elem141);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.cluster_infos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->disk_infos.clear();
            uint32_t _size142;
            ::apache::thrift::protocol::TType _etype145;
            xfer += iprot->readSetBegin(_etype145, _size142);
            uint32_t _i146;
            for (_i146 = 0; _i146 < _size142; ++_i146)
            {
              disk_info _elem147;
              xfer += _elem147.read(iprot);
              this->disk_infos.insert(_elem147);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.disk_infos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->network_infos.clear();
            uint32_t _size148;
            ::apache::thrift::protocol::TType _etype151;
            xfer += iprot->readSetBegin(_etype151, _size148);
            uint32_t _i152;
            for (_i152 = 0; _i152 < _size148; ++_i152)
            {
              network_info _elem153;
              xfer += _elem153.read(iprot);
              this->network_infos.insert(_elem153);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.network_infos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->partition_infos.clear();
            uint32_t _size154;
            ::apache::thrift::protocol::TType _etype157;
            xfer += iprot->readSetBegin(_etype157, _size154);
            uint32_t _i158;
            for (_i158 = 0; _i158 < _size154; ++_i158)
            {
              partition_info _elem159;
              xfer += _elem159.read(iprot);
              this->partition_infos.insert(_elem159);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.partition_infos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->volume_infos.clear();
            uint32_t _size160;
            ::apache::thrift::protocol::TType _etype163;
            xfer += iprot->readSetBegin(_etype163, _size160);
            uint32_t _i164;
            for (_i164 = 0; _i164 < _size160; ++_i164)
            {
              volume_info _elem165;
              xfer += _elem165.read(iprot);
              this->volume_infos.insert(_elem165);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.volume_infos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 26:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_vcbt_driver_installed);
          this->__isset.is_vcbt_driver_installed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 27:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_vcbt_enabled);
          this->__isset.is_vcbt_enabled = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 28:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->current_vcbt_version);
          this->__isset.current_vcbt_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 29:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->installed_vcbt_version);
          this->__isset.installed_vcbt_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_winpe);
          this->__isset.is_winpe = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_machine_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_machine_info");

  if (this->__isset.architecture) {
    xfer += oprot->writeFieldBegin("architecture", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->architecture);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.client_id) {
    xfer += oprot->writeFieldBegin("client_id", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->client_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.client_name) {
    xfer += oprot->writeFieldBegin("client_name", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->client_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.domain) {
    xfer += oprot->writeFieldBegin("domain", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->domain);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.hal) {
    xfer += oprot->writeFieldBegin("hal", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->hal);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.initiator_name) {
    xfer += oprot->writeFieldBegin("initiator_name", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->initiator_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_oem) {
    xfer += oprot->writeFieldBegin("is_oem", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->is_oem);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.logical_processors) {
    xfer += oprot->writeFieldBegin("logical_processors", ::apache::thrift::protocol::T_I16, 8);
    xfer += oprot->writeI16(this->logical_processors);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.machine_id) {
    xfer += oprot->writeFieldBegin("machine_id", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->machine_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.manufacturer) {
    xfer += oprot->writeFieldBegin("manufacturer", ::apache::thrift::protocol::T_STRING, 10);
    xfer += oprot->writeString(this->manufacturer);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.os_name) {
    xfer += oprot->writeFieldBegin("os_name", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeString(this->os_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.os_type) {
    xfer += oprot->writeFieldBegin("os_type", ::apache::thrift::protocol::T_I32, 12);
    xfer += oprot->writeI32(this->os_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.os_system_info) {
    xfer += oprot->writeFieldBegin("os_system_info", ::apache::thrift::protocol::T_STRING, 13);
    xfer += oprot->writeString(this->os_system_info);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.physical_memory) {
    xfer += oprot->writeFieldBegin("physical_memory", ::apache::thrift::protocol::T_I64, 14);
    xfer += oprot->writeI64(this->physical_memory);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.processors) {
    xfer += oprot->writeFieldBegin("processors", ::apache::thrift::protocol::T_I16, 15);
    xfer += oprot->writeI16(this->processors);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.role) {
    xfer += oprot->writeFieldBegin("role", ::apache::thrift::protocol::T_I32, 16);
    xfer += oprot->writeI32(this->role);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.system_model) {
    xfer += oprot->writeFieldBegin("system_model", ::apache::thrift::protocol::T_STRING, 17);
    xfer += oprot->writeString(this->system_model);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.system_root) {
    xfer += oprot->writeFieldBegin("system_root", ::apache::thrift::protocol::T_STRING, 18);
    xfer += oprot->writeString(this->system_root);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.workgroup) {
    xfer += oprot->writeFieldBegin("workgroup", ::apache::thrift::protocol::T_STRING, 19);
    xfer += oprot->writeString(this->workgroup);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.os_version) {
    xfer += oprot->writeFieldBegin("os_version", ::apache::thrift::protocol::T_STRUCT, 20);
    xfer += this->os_version.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_infos) {
    xfer += oprot->writeFieldBegin("cluster_infos", ::apache::thrift::protocol::T_SET, 21);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cluster_infos.size()));
      std::set<cluster_info> ::const_iterator _iter166;
      for (_iter166 = this->cluster_infos.begin(); _iter166 != this->cluster_infos.end(); ++_iter166)
      {
        xfer += (*_iter166).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.disk_infos) {
    xfer += oprot->writeFieldBegin("disk_infos", ::apache::thrift::protocol::T_SET, 22);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->disk_infos.size()));
      std::set<disk_info> ::const_iterator _iter167;
      for (_iter167 = this->disk_infos.begin(); _iter167 != this->disk_infos.end(); ++_iter167)
      {
        xfer += (*_iter167).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.network_infos) {
    xfer += oprot->writeFieldBegin("network_infos", ::apache::thrift::protocol::T_SET, 23);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->network_infos.size()));
      std::set<network_info> ::const_iterator _iter168;
      for (_iter168 = this->network_infos.begin(); _iter168 != this->network_infos.end(); ++_iter168)
      {
        xfer += (*_iter168).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partition_infos) {
    xfer += oprot->writeFieldBegin("partition_infos", ::apache::thrift::protocol::T_SET, 24);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partition_infos.size()));
      std::set<partition_info> ::const_iterator _iter169;
      for (_iter169 = this->partition_infos.begin(); _iter169 != this->partition_infos.end(); ++_iter169)
      {
        xfer += (*_iter169).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.volume_infos) {
    xfer += oprot->writeFieldBegin("volume_infos", ::apache::thrift::protocol::T_SET, 25);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->volume_infos.size()));
      std::set<volume_info> ::const_iterator _iter170;
      for (_iter170 = this->volume_infos.begin(); _iter170 != this->volume_infos.end(); ++_iter170)
      {
        xfer += (*_iter170).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_vcbt_driver_installed) {
    xfer += oprot->writeFieldBegin("is_vcbt_driver_installed", ::apache::thrift::protocol::T_BOOL, 26);
    xfer += oprot->writeBool(this->is_vcbt_driver_installed);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_vcbt_enabled) {
    xfer += oprot->writeFieldBegin("is_vcbt_enabled", ::apache::thrift::protocol::T_BOOL, 27);
    xfer += oprot->writeBool(this->is_vcbt_enabled);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.current_vcbt_version) {
    xfer += oprot->writeFieldBegin("current_vcbt_version", ::apache::thrift::protocol::T_STRING, 28);
    xfer += oprot->writeString(this->current_vcbt_version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.installed_vcbt_version) {
    xfer += oprot->writeFieldBegin("installed_vcbt_version", ::apache::thrift::protocol::T_STRING, 29);
    xfer += oprot->writeString(this->installed_vcbt_version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_winpe) {
    xfer += oprot->writeFieldBegin("is_winpe", ::apache::thrift::protocol::T_BOOL, 30);
    xfer += oprot->writeBool(this->is_winpe);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(physical_machine_info &a, physical_machine_info &b) {
  using ::std::swap;
  swap(a.architecture, b.architecture);
  swap(a.client_id, b.client_id);
  swap(a.client_name, b.client_name);
  swap(a.domain, b.domain);
  swap(a.hal, b.hal);
  swap(a.initiator_name, b.initiator_name);
  swap(a.is_oem, b.is_oem);
  swap(a.logical_processors, b.logical_processors);
  swap(a.machine_id, b.machine_id);
  swap(a.manufacturer, b.manufacturer);
  swap(a.os_name, b.os_name);
  swap(a.os_type, b.os_type);
  swap(a.os_system_info, b.os_system_info);
  swap(a.physical_memory, b.physical_memory);
  swap(a.processors, b.processors);
  swap(a.role, b.role);
  swap(a.system_model, b.system_model);
  swap(a.system_root, b.system_root);
  swap(a.workgroup, b.workgroup);
  swap(a.os_version, b.os_version);
  swap(a.cluster_infos, b.cluster_infos);
  swap(a.disk_infos, b.disk_infos);
  swap(a.network_infos, b.network_infos);
  swap(a.partition_infos, b.partition_infos);
  swap(a.volume_infos, b.volume_infos);
  swap(a.is_vcbt_driver_installed, b.is_vcbt_driver_installed);
  swap(a.is_vcbt_enabled, b.is_vcbt_enabled);
  swap(a.current_vcbt_version, b.current_vcbt_version);
  swap(a.installed_vcbt_version, b.installed_vcbt_version);
  swap(a.is_winpe, b.is_winpe);
  swap(a.__isset, b.__isset);
}

physical_machine_info::physical_machine_info(const physical_machine_info& other171) {
  architecture = other171.architecture;
  client_id = other171.client_id;
  client_name = other171.client_name;
  domain = other171.domain;
  hal = other171.hal;
  initiator_name = other171.initiator_name;
  is_oem = other171.is_oem;
  logical_processors = other171.logical_processors;
  machine_id = other171.machine_id;
  manufacturer = other171.manufacturer;
  os_name = other171.os_name;
  os_type = other171.os_type;
  os_system_info = other171.os_system_info;
  physical_memory = other171.physical_memory;
  processors = other171.processors;
  role = other171.role;
  system_model = other171.system_model;
  system_root = other171.system_root;
  workgroup = other171.workgroup;
  os_version = other171.os_version;
  cluster_infos = other171.cluster_infos;
  disk_infos = other171.disk_infos;
  network_infos = other171.network_infos;
  partition_infos = other171.partition_infos;
  volume_infos = other171.volume_infos;
  is_vcbt_driver_installed = other171.is_vcbt_driver_installed;
  is_vcbt_enabled = other171.is_vcbt_enabled;
  current_vcbt_version = other171.current_vcbt_version;
  installed_vcbt_version = other171.installed_vcbt_version;
  is_winpe = other171.is_winpe;
  __isset = other171.__isset;
}
physical_machine_info& physical_machine_info::operator=(const physical_machine_info& other172) {
  architecture = other172.architecture;
  client_id = other172.client_id;
  client_name = other172.client_name;
  domain = other172.domain;
  hal = other172.hal;
  initiator_name = other172.initiator_name;
  is_oem = other172.is_oem;
  logical_processors = other172.logical_processors;
  machine_id = other172.machine_id;
  manufacturer = other172.manufacturer;
  os_name = other172.os_name;
  os_type = other172.os_type;
  os_system_info = other172.os_system_info;
  physical_memory = other172.physical_memory;
  processors = other172.processors;
  role = other172.role;
  system_model = other172.system_model;
  system_root = other172.system_root;
  workgroup = other172.workgroup;
  os_version = other172.os_version;
  cluster_infos = other172.cluster_infos;
  disk_infos = other172.disk_infos;
  network_infos = other172.network_infos;
  partition_infos = other172.partition_infos;
  volume_infos = other172.volume_infos;
  is_vcbt_driver_installed = other172.is_vcbt_driver_installed;
  is_vcbt_enabled = other172.is_vcbt_enabled;
  current_vcbt_version = other172.current_vcbt_version;
  installed_vcbt_version = other172.installed_vcbt_version;
  is_winpe = other172.is_winpe;
  __isset = other172.__isset;
  return *this;
}
void physical_machine_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "physical_machine_info(";
  out << "architecture="; (__isset.architecture ? (out << to_string(architecture)) : (out << "<null>"));
  out << ", " << "client_id="; (__isset.client_id ? (out << to_string(client_id)) : (out << "<null>"));
  out << ", " << "client_name="; (__isset.client_name ? (out << to_string(client_name)) : (out << "<null>"));
  out << ", " << "domain="; (__isset.domain ? (out << to_string(domain)) : (out << "<null>"));
  out << ", " << "hal="; (__isset.hal ? (out << to_string(hal)) : (out << "<null>"));
  out << ", " << "initiator_name="; (__isset.initiator_name ? (out << to_string(initiator_name)) : (out << "<null>"));
  out << ", " << "is_oem="; (__isset.is_oem ? (out << to_string(is_oem)) : (out << "<null>"));
  out << ", " << "logical_processors="; (__isset.logical_processors ? (out << to_string(logical_processors)) : (out << "<null>"));
  out << ", " << "machine_id="; (__isset.machine_id ? (out << to_string(machine_id)) : (out << "<null>"));
  out << ", " << "manufacturer="; (__isset.manufacturer ? (out << to_string(manufacturer)) : (out << "<null>"));
  out << ", " << "os_name="; (__isset.os_name ? (out << to_string(os_name)) : (out << "<null>"));
  out << ", " << "os_type="; (__isset.os_type ? (out << to_string(os_type)) : (out << "<null>"));
  out << ", " << "os_system_info="; (__isset.os_system_info ? (out << to_string(os_system_info)) : (out << "<null>"));
  out << ", " << "physical_memory="; (__isset.physical_memory ? (out << to_string(physical_memory)) : (out << "<null>"));
  out << ", " << "processors="; (__isset.processors ? (out << to_string(processors)) : (out << "<null>"));
  out << ", " << "role="; (__isset.role ? (out << to_string(role)) : (out << "<null>"));
  out << ", " << "system_model="; (__isset.system_model ? (out << to_string(system_model)) : (out << "<null>"));
  out << ", " << "system_root="; (__isset.system_root ? (out << to_string(system_root)) : (out << "<null>"));
  out << ", " << "workgroup="; (__isset.workgroup ? (out << to_string(workgroup)) : (out << "<null>"));
  out << ", " << "os_version="; (__isset.os_version ? (out << to_string(os_version)) : (out << "<null>"));
  out << ", " << "cluster_infos="; (__isset.cluster_infos ? (out << to_string(cluster_infos)) : (out << "<null>"));
  out << ", " << "disk_infos="; (__isset.disk_infos ? (out << to_string(disk_infos)) : (out << "<null>"));
  out << ", " << "network_infos="; (__isset.network_infos ? (out << to_string(network_infos)) : (out << "<null>"));
  out << ", " << "partition_infos="; (__isset.partition_infos ? (out << to_string(partition_infos)) : (out << "<null>"));
  out << ", " << "volume_infos="; (__isset.volume_infos ? (out << to_string(volume_infos)) : (out << "<null>"));
  out << ", " << "is_vcbt_driver_installed="; (__isset.is_vcbt_driver_installed ? (out << to_string(is_vcbt_driver_installed)) : (out << "<null>"));
  out << ", " << "is_vcbt_enabled="; (__isset.is_vcbt_enabled ? (out << to_string(is_vcbt_enabled)) : (out << "<null>"));
  out << ", " << "current_vcbt_version="; (__isset.current_vcbt_version ? (out << to_string(current_vcbt_version)) : (out << "<null>"));
  out << ", " << "installed_vcbt_version="; (__isset.installed_vcbt_version ? (out << to_string(installed_vcbt_version)) : (out << "<null>"));
  out << ", " << "is_winpe="; (__isset.is_winpe ? (out << to_string(is_winpe)) : (out << "<null>"));
  out << ")";
}


virtual_host::~virtual_host() throw() {
}


void virtual_host::__set_name_ref(const std::string& val) {
  this->name_ref = val;
__isset.name_ref = true;
}

void virtual_host::__set_name(const std::string& val) {
  this->name = val;
__isset.name = true;
}

void virtual_host::__set_ip_addresses(const std::vector<std::string> & val) {
  this->ip_addresses = val;
__isset.ip_addresses = true;
}

void virtual_host::__set_ip_address(const std::string& val) {
  this->ip_address = val;
__isset.ip_address = true;
}

void virtual_host::__set_product_name(const std::string& val) {
  this->product_name = val;
__isset.product_name = true;
}

void virtual_host::__set_version(const std::string& val) {
  this->version = val;
__isset.version = true;
}

void virtual_host::__set_power_state(const hv_host_power_state::type val) {
  this->power_state = val;
__isset.power_state = true;
}

void virtual_host::__set_state(const std::string& val) {
  this->state = val;
__isset.state = true;
}

void virtual_host::__set_in_maintenance_mode(const bool val) {
  this->in_maintenance_mode = val;
__isset.in_maintenance_mode = true;
}

void virtual_host::__set_vms(const std::map<std::string, std::string> & val) {
  this->vms = val;
__isset.vms = true;
}

void virtual_host::__set_datastores(const std::map<std::string, std::string> & val) {
  this->datastores = val;
__isset.datastores = true;
}

void virtual_host::__set_networks(const std::map<std::string, std::string> & val) {
  this->networks = val;
__isset.networks = true;
}

void virtual_host::__set_datacenter_name(const std::string& val) {
  this->datacenter_name = val;
__isset.datacenter_name = true;
}

void virtual_host::__set_domain_name(const std::string& val) {
  this->domain_name = val;
__isset.domain_name = true;
}

void virtual_host::__set_cluster_key(const std::string& val) {
  this->cluster_key = val;
__isset.cluster_key = true;
}

void virtual_host::__set_full_name(const std::string& val) {
  this->full_name = val;
__isset.full_name = true;
}

void virtual_host::__set_lic_features(const std::map<std::string, std::vector<std::string> > & val) {
  this->lic_features = val;
__isset.lic_features = true;
}

void virtual_host::__set_name_list(const std::vector<std::string> & val) {
  this->name_list = val;
__isset.name_list = true;
}

void virtual_host::__set_domain_name_list(const std::vector<std::string> & val) {
  this->domain_name_list = val;
__isset.domain_name_list = true;
}

void virtual_host::__set_connection_type(const hv_connection_type::type val) {
  this->connection_type = val;
__isset.connection_type = true;
}

void virtual_host::__set_virtual_center_name(const std::string& val) {
  this->virtual_center_name = val;
__isset.virtual_center_name = true;
}

void virtual_host::__set_virtual_center_version(const std::string& val) {
  this->virtual_center_version = val;
__isset.virtual_center_version = true;
}

void virtual_host::__set_uuid(const std::string& val) {
  this->uuid = val;
__isset.uuid = true;
}

uint32_t virtual_host::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name_ref);
          this->__isset.name_ref = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->ip_addresses.clear();
            uint32_t _size173;
            ::apache::thrift::protocol::TType _etype176;
            xfer += iprot->readListBegin(_etype176, _size173);
            this->ip_addresses.resize(_size173);
            uint32_t _i177;
            for (_i177 = 0; _i177 < _size173; ++_i177)
            {
              xfer += iprot->readString(this->ip_addresses[_i177]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.ip_addresses = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ip_address);
          this->__isset.ip_address = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->product_name);
          this->__isset.product_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast178;
          xfer += iprot->readI32(ecast178);
          this->power_state = (hv_host_power_state::type)ecast178;
          this->__isset.power_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->state);
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->in_maintenance_mode);
          this->__isset.in_maintenance_mode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->vms.clear();
            uint32_t _size179;
            ::apache::thrift::protocol::TType _ktype180;
            ::apache::thrift::protocol::TType _vtype181;
            xfer += iprot->readMapBegin(_ktype180, _vtype181, _size179);
            uint32_t _i183;
            for (_i183 = 0; _i183 < _size179; ++_i183)
            {
              std::string _key184;
              xfer += iprot->readString(_key184);
              std::string& _val185 = this->vms[_key184];
              xfer += iprot->readString(_val185);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.vms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->datastores.clear();
            uint32_t _size186;
            ::apache::thrift::protocol::TType _ktype187;
            ::apache::thrift::protocol::TType _vtype188;
            xfer += iprot->readMapBegin(_ktype187, _vtype188, _size186);
            uint32_t _i190;
            for (_i190 = 0; _i190 < _size186; ++_i190)
            {
              std::string _key191;
              xfer += iprot->readString(_key191);
              std::string& _val192 = this->datastores[_key191];
              xfer += iprot->readString(_val192);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.datastores = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->networks.clear();
            uint32_t _size193;
            ::apache::thrift::protocol::TType _ktype194;
            ::apache::thrift::protocol::TType _vtype195;
            xfer += iprot->readMapBegin(_ktype194, _vtype195, _size193);
            uint32_t _i197;
            for (_i197 = 0; _i197 < _size193; ++_i197)
            {
              std::string _key198;
              xfer += iprot->readString(_key198);
              std::string& _val199 = this->networks[_key198];
              xfer += iprot->readString(_val199);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.networks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->datacenter_name);
          this->__isset.datacenter_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->domain_name);
          this->__isset.domain_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cluster_key);
          this->__isset.cluster_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->full_name);
          this->__isset.full_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->lic_features.clear();
            uint32_t _size200;
            ::apache::thrift::protocol::TType _ktype201;
            ::apache::thrift::protocol::TType _vtype202;
            xfer += iprot->readMapBegin(_ktype201, _vtype202, _size200);
            uint32_t _i204;
            for (_i204 = 0; _i204 < _size200; ++_i204)
            {
              std::string _key205;
              xfer += iprot->readString(_key205);
              std::vector<std::string> & _val206 = this->lic_features[_key205];
              {
                _val206.clear();
                uint32_t _size207;
                ::apache::thrift::protocol::TType _etype210;
                xfer += iprot->readListBegin(_etype210, _size207);
                _val206.resize(_size207);
                uint32_t _i211;
                for (_i211 = 0; _i211 < _size207; ++_i211)
                {
                  xfer += iprot->readString(_val206[_i211]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.lic_features = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->name_list.clear();
            uint32_t _size212;
            ::apache::thrift::protocol::TType _etype215;
            xfer += iprot->readListBegin(_etype215, _size212);
            this->name_list.resize(_size212);
            uint32_t _i216;
            for (_i216 = 0; _i216 < _size212; ++_i216)
            {
              xfer += iprot->readString(this->name_list[_i216]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.name_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->domain_name_list.clear();
            uint32_t _size217;
            ::apache::thrift::protocol::TType _etype220;
            xfer += iprot->readListBegin(_etype220, _size217);
            this->domain_name_list.resize(_size217);
            uint32_t _i221;
            for (_i221 = 0; _i221 < _size217; ++_i221)
            {
              xfer += iprot->readString(this->domain_name_list[_i221]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.domain_name_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast222;
          xfer += iprot->readI32(ecast222);
          this->connection_type = (hv_connection_type::type)ecast222;
          this->__isset.connection_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->virtual_center_name);
          this->__isset.virtual_center_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->virtual_center_version);
          this->__isset.virtual_center_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->uuid);
          this->__isset.uuid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t virtual_host::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("virtual_host");

  if (this->__isset.name_ref) {
    xfer += oprot->writeFieldBegin("name_ref", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->name_ref);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ip_addresses) {
    xfer += oprot->writeFieldBegin("ip_addresses", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->ip_addresses.size()));
      std::vector<std::string> ::const_iterator _iter223;
      for (_iter223 = this->ip_addresses.begin(); _iter223 != this->ip_addresses.end(); ++_iter223)
      {
        xfer += oprot->writeString((*_iter223));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ip_address) {
    xfer += oprot->writeFieldBegin("ip_address", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->ip_address);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.product_name) {
    xfer += oprot->writeFieldBegin("product_name", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->product_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.version) {
    xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.power_state) {
    xfer += oprot->writeFieldBegin("power_state", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32((int32_t)this->power_state);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.state) {
    xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->state);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.in_maintenance_mode) {
    xfer += oprot->writeFieldBegin("in_maintenance_mode", ::apache::thrift::protocol::T_BOOL, 9);
    xfer += oprot->writeBool(this->in_maintenance_mode);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vms) {
    xfer += oprot->writeFieldBegin("vms", ::apache::thrift::protocol::T_MAP, 10);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->vms.size()));
      std::map<std::string, std::string> ::const_iterator _iter224;
      for (_iter224 = this->vms.begin(); _iter224 != this->vms.end(); ++_iter224)
      {
        xfer += oprot->writeString(_iter224->first);
        xfer += oprot->writeString(_iter224->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.datastores) {
    xfer += oprot->writeFieldBegin("datastores", ::apache::thrift::protocol::T_MAP, 11);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->datastores.size()));
      std::map<std::string, std::string> ::const_iterator _iter225;
      for (_iter225 = this->datastores.begin(); _iter225 != this->datastores.end(); ++_iter225)
      {
        xfer += oprot->writeString(_iter225->first);
        xfer += oprot->writeString(_iter225->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.networks) {
    xfer += oprot->writeFieldBegin("networks", ::apache::thrift::protocol::T_MAP, 12);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->networks.size()));
      std::map<std::string, std::string> ::const_iterator _iter226;
      for (_iter226 = this->networks.begin(); _iter226 != this->networks.end(); ++_iter226)
      {
        xfer += oprot->writeString(_iter226->first);
        xfer += oprot->writeString(_iter226->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.datacenter_name) {
    xfer += oprot->writeFieldBegin("datacenter_name", ::apache::thrift::protocol::T_STRING, 13);
    xfer += oprot->writeString(this->datacenter_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.domain_name) {
    xfer += oprot->writeFieldBegin("domain_name", ::apache::thrift::protocol::T_STRING, 14);
    xfer += oprot->writeString(this->domain_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_key) {
    xfer += oprot->writeFieldBegin("cluster_key", ::apache::thrift::protocol::T_STRING, 15);
    xfer += oprot->writeString(this->cluster_key);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.full_name) {
    xfer += oprot->writeFieldBegin("full_name", ::apache::thrift::protocol::T_STRING, 16);
    xfer += oprot->writeString(this->full_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lic_features) {
    xfer += oprot->writeFieldBegin("lic_features", ::apache::thrift::protocol::T_MAP, 17);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->lic_features.size()));
      std::map<std::string, std::vector<std::string> > ::const_iterator _iter227;
      for (_iter227 = this->lic_features.begin(); _iter227 != this->lic_features.end(); ++_iter227)
      {
        xfer += oprot->writeString(_iter227->first);
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter227->second.size()));
          std::vector<std::string> ::const_iterator _iter228;
          for (_iter228 = _iter227->second.begin(); _iter228 != _iter227->second.end(); ++_iter228)
          {
            xfer += oprot->writeString((*_iter228));
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.name_list) {
    xfer += oprot->writeFieldBegin("name_list", ::apache::thrift::protocol::T_LIST, 18);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->name_list.size()));
      std::vector<std::string> ::const_iterator _iter229;
      for (_iter229 = this->name_list.begin(); _iter229 != this->name_list.end(); ++_iter229)
      {
        xfer += oprot->writeString((*_iter229));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.domain_name_list) {
    xfer += oprot->writeFieldBegin("domain_name_list", ::apache::thrift::protocol::T_LIST, 19);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->domain_name_list.size()));
      std::vector<std::string> ::const_iterator _iter230;
      for (_iter230 = this->domain_name_list.begin(); _iter230 != this->domain_name_list.end(); ++_iter230)
      {
        xfer += oprot->writeString((*_iter230));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.connection_type) {
    xfer += oprot->writeFieldBegin("connection_type", ::apache::thrift::protocol::T_I32, 20);
    xfer += oprot->writeI32((int32_t)this->connection_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.virtual_center_name) {
    xfer += oprot->writeFieldBegin("virtual_center_name", ::apache::thrift::protocol::T_STRING, 21);
    xfer += oprot->writeString(this->virtual_center_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.virtual_center_version) {
    xfer += oprot->writeFieldBegin("virtual_center_version", ::apache::thrift::protocol::T_STRING, 22);
    xfer += oprot->writeString(this->virtual_center_version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.uuid) {
    xfer += oprot->writeFieldBegin("uuid", ::apache::thrift::protocol::T_STRING, 23);
    xfer += oprot->writeString(this->uuid);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(virtual_host &a, virtual_host &b) {
  using ::std::swap;
  swap(a.name_ref, b.name_ref);
  swap(a.name, b.name);
  swap(a.ip_addresses, b.ip_addresses);
  swap(a.ip_address, b.ip_address);
  swap(a.product_name, b.product_name);
  swap(a.version, b.version);
  swap(a.power_state, b.power_state);
  swap(a.state, b.state);
  swap(a.in_maintenance_mode, b.in_maintenance_mode);
  swap(a.vms, b.vms);
  swap(a.datastores, b.datastores);
  swap(a.networks, b.networks);
  swap(a.datacenter_name, b.datacenter_name);
  swap(a.domain_name, b.domain_name);
  swap(a.cluster_key, b.cluster_key);
  swap(a.full_name, b.full_name);
  swap(a.lic_features, b.lic_features);
  swap(a.name_list, b.name_list);
  swap(a.domain_name_list, b.domain_name_list);
  swap(a.connection_type, b.connection_type);
  swap(a.virtual_center_name, b.virtual_center_name);
  swap(a.virtual_center_version, b.virtual_center_version);
  swap(a.uuid, b.uuid);
  swap(a.__isset, b.__isset);
}

virtual_host::virtual_host(const virtual_host& other231) {
  name_ref = other231.name_ref;
  name = other231.name;
  ip_addresses = other231.ip_addresses;
  ip_address = other231.ip_address;
  product_name = other231.product_name;
  version = other231.version;
  power_state = other231.power_state;
  state = other231.state;
  in_maintenance_mode = other231.in_maintenance_mode;
  vms = other231.vms;
  datastores = other231.datastores;
  networks = other231.networks;
  datacenter_name = other231.datacenter_name;
  domain_name = other231.domain_name;
  cluster_key = other231.cluster_key;
  full_name = other231.full_name;
  lic_features = other231.lic_features;
  name_list = other231.name_list;
  domain_name_list = other231.domain_name_list;
  connection_type = other231.connection_type;
  virtual_center_name = other231.virtual_center_name;
  virtual_center_version = other231.virtual_center_version;
  uuid = other231.uuid;
  __isset = other231.__isset;
}
virtual_host& virtual_host::operator=(const virtual_host& other232) {
  name_ref = other232.name_ref;
  name = other232.name;
  ip_addresses = other232.ip_addresses;
  ip_address = other232.ip_address;
  product_name = other232.product_name;
  version = other232.version;
  power_state = other232.power_state;
  state = other232.state;
  in_maintenance_mode = other232.in_maintenance_mode;
  vms = other232.vms;
  datastores = other232.datastores;
  networks = other232.networks;
  datacenter_name = other232.datacenter_name;
  domain_name = other232.domain_name;
  cluster_key = other232.cluster_key;
  full_name = other232.full_name;
  lic_features = other232.lic_features;
  name_list = other232.name_list;
  domain_name_list = other232.domain_name_list;
  connection_type = other232.connection_type;
  virtual_center_name = other232.virtual_center_name;
  virtual_center_version = other232.virtual_center_version;
  uuid = other232.uuid;
  __isset = other232.__isset;
  return *this;
}
void virtual_host::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "virtual_host(";
  out << "name_ref="; (__isset.name_ref ? (out << to_string(name_ref)) : (out << "<null>"));
  out << ", " << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
  out << ", " << "ip_addresses="; (__isset.ip_addresses ? (out << to_string(ip_addresses)) : (out << "<null>"));
  out << ", " << "ip_address="; (__isset.ip_address ? (out << to_string(ip_address)) : (out << "<null>"));
  out << ", " << "product_name="; (__isset.product_name ? (out << to_string(product_name)) : (out << "<null>"));
  out << ", " << "version="; (__isset.version ? (out << to_string(version)) : (out << "<null>"));
  out << ", " << "power_state="; (__isset.power_state ? (out << to_string(power_state)) : (out << "<null>"));
  out << ", " << "state="; (__isset.state ? (out << to_string(state)) : (out << "<null>"));
  out << ", " << "in_maintenance_mode="; (__isset.in_maintenance_mode ? (out << to_string(in_maintenance_mode)) : (out << "<null>"));
  out << ", " << "vms="; (__isset.vms ? (out << to_string(vms)) : (out << "<null>"));
  out << ", " << "datastores="; (__isset.datastores ? (out << to_string(datastores)) : (out << "<null>"));
  out << ", " << "networks="; (__isset.networks ? (out << to_string(networks)) : (out << "<null>"));
  out << ", " << "datacenter_name="; (__isset.datacenter_name ? (out << to_string(datacenter_name)) : (out << "<null>"));
  out << ", " << "domain_name="; (__isset.domain_name ? (out << to_string(domain_name)) : (out << "<null>"));
  out << ", " << "cluster_key="; (__isset.cluster_key ? (out << to_string(cluster_key)) : (out << "<null>"));
  out << ", " << "full_name="; (__isset.full_name ? (out << to_string(full_name)) : (out << "<null>"));
  out << ", " << "lic_features="; (__isset.lic_features ? (out << to_string(lic_features)) : (out << "<null>"));
  out << ", " << "name_list="; (__isset.name_list ? (out << to_string(name_list)) : (out << "<null>"));
  out << ", " << "domain_name_list="; (__isset.domain_name_list ? (out << to_string(domain_name_list)) : (out << "<null>"));
  out << ", " << "connection_type="; (__isset.connection_type ? (out << to_string(connection_type)) : (out << "<null>"));
  out << ", " << "virtual_center_name="; (__isset.virtual_center_name ? (out << to_string(virtual_center_name)) : (out << "<null>"));
  out << ", " << "virtual_center_version="; (__isset.virtual_center_version ? (out << to_string(virtual_center_version)) : (out << "<null>"));
  out << ", " << "uuid="; (__isset.uuid ? (out << to_string(uuid)) : (out << "<null>"));
  out << ")";
}


virtual_network_adapter::~virtual_network_adapter() throw() {
}


void virtual_network_adapter::__set_key(const int32_t val) {
  this->key = val;
__isset.key = true;
}

void virtual_network_adapter::__set_name(const std::string& val) {
  this->name = val;
__isset.name = true;
}

void virtual_network_adapter::__set_mac_address(const std::string& val) {
  this->mac_address = val;
__isset.mac_address = true;
}

void virtual_network_adapter::__set_network(const std::string& val) {
  this->network = val;
__isset.network = true;
}

void virtual_network_adapter::__set_port_group(const std::string& val) {
  this->port_group = val;
__isset.port_group = true;
}

void virtual_network_adapter::__set_type(const std::string& val) {
  this->type = val;
__isset.type = true;
}

void virtual_network_adapter::__set_is_connected(const bool val) {
  this->is_connected = val;
__isset.is_connected = true;
}

void virtual_network_adapter::__set_is_start_connected(const bool val) {
  this->is_start_connected = val;
__isset.is_start_connected = true;
}

void virtual_network_adapter::__set_is_allow_guest_control(const bool val) {
  this->is_allow_guest_control = val;
__isset.is_allow_guest_control = true;
}

void virtual_network_adapter::__set_address_type(const std::string& val) {
  this->address_type = val;
__isset.address_type = true;
}

void virtual_network_adapter::__set_ip_addresses(const std::vector<std::string> & val) {
  this->ip_addresses = val;
__isset.ip_addresses = true;
}

uint32_t virtual_network_adapter::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->mac_address);
          this->__isset.mac_address = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->network);
          this->__isset.network = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->port_group);
          this->__isset.port_group = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_connected);
          this->__isset.is_connected = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_start_connected);
          this->__isset.is_start_connected = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_allow_guest_control);
          this->__isset.is_allow_guest_control = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->address_type);
          this->__isset.address_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->ip_addresses.clear();
            uint32_t _size233;
            ::apache::thrift::protocol::TType _etype236;
            xfer += iprot->readListBegin(_etype236, _size233);
            this->ip_addresses.resize(_size233);
            uint32_t _i237;
            for (_i237 = 0; _i237 < _size233; ++_i237)
            {
              xfer += iprot->readString(this->ip_addresses[_i237]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.ip_addresses = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t virtual_network_adapter::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("virtual_network_adapter");

  if (this->__isset.key) {
    xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->key);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mac_address) {
    xfer += oprot->writeFieldBegin("mac_address", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->mac_address);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.network) {
    xfer += oprot->writeFieldBegin("network", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->network);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.port_group) {
    xfer += oprot->writeFieldBegin("port_group", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->port_group);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.type) {
    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_connected) {
    xfer += oprot->writeFieldBegin("is_connected", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->is_connected);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_start_connected) {
    xfer += oprot->writeFieldBegin("is_start_connected", ::apache::thrift::protocol::T_BOOL, 8);
    xfer += oprot->writeBool(this->is_start_connected);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_allow_guest_control) {
    xfer += oprot->writeFieldBegin("is_allow_guest_control", ::apache::thrift::protocol::T_BOOL, 9);
    xfer += oprot->writeBool(this->is_allow_guest_control);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.address_type) {
    xfer += oprot->writeFieldBegin("address_type", ::apache::thrift::protocol::T_STRING, 10);
    xfer += oprot->writeString(this->address_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ip_addresses) {
    xfer += oprot->writeFieldBegin("ip_addresses", ::apache::thrift::protocol::T_LIST, 11);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->ip_addresses.size()));
      std::vector<std::string> ::const_iterator _iter238;
      for (_iter238 = this->ip_addresses.begin(); _iter238 != this->ip_addresses.end(); ++_iter238)
      {
        xfer += oprot->writeString((*_iter238));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(virtual_network_adapter &a, virtual_network_adapter &b) {
  using ::std::swap;
  swap(a.key, b.key);
  swap(a.name, b.name);
  swap(a.mac_address, b.mac_address);
  swap(a.network, b.network);
  swap(a.port_group, b.port_group);
  swap(a.type, b.type);
  swap(a.is_connected, b.is_connected);
  swap(a.is_start_connected, b.is_start_connected);
  swap(a.is_allow_guest_control, b.is_allow_guest_control);
  swap(a.address_type, b.address_type);
  swap(a.ip_addresses, b.ip_addresses);
  swap(a.__isset, b.__isset);
}

virtual_network_adapter::virtual_network_adapter(const virtual_network_adapter& other239) {
  key = other239.key;
  name = other239.name;
  mac_address = other239.mac_address;
  network = other239.network;
  port_group = other239.port_group;
  type = other239.type;
  is_connected = other239.is_connected;
  is_start_connected = other239.is_start_connected;
  is_allow_guest_control = other239.is_allow_guest_control;
  address_type = other239.address_type;
  ip_addresses = other239.ip_addresses;
  __isset = other239.__isset;
}
virtual_network_adapter& virtual_network_adapter::operator=(const virtual_network_adapter& other240) {
  key = other240.key;
  name = other240.name;
  mac_address = other240.mac_address;
  network = other240.network;
  port_group = other240.port_group;
  type = other240.type;
  is_connected = other240.is_connected;
  is_start_connected = other240.is_start_connected;
  is_allow_guest_control = other240.is_allow_guest_control;
  address_type = other240.address_type;
  ip_addresses = other240.ip_addresses;
  __isset = other240.__isset;
  return *this;
}
void virtual_network_adapter::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "virtual_network_adapter(";
  out << "key="; (__isset.key ? (out << to_string(key)) : (out << "<null>"));
  out << ", " << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
  out << ", " << "mac_address="; (__isset.mac_address ? (out << to_string(mac_address)) : (out << "<null>"));
  out << ", " << "network="; (__isset.network ? (out << to_string(network)) : (out << "<null>"));
  out << ", " << "port_group="; (__isset.port_group ? (out << to_string(port_group)) : (out << "<null>"));
  out << ", " << "type="; (__isset.type ? (out << to_string(type)) : (out << "<null>"));
  out << ", " << "is_connected="; (__isset.is_connected ? (out << to_string(is_connected)) : (out << "<null>"));
  out << ", " << "is_start_connected="; (__isset.is_start_connected ? (out << to_string(is_start_connected)) : (out << "<null>"));
  out << ", " << "is_allow_guest_control="; (__isset.is_allow_guest_control ? (out << to_string(is_allow_guest_control)) : (out << "<null>"));
  out << ", " << "address_type="; (__isset.address_type ? (out << to_string(address_type)) : (out << "<null>"));
  out << ", " << "ip_addresses="; (__isset.ip_addresses ? (out << to_string(ip_addresses)) : (out << "<null>"));
  out << ")";
}


virtual_machine_snapshots::~virtual_machine_snapshots() throw() {
}


void virtual_machine_snapshots::__set_name(const std::string& val) {
  this->name = val;
__isset.name = true;
}

void virtual_machine_snapshots::__set_description(const std::string& val) {
  this->description = val;
__isset.description = true;
}

void virtual_machine_snapshots::__set_create_time(const std::string& val) {
  this->create_time = val;
__isset.create_time = true;
}

void virtual_machine_snapshots::__set_quiesced(const bool val) {
  this->quiesced = val;
__isset.quiesced = true;
}

void virtual_machine_snapshots::__set_id(const int32_t val) {
  this->id = val;
__isset.id = true;
}

void virtual_machine_snapshots::__set_backup_manifest(const std::string& val) {
  this->backup_manifest = val;
__isset.backup_manifest = true;
}

void virtual_machine_snapshots::__set_replay_supported(const bool val) {
  this->replay_supported = val;
__isset.replay_supported = true;
}

void virtual_machine_snapshots::__set_child_snapshot_list(const std::vector<virtual_machine_snapshots> & val) {
  this->child_snapshot_list = val;
__isset.child_snapshot_list = true;
}

uint32_t virtual_machine_snapshots::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->description);
          this->__isset.description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->create_time);
          this->__isset.create_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->quiesced);
          this->__isset.quiesced = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->backup_manifest);
          this->__isset.backup_manifest = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->replay_supported);
          this->__isset.replay_supported = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->child_snapshot_list.clear();
            uint32_t _size241;
            ::apache::thrift::protocol::TType _etype244;
            xfer += iprot->readListBegin(_etype244, _size241);
            this->child_snapshot_list.resize(_size241);
            uint32_t _i245;
            for (_i245 = 0; _i245 < _size241; ++_i245)
            {
              xfer += this->child_snapshot_list[_i245].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.child_snapshot_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t virtual_machine_snapshots::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("virtual_machine_snapshots");

  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.description) {
    xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->description);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.create_time) {
    xfer += oprot->writeFieldBegin("create_time", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->create_time);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.quiesced) {
    xfer += oprot->writeFieldBegin("quiesced", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->quiesced);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.backup_manifest) {
    xfer += oprot->writeFieldBegin("backup_manifest", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->backup_manifest);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.replay_supported) {
    xfer += oprot->writeFieldBegin("replay_supported", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->replay_supported);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.child_snapshot_list) {
    xfer += oprot->writeFieldBegin("child_snapshot_list", ::apache::thrift::protocol::T_LIST, 8);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->child_snapshot_list.size()));
      std::vector<virtual_machine_snapshots> ::const_iterator _iter246;
      for (_iter246 = this->child_snapshot_list.begin(); _iter246 != this->child_snapshot_list.end(); ++_iter246)
      {
        xfer += (*_iter246).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(virtual_machine_snapshots &a, virtual_machine_snapshots &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.description, b.description);
  swap(a.create_time, b.create_time);
  swap(a.quiesced, b.quiesced);
  swap(a.id, b.id);
  swap(a.backup_manifest, b.backup_manifest);
  swap(a.replay_supported, b.replay_supported);
  swap(a.child_snapshot_list, b.child_snapshot_list);
  swap(a.__isset, b.__isset);
}

virtual_machine_snapshots::virtual_machine_snapshots(const virtual_machine_snapshots& other247) {
  name = other247.name;
  description = other247.description;
  create_time = other247.create_time;
  quiesced = other247.quiesced;
  id = other247.id;
  backup_manifest = other247.backup_manifest;
  replay_supported = other247.replay_supported;
  child_snapshot_list = other247.child_snapshot_list;
  __isset = other247.__isset;
}
virtual_machine_snapshots& virtual_machine_snapshots::operator=(const virtual_machine_snapshots& other248) {
  name = other248.name;
  description = other248.description;
  create_time = other248.create_time;
  quiesced = other248.quiesced;
  id = other248.id;
  backup_manifest = other248.backup_manifest;
  replay_supported = other248.replay_supported;
  child_snapshot_list = other248.child_snapshot_list;
  __isset = other248.__isset;
  return *this;
}
void virtual_machine_snapshots::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "virtual_machine_snapshots(";
  out << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
  out << ", " << "description="; (__isset.description ? (out << to_string(description)) : (out << "<null>"));
  out << ", " << "create_time="; (__isset.create_time ? (out << to_string(create_time)) : (out << "<null>"));
  out << ", " << "quiesced="; (__isset.quiesced ? (out << to_string(quiesced)) : (out << "<null>"));
  out << ", " << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "backup_manifest="; (__isset.backup_manifest ? (out << to_string(backup_manifest)) : (out << "<null>"));
  out << ", " << "replay_supported="; (__isset.replay_supported ? (out << to_string(replay_supported)) : (out << "<null>"));
  out << ", " << "child_snapshot_list="; (__isset.child_snapshot_list ? (out << to_string(child_snapshot_list)) : (out << "<null>"));
  out << ")";
}


virtual_disk_info::~virtual_disk_info() throw() {
}


void virtual_disk_info::__set_key(const std::string& val) {
  this->key = val;
__isset.key = true;
}

void virtual_disk_info::__set_name(const std::string& val) {
  this->name = val;
__isset.name = true;
}

void virtual_disk_info::__set_id(const std::string& val) {
  this->id = val;
__isset.id = true;
}

void virtual_disk_info::__set_size_kb(const int64_t val) {
  this->size_kb = val;
__isset.size_kb = true;
}

void virtual_disk_info::__set_size(const int64_t val) {
  this->size = val;
__isset.size = true;
}

uint32_t virtual_disk_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->size_kb);
          this->__isset.size_kb = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->size);
          this->__isset.size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t virtual_disk_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("virtual_disk_info");

  if (this->__isset.key) {
    xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->key);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.size_kb) {
    xfer += oprot->writeFieldBegin("size_kb", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->size_kb);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.size) {
    xfer += oprot->writeFieldBegin("size", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->size);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(virtual_disk_info &a, virtual_disk_info &b) {
  using ::std::swap;
  swap(a.key, b.key);
  swap(a.name, b.name);
  swap(a.id, b.id);
  swap(a.size_kb, b.size_kb);
  swap(a.size, b.size);
  swap(a.__isset, b.__isset);
}

virtual_disk_info::virtual_disk_info(const virtual_disk_info& other249) {
  key = other249.key;
  name = other249.name;
  id = other249.id;
  size_kb = other249.size_kb;
  size = other249.size;
  __isset = other249.__isset;
}
virtual_disk_info& virtual_disk_info::operator=(const virtual_disk_info& other250) {
  key = other250.key;
  name = other250.name;
  id = other250.id;
  size_kb = other250.size_kb;
  size = other250.size;
  __isset = other250.__isset;
  return *this;
}
void virtual_disk_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "virtual_disk_info(";
  out << "key="; (__isset.key ? (out << to_string(key)) : (out << "<null>"));
  out << ", " << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
  out << ", " << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "size_kb="; (__isset.size_kb ? (out << to_string(size_kb)) : (out << "<null>"));
  out << ", " << "size="; (__isset.size ? (out << to_string(size)) : (out << "<null>"));
  out << ")";
}


virtual_machine::~virtual_machine() throw() {
}


void virtual_machine::__set_uuid(const std::string& val) {
  this->uuid = val;
__isset.uuid = true;
}

void virtual_machine::__set_name(const std::string& val) {
  this->name = val;
__isset.name = true;
}

void virtual_machine::__set_host_key(const std::string& val) {
  this->host_key = val;
__isset.host_key = true;
}

void virtual_machine::__set_host_ip(const std::string& val) {
  this->host_ip = val;
__isset.host_ip = true;
}

void virtual_machine::__set_host_name(const std::string& val) {
  this->host_name = val;
__isset.host_name = true;
}

void virtual_machine::__set_cluster_key(const std::string& val) {
  this->cluster_key = val;
__isset.cluster_key = true;
}

void virtual_machine::__set_cluster_name(const std::string& val) {
  this->cluster_name = val;
__isset.cluster_name = true;
}

void virtual_machine::__set_annotation(const std::string& val) {
  this->annotation = val;
__isset.annotation = true;
}

void virtual_machine::__set_is_cpu_hot_add(const bool val) {
  this->is_cpu_hot_add = val;
__isset.is_cpu_hot_add = true;
}

void virtual_machine::__set_is_cpu_hot_remove(const bool val) {
  this->is_cpu_hot_remove = val;
__isset.is_cpu_hot_remove = true;
}

void virtual_machine::__set_memory_mb(const int32_t val) {
  this->memory_mb = val;
__isset.memory_mb = true;
}

void virtual_machine::__set_number_of_cpu(const int32_t val) {
  this->number_of_cpu = val;
__isset.number_of_cpu = true;
}

void virtual_machine::__set_is_template(const bool val) {
  this->is_template = val;
__isset.is_template = true;
}

void virtual_machine::__set_config_path(const std::string& val) {
  this->config_path = val;
__isset.config_path = true;
}

void virtual_machine::__set_config_path_file(const std::string& val) {
  this->config_path_file = val;
__isset.config_path_file = true;
}

void virtual_machine::__set_version(const int32_t val) {
  this->version = val;
__isset.version = true;
}

void virtual_machine::__set_power_state(const hv_vm_power_state::type val) {
  this->power_state = val;
__isset.power_state = true;
}

void virtual_machine::__set_connection_state(const hv_vm_connection_state::type val) {
  this->connection_state = val;
__isset.connection_state = true;
}

void virtual_machine::__set_tools_status(const hv_vm_tools_status::type val) {
  this->tools_status = val;
__isset.tools_status = true;
}

void virtual_machine::__set_firmware(const hv_vm_firmware::type val) {
  this->firmware = val;
__isset.firmware = true;
}

void virtual_machine::__set_guest_os_type(const hv_guest_os_type::type val) {
  this->guest_os_type = val;
__isset.guest_os_type = true;
}

void virtual_machine::__set_guest_id(const std::string& val) {
  this->guest_id = val;
__isset.guest_id = true;
}

void virtual_machine::__set_guest_os_name(const std::string& val) {
  this->guest_os_name = val;
__isset.guest_os_name = true;
}

void virtual_machine::__set_is_disk_uuid_enabled(const bool val) {
  this->is_disk_uuid_enabled = val;
__isset.is_disk_uuid_enabled = true;
}

void virtual_machine::__set_folder_path(const std::string& val) {
  this->folder_path = val;
__isset.folder_path = true;
}

void virtual_machine::__set_resource_pool_path(const std::string& val) {
  this->resource_pool_path = val;
__isset.resource_pool_path = true;
}

void virtual_machine::__set_disks(const std::vector<virtual_disk_info> & val) {
  this->disks = val;
__isset.disks = true;
}

void virtual_machine::__set_networks(const std::map<std::string, std::string> & val) {
  this->networks = val;
__isset.networks = true;
}

void virtual_machine::__set_datacenter_name(const std::string& val) {
  this->datacenter_name = val;
__isset.datacenter_name = true;
}

void virtual_machine::__set_network_adapters(const std::vector<virtual_network_adapter> & val) {
  this->network_adapters = val;
__isset.network_adapters = true;
}

void virtual_machine::__set_root_snapshot_list(const std::vector<virtual_machine_snapshots> & val) {
  this->root_snapshot_list = val;
__isset.root_snapshot_list = true;
}

void virtual_machine::__set_guest_host_name(const std::string& val) {
  this->guest_host_name = val;
__isset.guest_host_name = true;
}

void virtual_machine::__set_guest_ip(const std::string& val) {
  this->guest_ip = val;
__isset.guest_ip = true;
}

uint32_t virtual_machine::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->uuid);
          this->__isset.uuid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host_key);
          this->__isset.host_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host_ip);
          this->__isset.host_ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host_name);
          this->__isset.host_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cluster_key);
          this->__isset.cluster_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cluster_name);
          this->__isset.cluster_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->annotation);
          this->__isset.annotation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_cpu_hot_add);
          this->__isset.is_cpu_hot_add = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_cpu_hot_remove);
          this->__isset.is_cpu_hot_remove = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->memory_mb);
          this->__isset.memory_mb = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->number_of_cpu);
          this->__isset.number_of_cpu = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_template);
          this->__isset.is_template = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->config_path);
          this->__isset.config_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->config_path_file);
          this->__isset.config_path_file = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast251;
          xfer += iprot->readI32(ecast251);
          this->power_state = (hv_vm_power_state::type)ecast251;
          this->__isset.power_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast252;
          xfer += iprot->readI32(ecast252);
          this->connection_state = (hv_vm_connection_state::type)ecast252;
          this->__isset.connection_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast253;
          xfer += iprot->readI32(ecast253);
          this->tools_status = (hv_vm_tools_status::type)ecast253;
          this->__isset.tools_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast254;
          xfer += iprot->readI32(ecast254);
          this->firmware = (hv_vm_firmware::type)ecast254;
          this->__isset.firmware = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast255;
          xfer += iprot->readI32(ecast255);
          this->guest_os_type = (hv_guest_os_type::type)ecast255;
          this->__isset.guest_os_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guest_id);
          this->__isset.guest_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guest_os_name);
          this->__isset.guest_os_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_disk_uuid_enabled);
          this->__isset.is_disk_uuid_enabled = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->folder_path);
          this->__isset.folder_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 26:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resource_pool_path);
          this->__isset.resource_pool_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 27:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->disks.clear();
            uint32_t _size256;
            ::apache::thrift::protocol::TType _etype259;
            xfer += iprot->readListBegin(_etype259, _size256);
            this->disks.resize(_size256);
            uint32_t _i260;
            for (_i260 = 0; _i260 < _size256; ++_i260)
            {
              xfer += this->disks[_i260].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.disks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 28:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->networks.clear();
            uint32_t _size261;
            ::apache::thrift::protocol::TType _ktype262;
            ::apache::thrift::protocol::TType _vtype263;
            xfer += iprot->readMapBegin(_ktype262, _vtype263, _size261);
            uint32_t _i265;
            for (_i265 = 0; _i265 < _size261; ++_i265)
            {
              std::string _key266;
              xfer += iprot->readString(_key266);
              std::string& _val267 = this->networks[_key266];
              xfer += iprot->readString(_val267);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.networks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 29:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->datacenter_name);
          this->__isset.datacenter_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->network_adapters.clear();
            uint32_t _size268;
            ::apache::thrift::protocol::TType _etype271;
            xfer += iprot->readListBegin(_etype271, _size268);
            this->network_adapters.resize(_size268);
            uint32_t _i272;
            for (_i272 = 0; _i272 < _size268; ++_i272)
            {
              xfer += this->network_adapters[_i272].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.network_adapters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 31:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->root_snapshot_list.clear();
            uint32_t _size273;
            ::apache::thrift::protocol::TType _etype276;
            xfer += iprot->readListBegin(_etype276, _size273);
            this->root_snapshot_list.resize(_size273);
            uint32_t _i277;
            for (_i277 = 0; _i277 < _size273; ++_i277)
            {
              xfer += this->root_snapshot_list[_i277].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.root_snapshot_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 32:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guest_host_name);
          this->__isset.guest_host_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 33:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guest_ip);
          this->__isset.guest_ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t virtual_machine::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("virtual_machine");

  if (this->__isset.uuid) {
    xfer += oprot->writeFieldBegin("uuid", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->uuid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.host_key) {
    xfer += oprot->writeFieldBegin("host_key", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->host_key);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.host_ip) {
    xfer += oprot->writeFieldBegin("host_ip", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->host_ip);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.host_name) {
    xfer += oprot->writeFieldBegin("host_name", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->host_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_key) {
    xfer += oprot->writeFieldBegin("cluster_key", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->cluster_key);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_name) {
    xfer += oprot->writeFieldBegin("cluster_name", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->cluster_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.annotation) {
    xfer += oprot->writeFieldBegin("annotation", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->annotation);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_cpu_hot_add) {
    xfer += oprot->writeFieldBegin("is_cpu_hot_add", ::apache::thrift::protocol::T_BOOL, 9);
    xfer += oprot->writeBool(this->is_cpu_hot_add);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_cpu_hot_remove) {
    xfer += oprot->writeFieldBegin("is_cpu_hot_remove", ::apache::thrift::protocol::T_BOOL, 10);
    xfer += oprot->writeBool(this->is_cpu_hot_remove);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.memory_mb) {
    xfer += oprot->writeFieldBegin("memory_mb", ::apache::thrift::protocol::T_I32, 11);
    xfer += oprot->writeI32(this->memory_mb);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.number_of_cpu) {
    xfer += oprot->writeFieldBegin("number_of_cpu", ::apache::thrift::protocol::T_I32, 12);
    xfer += oprot->writeI32(this->number_of_cpu);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_template) {
    xfer += oprot->writeFieldBegin("is_template", ::apache::thrift::protocol::T_BOOL, 13);
    xfer += oprot->writeBool(this->is_template);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.config_path) {
    xfer += oprot->writeFieldBegin("config_path", ::apache::thrift::protocol::T_STRING, 14);
    xfer += oprot->writeString(this->config_path);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.config_path_file) {
    xfer += oprot->writeFieldBegin("config_path_file", ::apache::thrift::protocol::T_STRING, 15);
    xfer += oprot->writeString(this->config_path_file);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.version) {
    xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_I32, 16);
    xfer += oprot->writeI32(this->version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.power_state) {
    xfer += oprot->writeFieldBegin("power_state", ::apache::thrift::protocol::T_I32, 17);
    xfer += oprot->writeI32((int32_t)this->power_state);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.connection_state) {
    xfer += oprot->writeFieldBegin("connection_state", ::apache::thrift::protocol::T_I32, 18);
    xfer += oprot->writeI32((int32_t)this->connection_state);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tools_status) {
    xfer += oprot->writeFieldBegin("tools_status", ::apache::thrift::protocol::T_I32, 19);
    xfer += oprot->writeI32((int32_t)this->tools_status);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.firmware) {
    xfer += oprot->writeFieldBegin("firmware", ::apache::thrift::protocol::T_I32, 20);
    xfer += oprot->writeI32((int32_t)this->firmware);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.guest_os_type) {
    xfer += oprot->writeFieldBegin("guest_os_type", ::apache::thrift::protocol::T_I32, 21);
    xfer += oprot->writeI32((int32_t)this->guest_os_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.guest_id) {
    xfer += oprot->writeFieldBegin("guest_id", ::apache::thrift::protocol::T_STRING, 22);
    xfer += oprot->writeString(this->guest_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.guest_os_name) {
    xfer += oprot->writeFieldBegin("guest_os_name", ::apache::thrift::protocol::T_STRING, 23);
    xfer += oprot->writeString(this->guest_os_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_disk_uuid_enabled) {
    xfer += oprot->writeFieldBegin("is_disk_uuid_enabled", ::apache::thrift::protocol::T_BOOL, 24);
    xfer += oprot->writeBool(this->is_disk_uuid_enabled);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.folder_path) {
    xfer += oprot->writeFieldBegin("folder_path", ::apache::thrift::protocol::T_STRING, 25);
    xfer += oprot->writeString(this->folder_path);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.resource_pool_path) {
    xfer += oprot->writeFieldBegin("resource_pool_path", ::apache::thrift::protocol::T_STRING, 26);
    xfer += oprot->writeString(this->resource_pool_path);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.disks) {
    xfer += oprot->writeFieldBegin("disks", ::apache::thrift::protocol::T_LIST, 27);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->disks.size()));
      std::vector<virtual_disk_info> ::const_iterator _iter278;
      for (_iter278 = this->disks.begin(); _iter278 != this->disks.end(); ++_iter278)
      {
        xfer += (*_iter278).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.networks) {
    xfer += oprot->writeFieldBegin("networks", ::apache::thrift::protocol::T_MAP, 28);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->networks.size()));
      std::map<std::string, std::string> ::const_iterator _iter279;
      for (_iter279 = this->networks.begin(); _iter279 != this->networks.end(); ++_iter279)
      {
        xfer += oprot->writeString(_iter279->first);
        xfer += oprot->writeString(_iter279->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.datacenter_name) {
    xfer += oprot->writeFieldBegin("datacenter_name", ::apache::thrift::protocol::T_STRING, 29);
    xfer += oprot->writeString(this->datacenter_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.network_adapters) {
    xfer += oprot->writeFieldBegin("network_adapters", ::apache::thrift::protocol::T_LIST, 30);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->network_adapters.size()));
      std::vector<virtual_network_adapter> ::const_iterator _iter280;
      for (_iter280 = this->network_adapters.begin(); _iter280 != this->network_adapters.end(); ++_iter280)
      {
        xfer += (*_iter280).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.root_snapshot_list) {
    xfer += oprot->writeFieldBegin("root_snapshot_list", ::apache::thrift::protocol::T_LIST, 31);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->root_snapshot_list.size()));
      std::vector<virtual_machine_snapshots> ::const_iterator _iter281;
      for (_iter281 = this->root_snapshot_list.begin(); _iter281 != this->root_snapshot_list.end(); ++_iter281)
      {
        xfer += (*_iter281).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.guest_host_name) {
    xfer += oprot->writeFieldBegin("guest_host_name", ::apache::thrift::protocol::T_STRING, 32);
    xfer += oprot->writeString(this->guest_host_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.guest_ip) {
    xfer += oprot->writeFieldBegin("guest_ip", ::apache::thrift::protocol::T_STRING, 33);
    xfer += oprot->writeString(this->guest_ip);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(virtual_machine &a, virtual_machine &b) {
  using ::std::swap;
  swap(a.uuid, b.uuid);
  swap(a.name, b.name);
  swap(a.host_key, b.host_key);
  swap(a.host_ip, b.host_ip);
  swap(a.host_name, b.host_name);
  swap(a.cluster_key, b.cluster_key);
  swap(a.cluster_name, b.cluster_name);
  swap(a.annotation, b.annotation);
  swap(a.is_cpu_hot_add, b.is_cpu_hot_add);
  swap(a.is_cpu_hot_remove, b.is_cpu_hot_remove);
  swap(a.memory_mb, b.memory_mb);
  swap(a.number_of_cpu, b.number_of_cpu);
  swap(a.is_template, b.is_template);
  swap(a.config_path, b.config_path);
  swap(a.config_path_file, b.config_path_file);
  swap(a.version, b.version);
  swap(a.power_state, b.power_state);
  swap(a.connection_state, b.connection_state);
  swap(a.tools_status, b.tools_status);
  swap(a.firmware, b.firmware);
  swap(a.guest_os_type, b.guest_os_type);
  swap(a.guest_id, b.guest_id);
  swap(a.guest_os_name, b.guest_os_name);
  swap(a.is_disk_uuid_enabled, b.is_disk_uuid_enabled);
  swap(a.folder_path, b.folder_path);
  swap(a.resource_pool_path, b.resource_pool_path);
  swap(a.disks, b.disks);
  swap(a.networks, b.networks);
  swap(a.datacenter_name, b.datacenter_name);
  swap(a.network_adapters, b.network_adapters);
  swap(a.root_snapshot_list, b.root_snapshot_list);
  swap(a.guest_host_name, b.guest_host_name);
  swap(a.guest_ip, b.guest_ip);
  swap(a.__isset, b.__isset);
}

virtual_machine::virtual_machine(const virtual_machine& other282) {
  uuid = other282.uuid;
  name = other282.name;
  host_key = other282.host_key;
  host_ip = other282.host_ip;
  host_name = other282.host_name;
  cluster_key = other282.cluster_key;
  cluster_name = other282.cluster_name;
  annotation = other282.annotation;
  is_cpu_hot_add = other282.is_cpu_hot_add;
  is_cpu_hot_remove = other282.is_cpu_hot_remove;
  memory_mb = other282.memory_mb;
  number_of_cpu = other282.number_of_cpu;
  is_template = other282.is_template;
  config_path = other282.config_path;
  config_path_file = other282.config_path_file;
  version = other282.version;
  power_state = other282.power_state;
  connection_state = other282.connection_state;
  tools_status = other282.tools_status;
  firmware = other282.firmware;
  guest_os_type = other282.guest_os_type;
  guest_id = other282.guest_id;
  guest_os_name = other282.guest_os_name;
  is_disk_uuid_enabled = other282.is_disk_uuid_enabled;
  folder_path = other282.folder_path;
  resource_pool_path = other282.resource_pool_path;
  disks = other282.disks;
  networks = other282.networks;
  datacenter_name = other282.datacenter_name;
  network_adapters = other282.network_adapters;
  root_snapshot_list = other282.root_snapshot_list;
  guest_host_name = other282.guest_host_name;
  guest_ip = other282.guest_ip;
  __isset = other282.__isset;
}
virtual_machine& virtual_machine::operator=(const virtual_machine& other283) {
  uuid = other283.uuid;
  name = other283.name;
  host_key = other283.host_key;
  host_ip = other283.host_ip;
  host_name = other283.host_name;
  cluster_key = other283.cluster_key;
  cluster_name = other283.cluster_name;
  annotation = other283.annotation;
  is_cpu_hot_add = other283.is_cpu_hot_add;
  is_cpu_hot_remove = other283.is_cpu_hot_remove;
  memory_mb = other283.memory_mb;
  number_of_cpu = other283.number_of_cpu;
  is_template = other283.is_template;
  config_path = other283.config_path;
  config_path_file = other283.config_path_file;
  version = other283.version;
  power_state = other283.power_state;
  connection_state = other283.connection_state;
  tools_status = other283.tools_status;
  firmware = other283.firmware;
  guest_os_type = other283.guest_os_type;
  guest_id = other283.guest_id;
  guest_os_name = other283.guest_os_name;
  is_disk_uuid_enabled = other283.is_disk_uuid_enabled;
  folder_path = other283.folder_path;
  resource_pool_path = other283.resource_pool_path;
  disks = other283.disks;
  networks = other283.networks;
  datacenter_name = other283.datacenter_name;
  network_adapters = other283.network_adapters;
  root_snapshot_list = other283.root_snapshot_list;
  guest_host_name = other283.guest_host_name;
  guest_ip = other283.guest_ip;
  __isset = other283.__isset;
  return *this;
}
void virtual_machine::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "virtual_machine(";
  out << "uuid="; (__isset.uuid ? (out << to_string(uuid)) : (out << "<null>"));
  out << ", " << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
  out << ", " << "host_key="; (__isset.host_key ? (out << to_string(host_key)) : (out << "<null>"));
  out << ", " << "host_ip="; (__isset.host_ip ? (out << to_string(host_ip)) : (out << "<null>"));
  out << ", " << "host_name="; (__isset.host_name ? (out << to_string(host_name)) : (out << "<null>"));
  out << ", " << "cluster_key="; (__isset.cluster_key ? (out << to_string(cluster_key)) : (out << "<null>"));
  out << ", " << "cluster_name="; (__isset.cluster_name ? (out << to_string(cluster_name)) : (out << "<null>"));
  out << ", " << "annotation="; (__isset.annotation ? (out << to_string(annotation)) : (out << "<null>"));
  out << ", " << "is_cpu_hot_add="; (__isset.is_cpu_hot_add ? (out << to_string(is_cpu_hot_add)) : (out << "<null>"));
  out << ", " << "is_cpu_hot_remove="; (__isset.is_cpu_hot_remove ? (out << to_string(is_cpu_hot_remove)) : (out << "<null>"));
  out << ", " << "memory_mb="; (__isset.memory_mb ? (out << to_string(memory_mb)) : (out << "<null>"));
  out << ", " << "number_of_cpu="; (__isset.number_of_cpu ? (out << to_string(number_of_cpu)) : (out << "<null>"));
  out << ", " << "is_template="; (__isset.is_template ? (out << to_string(is_template)) : (out << "<null>"));
  out << ", " << "config_path="; (__isset.config_path ? (out << to_string(config_path)) : (out << "<null>"));
  out << ", " << "config_path_file="; (__isset.config_path_file ? (out << to_string(config_path_file)) : (out << "<null>"));
  out << ", " << "version="; (__isset.version ? (out << to_string(version)) : (out << "<null>"));
  out << ", " << "power_state="; (__isset.power_state ? (out << to_string(power_state)) : (out << "<null>"));
  out << ", " << "connection_state="; (__isset.connection_state ? (out << to_string(connection_state)) : (out << "<null>"));
  out << ", " << "tools_status="; (__isset.tools_status ? (out << to_string(tools_status)) : (out << "<null>"));
  out << ", " << "firmware="; (__isset.firmware ? (out << to_string(firmware)) : (out << "<null>"));
  out << ", " << "guest_os_type="; (__isset.guest_os_type ? (out << to_string(guest_os_type)) : (out << "<null>"));
  out << ", " << "guest_id="; (__isset.guest_id ? (out << to_string(guest_id)) : (out << "<null>"));
  out << ", " << "guest_os_name="; (__isset.guest_os_name ? (out << to_string(guest_os_name)) : (out << "<null>"));
  out << ", " << "is_disk_uuid_enabled="; (__isset.is_disk_uuid_enabled ? (out << to_string(is_disk_uuid_enabled)) : (out << "<null>"));
  out << ", " << "folder_path="; (__isset.folder_path ? (out << to_string(folder_path)) : (out << "<null>"));
  out << ", " << "resource_pool_path="; (__isset.resource_pool_path ? (out << to_string(resource_pool_path)) : (out << "<null>"));
  out << ", " << "disks="; (__isset.disks ? (out << to_string(disks)) : (out << "<null>"));
  out << ", " << "networks="; (__isset.networks ? (out << to_string(networks)) : (out << "<null>"));
  out << ", " << "datacenter_name="; (__isset.datacenter_name ? (out << to_string(datacenter_name)) : (out << "<null>"));
  out << ", " << "network_adapters="; (__isset.network_adapters ? (out << to_string(network_adapters)) : (out << "<null>"));
  out << ", " << "root_snapshot_list="; (__isset.root_snapshot_list ? (out << to_string(root_snapshot_list)) : (out << "<null>"));
  out << ", " << "guest_host_name="; (__isset.guest_host_name ? (out << to_string(guest_host_name)) : (out << "<null>"));
  out << ", " << "guest_ip="; (__isset.guest_ip ? (out << to_string(guest_ip)) : (out << "<null>"));
  out << ")";
}


invalid_operation::~invalid_operation() throw() {
}


void invalid_operation::__set_what_op(const int32_t val) {
  this->what_op = val;
}

void invalid_operation::__set_why(const std::string& val) {
  this->why = val;
}

void invalid_operation::__set_format(const std::string& val) {
  this->format = val;
__isset.format = true;
}

void invalid_operation::__set_arguments(const std::vector<std::string> & val) {
  this->arguments = val;
__isset.arguments = true;
}

uint32_t invalid_operation::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->what_op);
          this->__isset.what_op = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->why);
          this->__isset.why = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->format);
          this->__isset.format = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->arguments.clear();
            uint32_t _size284;
            ::apache::thrift::protocol::TType _etype287;
            xfer += iprot->readListBegin(_etype287, _size284);
            this->arguments.resize(_size284);
            uint32_t _i288;
            for (_i288 = 0; _i288 < _size284; ++_i288)
            {
              xfer += iprot->readString(this->arguments[_i288]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.arguments = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t invalid_operation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("invalid_operation");

  xfer += oprot->writeFieldBegin("what_op", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->what_op);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("why", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->why);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.format) {
    xfer += oprot->writeFieldBegin("format", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->format);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.arguments) {
    xfer += oprot->writeFieldBegin("arguments", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->arguments.size()));
      std::vector<std::string> ::const_iterator _iter289;
      for (_iter289 = this->arguments.begin(); _iter289 != this->arguments.end(); ++_iter289)
      {
        xfer += oprot->writeString((*_iter289));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(invalid_operation &a, invalid_operation &b) {
  using ::std::swap;
  swap(a.what_op, b.what_op);
  swap(a.why, b.why);
  swap(a.format, b.format);
  swap(a.arguments, b.arguments);
  swap(a.__isset, b.__isset);
}

invalid_operation::invalid_operation(const invalid_operation& other290) : TException() {
  what_op = other290.what_op;
  why = other290.why;
  format = other290.format;
  arguments = other290.arguments;
  __isset = other290.__isset;
}
invalid_operation& invalid_operation::operator=(const invalid_operation& other291) {
  what_op = other291.what_op;
  why = other291.why;
  format = other291.format;
  arguments = other291.arguments;
  __isset = other291.__isset;
  return *this;
}
void invalid_operation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "invalid_operation(";
  out << "what_op=" << to_string(what_op);
  out << ", " << "why=" << to_string(why);
  out << ", " << "format="; (__isset.format ? (out << to_string(format)) : (out << "<null>"));
  out << ", " << "arguments="; (__isset.arguments ? (out << to_string(arguments)) : (out << "<null>"));
  out << ")";
}

const char* invalid_operation::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: invalid_operation";
  }
}


job_trigger::~job_trigger() throw() {
}


void job_trigger::__set_type(const job_trigger_type::type val) {
  this->type = val;
__isset.type = true;
}

void job_trigger::__set_start(const std::string& val) {
  this->start = val;
__isset.start = true;
}

void job_trigger::__set_finish(const std::string& val) {
  this->finish = val;
__isset.finish = true;
}

void job_trigger::__set_interval(const int32_t val) {
  this->interval = val;
__isset.interval = true;
}

void job_trigger::__set_id(const std::string& val) {
  this->id = val;
__isset.id = true;
}

void job_trigger::__set_duration(const int32_t val) {
  this->duration = val;
__isset.duration = true;
}

uint32_t job_trigger::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast292;
          xfer += iprot->readI32(ecast292);
          this->type = (job_trigger_type::type)ecast292;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->start);
          this->__isset.start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->finish);
          this->__isset.finish = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->interval);
          this->__isset.interval = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->duration);
          this->__isset.duration = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t job_trigger::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("job_trigger");

  if (this->__isset.type) {
    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32((int32_t)this->type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.start) {
    xfer += oprot->writeFieldBegin("start", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->start);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.finish) {
    xfer += oprot->writeFieldBegin("finish", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->finish);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.interval) {
    xfer += oprot->writeFieldBegin("interval", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->interval);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.duration) {
    xfer += oprot->writeFieldBegin("duration", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(this->duration);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(job_trigger &a, job_trigger &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.start, b.start);
  swap(a.finish, b.finish);
  swap(a.interval, b.interval);
  swap(a.id, b.id);
  swap(a.duration, b.duration);
  swap(a.__isset, b.__isset);
}

job_trigger::job_trigger(const job_trigger& other293) {
  type = other293.type;
  start = other293.start;
  finish = other293.finish;
  interval = other293.interval;
  id = other293.id;
  duration = other293.duration;
  __isset = other293.__isset;
}
job_trigger& job_trigger::operator=(const job_trigger& other294) {
  type = other294.type;
  start = other294.start;
  finish = other294.finish;
  interval = other294.interval;
  id = other294.id;
  duration = other294.duration;
  __isset = other294.__isset;
  return *this;
}
void job_trigger::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "job_trigger(";
  out << "type="; (__isset.type ? (out << to_string(type)) : (out << "<null>"));
  out << ", " << "start="; (__isset.start ? (out << to_string(start)) : (out << "<null>"));
  out << ", " << "finish="; (__isset.finish ? (out << to_string(finish)) : (out << "<null>"));
  out << ", " << "interval="; (__isset.interval ? (out << to_string(interval)) : (out << "<null>"));
  out << ", " << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "duration="; (__isset.duration ? (out << to_string(duration)) : (out << "<null>"));
  out << ")";
}


job_history::~job_history() throw() {
}


void job_history::__set_time(const std::string& val) {
  this->time = val;
__isset.time = true;
}

void job_history::__set_state(const job_state::type val) {
  this->state = val;
__isset.state = true;
}

void job_history::__set_error(const int32_t val) {
  this->error = val;
__isset.error = true;
}

void job_history::__set_description(const std::string& val) {
  this->description = val;
__isset.description = true;
}

void job_history::__set_format(const std::string& val) {
  this->format = val;
__isset.format = true;
}

void job_history::__set_arguments(const std::vector<std::string> & val) {
  this->arguments = val;
__isset.arguments = true;
}

void job_history::__set_is_display(const bool val) {
  this->is_display = val;
__isset.is_display = true;
}

uint32_t job_history::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->time);
          this->__isset.time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast295;
          xfer += iprot->readI32(ecast295);
          this->state = (job_state::type)ecast295;
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->error);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->description);
          this->__isset.description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->format);
          this->__isset.format = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->arguments.clear();
            uint32_t _size296;
            ::apache::thrift::protocol::TType _etype299;
            xfer += iprot->readListBegin(_etype299, _size296);
            this->arguments.resize(_size296);
            uint32_t _i300;
            for (_i300 = 0; _i300 < _size296; ++_i300)
            {
              xfer += iprot->readString(this->arguments[_i300]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.arguments = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_display);
          this->__isset.is_display = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t job_history::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("job_history");

  if (this->__isset.time) {
    xfer += oprot->writeFieldBegin("time", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->time);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.state) {
    xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32((int32_t)this->state);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->error);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.description) {
    xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->description);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.format) {
    xfer += oprot->writeFieldBegin("format", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->format);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.arguments) {
    xfer += oprot->writeFieldBegin("arguments", ::apache::thrift::protocol::T_LIST, 8);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->arguments.size()));
      std::vector<std::string> ::const_iterator _iter301;
      for (_iter301 = this->arguments.begin(); _iter301 != this->arguments.end(); ++_iter301)
      {
        xfer += oprot->writeString((*_iter301));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_display) {
    xfer += oprot->writeFieldBegin("is_display", ::apache::thrift::protocol::T_BOOL, 9);
    xfer += oprot->writeBool(this->is_display);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(job_history &a, job_history &b) {
  using ::std::swap;
  swap(a.time, b.time);
  swap(a.state, b.state);
  swap(a.error, b.error);
  swap(a.description, b.description);
  swap(a.format, b.format);
  swap(a.arguments, b.arguments);
  swap(a.is_display, b.is_display);
  swap(a.__isset, b.__isset);
}

job_history::job_history(const job_history& other302) {
  time = other302.time;
  state = other302.state;
  error = other302.error;
  description = other302.description;
  format = other302.format;
  arguments = other302.arguments;
  is_display = other302.is_display;
  __isset = other302.__isset;
}
job_history& job_history::operator=(const job_history& other303) {
  time = other303.time;
  state = other303.state;
  error = other303.error;
  description = other303.description;
  format = other303.format;
  arguments = other303.arguments;
  is_display = other303.is_display;
  __isset = other303.__isset;
  return *this;
}
void job_history::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "job_history(";
  out << "time="; (__isset.time ? (out << to_string(time)) : (out << "<null>"));
  out << ", " << "state="; (__isset.state ? (out << to_string(state)) : (out << "<null>"));
  out << ", " << "error="; (__isset.error ? (out << to_string(error)) : (out << "<null>"));
  out << ", " << "description="; (__isset.description ? (out << to_string(description)) : (out << "<null>"));
  out << ", " << "format="; (__isset.format ? (out << to_string(format)) : (out << "<null>"));
  out << ", " << "arguments="; (__isset.arguments ? (out << to_string(arguments)) : (out << "<null>"));
  out << ", " << "is_display="; (__isset.is_display ? (out << to_string(is_display)) : (out << "<null>"));
  out << ")";
}


create_job_detail::~create_job_detail() throw() {
}


void create_job_detail::__set_type(const job_type::type val) {
  this->type = val;
__isset.type = true;
}

void create_job_detail::__set_triggers(const std::vector<job_trigger> & val) {
  this->triggers = val;
__isset.triggers = true;
}

void create_job_detail::__set_management_id(const std::string& val) {
  this->management_id = val;
__isset.management_id = true;
}

void create_job_detail::__set_mgmt_addr(const std::set<std::string> & val) {
  this->mgmt_addr = val;
__isset.mgmt_addr = true;
}

void create_job_detail::__set_mgmt_port(const int32_t val) {
  this->mgmt_port = val;
__isset.mgmt_port = true;
}

void create_job_detail::__set_is_ssl(const bool val) {
  this->is_ssl = val;
__isset.is_ssl = true;
}

uint32_t create_job_detail::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast304;
          xfer += iprot->readI32(ecast304);
          this->type = (job_type::type)ecast304;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->triggers.clear();
            uint32_t _size305;
            ::apache::thrift::protocol::TType _etype308;
            xfer += iprot->readListBegin(_etype308, _size305);
            this->triggers.resize(_size305);
            uint32_t _i309;
            for (_i309 = 0; _i309 < _size305; ++_i309)
            {
              xfer += this->triggers[_i309].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.triggers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->management_id);
          this->__isset.management_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->mgmt_addr.clear();
            uint32_t _size310;
            ::apache::thrift::protocol::TType _etype313;
            xfer += iprot->readSetBegin(_etype313, _size310);
            uint32_t _i314;
            for (_i314 = 0; _i314 < _size310; ++_i314)
            {
              std::string _elem315;
              xfer += iprot->readString(_elem315);
              this->mgmt_addr.insert(_elem315);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.mgmt_addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->mgmt_port);
          this->__isset.mgmt_port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_ssl);
          this->__isset.is_ssl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t create_job_detail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("create_job_detail");

  if (this->__isset.type) {
    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32((int32_t)this->type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.triggers) {
    xfer += oprot->writeFieldBegin("triggers", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->triggers.size()));
      std::vector<job_trigger> ::const_iterator _iter316;
      for (_iter316 = this->triggers.begin(); _iter316 != this->triggers.end(); ++_iter316)
      {
        xfer += (*_iter316).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.management_id) {
    xfer += oprot->writeFieldBegin("management_id", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->management_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mgmt_addr) {
    xfer += oprot->writeFieldBegin("mgmt_addr", ::apache::thrift::protocol::T_SET, 4);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->mgmt_addr.size()));
      std::set<std::string> ::const_iterator _iter317;
      for (_iter317 = this->mgmt_addr.begin(); _iter317 != this->mgmt_addr.end(); ++_iter317)
      {
        xfer += oprot->writeString((*_iter317));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mgmt_port) {
    xfer += oprot->writeFieldBegin("mgmt_port", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->mgmt_port);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_ssl) {
    xfer += oprot->writeFieldBegin("is_ssl", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->is_ssl);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(create_job_detail &a, create_job_detail &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.triggers, b.triggers);
  swap(a.management_id, b.management_id);
  swap(a.mgmt_addr, b.mgmt_addr);
  swap(a.mgmt_port, b.mgmt_port);
  swap(a.is_ssl, b.is_ssl);
  swap(a.__isset, b.__isset);
}

create_job_detail::create_job_detail(const create_job_detail& other318) {
  type = other318.type;
  triggers = other318.triggers;
  management_id = other318.management_id;
  mgmt_addr = other318.mgmt_addr;
  mgmt_port = other318.mgmt_port;
  is_ssl = other318.is_ssl;
  __isset = other318.__isset;
}
create_job_detail& create_job_detail::operator=(const create_job_detail& other319) {
  type = other319.type;
  triggers = other319.triggers;
  management_id = other319.management_id;
  mgmt_addr = other319.mgmt_addr;
  mgmt_port = other319.mgmt_port;
  is_ssl = other319.is_ssl;
  __isset = other319.__isset;
  return *this;
}
void create_job_detail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "create_job_detail(";
  out << "type="; (__isset.type ? (out << to_string(type)) : (out << "<null>"));
  out << ", " << "triggers="; (__isset.triggers ? (out << to_string(triggers)) : (out << "<null>"));
  out << ", " << "management_id="; (__isset.management_id ? (out << to_string(management_id)) : (out << "<null>"));
  out << ", " << "mgmt_addr="; (__isset.mgmt_addr ? (out << to_string(mgmt_addr)) : (out << "<null>"));
  out << ", " << "mgmt_port="; (__isset.mgmt_port ? (out << to_string(mgmt_port)) : (out << "<null>"));
  out << ", " << "is_ssl="; (__isset.is_ssl ? (out << to_string(is_ssl)) : (out << "<null>"));
  out << ")";
}


packer_disk_image::~packer_disk_image() throw() {
}


void packer_disk_image::__set_name(const std::string& val) {
  this->name = val;
__isset.name = true;
}

void packer_disk_image::__set_parent(const std::string& val) {
  this->parent = val;
__isset.parent = true;
}

void packer_disk_image::__set_base(const std::string& val) {
  this->base = val;
__isset.base = true;
}

uint32_t packer_disk_image::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->parent);
          this->__isset.parent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->base);
          this->__isset.base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t packer_disk_image::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("packer_disk_image");

  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.parent) {
    xfer += oprot->writeFieldBegin("parent", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->parent);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.base) {
    xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->base);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(packer_disk_image &a, packer_disk_image &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.parent, b.parent);
  swap(a.base, b.base);
  swap(a.__isset, b.__isset);
}

packer_disk_image::packer_disk_image(const packer_disk_image& other320) {
  name = other320.name;
  parent = other320.parent;
  base = other320.base;
  __isset = other320.__isset;
}
packer_disk_image& packer_disk_image::operator=(const packer_disk_image& other321) {
  name = other321.name;
  parent = other321.parent;
  base = other321.base;
  __isset = other321.__isset;
  return *this;
}
void packer_disk_image::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "packer_disk_image(";
  out << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
  out << ", " << "parent="; (__isset.parent ? (out << to_string(parent)) : (out << "<null>"));
  out << ", " << "base="; (__isset.base ? (out << to_string(base)) : (out << "<null>"));
  out << ")";
}


virtual_create_packer_job_detail::~virtual_create_packer_job_detail() throw() {
}


void virtual_create_packer_job_detail::__set_disks(const std::set<std::string> & val) {
  this->disks = val;
__isset.disks = true;
}

void virtual_create_packer_job_detail::__set_host(const std::string& val) {
  this->host = val;
__isset.host = true;
}

void virtual_create_packer_job_detail::__set_addr(const std::set<std::string> & val) {
  this->addr = val;
__isset.addr = true;
}

void virtual_create_packer_job_detail::__set_username(const std::string& val) {
  this->username = val;
__isset.username = true;
}

void virtual_create_packer_job_detail::__set_password(const std::string& val) {
  this->password = val;
__isset.password = true;
}

void virtual_create_packer_job_detail::__set_virtual_machine_id(const std::string& val) {
  this->virtual_machine_id = val;
__isset.virtual_machine_id = true;
}

void virtual_create_packer_job_detail::__set_snapshot(const std::string& val) {
  this->snapshot = val;
__isset.snapshot = true;
}

void virtual_create_packer_job_detail::__set_images(const std::map<std::string, packer_disk_image> & val) {
  this->images = val;
__isset.images = true;
}

void virtual_create_packer_job_detail::__set_backup_size(const std::map<std::string, int64_t> & val) {
  this->backup_size = val;
__isset.backup_size = true;
}

void virtual_create_packer_job_detail::__set_backup_progress(const std::map<std::string, int64_t> & val) {
  this->backup_progress = val;
__isset.backup_progress = true;
}

void virtual_create_packer_job_detail::__set_backup_image_offset(const std::map<std::string, int64_t> & val) {
  this->backup_image_offset = val;
__isset.backup_image_offset = true;
}

void virtual_create_packer_job_detail::__set_previous_change_ids(const std::map<std::string, std::string> & val) {
  this->previous_change_ids = val;
__isset.previous_change_ids = true;
}

void virtual_create_packer_job_detail::__set_completed_blocks(const std::map<std::string, std::vector<io_changed_range> > & val) {
  this->completed_blocks = val;
__isset.completed_blocks = true;
}

uint32_t virtual_create_packer_job_detail::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->disks.clear();
            uint32_t _size322;
            ::apache::thrift::protocol::TType _etype325;
            xfer += iprot->readSetBegin(_etype325, _size322);
            uint32_t _i326;
            for (_i326 = 0; _i326 < _size322; ++_i326)
            {
              std::string _elem327;
              xfer += iprot->readString(_elem327);
              this->disks.insert(_elem327);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.disks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host);
          this->__isset.host = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->addr.clear();
            uint32_t _size328;
            ::apache::thrift::protocol::TType _etype331;
            xfer += iprot->readSetBegin(_etype331, _size328);
            uint32_t _i332;
            for (_i332 = 0; _i332 < _size328; ++_i332)
            {
              std::string _elem333;
              xfer += iprot->readString(_elem333);
              this->addr.insert(_elem333);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->username);
          this->__isset.username = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->password);
          this->__isset.password = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->virtual_machine_id);
          this->__isset.virtual_machine_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->snapshot);
          this->__isset.snapshot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->images.clear();
            uint32_t _size334;
            ::apache::thrift::protocol::TType _ktype335;
            ::apache::thrift::protocol::TType _vtype336;
            xfer += iprot->readMapBegin(_ktype335, _vtype336, _size334);
            uint32_t _i338;
            for (_i338 = 0; _i338 < _size334; ++_i338)
            {
              std::string _key339;
              xfer += iprot->readString(_key339);
              packer_disk_image& _val340 = this->images[_key339];
              xfer += _val340.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.images = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->backup_size.clear();
            uint32_t _size341;
            ::apache::thrift::protocol::TType _ktype342;
            ::apache::thrift::protocol::TType _vtype343;
            xfer += iprot->readMapBegin(_ktype342, _vtype343, _size341);
            uint32_t _i345;
            for (_i345 = 0; _i345 < _size341; ++_i345)
            {
              std::string _key346;
              xfer += iprot->readString(_key346);
              int64_t& _val347 = this->backup_size[_key346];
              xfer += iprot->readI64(_val347);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.backup_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->backup_progress.clear();
            uint32_t _size348;
            ::apache::thrift::protocol::TType _ktype349;
            ::apache::thrift::protocol::TType _vtype350;
            xfer += iprot->readMapBegin(_ktype349, _vtype350, _size348);
            uint32_t _i352;
            for (_i352 = 0; _i352 < _size348; ++_i352)
            {
              std::string _key353;
              xfer += iprot->readString(_key353);
              int64_t& _val354 = this->backup_progress[_key353];
              xfer += iprot->readI64(_val354);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.backup_progress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->backup_image_offset.clear();
            uint32_t _size355;
            ::apache::thrift::protocol::TType _ktype356;
            ::apache::thrift::protocol::TType _vtype357;
            xfer += iprot->readMapBegin(_ktype356, _vtype357, _size355);
            uint32_t _i359;
            for (_i359 = 0; _i359 < _size355; ++_i359)
            {
              std::string _key360;
              xfer += iprot->readString(_key360);
              int64_t& _val361 = this->backup_image_offset[_key360];
              xfer += iprot->readI64(_val361);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.backup_image_offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->previous_change_ids.clear();
            uint32_t _size362;
            ::apache::thrift::protocol::TType _ktype363;
            ::apache::thrift::protocol::TType _vtype364;
            xfer += iprot->readMapBegin(_ktype363, _vtype364, _size362);
            uint32_t _i366;
            for (_i366 = 0; _i366 < _size362; ++_i366)
            {
              std::string _key367;
              xfer += iprot->readString(_key367);
              std::string& _val368 = this->previous_change_ids[_key367];
              xfer += iprot->readString(_val368);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.previous_change_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->completed_blocks.clear();
            uint32_t _size369;
            ::apache::thrift::protocol::TType _ktype370;
            ::apache::thrift::protocol::TType _vtype371;
            xfer += iprot->readMapBegin(_ktype370, _vtype371, _size369);
            uint32_t _i373;
            for (_i373 = 0; _i373 < _size369; ++_i373)
            {
              std::string _key374;
              xfer += iprot->readString(_key374);
              std::vector<io_changed_range> & _val375 = this->completed_blocks[_key374];
              {
                _val375.clear();
                uint32_t _size376;
                ::apache::thrift::protocol::TType _etype379;
                xfer += iprot->readListBegin(_etype379, _size376);
                _val375.resize(_size376);
                uint32_t _i380;
                for (_i380 = 0; _i380 < _size376; ++_i380)
                {
                  xfer += _val375[_i380].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.completed_blocks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t virtual_create_packer_job_detail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("virtual_create_packer_job_detail");

  if (this->__isset.disks) {
    xfer += oprot->writeFieldBegin("disks", ::apache::thrift::protocol::T_SET, 1);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->disks.size()));
      std::set<std::string> ::const_iterator _iter381;
      for (_iter381 = this->disks.begin(); _iter381 != this->disks.end(); ++_iter381)
      {
        xfer += oprot->writeString((*_iter381));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.host) {
    xfer += oprot->writeFieldBegin("host", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->host);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.addr) {
    xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_SET, 3);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->addr.size()));
      std::set<std::string> ::const_iterator _iter382;
      for (_iter382 = this->addr.begin(); _iter382 != this->addr.end(); ++_iter382)
      {
        xfer += oprot->writeString((*_iter382));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.username) {
    xfer += oprot->writeFieldBegin("username", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->username);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.password) {
    xfer += oprot->writeFieldBegin("password", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->password);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.virtual_machine_id) {
    xfer += oprot->writeFieldBegin("virtual_machine_id", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->virtual_machine_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.snapshot) {
    xfer += oprot->writeFieldBegin("snapshot", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->snapshot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.images) {
    xfer += oprot->writeFieldBegin("images", ::apache::thrift::protocol::T_MAP, 10);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->images.size()));
      std::map<std::string, packer_disk_image> ::const_iterator _iter383;
      for (_iter383 = this->images.begin(); _iter383 != this->images.end(); ++_iter383)
      {
        xfer += oprot->writeString(_iter383->first);
        xfer += _iter383->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.backup_size) {
    xfer += oprot->writeFieldBegin("backup_size", ::apache::thrift::protocol::T_MAP, 14);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->backup_size.size()));
      std::map<std::string, int64_t> ::const_iterator _iter384;
      for (_iter384 = this->backup_size.begin(); _iter384 != this->backup_size.end(); ++_iter384)
      {
        xfer += oprot->writeString(_iter384->first);
        xfer += oprot->writeI64(_iter384->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.backup_progress) {
    xfer += oprot->writeFieldBegin("backup_progress", ::apache::thrift::protocol::T_MAP, 15);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->backup_progress.size()));
      std::map<std::string, int64_t> ::const_iterator _iter385;
      for (_iter385 = this->backup_progress.begin(); _iter385 != this->backup_progress.end(); ++_iter385)
      {
        xfer += oprot->writeString(_iter385->first);
        xfer += oprot->writeI64(_iter385->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.backup_image_offset) {
    xfer += oprot->writeFieldBegin("backup_image_offset", ::apache::thrift::protocol::T_MAP, 16);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->backup_image_offset.size()));
      std::map<std::string, int64_t> ::const_iterator _iter386;
      for (_iter386 = this->backup_image_offset.begin(); _iter386 != this->backup_image_offset.end(); ++_iter386)
      {
        xfer += oprot->writeString(_iter386->first);
        xfer += oprot->writeI64(_iter386->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.previous_change_ids) {
    xfer += oprot->writeFieldBegin("previous_change_ids", ::apache::thrift::protocol::T_MAP, 17);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->previous_change_ids.size()));
      std::map<std::string, std::string> ::const_iterator _iter387;
      for (_iter387 = this->previous_change_ids.begin(); _iter387 != this->previous_change_ids.end(); ++_iter387)
      {
        xfer += oprot->writeString(_iter387->first);
        xfer += oprot->writeString(_iter387->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.completed_blocks) {
    xfer += oprot->writeFieldBegin("completed_blocks", ::apache::thrift::protocol::T_MAP, 18);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->completed_blocks.size()));
      std::map<std::string, std::vector<io_changed_range> > ::const_iterator _iter388;
      for (_iter388 = this->completed_blocks.begin(); _iter388 != this->completed_blocks.end(); ++_iter388)
      {
        xfer += oprot->writeString(_iter388->first);
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter388->second.size()));
          std::vector<io_changed_range> ::const_iterator _iter389;
          for (_iter389 = _iter388->second.begin(); _iter389 != _iter388->second.end(); ++_iter389)
          {
            xfer += (*_iter389).write(oprot);
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(virtual_create_packer_job_detail &a, virtual_create_packer_job_detail &b) {
  using ::std::swap;
  swap(a.disks, b.disks);
  swap(a.host, b.host);
  swap(a.addr, b.addr);
  swap(a.username, b.username);
  swap(a.password, b.password);
  swap(a.virtual_machine_id, b.virtual_machine_id);
  swap(a.snapshot, b.snapshot);
  swap(a.images, b.images);
  swap(a.backup_size, b.backup_size);
  swap(a.backup_progress, b.backup_progress);
  swap(a.backup_image_offset, b.backup_image_offset);
  swap(a.previous_change_ids, b.previous_change_ids);
  swap(a.completed_blocks, b.completed_blocks);
  swap(a.__isset, b.__isset);
}

virtual_create_packer_job_detail::virtual_create_packer_job_detail(const virtual_create_packer_job_detail& other390) {
  disks = other390.disks;
  host = other390.host;
  addr = other390.addr;
  username = other390.username;
  password = other390.password;
  virtual_machine_id = other390.virtual_machine_id;
  snapshot = other390.snapshot;
  images = other390.images;
  backup_size = other390.backup_size;
  backup_progress = other390.backup_progress;
  backup_image_offset = other390.backup_image_offset;
  previous_change_ids = other390.previous_change_ids;
  completed_blocks = other390.completed_blocks;
  __isset = other390.__isset;
}
virtual_create_packer_job_detail& virtual_create_packer_job_detail::operator=(const virtual_create_packer_job_detail& other391) {
  disks = other391.disks;
  host = other391.host;
  addr = other391.addr;
  username = other391.username;
  password = other391.password;
  virtual_machine_id = other391.virtual_machine_id;
  snapshot = other391.snapshot;
  images = other391.images;
  backup_size = other391.backup_size;
  backup_progress = other391.backup_progress;
  backup_image_offset = other391.backup_image_offset;
  previous_change_ids = other391.previous_change_ids;
  completed_blocks = other391.completed_blocks;
  __isset = other391.__isset;
  return *this;
}
void virtual_create_packer_job_detail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "virtual_create_packer_job_detail(";
  out << "disks="; (__isset.disks ? (out << to_string(disks)) : (out << "<null>"));
  out << ", " << "host="; (__isset.host ? (out << to_string(host)) : (out << "<null>"));
  out << ", " << "addr="; (__isset.addr ? (out << to_string(addr)) : (out << "<null>"));
  out << ", " << "username="; (__isset.username ? (out << to_string(username)) : (out << "<null>"));
  out << ", " << "password="; (__isset.password ? (out << to_string(password)) : (out << "<null>"));
  out << ", " << "virtual_machine_id="; (__isset.virtual_machine_id ? (out << to_string(virtual_machine_id)) : (out << "<null>"));
  out << ", " << "snapshot="; (__isset.snapshot ? (out << to_string(snapshot)) : (out << "<null>"));
  out << ", " << "images="; (__isset.images ? (out << to_string(images)) : (out << "<null>"));
  out << ", " << "backup_size="; (__isset.backup_size ? (out << to_string(backup_size)) : (out << "<null>"));
  out << ", " << "backup_progress="; (__isset.backup_progress ? (out << to_string(backup_progress)) : (out << "<null>"));
  out << ", " << "backup_image_offset="; (__isset.backup_image_offset ? (out << to_string(backup_image_offset)) : (out << "<null>"));
  out << ", " << "previous_change_ids="; (__isset.previous_change_ids ? (out << to_string(previous_change_ids)) : (out << "<null>"));
  out << ", " << "completed_blocks="; (__isset.completed_blocks ? (out << to_string(completed_blocks)) : (out << "<null>"));
  out << ")";
}


physical_vcbt_journal::~physical_vcbt_journal() throw() {
}


void physical_vcbt_journal::__set_id(const int64_t val) {
  this->id = val;
__isset.id = true;
}

void physical_vcbt_journal::__set_first_key(const int64_t val) {
  this->first_key = val;
__isset.first_key = true;
}

void physical_vcbt_journal::__set_latest_key(const int64_t val) {
  this->latest_key = val;
__isset.latest_key = true;
}

void physical_vcbt_journal::__set_lowest_valid_key(const int64_t val) {
  this->lowest_valid_key = val;
__isset.lowest_valid_key = true;
}

uint32_t physical_vcbt_journal::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->first_key);
          this->__isset.first_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->latest_key);
          this->__isset.latest_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lowest_valid_key);
          this->__isset.lowest_valid_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_vcbt_journal::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_vcbt_journal");

  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.first_key) {
    xfer += oprot->writeFieldBegin("first_key", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->first_key);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.latest_key) {
    xfer += oprot->writeFieldBegin("latest_key", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->latest_key);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lowest_valid_key) {
    xfer += oprot->writeFieldBegin("lowest_valid_key", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->lowest_valid_key);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(physical_vcbt_journal &a, physical_vcbt_journal &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.first_key, b.first_key);
  swap(a.latest_key, b.latest_key);
  swap(a.lowest_valid_key, b.lowest_valid_key);
  swap(a.__isset, b.__isset);
}

physical_vcbt_journal::physical_vcbt_journal(const physical_vcbt_journal& other392) {
  id = other392.id;
  first_key = other392.first_key;
  latest_key = other392.latest_key;
  lowest_valid_key = other392.lowest_valid_key;
  __isset = other392.__isset;
}
physical_vcbt_journal& physical_vcbt_journal::operator=(const physical_vcbt_journal& other393) {
  id = other393.id;
  first_key = other393.first_key;
  latest_key = other393.latest_key;
  lowest_valid_key = other393.lowest_valid_key;
  __isset = other393.__isset;
  return *this;
}
void physical_vcbt_journal::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "physical_vcbt_journal(";
  out << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "first_key="; (__isset.first_key ? (out << to_string(first_key)) : (out << "<null>"));
  out << ", " << "latest_key="; (__isset.latest_key ? (out << to_string(latest_key)) : (out << "<null>"));
  out << ", " << "lowest_valid_key="; (__isset.lowest_valid_key ? (out << to_string(lowest_valid_key)) : (out << "<null>"));
  out << ")";
}


io_changed_range::~io_changed_range() throw() {
}


void io_changed_range::__set_offset(const int64_t val) {
  this->offset = val;
}

void io_changed_range::__set_start(const int64_t val) {
  this->start = val;
}

void io_changed_range::__set_length(const int64_t val) {
  this->length = val;
}

uint32_t io_changed_range::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->offset);
          this->__isset.offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->start);
          this->__isset.start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->length);
          this->__isset.length = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t io_changed_range::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("io_changed_range");

  xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->offset);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->start);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("length", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->length);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(io_changed_range &a, io_changed_range &b) {
  using ::std::swap;
  swap(a.offset, b.offset);
  swap(a.start, b.start);
  swap(a.length, b.length);
  swap(a.__isset, b.__isset);
}

io_changed_range::io_changed_range(const io_changed_range& other394) {
  offset = other394.offset;
  start = other394.start;
  length = other394.length;
  __isset = other394.__isset;
}
io_changed_range& io_changed_range::operator=(const io_changed_range& other395) {
  offset = other395.offset;
  start = other395.start;
  length = other395.length;
  __isset = other395.__isset;
  return *this;
}
void io_changed_range::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "io_changed_range(";
  out << "offset=" << to_string(offset);
  out << ", " << "start=" << to_string(start);
  out << ", " << "length=" << to_string(length);
  out << ")";
}


physical_create_packer_job_detail::~physical_create_packer_job_detail() throw() {
}


void physical_create_packer_job_detail::__set_disks(const std::set<std::string> & val) {
  this->disks = val;
__isset.disks = true;
}

void physical_create_packer_job_detail::__set_snapshots(const std::vector<snapshot> & val) {
  this->snapshots = val;
__isset.snapshots = true;
}

void physical_create_packer_job_detail::__set_previous_journals(const std::map<int64_t, physical_vcbt_journal> & val) {
  this->previous_journals = val;
__isset.previous_journals = true;
}

void physical_create_packer_job_detail::__set_images(const std::map<std::string, packer_disk_image> & val) {
  this->images = val;
__isset.images = true;
}

void physical_create_packer_job_detail::__set_backup_size(const std::map<std::string, int64_t> & val) {
  this->backup_size = val;
__isset.backup_size = true;
}

void physical_create_packer_job_detail::__set_backup_progress(const std::map<std::string, int64_t> & val) {
  this->backup_progress = val;
__isset.backup_progress = true;
}

void physical_create_packer_job_detail::__set_backup_image_offset(const std::map<std::string, int64_t> & val) {
  this->backup_image_offset = val;
__isset.backup_image_offset = true;
}

void physical_create_packer_job_detail::__set_cdr_journals(const std::map<int64_t, physical_vcbt_journal> & val) {
  this->cdr_journals = val;
__isset.cdr_journals = true;
}

void physical_create_packer_job_detail::__set_cdr_changed_ranges(const std::map<std::string, std::vector<io_changed_range> > & val) {
  this->cdr_changed_ranges = val;
__isset.cdr_changed_ranges = true;
}

void physical_create_packer_job_detail::__set_completed_blocks(const std::map<std::string, std::vector<io_changed_range> > & val) {
  this->completed_blocks = val;
__isset.completed_blocks = true;
}

uint32_t physical_create_packer_job_detail::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->disks.clear();
            uint32_t _size396;
            ::apache::thrift::protocol::TType _etype399;
            xfer += iprot->readSetBegin(_etype399, _size396);
            uint32_t _i400;
            for (_i400 = 0; _i400 < _size396; ++_i400)
            {
              std::string _elem401;
              xfer += iprot->readString(_elem401);
              this->disks.insert(_elem401);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.disks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->snapshots.clear();
            uint32_t _size402;
            ::apache::thrift::protocol::TType _etype405;
            xfer += iprot->readListBegin(_etype405, _size402);
            this->snapshots.resize(_size402);
            uint32_t _i406;
            for (_i406 = 0; _i406 < _size402; ++_i406)
            {
              xfer += this->snapshots[_i406].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.snapshots = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->previous_journals.clear();
            uint32_t _size407;
            ::apache::thrift::protocol::TType _ktype408;
            ::apache::thrift::protocol::TType _vtype409;
            xfer += iprot->readMapBegin(_ktype408, _vtype409, _size407);
            uint32_t _i411;
            for (_i411 = 0; _i411 < _size407; ++_i411)
            {
              int64_t _key412;
              xfer += iprot->readI64(_key412);
              physical_vcbt_journal& _val413 = this->previous_journals[_key412];
              xfer += _val413.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.previous_journals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->images.clear();
            uint32_t _size414;
            ::apache::thrift::protocol::TType _ktype415;
            ::apache::thrift::protocol::TType _vtype416;
            xfer += iprot->readMapBegin(_ktype415, _vtype416, _size414);
            uint32_t _i418;
            for (_i418 = 0; _i418 < _size414; ++_i418)
            {
              std::string _key419;
              xfer += iprot->readString(_key419);
              packer_disk_image& _val420 = this->images[_key419];
              xfer += _val420.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.images = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->backup_size.clear();
            uint32_t _size421;
            ::apache::thrift::protocol::TType _ktype422;
            ::apache::thrift::protocol::TType _vtype423;
            xfer += iprot->readMapBegin(_ktype422, _vtype423, _size421);
            uint32_t _i425;
            for (_i425 = 0; _i425 < _size421; ++_i425)
            {
              std::string _key426;
              xfer += iprot->readString(_key426);
              int64_t& _val427 = this->backup_size[_key426];
              xfer += iprot->readI64(_val427);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.backup_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->backup_progress.clear();
            uint32_t _size428;
            ::apache::thrift::protocol::TType _ktype429;
            ::apache::thrift::protocol::TType _vtype430;
            xfer += iprot->readMapBegin(_ktype429, _vtype430, _size428);
            uint32_t _i432;
            for (_i432 = 0; _i432 < _size428; ++_i432)
            {
              std::string _key433;
              xfer += iprot->readString(_key433);
              int64_t& _val434 = this->backup_progress[_key433];
              xfer += iprot->readI64(_val434);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.backup_progress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->backup_image_offset.clear();
            uint32_t _size435;
            ::apache::thrift::protocol::TType _ktype436;
            ::apache::thrift::protocol::TType _vtype437;
            xfer += iprot->readMapBegin(_ktype436, _vtype437, _size435);
            uint32_t _i439;
            for (_i439 = 0; _i439 < _size435; ++_i439)
            {
              std::string _key440;
              xfer += iprot->readString(_key440);
              int64_t& _val441 = this->backup_image_offset[_key440];
              xfer += iprot->readI64(_val441);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.backup_image_offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->cdr_journals.clear();
            uint32_t _size442;
            ::apache::thrift::protocol::TType _ktype443;
            ::apache::thrift::protocol::TType _vtype444;
            xfer += iprot->readMapBegin(_ktype443, _vtype444, _size442);
            uint32_t _i446;
            for (_i446 = 0; _i446 < _size442; ++_i446)
            {
              int64_t _key447;
              xfer += iprot->readI64(_key447);
              physical_vcbt_journal& _val448 = this->cdr_journals[_key447];
              xfer += _val448.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.cdr_journals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->cdr_changed_ranges.clear();
            uint32_t _size449;
            ::apache::thrift::protocol::TType _ktype450;
            ::apache::thrift::protocol::TType _vtype451;
            xfer += iprot->readMapBegin(_ktype450, _vtype451, _size449);
            uint32_t _i453;
            for (_i453 = 0; _i453 < _size449; ++_i453)
            {
              std::string _key454;
              xfer += iprot->readString(_key454);
              std::vector<io_changed_range> & _val455 = this->cdr_changed_ranges[_key454];
              {
                _val455.clear();
                uint32_t _size456;
                ::apache::thrift::protocol::TType _etype459;
                xfer += iprot->readListBegin(_etype459, _size456);
                _val455.resize(_size456);
                uint32_t _i460;
                for (_i460 = 0; _i460 < _size456; ++_i460)
                {
                  xfer += _val455[_i460].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.cdr_changed_ranges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->completed_blocks.clear();
            uint32_t _size461;
            ::apache::thrift::protocol::TType _ktype462;
            ::apache::thrift::protocol::TType _vtype463;
            xfer += iprot->readMapBegin(_ktype462, _vtype463, _size461);
            uint32_t _i465;
            for (_i465 = 0; _i465 < _size461; ++_i465)
            {
              std::string _key466;
              xfer += iprot->readString(_key466);
              std::vector<io_changed_range> & _val467 = this->completed_blocks[_key466];
              {
                _val467.clear();
                uint32_t _size468;
                ::apache::thrift::protocol::TType _etype471;
                xfer += iprot->readListBegin(_etype471, _size468);
                _val467.resize(_size468);
                uint32_t _i472;
                for (_i472 = 0; _i472 < _size468; ++_i472)
                {
                  xfer += _val467[_i472].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.completed_blocks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_create_packer_job_detail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_create_packer_job_detail");

  if (this->__isset.disks) {
    xfer += oprot->writeFieldBegin("disks", ::apache::thrift::protocol::T_SET, 1);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->disks.size()));
      std::set<std::string> ::const_iterator _iter473;
      for (_iter473 = this->disks.begin(); _iter473 != this->disks.end(); ++_iter473)
      {
        xfer += oprot->writeString((*_iter473));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.snapshots) {
    xfer += oprot->writeFieldBegin("snapshots", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->snapshots.size()));
      std::vector<snapshot> ::const_iterator _iter474;
      for (_iter474 = this->snapshots.begin(); _iter474 != this->snapshots.end(); ++_iter474)
      {
        xfer += (*_iter474).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.previous_journals) {
    xfer += oprot->writeFieldBegin("previous_journals", ::apache::thrift::protocol::T_MAP, 3);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I64, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->previous_journals.size()));
      std::map<int64_t, physical_vcbt_journal> ::const_iterator _iter475;
      for (_iter475 = this->previous_journals.begin(); _iter475 != this->previous_journals.end(); ++_iter475)
      {
        xfer += oprot->writeI64(_iter475->first);
        xfer += _iter475->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.images) {
    xfer += oprot->writeFieldBegin("images", ::apache::thrift::protocol::T_MAP, 4);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->images.size()));
      std::map<std::string, packer_disk_image> ::const_iterator _iter476;
      for (_iter476 = this->images.begin(); _iter476 != this->images.end(); ++_iter476)
      {
        xfer += oprot->writeString(_iter476->first);
        xfer += _iter476->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.backup_size) {
    xfer += oprot->writeFieldBegin("backup_size", ::apache::thrift::protocol::T_MAP, 5);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->backup_size.size()));
      std::map<std::string, int64_t> ::const_iterator _iter477;
      for (_iter477 = this->backup_size.begin(); _iter477 != this->backup_size.end(); ++_iter477)
      {
        xfer += oprot->writeString(_iter477->first);
        xfer += oprot->writeI64(_iter477->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.backup_progress) {
    xfer += oprot->writeFieldBegin("backup_progress", ::apache::thrift::protocol::T_MAP, 6);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->backup_progress.size()));
      std::map<std::string, int64_t> ::const_iterator _iter478;
      for (_iter478 = this->backup_progress.begin(); _iter478 != this->backup_progress.end(); ++_iter478)
      {
        xfer += oprot->writeString(_iter478->first);
        xfer += oprot->writeI64(_iter478->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.backup_image_offset) {
    xfer += oprot->writeFieldBegin("backup_image_offset", ::apache::thrift::protocol::T_MAP, 7);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->backup_image_offset.size()));
      std::map<std::string, int64_t> ::const_iterator _iter479;
      for (_iter479 = this->backup_image_offset.begin(); _iter479 != this->backup_image_offset.end(); ++_iter479)
      {
        xfer += oprot->writeString(_iter479->first);
        xfer += oprot->writeI64(_iter479->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cdr_journals) {
    xfer += oprot->writeFieldBegin("cdr_journals", ::apache::thrift::protocol::T_MAP, 8);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I64, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cdr_journals.size()));
      std::map<int64_t, physical_vcbt_journal> ::const_iterator _iter480;
      for (_iter480 = this->cdr_journals.begin(); _iter480 != this->cdr_journals.end(); ++_iter480)
      {
        xfer += oprot->writeI64(_iter480->first);
        xfer += _iter480->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cdr_changed_ranges) {
    xfer += oprot->writeFieldBegin("cdr_changed_ranges", ::apache::thrift::protocol::T_MAP, 9);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->cdr_changed_ranges.size()));
      std::map<std::string, std::vector<io_changed_range> > ::const_iterator _iter481;
      for (_iter481 = this->cdr_changed_ranges.begin(); _iter481 != this->cdr_changed_ranges.end(); ++_iter481)
      {
        xfer += oprot->writeString(_iter481->first);
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter481->second.size()));
          std::vector<io_changed_range> ::const_iterator _iter482;
          for (_iter482 = _iter481->second.begin(); _iter482 != _iter481->second.end(); ++_iter482)
          {
            xfer += (*_iter482).write(oprot);
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.completed_blocks) {
    xfer += oprot->writeFieldBegin("completed_blocks", ::apache::thrift::protocol::T_MAP, 10);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->completed_blocks.size()));
      std::map<std::string, std::vector<io_changed_range> > ::const_iterator _iter483;
      for (_iter483 = this->completed_blocks.begin(); _iter483 != this->completed_blocks.end(); ++_iter483)
      {
        xfer += oprot->writeString(_iter483->first);
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter483->second.size()));
          std::vector<io_changed_range> ::const_iterator _iter484;
          for (_iter484 = _iter483->second.begin(); _iter484 != _iter483->second.end(); ++_iter484)
          {
            xfer += (*_iter484).write(oprot);
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(physical_create_packer_job_detail &a, physical_create_packer_job_detail &b) {
  using ::std::swap;
  swap(a.disks, b.disks);
  swap(a.snapshots, b.snapshots);
  swap(a.previous_journals, b.previous_journals);
  swap(a.images, b.images);
  swap(a.backup_size, b.backup_size);
  swap(a.backup_progress, b.backup_progress);
  swap(a.backup_image_offset, b.backup_image_offset);
  swap(a.cdr_journals, b.cdr_journals);
  swap(a.cdr_changed_ranges, b.cdr_changed_ranges);
  swap(a.completed_blocks, b.completed_blocks);
  swap(a.__isset, b.__isset);
}

physical_create_packer_job_detail::physical_create_packer_job_detail(const physical_create_packer_job_detail& other485) {
  disks = other485.disks;
  snapshots = other485.snapshots;
  previous_journals = other485.previous_journals;
  images = other485.images;
  backup_size = other485.backup_size;
  backup_progress = other485.backup_progress;
  backup_image_offset = other485.backup_image_offset;
  cdr_journals = other485.cdr_journals;
  cdr_changed_ranges = other485.cdr_changed_ranges;
  completed_blocks = other485.completed_blocks;
  __isset = other485.__isset;
}
physical_create_packer_job_detail& physical_create_packer_job_detail::operator=(const physical_create_packer_job_detail& other486) {
  disks = other486.disks;
  snapshots = other486.snapshots;
  previous_journals = other486.previous_journals;
  images = other486.images;
  backup_size = other486.backup_size;
  backup_progress = other486.backup_progress;
  backup_image_offset = other486.backup_image_offset;
  cdr_journals = other486.cdr_journals;
  cdr_changed_ranges = other486.cdr_changed_ranges;
  completed_blocks = other486.completed_blocks;
  __isset = other486.__isset;
  return *this;
}
void physical_create_packer_job_detail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "physical_create_packer_job_detail(";
  out << "disks="; (__isset.disks ? (out << to_string(disks)) : (out << "<null>"));
  out << ", " << "snapshots="; (__isset.snapshots ? (out << to_string(snapshots)) : (out << "<null>"));
  out << ", " << "previous_journals="; (__isset.previous_journals ? (out << to_string(previous_journals)) : (out << "<null>"));
  out << ", " << "images="; (__isset.images ? (out << to_string(images)) : (out << "<null>"));
  out << ", " << "backup_size="; (__isset.backup_size ? (out << to_string(backup_size)) : (out << "<null>"));
  out << ", " << "backup_progress="; (__isset.backup_progress ? (out << to_string(backup_progress)) : (out << "<null>"));
  out << ", " << "backup_image_offset="; (__isset.backup_image_offset ? (out << to_string(backup_image_offset)) : (out << "<null>"));
  out << ", " << "cdr_journals="; (__isset.cdr_journals ? (out << to_string(cdr_journals)) : (out << "<null>"));
  out << ", " << "cdr_changed_ranges="; (__isset.cdr_changed_ranges ? (out << to_string(cdr_changed_ranges)) : (out << "<null>"));
  out << ", " << "completed_blocks="; (__isset.completed_blocks ? (out << to_string(completed_blocks)) : (out << "<null>"));
  out << ")";
}


_create_packer_job_detail::~_create_packer_job_detail() throw() {
}


void _create_packer_job_detail::__set_p(const physical_create_packer_job_detail& val) {
  this->p = val;
__isset.p = true;
}

void _create_packer_job_detail::__set_v(const virtual_create_packer_job_detail& val) {
  this->v = val;
__isset.v = true;
}

uint32_t _create_packer_job_detail::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->p.read(iprot);
          this->__isset.p = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->v.read(iprot);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t _create_packer_job_detail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("_create_packer_job_detail");

  if (this->__isset.p) {
    xfer += oprot->writeFieldBegin("p", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->p.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.v) {
    xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->v.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(_create_packer_job_detail &a, _create_packer_job_detail &b) {
  using ::std::swap;
  swap(a.p, b.p);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

_create_packer_job_detail::_create_packer_job_detail(const _create_packer_job_detail& other487) {
  p = other487.p;
  v = other487.v;
  __isset = other487.__isset;
}
_create_packer_job_detail& _create_packer_job_detail::operator=(const _create_packer_job_detail& other488) {
  p = other488.p;
  v = other488.v;
  __isset = other488.__isset;
  return *this;
}
void _create_packer_job_detail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "_create_packer_job_detail(";
  out << "p="; (__isset.p ? (out << to_string(p)) : (out << "<null>"));
  out << ", " << "v="; (__isset.v ? (out << to_string(v)) : (out << "<null>"));
  out << ")";
}


create_packer_job_detail::~create_packer_job_detail() throw() {
}


void create_packer_job_detail::__set_type(const job_type::type val) {
  this->type = val;
}

void create_packer_job_detail::__set_connection_ids(const std::set<std::string> & val) {
  this->connection_ids = val;
}

void create_packer_job_detail::__set_carriers(const std::map<std::string, std::set<std::string> > & val) {
  this->carriers = val;
}

void create_packer_job_detail::__set_detail(const _create_packer_job_detail& val) {
  this->detail = val;
}

void create_packer_job_detail::__set_checksum_verify(const bool val) {
  this->checksum_verify = val;
__isset.checksum_verify = true;
}

void create_packer_job_detail::__set_timeout(const int32_t val) {
  this->timeout = val;
__isset.timeout = true;
}

void create_packer_job_detail::__set_is_encrypted(const bool val) {
  this->is_encrypted = val;
__isset.is_encrypted = true;
}

void create_packer_job_detail::__set_worker_thread_number(const int32_t val) {
  this->worker_thread_number = val;
__isset.worker_thread_number = true;
}

void create_packer_job_detail::__set_file_system_filter_enable(const bool val) {
  this->file_system_filter_enable = val;
__isset.file_system_filter_enable = true;
}

void create_packer_job_detail::__set_min_transport_size(const int32_t val) {
  this->min_transport_size = val;
__isset.min_transport_size = true;
}

void create_packer_job_detail::__set_full_min_transport_size(const int32_t val) {
  this->full_min_transport_size = val;
__isset.full_min_transport_size = true;
}

void create_packer_job_detail::__set_is_compressed(const bool val) {
  this->is_compressed = val;
__isset.is_compressed = true;
}

void create_packer_job_detail::__set_is_checksum(const bool val) {
  this->is_checksum = val;
__isset.is_checksum = true;
}

void create_packer_job_detail::__set_priority_carrier(const std::map<std::string, std::string> & val) {
  this->priority_carrier = val;
__isset.priority_carrier = true;
}

void create_packer_job_detail::__set_is_only_single_system_disk(const bool val) {
  this->is_only_single_system_disk = val;
__isset.is_only_single_system_disk = true;
}

void create_packer_job_detail::__set_is_compressed_by_packer(const bool val) {
  this->is_compressed_by_packer = val;
__isset.is_compressed_by_packer = true;
}

uint32_t create_packer_job_detail::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast489;
          xfer += iprot->readI32(ecast489);
          this->type = (job_type::type)ecast489;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->connection_ids.clear();
            uint32_t _size490;
            ::apache::thrift::protocol::TType _etype493;
            xfer += iprot->readSetBegin(_etype493, _size490);
            uint32_t _i494;
            for (_i494 = 0; _i494 < _size490; ++_i494)
            {
              std::string _elem495;
              xfer += iprot->readString(_elem495);
              this->connection_ids.insert(_elem495);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.connection_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->carriers.clear();
            uint32_t _size496;
            ::apache::thrift::protocol::TType _ktype497;
            ::apache::thrift::protocol::TType _vtype498;
            xfer += iprot->readMapBegin(_ktype497, _vtype498, _size496);
            uint32_t _i500;
            for (_i500 = 0; _i500 < _size496; ++_i500)
            {
              std::string _key501;
              xfer += iprot->readString(_key501);
              std::set<std::string> & _val502 = this->carriers[_key501];
              {
                _val502.clear();
                uint32_t _size503;
                ::apache::thrift::protocol::TType _etype506;
                xfer += iprot->readSetBegin(_etype506, _size503);
                uint32_t _i507;
                for (_i507 = 0; _i507 < _size503; ++_i507)
                {
                  std::string _elem508;
                  xfer += iprot->readString(_elem508);
                  _val502.insert(_elem508);
                }
                xfer += iprot->readSetEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.carriers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->detail.read(iprot);
          this->__isset.detail = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->checksum_verify);
          this->__isset.checksum_verify = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->timeout);
          this->__isset.timeout = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_encrypted);
          this->__isset.is_encrypted = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->worker_thread_number);
          this->__isset.worker_thread_number = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->file_system_filter_enable);
          this->__isset.file_system_filter_enable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->min_transport_size);
          this->__isset.min_transport_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->full_min_transport_size);
          this->__isset.full_min_transport_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_compressed);
          this->__isset.is_compressed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_checksum);
          this->__isset.is_checksum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->priority_carrier.clear();
            uint32_t _size509;
            ::apache::thrift::protocol::TType _ktype510;
            ::apache::thrift::protocol::TType _vtype511;
            xfer += iprot->readMapBegin(_ktype510, _vtype511, _size509);
            uint32_t _i513;
            for (_i513 = 0; _i513 < _size509; ++_i513)
            {
              std::string _key514;
              xfer += iprot->readString(_key514);
              std::string& _val515 = this->priority_carrier[_key514];
              xfer += iprot->readString(_val515);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.priority_carrier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_only_single_system_disk);
          this->__isset.is_only_single_system_disk = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_compressed_by_packer);
          this->__isset.is_compressed_by_packer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t create_packer_job_detail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("create_packer_job_detail");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("connection_ids", ::apache::thrift::protocol::T_SET, 2);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->connection_ids.size()));
    std::set<std::string> ::const_iterator _iter516;
    for (_iter516 = this->connection_ids.begin(); _iter516 != this->connection_ids.end(); ++_iter516)
    {
      xfer += oprot->writeString((*_iter516));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("carriers", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_SET, static_cast<uint32_t>(this->carriers.size()));
    std::map<std::string, std::set<std::string> > ::const_iterator _iter517;
    for (_iter517 = this->carriers.begin(); _iter517 != this->carriers.end(); ++_iter517)
    {
      xfer += oprot->writeString(_iter517->first);
      {
        xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter517->second.size()));
        std::set<std::string> ::const_iterator _iter518;
        for (_iter518 = _iter517->second.begin(); _iter518 != _iter517->second.end(); ++_iter518)
        {
          xfer += oprot->writeString((*_iter518));
        }
        xfer += oprot->writeSetEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("detail", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->detail.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.checksum_verify) {
    xfer += oprot->writeFieldBegin("checksum_verify", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->checksum_verify);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timeout) {
    xfer += oprot->writeFieldBegin("timeout", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(this->timeout);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_encrypted) {
    xfer += oprot->writeFieldBegin("is_encrypted", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->is_encrypted);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.worker_thread_number) {
    xfer += oprot->writeFieldBegin("worker_thread_number", ::apache::thrift::protocol::T_I32, 8);
    xfer += oprot->writeI32(this->worker_thread_number);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.file_system_filter_enable) {
    xfer += oprot->writeFieldBegin("file_system_filter_enable", ::apache::thrift::protocol::T_BOOL, 9);
    xfer += oprot->writeBool(this->file_system_filter_enable);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.min_transport_size) {
    xfer += oprot->writeFieldBegin("min_transport_size", ::apache::thrift::protocol::T_I32, 10);
    xfer += oprot->writeI32(this->min_transport_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.full_min_transport_size) {
    xfer += oprot->writeFieldBegin("full_min_transport_size", ::apache::thrift::protocol::T_I32, 11);
    xfer += oprot->writeI32(this->full_min_transport_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_compressed) {
    xfer += oprot->writeFieldBegin("is_compressed", ::apache::thrift::protocol::T_BOOL, 12);
    xfer += oprot->writeBool(this->is_compressed);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_checksum) {
    xfer += oprot->writeFieldBegin("is_checksum", ::apache::thrift::protocol::T_BOOL, 13);
    xfer += oprot->writeBool(this->is_checksum);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.priority_carrier) {
    xfer += oprot->writeFieldBegin("priority_carrier", ::apache::thrift::protocol::T_MAP, 14);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->priority_carrier.size()));
      std::map<std::string, std::string> ::const_iterator _iter519;
      for (_iter519 = this->priority_carrier.begin(); _iter519 != this->priority_carrier.end(); ++_iter519)
      {
        xfer += oprot->writeString(_iter519->first);
        xfer += oprot->writeString(_iter519->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_only_single_system_disk) {
    xfer += oprot->writeFieldBegin("is_only_single_system_disk", ::apache::thrift::protocol::T_BOOL, 15);
    xfer += oprot->writeBool(this->is_only_single_system_disk);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_compressed_by_packer) {
    xfer += oprot->writeFieldBegin("is_compressed_by_packer", ::apache::thrift::protocol::T_BOOL, 16);
    xfer += oprot->writeBool(this->is_compressed_by_packer);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(create_packer_job_detail &a, create_packer_job_detail &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.connection_ids, b.connection_ids);
  swap(a.carriers, b.carriers);
  swap(a.detail, b.detail);
  swap(a.checksum_verify, b.checksum_verify);
  swap(a.timeout, b.timeout);
  swap(a.is_encrypted, b.is_encrypted);
  swap(a.worker_thread_number, b.worker_thread_number);
  swap(a.file_system_filter_enable, b.file_system_filter_enable);
  swap(a.min_transport_size, b.min_transport_size);
  swap(a.full_min_transport_size, b.full_min_transport_size);
  swap(a.is_compressed, b.is_compressed);
  swap(a.is_checksum, b.is_checksum);
  swap(a.priority_carrier, b.priority_carrier);
  swap(a.is_only_single_system_disk, b.is_only_single_system_disk);
  swap(a.is_compressed_by_packer, b.is_compressed_by_packer);
  swap(a.__isset, b.__isset);
}

create_packer_job_detail::create_packer_job_detail(const create_packer_job_detail& other520) {
  type = other520.type;
  connection_ids = other520.connection_ids;
  carriers = other520.carriers;
  detail = other520.detail;
  checksum_verify = other520.checksum_verify;
  timeout = other520.timeout;
  is_encrypted = other520.is_encrypted;
  worker_thread_number = other520.worker_thread_number;
  file_system_filter_enable = other520.file_system_filter_enable;
  min_transport_size = other520.min_transport_size;
  full_min_transport_size = other520.full_min_transport_size;
  is_compressed = other520.is_compressed;
  is_checksum = other520.is_checksum;
  priority_carrier = other520.priority_carrier;
  is_only_single_system_disk = other520.is_only_single_system_disk;
  is_compressed_by_packer = other520.is_compressed_by_packer;
  __isset = other520.__isset;
}
create_packer_job_detail& create_packer_job_detail::operator=(const create_packer_job_detail& other521) {
  type = other521.type;
  connection_ids = other521.connection_ids;
  carriers = other521.carriers;
  detail = other521.detail;
  checksum_verify = other521.checksum_verify;
  timeout = other521.timeout;
  is_encrypted = other521.is_encrypted;
  worker_thread_number = other521.worker_thread_number;
  file_system_filter_enable = other521.file_system_filter_enable;
  min_transport_size = other521.min_transport_size;
  full_min_transport_size = other521.full_min_transport_size;
  is_compressed = other521.is_compressed;
  is_checksum = other521.is_checksum;
  priority_carrier = other521.priority_carrier;
  is_only_single_system_disk = other521.is_only_single_system_disk;
  is_compressed_by_packer = other521.is_compressed_by_packer;
  __isset = other521.__isset;
  return *this;
}
void create_packer_job_detail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "create_packer_job_detail(";
  out << "type=" << to_string(type);
  out << ", " << "connection_ids=" << to_string(connection_ids);
  out << ", " << "carriers=" << to_string(carriers);
  out << ", " << "detail=" << to_string(detail);
  out << ", " << "checksum_verify="; (__isset.checksum_verify ? (out << to_string(checksum_verify)) : (out << "<null>"));
  out << ", " << "timeout="; (__isset.timeout ? (out << to_string(timeout)) : (out << "<null>"));
  out << ", " << "is_encrypted="; (__isset.is_encrypted ? (out << to_string(is_encrypted)) : (out << "<null>"));
  out << ", " << "worker_thread_number="; (__isset.worker_thread_number ? (out << to_string(worker_thread_number)) : (out << "<null>"));
  out << ", " << "file_system_filter_enable="; (__isset.file_system_filter_enable ? (out << to_string(file_system_filter_enable)) : (out << "<null>"));
  out << ", " << "min_transport_size="; (__isset.min_transport_size ? (out << to_string(min_transport_size)) : (out << "<null>"));
  out << ", " << "full_min_transport_size="; (__isset.full_min_transport_size ? (out << to_string(full_min_transport_size)) : (out << "<null>"));
  out << ", " << "is_compressed="; (__isset.is_compressed ? (out << to_string(is_compressed)) : (out << "<null>"));
  out << ", " << "is_checksum="; (__isset.is_checksum ? (out << to_string(is_checksum)) : (out << "<null>"));
  out << ", " << "priority_carrier="; (__isset.priority_carrier ? (out << to_string(priority_carrier)) : (out << "<null>"));
  out << ", " << "is_only_single_system_disk="; (__isset.is_only_single_system_disk ? (out << to_string(is_only_single_system_disk)) : (out << "<null>"));
  out << ", " << "is_compressed_by_packer="; (__isset.is_compressed_by_packer ? (out << to_string(is_compressed_by_packer)) : (out << "<null>"));
  out << ")";
}


virtual_packer_job_detail::~virtual_packer_job_detail() throw() {
}


void virtual_packer_job_detail::__set_original_size(const std::map<std::string, int64_t> & val) {
  this->original_size = val;
__isset.original_size = true;
}

void virtual_packer_job_detail::__set_backup_size(const std::map<std::string, int64_t> & val) {
  this->backup_size = val;
__isset.backup_size = true;
}

void virtual_packer_job_detail::__set_backup_progress(const std::map<std::string, int64_t> & val) {
  this->backup_progress = val;
__isset.backup_progress = true;
}

void virtual_packer_job_detail::__set_backup_image_offset(const std::map<std::string, int64_t> & val) {
  this->backup_image_offset = val;
__isset.backup_image_offset = true;
}

void virtual_packer_job_detail::__set_change_ids(const std::map<std::string, std::string> & val) {
  this->change_ids = val;
__isset.change_ids = true;
}

void virtual_packer_job_detail::__set_guest_os_type(const hv_guest_os_type::type val) {
  this->guest_os_type = val;
__isset.guest_os_type = true;
}

void virtual_packer_job_detail::__set_completed_blocks(const std::map<std::string, std::vector<io_changed_range> > & val) {
  this->completed_blocks = val;
__isset.completed_blocks = true;
}

uint32_t virtual_packer_job_detail::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->original_size.clear();
            uint32_t _size522;
            ::apache::thrift::protocol::TType _ktype523;
            ::apache::thrift::protocol::TType _vtype524;
            xfer += iprot->readMapBegin(_ktype523, _vtype524, _size522);
            uint32_t _i526;
            for (_i526 = 0; _i526 < _size522; ++_i526)
            {
              std::string _key527;
              xfer += iprot->readString(_key527);
              int64_t& _val528 = this->original_size[_key527];
              xfer += iprot->readI64(_val528);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.original_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->backup_size.clear();
            uint32_t _size529;
            ::apache::thrift::protocol::TType _ktype530;
            ::apache::thrift::protocol::TType _vtype531;
            xfer += iprot->readMapBegin(_ktype530, _vtype531, _size529);
            uint32_t _i533;
            for (_i533 = 0; _i533 < _size529; ++_i533)
            {
              std::string _key534;
              xfer += iprot->readString(_key534);
              int64_t& _val535 = this->backup_size[_key534];
              xfer += iprot->readI64(_val535);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.backup_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->backup_progress.clear();
            uint32_t _size536;
            ::apache::thrift::protocol::TType _ktype537;
            ::apache::thrift::protocol::TType _vtype538;
            xfer += iprot->readMapBegin(_ktype537, _vtype538, _size536);
            uint32_t _i540;
            for (_i540 = 0; _i540 < _size536; ++_i540)
            {
              std::string _key541;
              xfer += iprot->readString(_key541);
              int64_t& _val542 = this->backup_progress[_key541];
              xfer += iprot->readI64(_val542);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.backup_progress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->backup_image_offset.clear();
            uint32_t _size543;
            ::apache::thrift::protocol::TType _ktype544;
            ::apache::thrift::protocol::TType _vtype545;
            xfer += iprot->readMapBegin(_ktype544, _vtype545, _size543);
            uint32_t _i547;
            for (_i547 = 0; _i547 < _size543; ++_i547)
            {
              std::string _key548;
              xfer += iprot->readString(_key548);
              int64_t& _val549 = this->backup_image_offset[_key548];
              xfer += iprot->readI64(_val549);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.backup_image_offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->change_ids.clear();
            uint32_t _size550;
            ::apache::thrift::protocol::TType _ktype551;
            ::apache::thrift::protocol::TType _vtype552;
            xfer += iprot->readMapBegin(_ktype551, _vtype552, _size550);
            uint32_t _i554;
            for (_i554 = 0; _i554 < _size550; ++_i554)
            {
              std::string _key555;
              xfer += iprot->readString(_key555);
              std::string& _val556 = this->change_ids[_key555];
              xfer += iprot->readString(_val556);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.change_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast557;
          xfer += iprot->readI32(ecast557);
          this->guest_os_type = (hv_guest_os_type::type)ecast557;
          this->__isset.guest_os_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->completed_blocks.clear();
            uint32_t _size558;
            ::apache::thrift::protocol::TType _ktype559;
            ::apache::thrift::protocol::TType _vtype560;
            xfer += iprot->readMapBegin(_ktype559, _vtype560, _size558);
            uint32_t _i562;
            for (_i562 = 0; _i562 < _size558; ++_i562)
            {
              std::string _key563;
              xfer += iprot->readString(_key563);
              std::vector<io_changed_range> & _val564 = this->completed_blocks[_key563];
              {
                _val564.clear();
                uint32_t _size565;
                ::apache::thrift::protocol::TType _etype568;
                xfer += iprot->readListBegin(_etype568, _size565);
                _val564.resize(_size565);
                uint32_t _i569;
                for (_i569 = 0; _i569 < _size565; ++_i569)
                {
                  xfer += _val564[_i569].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.completed_blocks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t virtual_packer_job_detail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("virtual_packer_job_detail");

  if (this->__isset.original_size) {
    xfer += oprot->writeFieldBegin("original_size", ::apache::thrift::protocol::T_MAP, 1);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->original_size.size()));
      std::map<std::string, int64_t> ::const_iterator _iter570;
      for (_iter570 = this->original_size.begin(); _iter570 != this->original_size.end(); ++_iter570)
      {
        xfer += oprot->writeString(_iter570->first);
        xfer += oprot->writeI64(_iter570->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.backup_size) {
    xfer += oprot->writeFieldBegin("backup_size", ::apache::thrift::protocol::T_MAP, 2);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->backup_size.size()));
      std::map<std::string, int64_t> ::const_iterator _iter571;
      for (_iter571 = this->backup_size.begin(); _iter571 != this->backup_size.end(); ++_iter571)
      {
        xfer += oprot->writeString(_iter571->first);
        xfer += oprot->writeI64(_iter571->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.backup_progress) {
    xfer += oprot->writeFieldBegin("backup_progress", ::apache::thrift::protocol::T_MAP, 3);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->backup_progress.size()));
      std::map<std::string, int64_t> ::const_iterator _iter572;
      for (_iter572 = this->backup_progress.begin(); _iter572 != this->backup_progress.end(); ++_iter572)
      {
        xfer += oprot->writeString(_iter572->first);
        xfer += oprot->writeI64(_iter572->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.backup_image_offset) {
    xfer += oprot->writeFieldBegin("backup_image_offset", ::apache::thrift::protocol::T_MAP, 4);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->backup_image_offset.size()));
      std::map<std::string, int64_t> ::const_iterator _iter573;
      for (_iter573 = this->backup_image_offset.begin(); _iter573 != this->backup_image_offset.end(); ++_iter573)
      {
        xfer += oprot->writeString(_iter573->first);
        xfer += oprot->writeI64(_iter573->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.change_ids) {
    xfer += oprot->writeFieldBegin("change_ids", ::apache::thrift::protocol::T_MAP, 5);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->change_ids.size()));
      std::map<std::string, std::string> ::const_iterator _iter574;
      for (_iter574 = this->change_ids.begin(); _iter574 != this->change_ids.end(); ++_iter574)
      {
        xfer += oprot->writeString(_iter574->first);
        xfer += oprot->writeString(_iter574->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.guest_os_type) {
    xfer += oprot->writeFieldBegin("guest_os_type", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32((int32_t)this->guest_os_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.completed_blocks) {
    xfer += oprot->writeFieldBegin("completed_blocks", ::apache::thrift::protocol::T_MAP, 7);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->completed_blocks.size()));
      std::map<std::string, std::vector<io_changed_range> > ::const_iterator _iter575;
      for (_iter575 = this->completed_blocks.begin(); _iter575 != this->completed_blocks.end(); ++_iter575)
      {
        xfer += oprot->writeString(_iter575->first);
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter575->second.size()));
          std::vector<io_changed_range> ::const_iterator _iter576;
          for (_iter576 = _iter575->second.begin(); _iter576 != _iter575->second.end(); ++_iter576)
          {
            xfer += (*_iter576).write(oprot);
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(virtual_packer_job_detail &a, virtual_packer_job_detail &b) {
  using ::std::swap;
  swap(a.original_size, b.original_size);
  swap(a.backup_size, b.backup_size);
  swap(a.backup_progress, b.backup_progress);
  swap(a.backup_image_offset, b.backup_image_offset);
  swap(a.change_ids, b.change_ids);
  swap(a.guest_os_type, b.guest_os_type);
  swap(a.completed_blocks, b.completed_blocks);
  swap(a.__isset, b.__isset);
}

virtual_packer_job_detail::virtual_packer_job_detail(const virtual_packer_job_detail& other577) {
  original_size = other577.original_size;
  backup_size = other577.backup_size;
  backup_progress = other577.backup_progress;
  backup_image_offset = other577.backup_image_offset;
  change_ids = other577.change_ids;
  guest_os_type = other577.guest_os_type;
  completed_blocks = other577.completed_blocks;
  __isset = other577.__isset;
}
virtual_packer_job_detail& virtual_packer_job_detail::operator=(const virtual_packer_job_detail& other578) {
  original_size = other578.original_size;
  backup_size = other578.backup_size;
  backup_progress = other578.backup_progress;
  backup_image_offset = other578.backup_image_offset;
  change_ids = other578.change_ids;
  guest_os_type = other578.guest_os_type;
  completed_blocks = other578.completed_blocks;
  __isset = other578.__isset;
  return *this;
}
void virtual_packer_job_detail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "virtual_packer_job_detail(";
  out << "original_size="; (__isset.original_size ? (out << to_string(original_size)) : (out << "<null>"));
  out << ", " << "backup_size="; (__isset.backup_size ? (out << to_string(backup_size)) : (out << "<null>"));
  out << ", " << "backup_progress="; (__isset.backup_progress ? (out << to_string(backup_progress)) : (out << "<null>"));
  out << ", " << "backup_image_offset="; (__isset.backup_image_offset ? (out << to_string(backup_image_offset)) : (out << "<null>"));
  out << ", " << "change_ids="; (__isset.change_ids ? (out << to_string(change_ids)) : (out << "<null>"));
  out << ", " << "guest_os_type="; (__isset.guest_os_type ? (out << to_string(guest_os_type)) : (out << "<null>"));
  out << ", " << "completed_blocks="; (__isset.completed_blocks ? (out << to_string(completed_blocks)) : (out << "<null>"));
  out << ")";
}


physical_packer_job_detail::~physical_packer_job_detail() throw() {
}


void physical_packer_job_detail::__set_original_size(const std::map<std::string, int64_t> & val) {
  this->original_size = val;
__isset.original_size = true;
}

void physical_packer_job_detail::__set_backup_size(const std::map<std::string, int64_t> & val) {
  this->backup_size = val;
__isset.backup_size = true;
}

void physical_packer_job_detail::__set_backup_progress(const std::map<std::string, int64_t> & val) {
  this->backup_progress = val;
__isset.backup_progress = true;
}

void physical_packer_job_detail::__set_backup_image_offset(const std::map<std::string, int64_t> & val) {
  this->backup_image_offset = val;
__isset.backup_image_offset = true;
}

void physical_packer_job_detail::__set_vcbt_journals(const std::map<int64_t, physical_vcbt_journal> & val) {
  this->vcbt_journals = val;
__isset.vcbt_journals = true;
}

void physical_packer_job_detail::__set_guest_os_type(const hv_guest_os_type::type val) {
  this->guest_os_type = val;
__isset.guest_os_type = true;
}

void physical_packer_job_detail::__set_cdr_changed_ranges(const std::map<std::string, std::vector<io_changed_range> > & val) {
  this->cdr_changed_ranges = val;
__isset.cdr_changed_ranges = true;
}

void physical_packer_job_detail::__set_completed_blocks(const std::map<std::string, std::vector<io_changed_range> > & val) {
  this->completed_blocks = val;
__isset.completed_blocks = true;
}

uint32_t physical_packer_job_detail::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->original_size.clear();
            uint32_t _size579;
            ::apache::thrift::protocol::TType _ktype580;
            ::apache::thrift::protocol::TType _vtype581;
            xfer += iprot->readMapBegin(_ktype580, _vtype581, _size579);
            uint32_t _i583;
            for (_i583 = 0; _i583 < _size579; ++_i583)
            {
              std::string _key584;
              xfer += iprot->readString(_key584);
              int64_t& _val585 = this->original_size[_key584];
              xfer += iprot->readI64(_val585);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.original_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->backup_size.clear();
            uint32_t _size586;
            ::apache::thrift::protocol::TType _ktype587;
            ::apache::thrift::protocol::TType _vtype588;
            xfer += iprot->readMapBegin(_ktype587, _vtype588, _size586);
            uint32_t _i590;
            for (_i590 = 0; _i590 < _size586; ++_i590)
            {
              std::string _key591;
              xfer += iprot->readString(_key591);
              int64_t& _val592 = this->backup_size[_key591];
              xfer += iprot->readI64(_val592);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.backup_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->backup_progress.clear();
            uint32_t _size593;
            ::apache::thrift::protocol::TType _ktype594;
            ::apache::thrift::protocol::TType _vtype595;
            xfer += iprot->readMapBegin(_ktype594, _vtype595, _size593);
            uint32_t _i597;
            for (_i597 = 0; _i597 < _size593; ++_i597)
            {
              std::string _key598;
              xfer += iprot->readString(_key598);
              int64_t& _val599 = this->backup_progress[_key598];
              xfer += iprot->readI64(_val599);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.backup_progress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->backup_image_offset.clear();
            uint32_t _size600;
            ::apache::thrift::protocol::TType _ktype601;
            ::apache::thrift::protocol::TType _vtype602;
            xfer += iprot->readMapBegin(_ktype601, _vtype602, _size600);
            uint32_t _i604;
            for (_i604 = 0; _i604 < _size600; ++_i604)
            {
              std::string _key605;
              xfer += iprot->readString(_key605);
              int64_t& _val606 = this->backup_image_offset[_key605];
              xfer += iprot->readI64(_val606);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.backup_image_offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->vcbt_journals.clear();
            uint32_t _size607;
            ::apache::thrift::protocol::TType _ktype608;
            ::apache::thrift::protocol::TType _vtype609;
            xfer += iprot->readMapBegin(_ktype608, _vtype609, _size607);
            uint32_t _i611;
            for (_i611 = 0; _i611 < _size607; ++_i611)
            {
              int64_t _key612;
              xfer += iprot->readI64(_key612);
              physical_vcbt_journal& _val613 = this->vcbt_journals[_key612];
              xfer += _val613.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.vcbt_journals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast614;
          xfer += iprot->readI32(ecast614);
          this->guest_os_type = (hv_guest_os_type::type)ecast614;
          this->__isset.guest_os_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->cdr_changed_ranges.clear();
            uint32_t _size615;
            ::apache::thrift::protocol::TType _ktype616;
            ::apache::thrift::protocol::TType _vtype617;
            xfer += iprot->readMapBegin(_ktype616, _vtype617, _size615);
            uint32_t _i619;
            for (_i619 = 0; _i619 < _size615; ++_i619)
            {
              std::string _key620;
              xfer += iprot->readString(_key620);
              std::vector<io_changed_range> & _val621 = this->cdr_changed_ranges[_key620];
              {
                _val621.clear();
                uint32_t _size622;
                ::apache::thrift::protocol::TType _etype625;
                xfer += iprot->readListBegin(_etype625, _size622);
                _val621.resize(_size622);
                uint32_t _i626;
                for (_i626 = 0; _i626 < _size622; ++_i626)
                {
                  xfer += _val621[_i626].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.cdr_changed_ranges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->completed_blocks.clear();
            uint32_t _size627;
            ::apache::thrift::protocol::TType _ktype628;
            ::apache::thrift::protocol::TType _vtype629;
            xfer += iprot->readMapBegin(_ktype628, _vtype629, _size627);
            uint32_t _i631;
            for (_i631 = 0; _i631 < _size627; ++_i631)
            {
              std::string _key632;
              xfer += iprot->readString(_key632);
              std::vector<io_changed_range> & _val633 = this->completed_blocks[_key632];
              {
                _val633.clear();
                uint32_t _size634;
                ::apache::thrift::protocol::TType _etype637;
                xfer += iprot->readListBegin(_etype637, _size634);
                _val633.resize(_size634);
                uint32_t _i638;
                for (_i638 = 0; _i638 < _size634; ++_i638)
                {
                  xfer += _val633[_i638].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.completed_blocks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_job_detail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_job_detail");

  if (this->__isset.original_size) {
    xfer += oprot->writeFieldBegin("original_size", ::apache::thrift::protocol::T_MAP, 1);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->original_size.size()));
      std::map<std::string, int64_t> ::const_iterator _iter639;
      for (_iter639 = this->original_size.begin(); _iter639 != this->original_size.end(); ++_iter639)
      {
        xfer += oprot->writeString(_iter639->first);
        xfer += oprot->writeI64(_iter639->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.backup_size) {
    xfer += oprot->writeFieldBegin("backup_size", ::apache::thrift::protocol::T_MAP, 2);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->backup_size.size()));
      std::map<std::string, int64_t> ::const_iterator _iter640;
      for (_iter640 = this->backup_size.begin(); _iter640 != this->backup_size.end(); ++_iter640)
      {
        xfer += oprot->writeString(_iter640->first);
        xfer += oprot->writeI64(_iter640->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.backup_progress) {
    xfer += oprot->writeFieldBegin("backup_progress", ::apache::thrift::protocol::T_MAP, 3);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->backup_progress.size()));
      std::map<std::string, int64_t> ::const_iterator _iter641;
      for (_iter641 = this->backup_progress.begin(); _iter641 != this->backup_progress.end(); ++_iter641)
      {
        xfer += oprot->writeString(_iter641->first);
        xfer += oprot->writeI64(_iter641->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.backup_image_offset) {
    xfer += oprot->writeFieldBegin("backup_image_offset", ::apache::thrift::protocol::T_MAP, 4);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->backup_image_offset.size()));
      std::map<std::string, int64_t> ::const_iterator _iter642;
      for (_iter642 = this->backup_image_offset.begin(); _iter642 != this->backup_image_offset.end(); ++_iter642)
      {
        xfer += oprot->writeString(_iter642->first);
        xfer += oprot->writeI64(_iter642->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vcbt_journals) {
    xfer += oprot->writeFieldBegin("vcbt_journals", ::apache::thrift::protocol::T_MAP, 5);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I64, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->vcbt_journals.size()));
      std::map<int64_t, physical_vcbt_journal> ::const_iterator _iter643;
      for (_iter643 = this->vcbt_journals.begin(); _iter643 != this->vcbt_journals.end(); ++_iter643)
      {
        xfer += oprot->writeI64(_iter643->first);
        xfer += _iter643->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.guest_os_type) {
    xfer += oprot->writeFieldBegin("guest_os_type", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32((int32_t)this->guest_os_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cdr_changed_ranges) {
    xfer += oprot->writeFieldBegin("cdr_changed_ranges", ::apache::thrift::protocol::T_MAP, 7);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->cdr_changed_ranges.size()));
      std::map<std::string, std::vector<io_changed_range> > ::const_iterator _iter644;
      for (_iter644 = this->cdr_changed_ranges.begin(); _iter644 != this->cdr_changed_ranges.end(); ++_iter644)
      {
        xfer += oprot->writeString(_iter644->first);
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter644->second.size()));
          std::vector<io_changed_range> ::const_iterator _iter645;
          for (_iter645 = _iter644->second.begin(); _iter645 != _iter644->second.end(); ++_iter645)
          {
            xfer += (*_iter645).write(oprot);
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.completed_blocks) {
    xfer += oprot->writeFieldBegin("completed_blocks", ::apache::thrift::protocol::T_MAP, 8);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->completed_blocks.size()));
      std::map<std::string, std::vector<io_changed_range> > ::const_iterator _iter646;
      for (_iter646 = this->completed_blocks.begin(); _iter646 != this->completed_blocks.end(); ++_iter646)
      {
        xfer += oprot->writeString(_iter646->first);
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter646->second.size()));
          std::vector<io_changed_range> ::const_iterator _iter647;
          for (_iter647 = _iter646->second.begin(); _iter647 != _iter646->second.end(); ++_iter647)
          {
            xfer += (*_iter647).write(oprot);
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(physical_packer_job_detail &a, physical_packer_job_detail &b) {
  using ::std::swap;
  swap(a.original_size, b.original_size);
  swap(a.backup_size, b.backup_size);
  swap(a.backup_progress, b.backup_progress);
  swap(a.backup_image_offset, b.backup_image_offset);
  swap(a.vcbt_journals, b.vcbt_journals);
  swap(a.guest_os_type, b.guest_os_type);
  swap(a.cdr_changed_ranges, b.cdr_changed_ranges);
  swap(a.completed_blocks, b.completed_blocks);
  swap(a.__isset, b.__isset);
}

physical_packer_job_detail::physical_packer_job_detail(const physical_packer_job_detail& other648) {
  original_size = other648.original_size;
  backup_size = other648.backup_size;
  backup_progress = other648.backup_progress;
  backup_image_offset = other648.backup_image_offset;
  vcbt_journals = other648.vcbt_journals;
  guest_os_type = other648.guest_os_type;
  cdr_changed_ranges = other648.cdr_changed_ranges;
  completed_blocks = other648.completed_blocks;
  __isset = other648.__isset;
}
physical_packer_job_detail& physical_packer_job_detail::operator=(const physical_packer_job_detail& other649) {
  original_size = other649.original_size;
  backup_size = other649.backup_size;
  backup_progress = other649.backup_progress;
  backup_image_offset = other649.backup_image_offset;
  vcbt_journals = other649.vcbt_journals;
  guest_os_type = other649.guest_os_type;
  cdr_changed_ranges = other649.cdr_changed_ranges;
  completed_blocks = other649.completed_blocks;
  __isset = other649.__isset;
  return *this;
}
void physical_packer_job_detail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "physical_packer_job_detail(";
  out << "original_size="; (__isset.original_size ? (out << to_string(original_size)) : (out << "<null>"));
  out << ", " << "backup_size="; (__isset.backup_size ? (out << to_string(backup_size)) : (out << "<null>"));
  out << ", " << "backup_progress="; (__isset.backup_progress ? (out << to_string(backup_progress)) : (out << "<null>"));
  out << ", " << "backup_image_offset="; (__isset.backup_image_offset ? (out << to_string(backup_image_offset)) : (out << "<null>"));
  out << ", " << "vcbt_journals="; (__isset.vcbt_journals ? (out << to_string(vcbt_journals)) : (out << "<null>"));
  out << ", " << "guest_os_type="; (__isset.guest_os_type ? (out << to_string(guest_os_type)) : (out << "<null>"));
  out << ", " << "cdr_changed_ranges="; (__isset.cdr_changed_ranges ? (out << to_string(cdr_changed_ranges)) : (out << "<null>"));
  out << ", " << "completed_blocks="; (__isset.completed_blocks ? (out << to_string(completed_blocks)) : (out << "<null>"));
  out << ")";
}


_packer_job_detail::~_packer_job_detail() throw() {
}


void _packer_job_detail::__set_p(const physical_packer_job_detail& val) {
  this->p = val;
__isset.p = true;
}

void _packer_job_detail::__set_v(const virtual_packer_job_detail& val) {
  this->v = val;
__isset.v = true;
}

uint32_t _packer_job_detail::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->p.read(iprot);
          this->__isset.p = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->v.read(iprot);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t _packer_job_detail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("_packer_job_detail");

  if (this->__isset.p) {
    xfer += oprot->writeFieldBegin("p", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->p.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.v) {
    xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->v.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(_packer_job_detail &a, _packer_job_detail &b) {
  using ::std::swap;
  swap(a.p, b.p);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

_packer_job_detail::_packer_job_detail(const _packer_job_detail& other650) {
  p = other650.p;
  v = other650.v;
  __isset = other650.__isset;
}
_packer_job_detail& _packer_job_detail::operator=(const _packer_job_detail& other651) {
  p = other651.p;
  v = other651.v;
  __isset = other651.__isset;
  return *this;
}
void _packer_job_detail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "_packer_job_detail(";
  out << "p="; (__isset.p ? (out << to_string(p)) : (out << "<null>"));
  out << ", " << "v="; (__isset.v ? (out << to_string(v)) : (out << "<null>"));
  out << ")";
}


packer_job_detail::~packer_job_detail() throw() {
}


void packer_job_detail::__set_id(const std::string& val) {
  this->id = val;
__isset.id = true;
}

void packer_job_detail::__set_type(const job_type::type val) {
  this->type = val;
__isset.type = true;
}

void packer_job_detail::__set_state(const job_state::type val) {
  this->state = val;
__isset.state = true;
}

void packer_job_detail::__set_created_time(const std::string& val) {
  this->created_time = val;
__isset.created_time = true;
}

void packer_job_detail::__set_updated_time(const std::string& val) {
  this->updated_time = val;
__isset.updated_time = true;
}

void packer_job_detail::__set_histories(const std::vector<job_history> & val) {
  this->histories = val;
__isset.histories = true;
}

void packer_job_detail::__set_detail(const _packer_job_detail& val) {
  this->detail = val;
__isset.detail = true;
}

void packer_job_detail::__set_is_error(const bool val) {
  this->is_error = val;
__isset.is_error = true;
}

void packer_job_detail::__set_boot_disk(const std::string& val) {
  this->boot_disk = val;
__isset.boot_disk = true;
}

void packer_job_detail::__set_system_disks(const std::vector<std::string> & val) {
  this->system_disks = val;
__isset.system_disks = true;
}

void packer_job_detail::__set_completed_blocks(const std::map<std::string, std::vector<io_changed_range> > & val) {
  this->completed_blocks = val;
__isset.completed_blocks = true;
}

uint32_t packer_job_detail::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast652;
          xfer += iprot->readI32(ecast652);
          this->type = (job_type::type)ecast652;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast653;
          xfer += iprot->readI32(ecast653);
          this->state = (job_state::type)ecast653;
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->created_time);
          this->__isset.created_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->updated_time);
          this->__isset.updated_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->histories.clear();
            uint32_t _size654;
            ::apache::thrift::protocol::TType _etype657;
            xfer += iprot->readListBegin(_etype657, _size654);
            this->histories.resize(_size654);
            uint32_t _i658;
            for (_i658 = 0; _i658 < _size654; ++_i658)
            {
              xfer += this->histories[_i658].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.histories = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->detail.read(iprot);
          this->__isset.detail = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_error);
          this->__isset.is_error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->boot_disk);
          this->__isset.boot_disk = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->system_disks.clear();
            uint32_t _size659;
            ::apache::thrift::protocol::TType _etype662;
            xfer += iprot->readListBegin(_etype662, _size659);
            this->system_disks.resize(_size659);
            uint32_t _i663;
            for (_i663 = 0; _i663 < _size659; ++_i663)
            {
              xfer += iprot->readString(this->system_disks[_i663]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.system_disks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->completed_blocks.clear();
            uint32_t _size664;
            ::apache::thrift::protocol::TType _ktype665;
            ::apache::thrift::protocol::TType _vtype666;
            xfer += iprot->readMapBegin(_ktype665, _vtype666, _size664);
            uint32_t _i668;
            for (_i668 = 0; _i668 < _size664; ++_i668)
            {
              std::string _key669;
              xfer += iprot->readString(_key669);
              std::vector<io_changed_range> & _val670 = this->completed_blocks[_key669];
              {
                _val670.clear();
                uint32_t _size671;
                ::apache::thrift::protocol::TType _etype674;
                xfer += iprot->readListBegin(_etype674, _size671);
                _val670.resize(_size671);
                uint32_t _i675;
                for (_i675 = 0; _i675 < _size671; ++_i675)
                {
                  xfer += _val670[_i675].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.completed_blocks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t packer_job_detail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("packer_job_detail");

  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.type) {
    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32((int32_t)this->type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.state) {
    xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32((int32_t)this->state);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.created_time) {
    xfer += oprot->writeFieldBegin("created_time", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->created_time);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.updated_time) {
    xfer += oprot->writeFieldBegin("updated_time", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->updated_time);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.histories) {
    xfer += oprot->writeFieldBegin("histories", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->histories.size()));
      std::vector<job_history> ::const_iterator _iter676;
      for (_iter676 = this->histories.begin(); _iter676 != this->histories.end(); ++_iter676)
      {
        xfer += (*_iter676).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.detail) {
    xfer += oprot->writeFieldBegin("detail", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->detail.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_error) {
    xfer += oprot->writeFieldBegin("is_error", ::apache::thrift::protocol::T_BOOL, 8);
    xfer += oprot->writeBool(this->is_error);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.boot_disk) {
    xfer += oprot->writeFieldBegin("boot_disk", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->boot_disk);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.system_disks) {
    xfer += oprot->writeFieldBegin("system_disks", ::apache::thrift::protocol::T_LIST, 10);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->system_disks.size()));
      std::vector<std::string> ::const_iterator _iter677;
      for (_iter677 = this->system_disks.begin(); _iter677 != this->system_disks.end(); ++_iter677)
      {
        xfer += oprot->writeString((*_iter677));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.completed_blocks) {
    xfer += oprot->writeFieldBegin("completed_blocks", ::apache::thrift::protocol::T_MAP, 11);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->completed_blocks.size()));
      std::map<std::string, std::vector<io_changed_range> > ::const_iterator _iter678;
      for (_iter678 = this->completed_blocks.begin(); _iter678 != this->completed_blocks.end(); ++_iter678)
      {
        xfer += oprot->writeString(_iter678->first);
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter678->second.size()));
          std::vector<io_changed_range> ::const_iterator _iter679;
          for (_iter679 = _iter678->second.begin(); _iter679 != _iter678->second.end(); ++_iter679)
          {
            xfer += (*_iter679).write(oprot);
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(packer_job_detail &a, packer_job_detail &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.type, b.type);
  swap(a.state, b.state);
  swap(a.created_time, b.created_time);
  swap(a.updated_time, b.updated_time);
  swap(a.histories, b.histories);
  swap(a.detail, b.detail);
  swap(a.is_error, b.is_error);
  swap(a.boot_disk, b.boot_disk);
  swap(a.system_disks, b.system_disks);
  swap(a.completed_blocks, b.completed_blocks);
  swap(a.__isset, b.__isset);
}

packer_job_detail::packer_job_detail(const packer_job_detail& other680) {
  id = other680.id;
  type = other680.type;
  state = other680.state;
  created_time = other680.created_time;
  updated_time = other680.updated_time;
  histories = other680.histories;
  detail = other680.detail;
  is_error = other680.is_error;
  boot_disk = other680.boot_disk;
  system_disks = other680.system_disks;
  completed_blocks = other680.completed_blocks;
  __isset = other680.__isset;
}
packer_job_detail& packer_job_detail::operator=(const packer_job_detail& other681) {
  id = other681.id;
  type = other681.type;
  state = other681.state;
  created_time = other681.created_time;
  updated_time = other681.updated_time;
  histories = other681.histories;
  detail = other681.detail;
  is_error = other681.is_error;
  boot_disk = other681.boot_disk;
  system_disks = other681.system_disks;
  completed_blocks = other681.completed_blocks;
  __isset = other681.__isset;
  return *this;
}
void packer_job_detail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "packer_job_detail(";
  out << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "type="; (__isset.type ? (out << to_string(type)) : (out << "<null>"));
  out << ", " << "state="; (__isset.state ? (out << to_string(state)) : (out << "<null>"));
  out << ", " << "created_time="; (__isset.created_time ? (out << to_string(created_time)) : (out << "<null>"));
  out << ", " << "updated_time="; (__isset.updated_time ? (out << to_string(updated_time)) : (out << "<null>"));
  out << ", " << "histories="; (__isset.histories ? (out << to_string(histories)) : (out << "<null>"));
  out << ", " << "detail="; (__isset.detail ? (out << to_string(detail)) : (out << "<null>"));
  out << ", " << "is_error="; (__isset.is_error ? (out << to_string(is_error)) : (out << "<null>"));
  out << ", " << "boot_disk="; (__isset.boot_disk ? (out << to_string(boot_disk)) : (out << "<null>"));
  out << ", " << "system_disks="; (__isset.system_disks ? (out << to_string(system_disks)) : (out << "<null>"));
  out << ", " << "completed_blocks="; (__isset.completed_blocks ? (out << to_string(completed_blocks)) : (out << "<null>"));
  out << ")";
}


replica_job_detail::~replica_job_detail() throw() {
}


void replica_job_detail::__set_replica_id(const std::string& val) {
  this->replica_id = val;
__isset.replica_id = true;
}

void replica_job_detail::__set_host(const std::string& val) {
  this->host = val;
__isset.host = true;
}

void replica_job_detail::__set_id(const std::string& val) {
  this->id = val;
__isset.id = true;
}

void replica_job_detail::__set_type(const job_type::type val) {
  this->type = val;
__isset.type = true;
}

void replica_job_detail::__set_state(const job_state::type val) {
  this->state = val;
__isset.state = true;
}

void replica_job_detail::__set_is_error(const bool val) {
  this->is_error = val;
__isset.is_error = true;
}

void replica_job_detail::__set_created_time(const std::string& val) {
  this->created_time = val;
__isset.created_time = true;
}

void replica_job_detail::__set_updated_time(const std::string& val) {
  this->updated_time = val;
__isset.updated_time = true;
}

void replica_job_detail::__set_virtual_machine_id(const std::string& val) {
  this->virtual_machine_id = val;
__isset.virtual_machine_id = true;
}

void replica_job_detail::__set_disks(const std::set<std::string> & val) {
  this->disks = val;
__isset.disks = true;
}

void replica_job_detail::__set_connection_id(const std::string& val) {
  this->connection_id = val;
__isset.connection_id = true;
}

void replica_job_detail::__set_original_size(const std::map<std::string, int64_t> & val) {
  this->original_size = val;
__isset.original_size = true;
}

void replica_job_detail::__set_backup_progress(const std::map<std::string, int64_t> & val) {
  this->backup_progress = val;
__isset.backup_progress = true;
}

void replica_job_detail::__set_snapshot_mapping(const std::map<std::string, std::string> & val) {
  this->snapshot_mapping = val;
__isset.snapshot_mapping = true;
}

void replica_job_detail::__set_backup_size(const std::map<std::string, int64_t> & val) {
  this->backup_size = val;
__isset.backup_size = true;
}

void replica_job_detail::__set_backup_image_offset(const std::map<std::string, int64_t> & val) {
  this->backup_image_offset = val;
__isset.backup_image_offset = true;
}

void replica_job_detail::__set_cbt_info(const std::string& val) {
  this->cbt_info = val;
__isset.cbt_info = true;
}

void replica_job_detail::__set_histories(const std::vector<job_history> & val) {
  this->histories = val;
__isset.histories = true;
}

void replica_job_detail::__set_snapshot_time(const std::string& val) {
  this->snapshot_time = val;
__isset.snapshot_time = true;
}

void replica_job_detail::__set_snapshot_info(const std::string& val) {
  this->snapshot_info = val;
__isset.snapshot_info = true;
}

void replica_job_detail::__set_boot_disk(const std::string& val) {
  this->boot_disk = val;
__isset.boot_disk = true;
}

void replica_job_detail::__set_system_disks(const std::vector<std::string> & val) {
  this->system_disks = val;
__isset.system_disks = true;
}

void replica_job_detail::__set_is_pending_rerun(const bool val) {
  this->is_pending_rerun = val;
__isset.is_pending_rerun = true;
}

void replica_job_detail::__set_is_cdr(const bool val) {
  this->is_cdr = val;
__isset.is_cdr = true;
}

uint32_t replica_job_detail::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->replica_id);
          this->__isset.replica_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host);
          this->__isset.host = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast682;
          xfer += iprot->readI32(ecast682);
          this->type = (job_type::type)ecast682;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast683;
          xfer += iprot->readI32(ecast683);
          this->state = (job_state::type)ecast683;
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_error);
          this->__isset.is_error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->created_time);
          this->__isset.created_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->updated_time);
          this->__isset.updated_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->virtual_machine_id);
          this->__isset.virtual_machine_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->disks.clear();
            uint32_t _size684;
            ::apache::thrift::protocol::TType _etype687;
            xfer += iprot->readSetBegin(_etype687, _size684);
            uint32_t _i688;
            for (_i688 = 0; _i688 < _size684; ++_i688)
            {
              std::string _elem689;
              xfer += iprot->readString(_elem689);
              this->disks.insert(_elem689);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.disks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->connection_id);
          this->__isset.connection_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->original_size.clear();
            uint32_t _size690;
            ::apache::thrift::protocol::TType _ktype691;
            ::apache::thrift::protocol::TType _vtype692;
            xfer += iprot->readMapBegin(_ktype691, _vtype692, _size690);
            uint32_t _i694;
            for (_i694 = 0; _i694 < _size690; ++_i694)
            {
              std::string _key695;
              xfer += iprot->readString(_key695);
              int64_t& _val696 = this->original_size[_key695];
              xfer += iprot->readI64(_val696);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.original_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->backup_progress.clear();
            uint32_t _size697;
            ::apache::thrift::protocol::TType _ktype698;
            ::apache::thrift::protocol::TType _vtype699;
            xfer += iprot->readMapBegin(_ktype698, _vtype699, _size697);
            uint32_t _i701;
            for (_i701 = 0; _i701 < _size697; ++_i701)
            {
              std::string _key702;
              xfer += iprot->readString(_key702);
              int64_t& _val703 = this->backup_progress[_key702];
              xfer += iprot->readI64(_val703);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.backup_progress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->snapshot_mapping.clear();
            uint32_t _size704;
            ::apache::thrift::protocol::TType _ktype705;
            ::apache::thrift::protocol::TType _vtype706;
            xfer += iprot->readMapBegin(_ktype705, _vtype706, _size704);
            uint32_t _i708;
            for (_i708 = 0; _i708 < _size704; ++_i708)
            {
              std::string _key709;
              xfer += iprot->readString(_key709);
              std::string& _val710 = this->snapshot_mapping[_key709];
              xfer += iprot->readString(_val710);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.snapshot_mapping = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->backup_size.clear();
            uint32_t _size711;
            ::apache::thrift::protocol::TType _ktype712;
            ::apache::thrift::protocol::TType _vtype713;
            xfer += iprot->readMapBegin(_ktype712, _vtype713, _size711);
            uint32_t _i715;
            for (_i715 = 0; _i715 < _size711; ++_i715)
            {
              std::string _key716;
              xfer += iprot->readString(_key716);
              int64_t& _val717 = this->backup_size[_key716];
              xfer += iprot->readI64(_val717);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.backup_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->backup_image_offset.clear();
            uint32_t _size718;
            ::apache::thrift::protocol::TType _ktype719;
            ::apache::thrift::protocol::TType _vtype720;
            xfer += iprot->readMapBegin(_ktype719, _vtype720, _size718);
            uint32_t _i722;
            for (_i722 = 0; _i722 < _size718; ++_i722)
            {
              std::string _key723;
              xfer += iprot->readString(_key723);
              int64_t& _val724 = this->backup_image_offset[_key723];
              xfer += iprot->readI64(_val724);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.backup_image_offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cbt_info);
          this->__isset.cbt_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->histories.clear();
            uint32_t _size725;
            ::apache::thrift::protocol::TType _etype728;
            xfer += iprot->readListBegin(_etype728, _size725);
            this->histories.resize(_size725);
            uint32_t _i729;
            for (_i729 = 0; _i729 < _size725; ++_i729)
            {
              xfer += this->histories[_i729].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.histories = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->snapshot_time);
          this->__isset.snapshot_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->snapshot_info);
          this->__isset.snapshot_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->boot_disk);
          this->__isset.boot_disk = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->system_disks.clear();
            uint32_t _size730;
            ::apache::thrift::protocol::TType _etype733;
            xfer += iprot->readListBegin(_etype733, _size730);
            this->system_disks.resize(_size730);
            uint32_t _i734;
            for (_i734 = 0; _i734 < _size730; ++_i734)
            {
              xfer += iprot->readString(this->system_disks[_i734]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.system_disks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_pending_rerun);
          this->__isset.is_pending_rerun = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_cdr);
          this->__isset.is_cdr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t replica_job_detail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("replica_job_detail");

  if (this->__isset.replica_id) {
    xfer += oprot->writeFieldBegin("replica_id", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->replica_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.host) {
    xfer += oprot->writeFieldBegin("host", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->host);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.type) {
    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32((int32_t)this->type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.state) {
    xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32((int32_t)this->state);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_error) {
    xfer += oprot->writeFieldBegin("is_error", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->is_error);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.created_time) {
    xfer += oprot->writeFieldBegin("created_time", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->created_time);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.updated_time) {
    xfer += oprot->writeFieldBegin("updated_time", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->updated_time);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.virtual_machine_id) {
    xfer += oprot->writeFieldBegin("virtual_machine_id", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->virtual_machine_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.disks) {
    xfer += oprot->writeFieldBegin("disks", ::apache::thrift::protocol::T_SET, 10);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->disks.size()));
      std::set<std::string> ::const_iterator _iter735;
      for (_iter735 = this->disks.begin(); _iter735 != this->disks.end(); ++_iter735)
      {
        xfer += oprot->writeString((*_iter735));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.connection_id) {
    xfer += oprot->writeFieldBegin("connection_id", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeString(this->connection_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.original_size) {
    xfer += oprot->writeFieldBegin("original_size", ::apache::thrift::protocol::T_MAP, 12);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->original_size.size()));
      std::map<std::string, int64_t> ::const_iterator _iter736;
      for (_iter736 = this->original_size.begin(); _iter736 != this->original_size.end(); ++_iter736)
      {
        xfer += oprot->writeString(_iter736->first);
        xfer += oprot->writeI64(_iter736->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.backup_progress) {
    xfer += oprot->writeFieldBegin("backup_progress", ::apache::thrift::protocol::T_MAP, 13);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->backup_progress.size()));
      std::map<std::string, int64_t> ::const_iterator _iter737;
      for (_iter737 = this->backup_progress.begin(); _iter737 != this->backup_progress.end(); ++_iter737)
      {
        xfer += oprot->writeString(_iter737->first);
        xfer += oprot->writeI64(_iter737->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.snapshot_mapping) {
    xfer += oprot->writeFieldBegin("snapshot_mapping", ::apache::thrift::protocol::T_MAP, 14);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->snapshot_mapping.size()));
      std::map<std::string, std::string> ::const_iterator _iter738;
      for (_iter738 = this->snapshot_mapping.begin(); _iter738 != this->snapshot_mapping.end(); ++_iter738)
      {
        xfer += oprot->writeString(_iter738->first);
        xfer += oprot->writeString(_iter738->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.backup_size) {
    xfer += oprot->writeFieldBegin("backup_size", ::apache::thrift::protocol::T_MAP, 15);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->backup_size.size()));
      std::map<std::string, int64_t> ::const_iterator _iter739;
      for (_iter739 = this->backup_size.begin(); _iter739 != this->backup_size.end(); ++_iter739)
      {
        xfer += oprot->writeString(_iter739->first);
        xfer += oprot->writeI64(_iter739->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.backup_image_offset) {
    xfer += oprot->writeFieldBegin("backup_image_offset", ::apache::thrift::protocol::T_MAP, 16);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->backup_image_offset.size()));
      std::map<std::string, int64_t> ::const_iterator _iter740;
      for (_iter740 = this->backup_image_offset.begin(); _iter740 != this->backup_image_offset.end(); ++_iter740)
      {
        xfer += oprot->writeString(_iter740->first);
        xfer += oprot->writeI64(_iter740->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cbt_info) {
    xfer += oprot->writeFieldBegin("cbt_info", ::apache::thrift::protocol::T_STRING, 17);
    xfer += oprot->writeString(this->cbt_info);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.histories) {
    xfer += oprot->writeFieldBegin("histories", ::apache::thrift::protocol::T_LIST, 18);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->histories.size()));
      std::vector<job_history> ::const_iterator _iter741;
      for (_iter741 = this->histories.begin(); _iter741 != this->histories.end(); ++_iter741)
      {
        xfer += (*_iter741).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.snapshot_time) {
    xfer += oprot->writeFieldBegin("snapshot_time", ::apache::thrift::protocol::T_STRING, 19);
    xfer += oprot->writeString(this->snapshot_time);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.snapshot_info) {
    xfer += oprot->writeFieldBegin("snapshot_info", ::apache::thrift::protocol::T_STRING, 20);
    xfer += oprot->writeString(this->snapshot_info);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.boot_disk) {
    xfer += oprot->writeFieldBegin("boot_disk", ::apache::thrift::protocol::T_STRING, 21);
    xfer += oprot->writeString(this->boot_disk);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.system_disks) {
    xfer += oprot->writeFieldBegin("system_disks", ::apache::thrift::protocol::T_LIST, 22);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->system_disks.size()));
      std::vector<std::string> ::const_iterator _iter742;
      for (_iter742 = this->system_disks.begin(); _iter742 != this->system_disks.end(); ++_iter742)
      {
        xfer += oprot->writeString((*_iter742));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_pending_rerun) {
    xfer += oprot->writeFieldBegin("is_pending_rerun", ::apache::thrift::protocol::T_BOOL, 23);
    xfer += oprot->writeBool(this->is_pending_rerun);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_cdr) {
    xfer += oprot->writeFieldBegin("is_cdr", ::apache::thrift::protocol::T_BOOL, 24);
    xfer += oprot->writeBool(this->is_cdr);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(replica_job_detail &a, replica_job_detail &b) {
  using ::std::swap;
  swap(a.replica_id, b.replica_id);
  swap(a.host, b.host);
  swap(a.id, b.id);
  swap(a.type, b.type);
  swap(a.state, b.state);
  swap(a.is_error, b.is_error);
  swap(a.created_time, b.created_time);
  swap(a.updated_time, b.updated_time);
  swap(a.virtual_machine_id, b.virtual_machine_id);
  swap(a.disks, b.disks);
  swap(a.connection_id, b.connection_id);
  swap(a.original_size, b.original_size);
  swap(a.backup_progress, b.backup_progress);
  swap(a.snapshot_mapping, b.snapshot_mapping);
  swap(a.backup_size, b.backup_size);
  swap(a.backup_image_offset, b.backup_image_offset);
  swap(a.cbt_info, b.cbt_info);
  swap(a.histories, b.histories);
  swap(a.snapshot_time, b.snapshot_time);
  swap(a.snapshot_info, b.snapshot_info);
  swap(a.boot_disk, b.boot_disk);
  swap(a.system_disks, b.system_disks);
  swap(a.is_pending_rerun, b.is_pending_rerun);
  swap(a.is_cdr, b.is_cdr);
  swap(a.__isset, b.__isset);
}

replica_job_detail::replica_job_detail(const replica_job_detail& other743) {
  replica_id = other743.replica_id;
  host = other743.host;
  id = other743.id;
  type = other743.type;
  state = other743.state;
  is_error = other743.is_error;
  created_time = other743.created_time;
  updated_time = other743.updated_time;
  virtual_machine_id = other743.virtual_machine_id;
  disks = other743.disks;
  connection_id = other743.connection_id;
  original_size = other743.original_size;
  backup_progress = other743.backup_progress;
  snapshot_mapping = other743.snapshot_mapping;
  backup_size = other743.backup_size;
  backup_image_offset = other743.backup_image_offset;
  cbt_info = other743.cbt_info;
  histories = other743.histories;
  snapshot_time = other743.snapshot_time;
  snapshot_info = other743.snapshot_info;
  boot_disk = other743.boot_disk;
  system_disks = other743.system_disks;
  is_pending_rerun = other743.is_pending_rerun;
  is_cdr = other743.is_cdr;
  __isset = other743.__isset;
}
replica_job_detail& replica_job_detail::operator=(const replica_job_detail& other744) {
  replica_id = other744.replica_id;
  host = other744.host;
  id = other744.id;
  type = other744.type;
  state = other744.state;
  is_error = other744.is_error;
  created_time = other744.created_time;
  updated_time = other744.updated_time;
  virtual_machine_id = other744.virtual_machine_id;
  disks = other744.disks;
  connection_id = other744.connection_id;
  original_size = other744.original_size;
  backup_progress = other744.backup_progress;
  snapshot_mapping = other744.snapshot_mapping;
  backup_size = other744.backup_size;
  backup_image_offset = other744.backup_image_offset;
  cbt_info = other744.cbt_info;
  histories = other744.histories;
  snapshot_time = other744.snapshot_time;
  snapshot_info = other744.snapshot_info;
  boot_disk = other744.boot_disk;
  system_disks = other744.system_disks;
  is_pending_rerun = other744.is_pending_rerun;
  is_cdr = other744.is_cdr;
  __isset = other744.__isset;
  return *this;
}
void replica_job_detail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "replica_job_detail(";
  out << "replica_id="; (__isset.replica_id ? (out << to_string(replica_id)) : (out << "<null>"));
  out << ", " << "host="; (__isset.host ? (out << to_string(host)) : (out << "<null>"));
  out << ", " << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "type="; (__isset.type ? (out << to_string(type)) : (out << "<null>"));
  out << ", " << "state="; (__isset.state ? (out << to_string(state)) : (out << "<null>"));
  out << ", " << "is_error="; (__isset.is_error ? (out << to_string(is_error)) : (out << "<null>"));
  out << ", " << "created_time="; (__isset.created_time ? (out << to_string(created_time)) : (out << "<null>"));
  out << ", " << "updated_time="; (__isset.updated_time ? (out << to_string(updated_time)) : (out << "<null>"));
  out << ", " << "virtual_machine_id="; (__isset.virtual_machine_id ? (out << to_string(virtual_machine_id)) : (out << "<null>"));
  out << ", " << "disks="; (__isset.disks ? (out << to_string(disks)) : (out << "<null>"));
  out << ", " << "connection_id="; (__isset.connection_id ? (out << to_string(connection_id)) : (out << "<null>"));
  out << ", " << "original_size="; (__isset.original_size ? (out << to_string(original_size)) : (out << "<null>"));
  out << ", " << "backup_progress="; (__isset.backup_progress ? (out << to_string(backup_progress)) : (out << "<null>"));
  out << ", " << "snapshot_mapping="; (__isset.snapshot_mapping ? (out << to_string(snapshot_mapping)) : (out << "<null>"));
  out << ", " << "backup_size="; (__isset.backup_size ? (out << to_string(backup_size)) : (out << "<null>"));
  out << ", " << "backup_image_offset="; (__isset.backup_image_offset ? (out << to_string(backup_image_offset)) : (out << "<null>"));
  out << ", " << "cbt_info="; (__isset.cbt_info ? (out << to_string(cbt_info)) : (out << "<null>"));
  out << ", " << "histories="; (__isset.histories ? (out << to_string(histories)) : (out << "<null>"));
  out << ", " << "snapshot_time="; (__isset.snapshot_time ? (out << to_string(snapshot_time)) : (out << "<null>"));
  out << ", " << "snapshot_info="; (__isset.snapshot_info ? (out << to_string(snapshot_info)) : (out << "<null>"));
  out << ", " << "boot_disk="; (__isset.boot_disk ? (out << to_string(boot_disk)) : (out << "<null>"));
  out << ", " << "system_disks="; (__isset.system_disks ? (out << to_string(system_disks)) : (out << "<null>"));
  out << ", " << "is_pending_rerun="; (__isset.is_pending_rerun ? (out << to_string(is_pending_rerun)) : (out << "<null>"));
  out << ", " << "is_cdr="; (__isset.is_cdr ? (out << to_string(is_cdr)) : (out << "<null>"));
  out << ")";
}


service_info::~service_info() throw() {
}


void service_info::__set_id(const std::string& val) {
  this->id = val;
}

void service_info::__set_version(const std::string& val) {
  this->version = val;
}

void service_info::__set_path(const std::string& val) {
  this->path = val;
}

uint32_t service_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->path);
          this->__isset.path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t service_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("service_info");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(service_info &a, service_info &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.version, b.version);
  swap(a.path, b.path);
  swap(a.__isset, b.__isset);
}

service_info::service_info(const service_info& other745) {
  id = other745.id;
  version = other745.version;
  path = other745.path;
  __isset = other745.__isset;
}
service_info& service_info::operator=(const service_info& other746) {
  id = other746.id;
  version = other746.version;
  path = other746.path;
  __isset = other746.__isset;
  return *this;
}
void service_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "service_info(";
  out << "id=" << to_string(id);
  out << ", " << "version=" << to_string(version);
  out << ", " << "path=" << to_string(path);
  out << ")";
}


local_folder::~local_folder() throw() {
}


void local_folder::__set_path(const std::string& val) {
  this->path = val;
__isset.path = true;
}

uint32_t local_folder::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->path);
          this->__isset.path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t local_folder::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("local_folder");

  if (this->__isset.path) {
    xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->path);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(local_folder &a, local_folder &b) {
  using ::std::swap;
  swap(a.path, b.path);
  swap(a.__isset, b.__isset);
}

local_folder::local_folder(const local_folder& other747) {
  path = other747.path;
  __isset = other747.__isset;
}
local_folder& local_folder::operator=(const local_folder& other748) {
  path = other748.path;
  __isset = other748.__isset;
  return *this;
}
void local_folder::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "local_folder(";
  out << "path="; (__isset.path ? (out << to_string(path)) : (out << "<null>"));
  out << ")";
}


network_folder::~network_folder() throw() {
}


void network_folder::__set_path(const std::string& val) {
  this->path = val;
__isset.path = true;
}

void network_folder::__set_username(const std::string& val) {
  this->username = val;
__isset.username = true;
}

void network_folder::__set_password(const std::string& val) {
  this->password = val;
__isset.password = true;
}

void network_folder::__set_port(const int32_t val) {
  this->port = val;
__isset.port = true;
}

void network_folder::__set_proxy_host(const std::string& val) {
  this->proxy_host = val;
__isset.proxy_host = true;
}

void network_folder::__set_proxy_port(const int32_t val) {
  this->proxy_port = val;
__isset.proxy_port = true;
}

void network_folder::__set_proxy_username(const std::string& val) {
  this->proxy_username = val;
__isset.proxy_username = true;
}

void network_folder::__set_proxy_password(const std::string& val) {
  this->proxy_password = val;
__isset.proxy_password = true;
}

void network_folder::__set_s3_region(const aws_region::type val) {
  this->s3_region = val;
__isset.s3_region = true;
}

void network_folder::__set_timeout(const int32_t val) {
  this->timeout = val;
__isset.timeout = true;
}

uint32_t network_folder::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->path);
          this->__isset.path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->username);
          this->__isset.username = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->password);
          this->__isset.password = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->port);
          this->__isset.port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->proxy_host);
          this->__isset.proxy_host = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->proxy_port);
          this->__isset.proxy_port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->proxy_username);
          this->__isset.proxy_username = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->proxy_password);
          this->__isset.proxy_password = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast749;
          xfer += iprot->readI32(ecast749);
          this->s3_region = (aws_region::type)ecast749;
          this->__isset.s3_region = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->timeout);
          this->__isset.timeout = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t network_folder::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("network_folder");

  if (this->__isset.path) {
    xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->path);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.username) {
    xfer += oprot->writeFieldBegin("username", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->username);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.password) {
    xfer += oprot->writeFieldBegin("password", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->password);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.port) {
    xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->port);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.proxy_host) {
    xfer += oprot->writeFieldBegin("proxy_host", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->proxy_host);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.proxy_port) {
    xfer += oprot->writeFieldBegin("proxy_port", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(this->proxy_port);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.proxy_username) {
    xfer += oprot->writeFieldBegin("proxy_username", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->proxy_username);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.proxy_password) {
    xfer += oprot->writeFieldBegin("proxy_password", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->proxy_password);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.s3_region) {
    xfer += oprot->writeFieldBegin("s3_region", ::apache::thrift::protocol::T_I32, 9);
    xfer += oprot->writeI32((int32_t)this->s3_region);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timeout) {
    xfer += oprot->writeFieldBegin("timeout", ::apache::thrift::protocol::T_I32, 10);
    xfer += oprot->writeI32(this->timeout);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(network_folder &a, network_folder &b) {
  using ::std::swap;
  swap(a.path, b.path);
  swap(a.username, b.username);
  swap(a.password, b.password);
  swap(a.port, b.port);
  swap(a.proxy_host, b.proxy_host);
  swap(a.proxy_port, b.proxy_port);
  swap(a.proxy_username, b.proxy_username);
  swap(a.proxy_password, b.proxy_password);
  swap(a.s3_region, b.s3_region);
  swap(a.timeout, b.timeout);
  swap(a.__isset, b.__isset);
}

network_folder::network_folder(const network_folder& other750) {
  path = other750.path;
  username = other750.username;
  password = other750.password;
  port = other750.port;
  proxy_host = other750.proxy_host;
  proxy_port = other750.proxy_port;
  proxy_username = other750.proxy_username;
  proxy_password = other750.proxy_password;
  s3_region = other750.s3_region;
  timeout = other750.timeout;
  __isset = other750.__isset;
}
network_folder& network_folder::operator=(const network_folder& other751) {
  path = other751.path;
  username = other751.username;
  password = other751.password;
  port = other751.port;
  proxy_host = other751.proxy_host;
  proxy_port = other751.proxy_port;
  proxy_username = other751.proxy_username;
  proxy_password = other751.proxy_password;
  s3_region = other751.s3_region;
  timeout = other751.timeout;
  __isset = other751.__isset;
  return *this;
}
void network_folder::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "network_folder(";
  out << "path="; (__isset.path ? (out << to_string(path)) : (out << "<null>"));
  out << ", " << "username="; (__isset.username ? (out << to_string(username)) : (out << "<null>"));
  out << ", " << "password="; (__isset.password ? (out << to_string(password)) : (out << "<null>"));
  out << ", " << "port="; (__isset.port ? (out << to_string(port)) : (out << "<null>"));
  out << ", " << "proxy_host="; (__isset.proxy_host ? (out << to_string(proxy_host)) : (out << "<null>"));
  out << ", " << "proxy_port="; (__isset.proxy_port ? (out << to_string(proxy_port)) : (out << "<null>"));
  out << ", " << "proxy_username="; (__isset.proxy_username ? (out << to_string(proxy_username)) : (out << "<null>"));
  out << ", " << "proxy_password="; (__isset.proxy_password ? (out << to_string(proxy_password)) : (out << "<null>"));
  out << ", " << "s3_region="; (__isset.s3_region ? (out << to_string(s3_region)) : (out << "<null>"));
  out << ", " << "timeout="; (__isset.timeout ? (out << to_string(timeout)) : (out << "<null>"));
  out << ")";
}


_detail::~_detail() throw() {
}


void _detail::__set_local(const local_folder& val) {
  this->local = val;
}

void _detail::__set_remote(const network_folder& val) {
  this->remote = val;
}

uint32_t _detail::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->local.read(iprot);
          this->__isset.local = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->remote.read(iprot);
          this->__isset.remote = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t _detail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("_detail");

  xfer += oprot->writeFieldBegin("local", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->local.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("remote", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->remote.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(_detail &a, _detail &b) {
  using ::std::swap;
  swap(a.local, b.local);
  swap(a.remote, b.remote);
  swap(a.__isset, b.__isset);
}

_detail::_detail(const _detail& other752) {
  local = other752.local;
  remote = other752.remote;
  __isset = other752.__isset;
}
_detail& _detail::operator=(const _detail& other753) {
  local = other753.local;
  remote = other753.remote;
  __isset = other753.__isset;
  return *this;
}
void _detail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "_detail(";
  out << "local=" << to_string(local);
  out << ", " << "remote=" << to_string(remote);
  out << ")";
}


connection::~connection() throw() {
}


void connection::__set_type(const connection_type::type val) {
  this->type = val;
__isset.type = true;
}

void connection::__set_id(const std::string& val) {
  this->id = val;
__isset.id = true;
}

void connection::__set_options(const std::map<std::string, std::string> & val) {
  this->options = val;
__isset.options = true;
}

void connection::__set_compressed(const bool val) {
  this->compressed = val;
__isset.compressed = true;
}

void connection::__set_checksum(const bool val) {
  this->checksum = val;
__isset.checksum = true;
}

void connection::__set_encrypted(const bool val) {
  this->encrypted = val;
__isset.encrypted = true;
}

void connection::__set_detail(const _detail& val) {
  this->detail = val;
__isset.detail = true;
}

uint32_t connection::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast754;
          xfer += iprot->readI32(ecast754);
          this->type = (connection_type::type)ecast754;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->options.clear();
            uint32_t _size755;
            ::apache::thrift::protocol::TType _ktype756;
            ::apache::thrift::protocol::TType _vtype757;
            xfer += iprot->readMapBegin(_ktype756, _vtype757, _size755);
            uint32_t _i759;
            for (_i759 = 0; _i759 < _size755; ++_i759)
            {
              std::string _key760;
              xfer += iprot->readString(_key760);
              std::string& _val761 = this->options[_key760];
              xfer += iprot->readString(_val761);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->compressed);
          this->__isset.compressed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->checksum);
          this->__isset.checksum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->encrypted);
          this->__isset.encrypted = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->detail.read(iprot);
          this->__isset.detail = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t connection::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("connection");

  if (this->__isset.type) {
    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32((int32_t)this->type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.options) {
    xfer += oprot->writeFieldBegin("options", ::apache::thrift::protocol::T_MAP, 3);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->options.size()));
      std::map<std::string, std::string> ::const_iterator _iter762;
      for (_iter762 = this->options.begin(); _iter762 != this->options.end(); ++_iter762)
      {
        xfer += oprot->writeString(_iter762->first);
        xfer += oprot->writeString(_iter762->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.compressed) {
    xfer += oprot->writeFieldBegin("compressed", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->compressed);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.checksum) {
    xfer += oprot->writeFieldBegin("checksum", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->checksum);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.encrypted) {
    xfer += oprot->writeFieldBegin("encrypted", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->encrypted);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.detail) {
    xfer += oprot->writeFieldBegin("detail", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->detail.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(connection &a, connection &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.id, b.id);
  swap(a.options, b.options);
  swap(a.compressed, b.compressed);
  swap(a.checksum, b.checksum);
  swap(a.encrypted, b.encrypted);
  swap(a.detail, b.detail);
  swap(a.__isset, b.__isset);
}

connection::connection(const connection& other763) {
  type = other763.type;
  id = other763.id;
  options = other763.options;
  compressed = other763.compressed;
  checksum = other763.checksum;
  encrypted = other763.encrypted;
  detail = other763.detail;
  __isset = other763.__isset;
}
connection& connection::operator=(const connection& other764) {
  type = other764.type;
  id = other764.id;
  options = other764.options;
  compressed = other764.compressed;
  checksum = other764.checksum;
  encrypted = other764.encrypted;
  detail = other764.detail;
  __isset = other764.__isset;
  return *this;
}
void connection::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "connection(";
  out << "type="; (__isset.type ? (out << to_string(type)) : (out << "<null>"));
  out << ", " << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "options="; (__isset.options ? (out << to_string(options)) : (out << "<null>"));
  out << ", " << "compressed="; (__isset.compressed ? (out << to_string(compressed)) : (out << "<null>"));
  out << ", " << "checksum="; (__isset.checksum ? (out << to_string(checksum)) : (out << "<null>"));
  out << ", " << "encrypted="; (__isset.encrypted ? (out << to_string(encrypted)) : (out << "<null>"));
  out << ", " << "detail="; (__isset.detail ? (out << to_string(detail)) : (out << "<null>"));
  out << ")";
}


image_map_info::~image_map_info() throw() {
}


void image_map_info::__set_image(const std::string& val) {
  this->image = val;
__isset.image = true;
}

void image_map_info::__set_base_image(const std::string& val) {
  this->base_image = val;
__isset.base_image = true;
}

void image_map_info::__set_connection_ids(const std::set<std::string> & val) {
  this->connection_ids = val;
__isset.connection_ids = true;
}

uint32_t image_map_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->image);
          this->__isset.image = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->base_image);
          this->__isset.base_image = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->connection_ids.clear();
            uint32_t _size765;
            ::apache::thrift::protocol::TType _etype768;
            xfer += iprot->readSetBegin(_etype768, _size765);
            uint32_t _i769;
            for (_i769 = 0; _i769 < _size765; ++_i769)
            {
              std::string _elem770;
              xfer += iprot->readString(_elem770);
              this->connection_ids.insert(_elem770);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.connection_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t image_map_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("image_map_info");

  if (this->__isset.image) {
    xfer += oprot->writeFieldBegin("image", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->image);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.base_image) {
    xfer += oprot->writeFieldBegin("base_image", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->base_image);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.connection_ids) {
    xfer += oprot->writeFieldBegin("connection_ids", ::apache::thrift::protocol::T_SET, 3);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->connection_ids.size()));
      std::set<std::string> ::const_iterator _iter771;
      for (_iter771 = this->connection_ids.begin(); _iter771 != this->connection_ids.end(); ++_iter771)
      {
        xfer += oprot->writeString((*_iter771));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(image_map_info &a, image_map_info &b) {
  using ::std::swap;
  swap(a.image, b.image);
  swap(a.base_image, b.base_image);
  swap(a.connection_ids, b.connection_ids);
  swap(a.__isset, b.__isset);
}

image_map_info::image_map_info(const image_map_info& other772) {
  image = other772.image;
  base_image = other772.base_image;
  connection_ids = other772.connection_ids;
  __isset = other772.__isset;
}
image_map_info& image_map_info::operator=(const image_map_info& other773) {
  image = other773.image;
  base_image = other773.base_image;
  connection_ids = other773.connection_ids;
  __isset = other773.__isset;
  return *this;
}
void image_map_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "image_map_info(";
  out << "image="; (__isset.image ? (out << to_string(image)) : (out << "<null>"));
  out << ", " << "base_image="; (__isset.base_image ? (out << to_string(base_image)) : (out << "<null>"));
  out << ", " << "connection_ids="; (__isset.connection_ids ? (out << to_string(connection_ids)) : (out << "<null>"));
  out << ")";
}


create_image_info::~create_image_info() throw() {
}


void create_image_info::__set_name(const std::string& val) {
  this->name = val;
__isset.name = true;
}

void create_image_info::__set_base(const std::string& val) {
  this->base = val;
__isset.base = true;
}

void create_image_info::__set_parent(const std::string& val) {
  this->parent = val;
__isset.parent = true;
}

void create_image_info::__set_connection_ids(const std::set<std::string> & val) {
  this->connection_ids = val;
__isset.connection_ids = true;
}

void create_image_info::__set_size(const int64_t val) {
  this->size = val;
__isset.size = true;
}

void create_image_info::__set_block_size(const int32_t val) {
  this->block_size = val;
__isset.block_size = true;
}

void create_image_info::__set_checksum_verify(const bool val) {
  this->checksum_verify = val;
__isset.checksum_verify = true;
}

void create_image_info::__set_comment(const std::string& val) {
  this->comment = val;
__isset.comment = true;
}

void create_image_info::__set_version(const create_image_option::type val) {
  this->version = val;
__isset.version = true;
}

void create_image_info::__set_compressed(const bool val) {
  this->compressed = val;
__isset.compressed = true;
}

void create_image_info::__set_checksum(const bool val) {
  this->checksum = val;
__isset.checksum = true;
}

void create_image_info::__set_cdr(const bool val) {
  this->cdr = val;
__isset.cdr = true;
}

void create_image_info::__set_mode(const int8_t val) {
  this->mode = val;
__isset.mode = true;
}

uint32_t create_image_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->base);
          this->__isset.base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->parent);
          this->__isset.parent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->connection_ids.clear();
            uint32_t _size774;
            ::apache::thrift::protocol::TType _etype777;
            xfer += iprot->readSetBegin(_etype777, _size774);
            uint32_t _i778;
            for (_i778 = 0; _i778 < _size774; ++_i778)
            {
              std::string _elem779;
              xfer += iprot->readString(_elem779);
              this->connection_ids.insert(_elem779);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.connection_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->size);
          this->__isset.size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->block_size);
          this->__isset.block_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->checksum_verify);
          this->__isset.checksum_verify = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comment);
          this->__isset.comment = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast780;
          xfer += iprot->readI32(ecast780);
          this->version = (create_image_option::type)ecast780;
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->compressed);
          this->__isset.compressed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->checksum);
          this->__isset.checksum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->cdr);
          this->__isset.cdr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->mode);
          this->__isset.mode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t create_image_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("create_image_info");

  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.base) {
    xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->base);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.parent) {
    xfer += oprot->writeFieldBegin("parent", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->parent);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.connection_ids) {
    xfer += oprot->writeFieldBegin("connection_ids", ::apache::thrift::protocol::T_SET, 4);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->connection_ids.size()));
      std::set<std::string> ::const_iterator _iter781;
      for (_iter781 = this->connection_ids.begin(); _iter781 != this->connection_ids.end(); ++_iter781)
      {
        xfer += oprot->writeString((*_iter781));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.size) {
    xfer += oprot->writeFieldBegin("size", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.block_size) {
    xfer += oprot->writeFieldBegin("block_size", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(this->block_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.checksum_verify) {
    xfer += oprot->writeFieldBegin("checksum_verify", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->checksum_verify);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.comment) {
    xfer += oprot->writeFieldBegin("comment", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->comment);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.version) {
    xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_I32, 9);
    xfer += oprot->writeI32((int32_t)this->version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.compressed) {
    xfer += oprot->writeFieldBegin("compressed", ::apache::thrift::protocol::T_BOOL, 10);
    xfer += oprot->writeBool(this->compressed);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.checksum) {
    xfer += oprot->writeFieldBegin("checksum", ::apache::thrift::protocol::T_BOOL, 11);
    xfer += oprot->writeBool(this->checksum);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cdr) {
    xfer += oprot->writeFieldBegin("cdr", ::apache::thrift::protocol::T_BOOL, 12);
    xfer += oprot->writeBool(this->cdr);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mode) {
    xfer += oprot->writeFieldBegin("mode", ::apache::thrift::protocol::T_BYTE, 13);
    xfer += oprot->writeByte(this->mode);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(create_image_info &a, create_image_info &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.base, b.base);
  swap(a.parent, b.parent);
  swap(a.connection_ids, b.connection_ids);
  swap(a.size, b.size);
  swap(a.block_size, b.block_size);
  swap(a.checksum_verify, b.checksum_verify);
  swap(a.comment, b.comment);
  swap(a.version, b.version);
  swap(a.compressed, b.compressed);
  swap(a.checksum, b.checksum);
  swap(a.cdr, b.cdr);
  swap(a.mode, b.mode);
  swap(a.__isset, b.__isset);
}

create_image_info::create_image_info(const create_image_info& other782) {
  name = other782.name;
  base = other782.base;
  parent = other782.parent;
  connection_ids = other782.connection_ids;
  size = other782.size;
  block_size = other782.block_size;
  checksum_verify = other782.checksum_verify;
  comment = other782.comment;
  version = other782.version;
  compressed = other782.compressed;
  checksum = other782.checksum;
  cdr = other782.cdr;
  mode = other782.mode;
  __isset = other782.__isset;
}
create_image_info& create_image_info::operator=(const create_image_info& other783) {
  name = other783.name;
  base = other783.base;
  parent = other783.parent;
  connection_ids = other783.connection_ids;
  size = other783.size;
  block_size = other783.block_size;
  checksum_verify = other783.checksum_verify;
  comment = other783.comment;
  version = other783.version;
  compressed = other783.compressed;
  checksum = other783.checksum;
  cdr = other783.cdr;
  mode = other783.mode;
  __isset = other783.__isset;
  return *this;
}
void create_image_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "create_image_info(";
  out << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
  out << ", " << "base="; (__isset.base ? (out << to_string(base)) : (out << "<null>"));
  out << ", " << "parent="; (__isset.parent ? (out << to_string(parent)) : (out << "<null>"));
  out << ", " << "connection_ids="; (__isset.connection_ids ? (out << to_string(connection_ids)) : (out << "<null>"));
  out << ", " << "size="; (__isset.size ? (out << to_string(size)) : (out << "<null>"));
  out << ", " << "block_size="; (__isset.block_size ? (out << to_string(block_size)) : (out << "<null>"));
  out << ", " << "checksum_verify="; (__isset.checksum_verify ? (out << to_string(checksum_verify)) : (out << "<null>"));
  out << ", " << "comment="; (__isset.comment ? (out << to_string(comment)) : (out << "<null>"));
  out << ", " << "version="; (__isset.version ? (out << to_string(version)) : (out << "<null>"));
  out << ", " << "compressed="; (__isset.compressed ? (out << to_string(compressed)) : (out << "<null>"));
  out << ", " << "checksum="; (__isset.checksum ? (out << to_string(checksum)) : (out << "<null>"));
  out << ", " << "cdr="; (__isset.cdr ? (out << to_string(cdr)) : (out << "<null>"));
  out << ", " << "mode="; (__isset.mode ? (out << to_string(mode)) : (out << "<null>"));
  out << ")";
}


loader_job_detail::~loader_job_detail() throw() {
}


void loader_job_detail::__set_replica_id(const std::string& val) {
  this->replica_id = val;
__isset.replica_id = true;
}

void loader_job_detail::__set_id(const std::string& val) {
  this->id = val;
__isset.id = true;
}

void loader_job_detail::__set_state(const job_state::type val) {
  this->state = val;
__isset.state = true;
}

void loader_job_detail::__set_created_time(const std::string& val) {
  this->created_time = val;
__isset.created_time = true;
}

void loader_job_detail::__set_updated_time(const std::string& val) {
  this->updated_time = val;
__isset.updated_time = true;
}

void loader_job_detail::__set_progress(const std::map<std::string, int64_t> & val) {
  this->progress = val;
__isset.progress = true;
}

void loader_job_detail::__set_histories(const std::vector<job_history> & val) {
  this->histories = val;
__isset.histories = true;
}

void loader_job_detail::__set_connection_id(const std::string& val) {
  this->connection_id = val;
__isset.connection_id = true;
}

void loader_job_detail::__set_data(const std::map<std::string, int64_t> & val) {
  this->data = val;
__isset.data = true;
}

void loader_job_detail::__set_snapshot_id(const std::string& val) {
  this->snapshot_id = val;
__isset.snapshot_id = true;
}

void loader_job_detail::__set_duplicated_data(const std::map<std::string, int64_t> & val) {
  this->duplicated_data = val;
__isset.duplicated_data = true;
}

void loader_job_detail::__set_transport_data(const std::map<std::string, int64_t> & val) {
  this->transport_data = val;
__isset.transport_data = true;
}

uint32_t loader_job_detail::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->replica_id);
          this->__isset.replica_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast784;
          xfer += iprot->readI32(ecast784);
          this->state = (job_state::type)ecast784;
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->created_time);
          this->__isset.created_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->updated_time);
          this->__isset.updated_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->progress.clear();
            uint32_t _size785;
            ::apache::thrift::protocol::TType _ktype786;
            ::apache::thrift::protocol::TType _vtype787;
            xfer += iprot->readMapBegin(_ktype786, _vtype787, _size785);
            uint32_t _i789;
            for (_i789 = 0; _i789 < _size785; ++_i789)
            {
              std::string _key790;
              xfer += iprot->readString(_key790);
              int64_t& _val791 = this->progress[_key790];
              xfer += iprot->readI64(_val791);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.progress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->histories.clear();
            uint32_t _size792;
            ::apache::thrift::protocol::TType _etype795;
            xfer += iprot->readListBegin(_etype795, _size792);
            this->histories.resize(_size792);
            uint32_t _i796;
            for (_i796 = 0; _i796 < _size792; ++_i796)
            {
              xfer += this->histories[_i796].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.histories = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->connection_id);
          this->__isset.connection_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->data.clear();
            uint32_t _size797;
            ::apache::thrift::protocol::TType _ktype798;
            ::apache::thrift::protocol::TType _vtype799;
            xfer += iprot->readMapBegin(_ktype798, _vtype799, _size797);
            uint32_t _i801;
            for (_i801 = 0; _i801 < _size797; ++_i801)
            {
              std::string _key802;
              xfer += iprot->readString(_key802);
              int64_t& _val803 = this->data[_key802];
              xfer += iprot->readI64(_val803);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->snapshot_id);
          this->__isset.snapshot_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->duplicated_data.clear();
            uint32_t _size804;
            ::apache::thrift::protocol::TType _ktype805;
            ::apache::thrift::protocol::TType _vtype806;
            xfer += iprot->readMapBegin(_ktype805, _vtype806, _size804);
            uint32_t _i808;
            for (_i808 = 0; _i808 < _size804; ++_i808)
            {
              std::string _key809;
              xfer += iprot->readString(_key809);
              int64_t& _val810 = this->duplicated_data[_key809];
              xfer += iprot->readI64(_val810);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.duplicated_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->transport_data.clear();
            uint32_t _size811;
            ::apache::thrift::protocol::TType _ktype812;
            ::apache::thrift::protocol::TType _vtype813;
            xfer += iprot->readMapBegin(_ktype812, _vtype813, _size811);
            uint32_t _i815;
            for (_i815 = 0; _i815 < _size811; ++_i815)
            {
              std::string _key816;
              xfer += iprot->readString(_key816);
              int64_t& _val817 = this->transport_data[_key816];
              xfer += iprot->readI64(_val817);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.transport_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t loader_job_detail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("loader_job_detail");

  if (this->__isset.replica_id) {
    xfer += oprot->writeFieldBegin("replica_id", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->replica_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.state) {
    xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32((int32_t)this->state);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.created_time) {
    xfer += oprot->writeFieldBegin("created_time", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->created_time);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.updated_time) {
    xfer += oprot->writeFieldBegin("updated_time", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->updated_time);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.progress) {
    xfer += oprot->writeFieldBegin("progress", ::apache::thrift::protocol::T_MAP, 6);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->progress.size()));
      std::map<std::string, int64_t> ::const_iterator _iter818;
      for (_iter818 = this->progress.begin(); _iter818 != this->progress.end(); ++_iter818)
      {
        xfer += oprot->writeString(_iter818->first);
        xfer += oprot->writeI64(_iter818->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.histories) {
    xfer += oprot->writeFieldBegin("histories", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->histories.size()));
      std::vector<job_history> ::const_iterator _iter819;
      for (_iter819 = this->histories.begin(); _iter819 != this->histories.end(); ++_iter819)
      {
        xfer += (*_iter819).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.connection_id) {
    xfer += oprot->writeFieldBegin("connection_id", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->connection_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.data) {
    xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_MAP, 9);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->data.size()));
      std::map<std::string, int64_t> ::const_iterator _iter820;
      for (_iter820 = this->data.begin(); _iter820 != this->data.end(); ++_iter820)
      {
        xfer += oprot->writeString(_iter820->first);
        xfer += oprot->writeI64(_iter820->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.snapshot_id) {
    xfer += oprot->writeFieldBegin("snapshot_id", ::apache::thrift::protocol::T_STRING, 10);
    xfer += oprot->writeString(this->snapshot_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.duplicated_data) {
    xfer += oprot->writeFieldBegin("duplicated_data", ::apache::thrift::protocol::T_MAP, 11);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->duplicated_data.size()));
      std::map<std::string, int64_t> ::const_iterator _iter821;
      for (_iter821 = this->duplicated_data.begin(); _iter821 != this->duplicated_data.end(); ++_iter821)
      {
        xfer += oprot->writeString(_iter821->first);
        xfer += oprot->writeI64(_iter821->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.transport_data) {
    xfer += oprot->writeFieldBegin("transport_data", ::apache::thrift::protocol::T_MAP, 12);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->transport_data.size()));
      std::map<std::string, int64_t> ::const_iterator _iter822;
      for (_iter822 = this->transport_data.begin(); _iter822 != this->transport_data.end(); ++_iter822)
      {
        xfer += oprot->writeString(_iter822->first);
        xfer += oprot->writeI64(_iter822->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(loader_job_detail &a, loader_job_detail &b) {
  using ::std::swap;
  swap(a.replica_id, b.replica_id);
  swap(a.id, b.id);
  swap(a.state, b.state);
  swap(a.created_time, b.created_time);
  swap(a.updated_time, b.updated_time);
  swap(a.progress, b.progress);
  swap(a.histories, b.histories);
  swap(a.connection_id, b.connection_id);
  swap(a.data, b.data);
  swap(a.snapshot_id, b.snapshot_id);
  swap(a.duplicated_data, b.duplicated_data);
  swap(a.transport_data, b.transport_data);
  swap(a.__isset, b.__isset);
}

loader_job_detail::loader_job_detail(const loader_job_detail& other823) {
  replica_id = other823.replica_id;
  id = other823.id;
  state = other823.state;
  created_time = other823.created_time;
  updated_time = other823.updated_time;
  progress = other823.progress;
  histories = other823.histories;
  connection_id = other823.connection_id;
  data = other823.data;
  snapshot_id = other823.snapshot_id;
  duplicated_data = other823.duplicated_data;
  transport_data = other823.transport_data;
  __isset = other823.__isset;
}
loader_job_detail& loader_job_detail::operator=(const loader_job_detail& other824) {
  replica_id = other824.replica_id;
  id = other824.id;
  state = other824.state;
  created_time = other824.created_time;
  updated_time = other824.updated_time;
  progress = other824.progress;
  histories = other824.histories;
  connection_id = other824.connection_id;
  data = other824.data;
  snapshot_id = other824.snapshot_id;
  duplicated_data = other824.duplicated_data;
  transport_data = other824.transport_data;
  __isset = other824.__isset;
  return *this;
}
void loader_job_detail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "loader_job_detail(";
  out << "replica_id="; (__isset.replica_id ? (out << to_string(replica_id)) : (out << "<null>"));
  out << ", " << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "state="; (__isset.state ? (out << to_string(state)) : (out << "<null>"));
  out << ", " << "created_time="; (__isset.created_time ? (out << to_string(created_time)) : (out << "<null>"));
  out << ", " << "updated_time="; (__isset.updated_time ? (out << to_string(updated_time)) : (out << "<null>"));
  out << ", " << "progress="; (__isset.progress ? (out << to_string(progress)) : (out << "<null>"));
  out << ", " << "histories="; (__isset.histories ? (out << to_string(histories)) : (out << "<null>"));
  out << ", " << "connection_id="; (__isset.connection_id ? (out << to_string(connection_id)) : (out << "<null>"));
  out << ", " << "data="; (__isset.data ? (out << to_string(data)) : (out << "<null>"));
  out << ", " << "snapshot_id="; (__isset.snapshot_id ? (out << to_string(snapshot_id)) : (out << "<null>"));
  out << ", " << "duplicated_data="; (__isset.duplicated_data ? (out << to_string(duplicated_data)) : (out << "<null>"));
  out << ", " << "transport_data="; (__isset.transport_data ? (out << to_string(transport_data)) : (out << "<null>"));
  out << ")";
}


upload_progress::~upload_progress() throw() {
}


void upload_progress::__set_size(const int64_t val) {
  this->size = val;
__isset.size = true;
}

void upload_progress::__set_progress(const int64_t val) {
  this->progress = val;
__isset.progress = true;
}

void upload_progress::__set_vhd_size(const int64_t val) {
  this->vhd_size = val;
__isset.vhd_size = true;
}

void upload_progress::__set_upload_id(const std::string& val) {
  this->upload_id = val;
__isset.upload_id = true;
}

void upload_progress::__set_completed(const bool val) {
  this->completed = val;
__isset.completed = true;
}

uint32_t upload_progress::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->size);
          this->__isset.size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->progress);
          this->__isset.progress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->vhd_size);
          this->__isset.vhd_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->upload_id);
          this->__isset.upload_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->completed);
          this->__isset.completed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t upload_progress::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("upload_progress");

  if (this->__isset.size) {
    xfer += oprot->writeFieldBegin("size", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.progress) {
    xfer += oprot->writeFieldBegin("progress", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->progress);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vhd_size) {
    xfer += oprot->writeFieldBegin("vhd_size", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->vhd_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.upload_id) {
    xfer += oprot->writeFieldBegin("upload_id", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->upload_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.completed) {
    xfer += oprot->writeFieldBegin("completed", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->completed);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(upload_progress &a, upload_progress &b) {
  using ::std::swap;
  swap(a.size, b.size);
  swap(a.progress, b.progress);
  swap(a.vhd_size, b.vhd_size);
  swap(a.upload_id, b.upload_id);
  swap(a.completed, b.completed);
  swap(a.__isset, b.__isset);
}

upload_progress::upload_progress(const upload_progress& other825) {
  size = other825.size;
  progress = other825.progress;
  vhd_size = other825.vhd_size;
  upload_id = other825.upload_id;
  completed = other825.completed;
  __isset = other825.__isset;
}
upload_progress& upload_progress::operator=(const upload_progress& other826) {
  size = other826.size;
  progress = other826.progress;
  vhd_size = other826.vhd_size;
  upload_id = other826.upload_id;
  completed = other826.completed;
  __isset = other826.__isset;
  return *this;
}
void upload_progress::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "upload_progress(";
  out << "size="; (__isset.size ? (out << to_string(size)) : (out << "<null>"));
  out << ", " << "progress="; (__isset.progress ? (out << to_string(progress)) : (out << "<null>"));
  out << ", " << "vhd_size="; (__isset.vhd_size ? (out << to_string(vhd_size)) : (out << "<null>"));
  out << ", " << "upload_id="; (__isset.upload_id ? (out << to_string(upload_id)) : (out << "<null>"));
  out << ", " << "completed="; (__isset.completed ? (out << to_string(completed)) : (out << "<null>"));
  out << ")";
}


launcher_job_detail::~launcher_job_detail() throw() {
}


void launcher_job_detail::__set_replica_id(const std::string& val) {
  this->replica_id = val;
__isset.replica_id = true;
}

void launcher_job_detail::__set_id(const std::string& val) {
  this->id = val;
__isset.id = true;
}

void launcher_job_detail::__set_state(const job_state::type val) {
  this->state = val;
__isset.state = true;
}

void launcher_job_detail::__set_created_time(const std::string& val) {
  this->created_time = val;
__isset.created_time = true;
}

void launcher_job_detail::__set_updated_time(const std::string& val) {
  this->updated_time = val;
__isset.updated_time = true;
}

void launcher_job_detail::__set_boot_disk(const std::string& val) {
  this->boot_disk = val;
__isset.boot_disk = true;
}

void launcher_job_detail::__set_histories(const std::vector<job_history> & val) {
  this->histories = val;
__isset.histories = true;
}

void launcher_job_detail::__set_is_error(const bool val) {
  this->is_error = val;
__isset.is_error = true;
}

void launcher_job_detail::__set_is_windows_update(const bool val) {
  this->is_windows_update = val;
__isset.is_windows_update = true;
}

void launcher_job_detail::__set_platform(const std::string& val) {
  this->platform = val;
__isset.platform = true;
}

void launcher_job_detail::__set_architecture(const std::string& val) {
  this->architecture = val;
__isset.architecture = true;
}

void launcher_job_detail::__set_size(const int64_t val) {
  this->size = val;
__isset.size = true;
}

void launcher_job_detail::__set_progress(const int64_t val) {
  this->progress = val;
__isset.progress = true;
}

void launcher_job_detail::__set_vhd_size(const int64_t val) {
  this->vhd_size = val;
__isset.vhd_size = true;
}

void launcher_job_detail::__set_upload_id(const std::string& val) {
  this->upload_id = val;
__isset.upload_id = true;
}

void launcher_job_detail::__set_host_name(const std::string& val) {
  this->host_name = val;
__isset.host_name = true;
}

void launcher_job_detail::__set_vhd_upload_progress(const std::map<std::string, upload_progress> & val) {
  this->vhd_upload_progress = val;
__isset.vhd_upload_progress = true;
}

uint32_t launcher_job_detail::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->replica_id);
          this->__isset.replica_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast827;
          xfer += iprot->readI32(ecast827);
          this->state = (job_state::type)ecast827;
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->created_time);
          this->__isset.created_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->updated_time);
          this->__isset.updated_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->boot_disk);
          this->__isset.boot_disk = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->histories.clear();
            uint32_t _size828;
            ::apache::thrift::protocol::TType _etype831;
            xfer += iprot->readListBegin(_etype831, _size828);
            this->histories.resize(_size828);
            uint32_t _i832;
            for (_i832 = 0; _i832 < _size828; ++_i832)
            {
              xfer += this->histories[_i832].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.histories = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_error);
          this->__isset.is_error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_windows_update);
          this->__isset.is_windows_update = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->platform);
          this->__isset.platform = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->architecture);
          this->__isset.architecture = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->size);
          this->__isset.size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->progress);
          this->__isset.progress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->vhd_size);
          this->__isset.vhd_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->upload_id);
          this->__isset.upload_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host_name);
          this->__isset.host_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->vhd_upload_progress.clear();
            uint32_t _size833;
            ::apache::thrift::protocol::TType _ktype834;
            ::apache::thrift::protocol::TType _vtype835;
            xfer += iprot->readMapBegin(_ktype834, _vtype835, _size833);
            uint32_t _i837;
            for (_i837 = 0; _i837 < _size833; ++_i837)
            {
              std::string _key838;
              xfer += iprot->readString(_key838);
              upload_progress& _val839 = this->vhd_upload_progress[_key838];
              xfer += _val839.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.vhd_upload_progress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t launcher_job_detail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("launcher_job_detail");

  if (this->__isset.replica_id) {
    xfer += oprot->writeFieldBegin("replica_id", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->replica_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.state) {
    xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32((int32_t)this->state);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.created_time) {
    xfer += oprot->writeFieldBegin("created_time", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->created_time);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.updated_time) {
    xfer += oprot->writeFieldBegin("updated_time", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->updated_time);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.boot_disk) {
    xfer += oprot->writeFieldBegin("boot_disk", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->boot_disk);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.histories) {
    xfer += oprot->writeFieldBegin("histories", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->histories.size()));
      std::vector<job_history> ::const_iterator _iter840;
      for (_iter840 = this->histories.begin(); _iter840 != this->histories.end(); ++_iter840)
      {
        xfer += (*_iter840).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_error) {
    xfer += oprot->writeFieldBegin("is_error", ::apache::thrift::protocol::T_BOOL, 8);
    xfer += oprot->writeBool(this->is_error);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_windows_update) {
    xfer += oprot->writeFieldBegin("is_windows_update", ::apache::thrift::protocol::T_BOOL, 9);
    xfer += oprot->writeBool(this->is_windows_update);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.platform) {
    xfer += oprot->writeFieldBegin("platform", ::apache::thrift::protocol::T_STRING, 10);
    xfer += oprot->writeString(this->platform);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.architecture) {
    xfer += oprot->writeFieldBegin("architecture", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeString(this->architecture);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.size) {
    xfer += oprot->writeFieldBegin("size", ::apache::thrift::protocol::T_I64, 12);
    xfer += oprot->writeI64(this->size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.progress) {
    xfer += oprot->writeFieldBegin("progress", ::apache::thrift::protocol::T_I64, 13);
    xfer += oprot->writeI64(this->progress);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vhd_size) {
    xfer += oprot->writeFieldBegin("vhd_size", ::apache::thrift::protocol::T_I64, 14);
    xfer += oprot->writeI64(this->vhd_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.upload_id) {
    xfer += oprot->writeFieldBegin("upload_id", ::apache::thrift::protocol::T_STRING, 15);
    xfer += oprot->writeString(this->upload_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.host_name) {
    xfer += oprot->writeFieldBegin("host_name", ::apache::thrift::protocol::T_STRING, 16);
    xfer += oprot->writeString(this->host_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vhd_upload_progress) {
    xfer += oprot->writeFieldBegin("vhd_upload_progress", ::apache::thrift::protocol::T_MAP, 17);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->vhd_upload_progress.size()));
      std::map<std::string, upload_progress> ::const_iterator _iter841;
      for (_iter841 = this->vhd_upload_progress.begin(); _iter841 != this->vhd_upload_progress.end(); ++_iter841)
      {
        xfer += oprot->writeString(_iter841->first);
        xfer += _iter841->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(launcher_job_detail &a, launcher_job_detail &b) {
  using ::std::swap;
  swap(a.replica_id, b.replica_id);
  swap(a.id, b.id);
  swap(a.state, b.state);
  swap(a.created_time, b.created_time);
  swap(a.updated_time, b.updated_time);
  swap(a.boot_disk, b.boot_disk);
  swap(a.histories, b.histories);
  swap(a.is_error, b.is_error);
  swap(a.is_windows_update, b.is_windows_update);
  swap(a.platform, b.platform);
  swap(a.architecture, b.architecture);
  swap(a.size, b.size);
  swap(a.progress, b.progress);
  swap(a.vhd_size, b.vhd_size);
  swap(a.upload_id, b.upload_id);
  swap(a.host_name, b.host_name);
  swap(a.vhd_upload_progress, b.vhd_upload_progress);
  swap(a.__isset, b.__isset);
}

launcher_job_detail::launcher_job_detail(const launcher_job_detail& other842) {
  replica_id = other842.replica_id;
  id = other842.id;
  state = other842.state;
  created_time = other842.created_time;
  updated_time = other842.updated_time;
  boot_disk = other842.boot_disk;
  histories = other842.histories;
  is_error = other842.is_error;
  is_windows_update = other842.is_windows_update;
  platform = other842.platform;
  architecture = other842.architecture;
  size = other842.size;
  progress = other842.progress;
  vhd_size = other842.vhd_size;
  upload_id = other842.upload_id;
  host_name = other842.host_name;
  vhd_upload_progress = other842.vhd_upload_progress;
  __isset = other842.__isset;
}
launcher_job_detail& launcher_job_detail::operator=(const launcher_job_detail& other843) {
  replica_id = other843.replica_id;
  id = other843.id;
  state = other843.state;
  created_time = other843.created_time;
  updated_time = other843.updated_time;
  boot_disk = other843.boot_disk;
  histories = other843.histories;
  is_error = other843.is_error;
  is_windows_update = other843.is_windows_update;
  platform = other843.platform;
  architecture = other843.architecture;
  size = other843.size;
  progress = other843.progress;
  vhd_size = other843.vhd_size;
  upload_id = other843.upload_id;
  host_name = other843.host_name;
  vhd_upload_progress = other843.vhd_upload_progress;
  __isset = other843.__isset;
  return *this;
}
void launcher_job_detail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "launcher_job_detail(";
  out << "replica_id="; (__isset.replica_id ? (out << to_string(replica_id)) : (out << "<null>"));
  out << ", " << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "state="; (__isset.state ? (out << to_string(state)) : (out << "<null>"));
  out << ", " << "created_time="; (__isset.created_time ? (out << to_string(created_time)) : (out << "<null>"));
  out << ", " << "updated_time="; (__isset.updated_time ? (out << to_string(updated_time)) : (out << "<null>"));
  out << ", " << "boot_disk="; (__isset.boot_disk ? (out << to_string(boot_disk)) : (out << "<null>"));
  out << ", " << "histories="; (__isset.histories ? (out << to_string(histories)) : (out << "<null>"));
  out << ", " << "is_error="; (__isset.is_error ? (out << to_string(is_error)) : (out << "<null>"));
  out << ", " << "is_windows_update="; (__isset.is_windows_update ? (out << to_string(is_windows_update)) : (out << "<null>"));
  out << ", " << "platform="; (__isset.platform ? (out << to_string(platform)) : (out << "<null>"));
  out << ", " << "architecture="; (__isset.architecture ? (out << to_string(architecture)) : (out << "<null>"));
  out << ", " << "size="; (__isset.size ? (out << to_string(size)) : (out << "<null>"));
  out << ", " << "progress="; (__isset.progress ? (out << to_string(progress)) : (out << "<null>"));
  out << ", " << "vhd_size="; (__isset.vhd_size ? (out << to_string(vhd_size)) : (out << "<null>"));
  out << ", " << "upload_id="; (__isset.upload_id ? (out << to_string(upload_id)) : (out << "<null>"));
  out << ", " << "host_name="; (__isset.host_name ? (out << to_string(host_name)) : (out << "<null>"));
  out << ", " << "vhd_upload_progress="; (__isset.vhd_upload_progress ? (out << to_string(vhd_upload_progress)) : (out << "<null>"));
  out << ")";
}


job_detail::~job_detail() throw() {
}


void job_detail::__set_scheduler(const replica_job_detail& val) {
  this->scheduler = val;
__isset.scheduler = true;
}

void job_detail::__set_launcher(const launcher_job_detail& val) {
  this->launcher = val;
__isset.launcher = true;
}

void job_detail::__set_loader(const loader_job_detail& val) {
  this->loader = val;
__isset.loader = true;
}

uint32_t job_detail::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->scheduler.read(iprot);
          this->__isset.scheduler = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->launcher.read(iprot);
          this->__isset.launcher = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->loader.read(iprot);
          this->__isset.loader = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t job_detail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("job_detail");

  if (this->__isset.scheduler) {
    xfer += oprot->writeFieldBegin("scheduler", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->scheduler.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.launcher) {
    xfer += oprot->writeFieldBegin("launcher", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->launcher.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.loader) {
    xfer += oprot->writeFieldBegin("loader", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->loader.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(job_detail &a, job_detail &b) {
  using ::std::swap;
  swap(a.scheduler, b.scheduler);
  swap(a.launcher, b.launcher);
  swap(a.loader, b.loader);
  swap(a.__isset, b.__isset);
}

job_detail::job_detail(const job_detail& other844) {
  scheduler = other844.scheduler;
  launcher = other844.launcher;
  loader = other844.loader;
  __isset = other844.__isset;
}
job_detail& job_detail::operator=(const job_detail& other845) {
  scheduler = other845.scheduler;
  launcher = other845.launcher;
  loader = other845.loader;
  __isset = other845.__isset;
  return *this;
}
void job_detail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "job_detail(";
  out << "scheduler="; (__isset.scheduler ? (out << to_string(scheduler)) : (out << "<null>"));
  out << ", " << "launcher="; (__isset.launcher ? (out << to_string(launcher)) : (out << "<null>"));
  out << ", " << "loader="; (__isset.loader ? (out << to_string(loader)) : (out << "<null>"));
  out << ")";
}


replica_job_create_detail::~replica_job_create_detail() throw() {
}


void replica_job_create_detail::__set_host(const std::string& val) {
  this->host = val;
__isset.host = true;
}

void replica_job_create_detail::__set_addr(const std::set<std::string> & val) {
  this->addr = val;
__isset.addr = true;
}

void replica_job_create_detail::__set_username(const std::string& val) {
  this->username = val;
__isset.username = true;
}

void replica_job_create_detail::__set_password(const std::string& val) {
  this->password = val;
__isset.password = true;
}

void replica_job_create_detail::__set_type(const job_type::type val) {
  this->type = val;
__isset.type = true;
}

void replica_job_create_detail::__set_virtual_machine_id(const std::string& val) {
  this->virtual_machine_id = val;
__isset.virtual_machine_id = true;
}

void replica_job_create_detail::__set_disks(const std::set<std::string> & val) {
  this->disks = val;
__isset.disks = true;
}

void replica_job_create_detail::__set_targets(const std::map<std::string, std::string> & val) {
  this->targets = val;
__isset.targets = true;
}

void replica_job_create_detail::__set_carriers(const std::map<std::string, std::set<std::string> > & val) {
  this->carriers = val;
__isset.carriers = true;
}

void replica_job_create_detail::__set_full_replicas(const std::set<std::string> & val) {
  this->full_replicas = val;
__isset.full_replicas = true;
}

void replica_job_create_detail::__set_disk_ids(const std::map<std::string, std::string> & val) {
  this->disk_ids = val;
__isset.disk_ids = true;
}

void replica_job_create_detail::__set_cbt_info(const std::string& val) {
  this->cbt_info = val;
__isset.cbt_info = true;
}

void replica_job_create_detail::__set_snapshot_info(const std::string& val) {
  this->snapshot_info = val;
__isset.snapshot_info = true;
}

void replica_job_create_detail::__set_checksum_verify(const bool val) {
  this->checksum_verify = val;
__isset.checksum_verify = true;
}

void replica_job_create_detail::__set_always_retry(const bool val) {
  this->always_retry = val;
__isset.always_retry = true;
}

void replica_job_create_detail::__set_timeout(const int32_t val) {
  this->timeout = val;
__isset.timeout = true;
}

void replica_job_create_detail::__set_is_encrypted(const bool val) {
  this->is_encrypted = val;
__isset.is_encrypted = true;
}

void replica_job_create_detail::__set_is_paused(const bool val) {
  this->is_paused = val;
__isset.is_paused = true;
}

void replica_job_create_detail::__set_worker_thread_number(const int32_t val) {
  this->worker_thread_number = val;
__isset.worker_thread_number = true;
}

void replica_job_create_detail::__set_block_mode_enable(const bool val) {
  this->block_mode_enable = val;
__isset.block_mode_enable = true;
}

void replica_job_create_detail::__set_file_system_filter_enable(const bool val) {
  this->file_system_filter_enable = val;
__isset.file_system_filter_enable = true;
}

void replica_job_create_detail::__set_min_transport_size(const int32_t val) {
  this->min_transport_size = val;
__isset.min_transport_size = true;
}

void replica_job_create_detail::__set_full_min_transport_size(const int32_t val) {
  this->full_min_transport_size = val;
__isset.full_min_transport_size = true;
}

void replica_job_create_detail::__set_is_full_replica(const bool val) {
  this->is_full_replica = val;
__isset.is_full_replica = true;
}

void replica_job_create_detail::__set_buffer_size(const int32_t val) {
  this->buffer_size = val;
__isset.buffer_size = true;
}

void replica_job_create_detail::__set_is_compressed(const bool val) {
  this->is_compressed = val;
__isset.is_compressed = true;
}

void replica_job_create_detail::__set_is_checksum(const bool val) {
  this->is_checksum = val;
__isset.is_checksum = true;
}

void replica_job_create_detail::__set_time(const std::string& val) {
  this->time = val;
__isset.time = true;
}

void replica_job_create_detail::__set_priority_carrier(const std::map<std::string, std::string> & val) {
  this->priority_carrier = val;
__isset.priority_carrier = true;
}

void replica_job_create_detail::__set_is_only_single_system_disk(const bool val) {
  this->is_only_single_system_disk = val;
__isset.is_only_single_system_disk = true;
}

void replica_job_create_detail::__set_is_continuous_data_replication(const bool val) {
  this->is_continuous_data_replication = val;
__isset.is_continuous_data_replication = true;
}

void replica_job_create_detail::__set_pre_snapshot_script(const std::string& val) {
  this->pre_snapshot_script = val;
__isset.pre_snapshot_script = true;
}

void replica_job_create_detail::__set_post_snapshot_script(const std::string& val) {
  this->post_snapshot_script = val;
__isset.post_snapshot_script = true;
}

void replica_job_create_detail::__set_is_compressed_by_packer(const bool val) {
  this->is_compressed_by_packer = val;
__isset.is_compressed_by_packer = true;
}

uint32_t replica_job_create_detail::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host);
          this->__isset.host = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->addr.clear();
            uint32_t _size846;
            ::apache::thrift::protocol::TType _etype849;
            xfer += iprot->readSetBegin(_etype849, _size846);
            uint32_t _i850;
            for (_i850 = 0; _i850 < _size846; ++_i850)
            {
              std::string _elem851;
              xfer += iprot->readString(_elem851);
              this->addr.insert(_elem851);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->username);
          this->__isset.username = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->password);
          this->__isset.password = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast852;
          xfer += iprot->readI32(ecast852);
          this->type = (job_type::type)ecast852;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->virtual_machine_id);
          this->__isset.virtual_machine_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->disks.clear();
            uint32_t _size853;
            ::apache::thrift::protocol::TType _etype856;
            xfer += iprot->readSetBegin(_etype856, _size853);
            uint32_t _i857;
            for (_i857 = 0; _i857 < _size853; ++_i857)
            {
              std::string _elem858;
              xfer += iprot->readString(_elem858);
              this->disks.insert(_elem858);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.disks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->targets.clear();
            uint32_t _size859;
            ::apache::thrift::protocol::TType _ktype860;
            ::apache::thrift::protocol::TType _vtype861;
            xfer += iprot->readMapBegin(_ktype860, _vtype861, _size859);
            uint32_t _i863;
            for (_i863 = 0; _i863 < _size859; ++_i863)
            {
              std::string _key864;
              xfer += iprot->readString(_key864);
              std::string& _val865 = this->targets[_key864];
              xfer += iprot->readString(_val865);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.targets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->carriers.clear();
            uint32_t _size866;
            ::apache::thrift::protocol::TType _ktype867;
            ::apache::thrift::protocol::TType _vtype868;
            xfer += iprot->readMapBegin(_ktype867, _vtype868, _size866);
            uint32_t _i870;
            for (_i870 = 0; _i870 < _size866; ++_i870)
            {
              std::string _key871;
              xfer += iprot->readString(_key871);
              std::set<std::string> & _val872 = this->carriers[_key871];
              {
                _val872.clear();
                uint32_t _size873;
                ::apache::thrift::protocol::TType _etype876;
                xfer += iprot->readSetBegin(_etype876, _size873);
                uint32_t _i877;
                for (_i877 = 0; _i877 < _size873; ++_i877)
                {
                  std::string _elem878;
                  xfer += iprot->readString(_elem878);
                  _val872.insert(_elem878);
                }
                xfer += iprot->readSetEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.carriers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->full_replicas.clear();
            uint32_t _size879;
            ::apache::thrift::protocol::TType _etype882;
            xfer += iprot->readSetBegin(_etype882, _size879);
            uint32_t _i883;
            for (_i883 = 0; _i883 < _size879; ++_i883)
            {
              std::string _elem884;
              xfer += iprot->readString(_elem884);
              this->full_replicas.insert(_elem884);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.full_replicas = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->disk_ids.clear();
            uint32_t _size885;
            ::apache::thrift::protocol::TType _ktype886;
            ::apache::thrift::protocol::TType _vtype887;
            xfer += iprot->readMapBegin(_ktype886, _vtype887, _size885);
            uint32_t _i889;
            for (_i889 = 0; _i889 < _size885; ++_i889)
            {
              std::string _key890;
              xfer += iprot->readString(_key890);
              std::string& _val891 = this->disk_ids[_key890];
              xfer += iprot->readString(_val891);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.disk_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cbt_info);
          this->__isset.cbt_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->snapshot_info);
          this->__isset.snapshot_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->checksum_verify);
          this->__isset.checksum_verify = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->always_retry);
          this->__isset.always_retry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->timeout);
          this->__isset.timeout = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_encrypted);
          this->__isset.is_encrypted = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_paused);
          this->__isset.is_paused = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->worker_thread_number);
          this->__isset.worker_thread_number = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->block_mode_enable);
          this->__isset.block_mode_enable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->file_system_filter_enable);
          this->__isset.file_system_filter_enable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->min_transport_size);
          this->__isset.min_transport_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->full_min_transport_size);
          this->__isset.full_min_transport_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_full_replica);
          this->__isset.is_full_replica = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->buffer_size);
          this->__isset.buffer_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 26:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_compressed);
          this->__isset.is_compressed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 27:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_checksum);
          this->__isset.is_checksum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 28:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->time);
          this->__isset.time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 29:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->priority_carrier.clear();
            uint32_t _size892;
            ::apache::thrift::protocol::TType _ktype893;
            ::apache::thrift::protocol::TType _vtype894;
            xfer += iprot->readMapBegin(_ktype893, _vtype894, _size892);
            uint32_t _i896;
            for (_i896 = 0; _i896 < _size892; ++_i896)
            {
              std::string _key897;
              xfer += iprot->readString(_key897);
              std::string& _val898 = this->priority_carrier[_key897];
              xfer += iprot->readString(_val898);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.priority_carrier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_only_single_system_disk);
          this->__isset.is_only_single_system_disk = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 31:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_continuous_data_replication);
          this->__isset.is_continuous_data_replication = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 32:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pre_snapshot_script);
          this->__isset.pre_snapshot_script = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 33:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->post_snapshot_script);
          this->__isset.post_snapshot_script = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 34:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_compressed_by_packer);
          this->__isset.is_compressed_by_packer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t replica_job_create_detail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("replica_job_create_detail");

  if (this->__isset.host) {
    xfer += oprot->writeFieldBegin("host", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->host);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.addr) {
    xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_SET, 2);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->addr.size()));
      std::set<std::string> ::const_iterator _iter899;
      for (_iter899 = this->addr.begin(); _iter899 != this->addr.end(); ++_iter899)
      {
        xfer += oprot->writeString((*_iter899));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.username) {
    xfer += oprot->writeFieldBegin("username", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->username);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.password) {
    xfer += oprot->writeFieldBegin("password", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->password);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.type) {
    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32((int32_t)this->type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.virtual_machine_id) {
    xfer += oprot->writeFieldBegin("virtual_machine_id", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->virtual_machine_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.disks) {
    xfer += oprot->writeFieldBegin("disks", ::apache::thrift::protocol::T_SET, 7);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->disks.size()));
      std::set<std::string> ::const_iterator _iter900;
      for (_iter900 = this->disks.begin(); _iter900 != this->disks.end(); ++_iter900)
      {
        xfer += oprot->writeString((*_iter900));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.targets) {
    xfer += oprot->writeFieldBegin("targets", ::apache::thrift::protocol::T_MAP, 8);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->targets.size()));
      std::map<std::string, std::string> ::const_iterator _iter901;
      for (_iter901 = this->targets.begin(); _iter901 != this->targets.end(); ++_iter901)
      {
        xfer += oprot->writeString(_iter901->first);
        xfer += oprot->writeString(_iter901->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.carriers) {
    xfer += oprot->writeFieldBegin("carriers", ::apache::thrift::protocol::T_MAP, 9);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_SET, static_cast<uint32_t>(this->carriers.size()));
      std::map<std::string, std::set<std::string> > ::const_iterator _iter902;
      for (_iter902 = this->carriers.begin(); _iter902 != this->carriers.end(); ++_iter902)
      {
        xfer += oprot->writeString(_iter902->first);
        {
          xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter902->second.size()));
          std::set<std::string> ::const_iterator _iter903;
          for (_iter903 = _iter902->second.begin(); _iter903 != _iter902->second.end(); ++_iter903)
          {
            xfer += oprot->writeString((*_iter903));
          }
          xfer += oprot->writeSetEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.full_replicas) {
    xfer += oprot->writeFieldBegin("full_replicas", ::apache::thrift::protocol::T_SET, 10);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->full_replicas.size()));
      std::set<std::string> ::const_iterator _iter904;
      for (_iter904 = this->full_replicas.begin(); _iter904 != this->full_replicas.end(); ++_iter904)
      {
        xfer += oprot->writeString((*_iter904));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.disk_ids) {
    xfer += oprot->writeFieldBegin("disk_ids", ::apache::thrift::protocol::T_MAP, 11);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->disk_ids.size()));
      std::map<std::string, std::string> ::const_iterator _iter905;
      for (_iter905 = this->disk_ids.begin(); _iter905 != this->disk_ids.end(); ++_iter905)
      {
        xfer += oprot->writeString(_iter905->first);
        xfer += oprot->writeString(_iter905->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cbt_info) {
    xfer += oprot->writeFieldBegin("cbt_info", ::apache::thrift::protocol::T_STRING, 12);
    xfer += oprot->writeString(this->cbt_info);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.snapshot_info) {
    xfer += oprot->writeFieldBegin("snapshot_info", ::apache::thrift::protocol::T_STRING, 13);
    xfer += oprot->writeString(this->snapshot_info);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.checksum_verify) {
    xfer += oprot->writeFieldBegin("checksum_verify", ::apache::thrift::protocol::T_BOOL, 14);
    xfer += oprot->writeBool(this->checksum_verify);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.always_retry) {
    xfer += oprot->writeFieldBegin("always_retry", ::apache::thrift::protocol::T_BOOL, 15);
    xfer += oprot->writeBool(this->always_retry);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timeout) {
    xfer += oprot->writeFieldBegin("timeout", ::apache::thrift::protocol::T_I32, 16);
    xfer += oprot->writeI32(this->timeout);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_encrypted) {
    xfer += oprot->writeFieldBegin("is_encrypted", ::apache::thrift::protocol::T_BOOL, 17);
    xfer += oprot->writeBool(this->is_encrypted);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_paused) {
    xfer += oprot->writeFieldBegin("is_paused", ::apache::thrift::protocol::T_BOOL, 18);
    xfer += oprot->writeBool(this->is_paused);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.worker_thread_number) {
    xfer += oprot->writeFieldBegin("worker_thread_number", ::apache::thrift::protocol::T_I32, 19);
    xfer += oprot->writeI32(this->worker_thread_number);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.block_mode_enable) {
    xfer += oprot->writeFieldBegin("block_mode_enable", ::apache::thrift::protocol::T_BOOL, 20);
    xfer += oprot->writeBool(this->block_mode_enable);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.file_system_filter_enable) {
    xfer += oprot->writeFieldBegin("file_system_filter_enable", ::apache::thrift::protocol::T_BOOL, 21);
    xfer += oprot->writeBool(this->file_system_filter_enable);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.min_transport_size) {
    xfer += oprot->writeFieldBegin("min_transport_size", ::apache::thrift::protocol::T_I32, 22);
    xfer += oprot->writeI32(this->min_transport_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.full_min_transport_size) {
    xfer += oprot->writeFieldBegin("full_min_transport_size", ::apache::thrift::protocol::T_I32, 23);
    xfer += oprot->writeI32(this->full_min_transport_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_full_replica) {
    xfer += oprot->writeFieldBegin("is_full_replica", ::apache::thrift::protocol::T_BOOL, 24);
    xfer += oprot->writeBool(this->is_full_replica);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.buffer_size) {
    xfer += oprot->writeFieldBegin("buffer_size", ::apache::thrift::protocol::T_I32, 25);
    xfer += oprot->writeI32(this->buffer_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_compressed) {
    xfer += oprot->writeFieldBegin("is_compressed", ::apache::thrift::protocol::T_BOOL, 26);
    xfer += oprot->writeBool(this->is_compressed);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_checksum) {
    xfer += oprot->writeFieldBegin("is_checksum", ::apache::thrift::protocol::T_BOOL, 27);
    xfer += oprot->writeBool(this->is_checksum);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.time) {
    xfer += oprot->writeFieldBegin("time", ::apache::thrift::protocol::T_STRING, 28);
    xfer += oprot->writeString(this->time);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.priority_carrier) {
    xfer += oprot->writeFieldBegin("priority_carrier", ::apache::thrift::protocol::T_MAP, 29);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->priority_carrier.size()));
      std::map<std::string, std::string> ::const_iterator _iter906;
      for (_iter906 = this->priority_carrier.begin(); _iter906 != this->priority_carrier.end(); ++_iter906)
      {
        xfer += oprot->writeString(_iter906->first);
        xfer += oprot->writeString(_iter906->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_only_single_system_disk) {
    xfer += oprot->writeFieldBegin("is_only_single_system_disk", ::apache::thrift::protocol::T_BOOL, 30);
    xfer += oprot->writeBool(this->is_only_single_system_disk);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_continuous_data_replication) {
    xfer += oprot->writeFieldBegin("is_continuous_data_replication", ::apache::thrift::protocol::T_BOOL, 31);
    xfer += oprot->writeBool(this->is_continuous_data_replication);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.pre_snapshot_script) {
    xfer += oprot->writeFieldBegin("pre_snapshot_script", ::apache::thrift::protocol::T_STRING, 32);
    xfer += oprot->writeString(this->pre_snapshot_script);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.post_snapshot_script) {
    xfer += oprot->writeFieldBegin("post_snapshot_script", ::apache::thrift::protocol::T_STRING, 33);
    xfer += oprot->writeString(this->post_snapshot_script);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_compressed_by_packer) {
    xfer += oprot->writeFieldBegin("is_compressed_by_packer", ::apache::thrift::protocol::T_BOOL, 34);
    xfer += oprot->writeBool(this->is_compressed_by_packer);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(replica_job_create_detail &a, replica_job_create_detail &b) {
  using ::std::swap;
  swap(a.host, b.host);
  swap(a.addr, b.addr);
  swap(a.username, b.username);
  swap(a.password, b.password);
  swap(a.type, b.type);
  swap(a.virtual_machine_id, b.virtual_machine_id);
  swap(a.disks, b.disks);
  swap(a.targets, b.targets);
  swap(a.carriers, b.carriers);
  swap(a.full_replicas, b.full_replicas);
  swap(a.disk_ids, b.disk_ids);
  swap(a.cbt_info, b.cbt_info);
  swap(a.snapshot_info, b.snapshot_info);
  swap(a.checksum_verify, b.checksum_verify);
  swap(a.always_retry, b.always_retry);
  swap(a.timeout, b.timeout);
  swap(a.is_encrypted, b.is_encrypted);
  swap(a.is_paused, b.is_paused);
  swap(a.worker_thread_number, b.worker_thread_number);
  swap(a.block_mode_enable, b.block_mode_enable);
  swap(a.file_system_filter_enable, b.file_system_filter_enable);
  swap(a.min_transport_size, b.min_transport_size);
  swap(a.full_min_transport_size, b.full_min_transport_size);
  swap(a.is_full_replica, b.is_full_replica);
  swap(a.buffer_size, b.buffer_size);
  swap(a.is_compressed, b.is_compressed);
  swap(a.is_checksum, b.is_checksum);
  swap(a.time, b.time);
  swap(a.priority_carrier, b.priority_carrier);
  swap(a.is_only_single_system_disk, b.is_only_single_system_disk);
  swap(a.is_continuous_data_replication, b.is_continuous_data_replication);
  swap(a.pre_snapshot_script, b.pre_snapshot_script);
  swap(a.post_snapshot_script, b.post_snapshot_script);
  swap(a.is_compressed_by_packer, b.is_compressed_by_packer);
  swap(a.__isset, b.__isset);
}

replica_job_create_detail::replica_job_create_detail(const replica_job_create_detail& other907) {
  host = other907.host;
  addr = other907.addr;
  username = other907.username;
  password = other907.password;
  type = other907.type;
  virtual_machine_id = other907.virtual_machine_id;
  disks = other907.disks;
  targets = other907.targets;
  carriers = other907.carriers;
  full_replicas = other907.full_replicas;
  disk_ids = other907.disk_ids;
  cbt_info = other907.cbt_info;
  snapshot_info = other907.snapshot_info;
  checksum_verify = other907.checksum_verify;
  always_retry = other907.always_retry;
  timeout = other907.timeout;
  is_encrypted = other907.is_encrypted;
  is_paused = other907.is_paused;
  worker_thread_number = other907.worker_thread_number;
  block_mode_enable = other907.block_mode_enable;
  file_system_filter_enable = other907.file_system_filter_enable;
  min_transport_size = other907.min_transport_size;
  full_min_transport_size = other907.full_min_transport_size;
  is_full_replica = other907.is_full_replica;
  buffer_size = other907.buffer_size;
  is_compressed = other907.is_compressed;
  is_checksum = other907.is_checksum;
  time = other907.time;
  priority_carrier = other907.priority_carrier;
  is_only_single_system_disk = other907.is_only_single_system_disk;
  is_continuous_data_replication = other907.is_continuous_data_replication;
  pre_snapshot_script = other907.pre_snapshot_script;
  post_snapshot_script = other907.post_snapshot_script;
  is_compressed_by_packer = other907.is_compressed_by_packer;
  __isset = other907.__isset;
}
replica_job_create_detail& replica_job_create_detail::operator=(const replica_job_create_detail& other908) {
  host = other908.host;
  addr = other908.addr;
  username = other908.username;
  password = other908.password;
  type = other908.type;
  virtual_machine_id = other908.virtual_machine_id;
  disks = other908.disks;
  targets = other908.targets;
  carriers = other908.carriers;
  full_replicas = other908.full_replicas;
  disk_ids = other908.disk_ids;
  cbt_info = other908.cbt_info;
  snapshot_info = other908.snapshot_info;
  checksum_verify = other908.checksum_verify;
  always_retry = other908.always_retry;
  timeout = other908.timeout;
  is_encrypted = other908.is_encrypted;
  is_paused = other908.is_paused;
  worker_thread_number = other908.worker_thread_number;
  block_mode_enable = other908.block_mode_enable;
  file_system_filter_enable = other908.file_system_filter_enable;
  min_transport_size = other908.min_transport_size;
  full_min_transport_size = other908.full_min_transport_size;
  is_full_replica = other908.is_full_replica;
  buffer_size = other908.buffer_size;
  is_compressed = other908.is_compressed;
  is_checksum = other908.is_checksum;
  time = other908.time;
  priority_carrier = other908.priority_carrier;
  is_only_single_system_disk = other908.is_only_single_system_disk;
  is_continuous_data_replication = other908.is_continuous_data_replication;
  pre_snapshot_script = other908.pre_snapshot_script;
  post_snapshot_script = other908.post_snapshot_script;
  is_compressed_by_packer = other908.is_compressed_by_packer;
  __isset = other908.__isset;
  return *this;
}
void replica_job_create_detail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "replica_job_create_detail(";
  out << "host="; (__isset.host ? (out << to_string(host)) : (out << "<null>"));
  out << ", " << "addr="; (__isset.addr ? (out << to_string(addr)) : (out << "<null>"));
  out << ", " << "username="; (__isset.username ? (out << to_string(username)) : (out << "<null>"));
  out << ", " << "password="; (__isset.password ? (out << to_string(password)) : (out << "<null>"));
  out << ", " << "type="; (__isset.type ? (out << to_string(type)) : (out << "<null>"));
  out << ", " << "virtual_machine_id="; (__isset.virtual_machine_id ? (out << to_string(virtual_machine_id)) : (out << "<null>"));
  out << ", " << "disks="; (__isset.disks ? (out << to_string(disks)) : (out << "<null>"));
  out << ", " << "targets="; (__isset.targets ? (out << to_string(targets)) : (out << "<null>"));
  out << ", " << "carriers="; (__isset.carriers ? (out << to_string(carriers)) : (out << "<null>"));
  out << ", " << "full_replicas="; (__isset.full_replicas ? (out << to_string(full_replicas)) : (out << "<null>"));
  out << ", " << "disk_ids="; (__isset.disk_ids ? (out << to_string(disk_ids)) : (out << "<null>"));
  out << ", " << "cbt_info="; (__isset.cbt_info ? (out << to_string(cbt_info)) : (out << "<null>"));
  out << ", " << "snapshot_info="; (__isset.snapshot_info ? (out << to_string(snapshot_info)) : (out << "<null>"));
  out << ", " << "checksum_verify="; (__isset.checksum_verify ? (out << to_string(checksum_verify)) : (out << "<null>"));
  out << ", " << "always_retry="; (__isset.always_retry ? (out << to_string(always_retry)) : (out << "<null>"));
  out << ", " << "timeout="; (__isset.timeout ? (out << to_string(timeout)) : (out << "<null>"));
  out << ", " << "is_encrypted="; (__isset.is_encrypted ? (out << to_string(is_encrypted)) : (out << "<null>"));
  out << ", " << "is_paused="; (__isset.is_paused ? (out << to_string(is_paused)) : (out << "<null>"));
  out << ", " << "worker_thread_number="; (__isset.worker_thread_number ? (out << to_string(worker_thread_number)) : (out << "<null>"));
  out << ", " << "block_mode_enable="; (__isset.block_mode_enable ? (out << to_string(block_mode_enable)) : (out << "<null>"));
  out << ", " << "file_system_filter_enable="; (__isset.file_system_filter_enable ? (out << to_string(file_system_filter_enable)) : (out << "<null>"));
  out << ", " << "min_transport_size="; (__isset.min_transport_size ? (out << to_string(min_transport_size)) : (out << "<null>"));
  out << ", " << "full_min_transport_size="; (__isset.full_min_transport_size ? (out << to_string(full_min_transport_size)) : (out << "<null>"));
  out << ", " << "is_full_replica="; (__isset.is_full_replica ? (out << to_string(is_full_replica)) : (out << "<null>"));
  out << ", " << "buffer_size="; (__isset.buffer_size ? (out << to_string(buffer_size)) : (out << "<null>"));
  out << ", " << "is_compressed="; (__isset.is_compressed ? (out << to_string(is_compressed)) : (out << "<null>"));
  out << ", " << "is_checksum="; (__isset.is_checksum ? (out << to_string(is_checksum)) : (out << "<null>"));
  out << ", " << "time="; (__isset.time ? (out << to_string(time)) : (out << "<null>"));
  out << ", " << "priority_carrier="; (__isset.priority_carrier ? (out << to_string(priority_carrier)) : (out << "<null>"));
  out << ", " << "is_only_single_system_disk="; (__isset.is_only_single_system_disk ? (out << to_string(is_only_single_system_disk)) : (out << "<null>"));
  out << ", " << "is_continuous_data_replication="; (__isset.is_continuous_data_replication ? (out << to_string(is_continuous_data_replication)) : (out << "<null>"));
  out << ", " << "pre_snapshot_script="; (__isset.pre_snapshot_script ? (out << to_string(pre_snapshot_script)) : (out << "<null>"));
  out << ", " << "post_snapshot_script="; (__isset.post_snapshot_script ? (out << to_string(post_snapshot_script)) : (out << "<null>"));
  out << ", " << "is_compressed_by_packer="; (__isset.is_compressed_by_packer ? (out << to_string(is_compressed_by_packer)) : (out << "<null>"));
  out << ")";
}


aliyun_options::~aliyun_options() throw() {
}


void aliyun_options::__set_access_key(const std::string& val) {
  this->access_key = val;
__isset.access_key = true;
}

void aliyun_options::__set_secret_key(const std::string& val) {
  this->secret_key = val;
__isset.secret_key = true;
}

void aliyun_options::__set_objectname(const std::string& val) {
  this->objectname = val;
__isset.objectname = true;
}

void aliyun_options::__set_bucketname(const std::string& val) {
  this->bucketname = val;
__isset.bucketname = true;
}

void aliyun_options::__set_region(const std::string& val) {
  this->region = val;
__isset.region = true;
}

void aliyun_options::__set_max_size(const int32_t val) {
  this->max_size = val;
__isset.max_size = true;
}

void aliyun_options::__set_file_system_filter_enable(const bool val) {
  this->file_system_filter_enable = val;
__isset.file_system_filter_enable = true;
}

void aliyun_options::__set_number_of_upload_threads(const int16_t val) {
  this->number_of_upload_threads = val;
__isset.number_of_upload_threads = true;
}

void aliyun_options::__set_disks_object_name_mapping(const std::map<std::string, std::string> & val) {
  this->disks_object_name_mapping = val;
__isset.disks_object_name_mapping = true;
}

uint32_t aliyun_options::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->access_key);
          this->__isset.access_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->secret_key);
          this->__isset.secret_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->objectname);
          this->__isset.objectname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->bucketname);
          this->__isset.bucketname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->region);
          this->__isset.region = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->max_size);
          this->__isset.max_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->file_system_filter_enable);
          this->__isset.file_system_filter_enable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->number_of_upload_threads);
          this->__isset.number_of_upload_threads = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->disks_object_name_mapping.clear();
            uint32_t _size909;
            ::apache::thrift::protocol::TType _ktype910;
            ::apache::thrift::protocol::TType _vtype911;
            xfer += iprot->readMapBegin(_ktype910, _vtype911, _size909);
            uint32_t _i913;
            for (_i913 = 0; _i913 < _size909; ++_i913)
            {
              std::string _key914;
              xfer += iprot->readString(_key914);
              std::string& _val915 = this->disks_object_name_mapping[_key914];
              xfer += iprot->readString(_val915);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.disks_object_name_mapping = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t aliyun_options::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("aliyun_options");

  if (this->__isset.access_key) {
    xfer += oprot->writeFieldBegin("access_key", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->access_key);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.secret_key) {
    xfer += oprot->writeFieldBegin("secret_key", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->secret_key);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.objectname) {
    xfer += oprot->writeFieldBegin("objectname", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->objectname);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.bucketname) {
    xfer += oprot->writeFieldBegin("bucketname", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->bucketname);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.region) {
    xfer += oprot->writeFieldBegin("region", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->region);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.max_size) {
    xfer += oprot->writeFieldBegin("max_size", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(this->max_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.file_system_filter_enable) {
    xfer += oprot->writeFieldBegin("file_system_filter_enable", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->file_system_filter_enable);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.number_of_upload_threads) {
    xfer += oprot->writeFieldBegin("number_of_upload_threads", ::apache::thrift::protocol::T_I16, 8);
    xfer += oprot->writeI16(this->number_of_upload_threads);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.disks_object_name_mapping) {
    xfer += oprot->writeFieldBegin("disks_object_name_mapping", ::apache::thrift::protocol::T_MAP, 9);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->disks_object_name_mapping.size()));
      std::map<std::string, std::string> ::const_iterator _iter916;
      for (_iter916 = this->disks_object_name_mapping.begin(); _iter916 != this->disks_object_name_mapping.end(); ++_iter916)
      {
        xfer += oprot->writeString(_iter916->first);
        xfer += oprot->writeString(_iter916->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(aliyun_options &a, aliyun_options &b) {
  using ::std::swap;
  swap(a.access_key, b.access_key);
  swap(a.secret_key, b.secret_key);
  swap(a.objectname, b.objectname);
  swap(a.bucketname, b.bucketname);
  swap(a.region, b.region);
  swap(a.max_size, b.max_size);
  swap(a.file_system_filter_enable, b.file_system_filter_enable);
  swap(a.number_of_upload_threads, b.number_of_upload_threads);
  swap(a.disks_object_name_mapping, b.disks_object_name_mapping);
  swap(a.__isset, b.__isset);
}

aliyun_options::aliyun_options(const aliyun_options& other917) {
  access_key = other917.access_key;
  secret_key = other917.secret_key;
  objectname = other917.objectname;
  bucketname = other917.bucketname;
  region = other917.region;
  max_size = other917.max_size;
  file_system_filter_enable = other917.file_system_filter_enable;
  number_of_upload_threads = other917.number_of_upload_threads;
  disks_object_name_mapping = other917.disks_object_name_mapping;
  __isset = other917.__isset;
}
aliyun_options& aliyun_options::operator=(const aliyun_options& other918) {
  access_key = other918.access_key;
  secret_key = other918.secret_key;
  objectname = other918.objectname;
  bucketname = other918.bucketname;
  region = other918.region;
  max_size = other918.max_size;
  file_system_filter_enable = other918.file_system_filter_enable;
  number_of_upload_threads = other918.number_of_upload_threads;
  disks_object_name_mapping = other918.disks_object_name_mapping;
  __isset = other918.__isset;
  return *this;
}
void aliyun_options::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "aliyun_options(";
  out << "access_key="; (__isset.access_key ? (out << to_string(access_key)) : (out << "<null>"));
  out << ", " << "secret_key="; (__isset.secret_key ? (out << to_string(secret_key)) : (out << "<null>"));
  out << ", " << "objectname="; (__isset.objectname ? (out << to_string(objectname)) : (out << "<null>"));
  out << ", " << "bucketname="; (__isset.bucketname ? (out << to_string(bucketname)) : (out << "<null>"));
  out << ", " << "region="; (__isset.region ? (out << to_string(region)) : (out << "<null>"));
  out << ", " << "max_size="; (__isset.max_size ? (out << to_string(max_size)) : (out << "<null>"));
  out << ", " << "file_system_filter_enable="; (__isset.file_system_filter_enable ? (out << to_string(file_system_filter_enable)) : (out << "<null>"));
  out << ", " << "number_of_upload_threads="; (__isset.number_of_upload_threads ? (out << to_string(number_of_upload_threads)) : (out << "<null>"));
  out << ", " << "disks_object_name_mapping="; (__isset.disks_object_name_mapping ? (out << to_string(disks_object_name_mapping)) : (out << "<null>"));
  out << ")";
}


tencent_options::~tencent_options() throw() {
}


void tencent_options::__set_access_key(const std::string& val) {
  this->access_key = val;
__isset.access_key = true;
}

void tencent_options::__set_secret_key(const std::string& val) {
  this->secret_key = val;
__isset.secret_key = true;
}

void tencent_options::__set_objectname(const std::string& val) {
  this->objectname = val;
__isset.objectname = true;
}

void tencent_options::__set_bucketname(const std::string& val) {
  this->bucketname = val;
__isset.bucketname = true;
}

void tencent_options::__set_region(const std::string& val) {
  this->region = val;
__isset.region = true;
}

void tencent_options::__set_max_size(const int32_t val) {
  this->max_size = val;
__isset.max_size = true;
}

void tencent_options::__set_file_system_filter_enable(const bool val) {
  this->file_system_filter_enable = val;
__isset.file_system_filter_enable = true;
}

void tencent_options::__set_number_of_upload_threads(const int16_t val) {
  this->number_of_upload_threads = val;
__isset.number_of_upload_threads = true;
}

void tencent_options::__set_disks_object_name_mapping(const std::map<std::string, std::string> & val) {
  this->disks_object_name_mapping = val;
__isset.disks_object_name_mapping = true;
}

uint32_t tencent_options::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->access_key);
          this->__isset.access_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->secret_key);
          this->__isset.secret_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->objectname);
          this->__isset.objectname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->bucketname);
          this->__isset.bucketname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->region);
          this->__isset.region = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->max_size);
          this->__isset.max_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->file_system_filter_enable);
          this->__isset.file_system_filter_enable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->number_of_upload_threads);
          this->__isset.number_of_upload_threads = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->disks_object_name_mapping.clear();
            uint32_t _size919;
            ::apache::thrift::protocol::TType _ktype920;
            ::apache::thrift::protocol::TType _vtype921;
            xfer += iprot->readMapBegin(_ktype920, _vtype921, _size919);
            uint32_t _i923;
            for (_i923 = 0; _i923 < _size919; ++_i923)
            {
              std::string _key924;
              xfer += iprot->readString(_key924);
              std::string& _val925 = this->disks_object_name_mapping[_key924];
              xfer += iprot->readString(_val925);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.disks_object_name_mapping = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t tencent_options::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("tencent_options");

  if (this->__isset.access_key) {
    xfer += oprot->writeFieldBegin("access_key", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->access_key);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.secret_key) {
    xfer += oprot->writeFieldBegin("secret_key", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->secret_key);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.objectname) {
    xfer += oprot->writeFieldBegin("objectname", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->objectname);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.bucketname) {
    xfer += oprot->writeFieldBegin("bucketname", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->bucketname);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.region) {
    xfer += oprot->writeFieldBegin("region", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->region);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.max_size) {
    xfer += oprot->writeFieldBegin("max_size", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(this->max_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.file_system_filter_enable) {
    xfer += oprot->writeFieldBegin("file_system_filter_enable", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->file_system_filter_enable);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.number_of_upload_threads) {
    xfer += oprot->writeFieldBegin("number_of_upload_threads", ::apache::thrift::protocol::T_I16, 8);
    xfer += oprot->writeI16(this->number_of_upload_threads);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.disks_object_name_mapping) {
    xfer += oprot->writeFieldBegin("disks_object_name_mapping", ::apache::thrift::protocol::T_MAP, 9);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->disks_object_name_mapping.size()));
      std::map<std::string, std::string> ::const_iterator _iter926;
      for (_iter926 = this->disks_object_name_mapping.begin(); _iter926 != this->disks_object_name_mapping.end(); ++_iter926)
      {
        xfer += oprot->writeString(_iter926->first);
        xfer += oprot->writeString(_iter926->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(tencent_options &a, tencent_options &b) {
  using ::std::swap;
  swap(a.access_key, b.access_key);
  swap(a.secret_key, b.secret_key);
  swap(a.objectname, b.objectname);
  swap(a.bucketname, b.bucketname);
  swap(a.region, b.region);
  swap(a.max_size, b.max_size);
  swap(a.file_system_filter_enable, b.file_system_filter_enable);
  swap(a.number_of_upload_threads, b.number_of_upload_threads);
  swap(a.disks_object_name_mapping, b.disks_object_name_mapping);
  swap(a.__isset, b.__isset);
}

tencent_options::tencent_options(const tencent_options& other927) {
  access_key = other927.access_key;
  secret_key = other927.secret_key;
  objectname = other927.objectname;
  bucketname = other927.bucketname;
  region = other927.region;
  max_size = other927.max_size;
  file_system_filter_enable = other927.file_system_filter_enable;
  number_of_upload_threads = other927.number_of_upload_threads;
  disks_object_name_mapping = other927.disks_object_name_mapping;
  __isset = other927.__isset;
}
tencent_options& tencent_options::operator=(const tencent_options& other928) {
  access_key = other928.access_key;
  secret_key = other928.secret_key;
  objectname = other928.objectname;
  bucketname = other928.bucketname;
  region = other928.region;
  max_size = other928.max_size;
  file_system_filter_enable = other928.file_system_filter_enable;
  number_of_upload_threads = other928.number_of_upload_threads;
  disks_object_name_mapping = other928.disks_object_name_mapping;
  __isset = other928.__isset;
  return *this;
}
void tencent_options::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "tencent_options(";
  out << "access_key="; (__isset.access_key ? (out << to_string(access_key)) : (out << "<null>"));
  out << ", " << "secret_key="; (__isset.secret_key ? (out << to_string(secret_key)) : (out << "<null>"));
  out << ", " << "objectname="; (__isset.objectname ? (out << to_string(objectname)) : (out << "<null>"));
  out << ", " << "bucketname="; (__isset.bucketname ? (out << to_string(bucketname)) : (out << "<null>"));
  out << ", " << "region="; (__isset.region ? (out << to_string(region)) : (out << "<null>"));
  out << ", " << "max_size="; (__isset.max_size ? (out << to_string(max_size)) : (out << "<null>"));
  out << ", " << "file_system_filter_enable="; (__isset.file_system_filter_enable ? (out << to_string(file_system_filter_enable)) : (out << "<null>"));
  out << ", " << "number_of_upload_threads="; (__isset.number_of_upload_threads ? (out << to_string(number_of_upload_threads)) : (out << "<null>"));
  out << ", " << "disks_object_name_mapping="; (__isset.disks_object_name_mapping ? (out << to_string(disks_object_name_mapping)) : (out << "<null>"));
  out << ")";
}


extra_options::~extra_options() throw() {
}


void extra_options::__set_aliyun(const aliyun_options& val) {
  this->aliyun = val;
__isset.aliyun = true;
}

void extra_options::__set_tencent(const tencent_options& val) {
  this->tencent = val;
__isset.tencent = true;
}

uint32_t extra_options::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->aliyun.read(iprot);
          this->__isset.aliyun = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tencent.read(iprot);
          this->__isset.tencent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t extra_options::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("extra_options");

  if (this->__isset.aliyun) {
    xfer += oprot->writeFieldBegin("aliyun", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->aliyun.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tencent) {
    xfer += oprot->writeFieldBegin("tencent", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->tencent.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(extra_options &a, extra_options &b) {
  using ::std::swap;
  swap(a.aliyun, b.aliyun);
  swap(a.tencent, b.tencent);
  swap(a.__isset, b.__isset);
}

extra_options::extra_options(const extra_options& other929) {
  aliyun = other929.aliyun;
  tencent = other929.tencent;
  __isset = other929.__isset;
}
extra_options& extra_options::operator=(const extra_options& other930) {
  aliyun = other930.aliyun;
  tencent = other930.tencent;
  __isset = other930.__isset;
  return *this;
}
void extra_options::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "extra_options(";
  out << "aliyun="; (__isset.aliyun ? (out << to_string(aliyun)) : (out << "<null>"));
  out << ", " << "tencent="; (__isset.tencent ? (out << to_string(tencent)) : (out << "<null>"));
  out << ")";
}


vhd_snapshot::~vhd_snapshot() throw() {
}


void vhd_snapshot::__set_id(const std::string& val) {
  this->id = val;
__isset.id = true;
}

void vhd_snapshot::__set_datetime(const std::string& val) {
  this->datetime = val;
__isset.datetime = true;
}

void vhd_snapshot::__set_name(const std::string& val) {
  this->name = val;
__isset.name = true;
}

uint32_t vhd_snapshot::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->datetime);
          this->__isset.datetime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t vhd_snapshot::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("vhd_snapshot");

  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.datetime) {
    xfer += oprot->writeFieldBegin("datetime", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->datetime);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(vhd_snapshot &a, vhd_snapshot &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.datetime, b.datetime);
  swap(a.name, b.name);
  swap(a.__isset, b.__isset);
}

vhd_snapshot::vhd_snapshot(const vhd_snapshot& other931) {
  id = other931.id;
  datetime = other931.datetime;
  name = other931.name;
  __isset = other931.__isset;
}
vhd_snapshot& vhd_snapshot::operator=(const vhd_snapshot& other932) {
  id = other932.id;
  datetime = other932.datetime;
  name = other932.name;
  __isset = other932.__isset;
  return *this;
}
void vhd_snapshot::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "vhd_snapshot(";
  out << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "datetime="; (__isset.datetime ? (out << to_string(datetime)) : (out << "<null>"));
  out << ", " << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
  out << ")";
}


loader_job_create_detail::~loader_job_create_detail() throw() {
}


void loader_job_create_detail::__set_replica_id(const std::string& val) {
  this->replica_id = val;
__isset.replica_id = true;
}

void loader_job_create_detail::__set_disks_lun_mapping(const std::map<std::string, std::string> & val) {
  this->disks_lun_mapping = val;
__isset.disks_lun_mapping = true;
}

void loader_job_create_detail::__set_snapshots(const std::vector<std::string> & val) {
  this->snapshots = val;
__isset.snapshots = true;
}

void loader_job_create_detail::__set_disks_snapshot_mapping(const std::map<std::string, std::map<std::string, std::string> > & val) {
  this->disks_snapshot_mapping = val;
__isset.disks_snapshot_mapping = true;
}

void loader_job_create_detail::__set_connection_id(const std::string& val) {
  this->connection_id = val;
__isset.connection_id = true;
}

void loader_job_create_detail::__set_block_mode_enable(const bool val) {
  this->block_mode_enable = val;
__isset.block_mode_enable = true;
}

void loader_job_create_detail::__set_purge_data(const bool val) {
  this->purge_data = val;
__isset.purge_data = true;
}

void loader_job_create_detail::__set_remap(const bool val) {
  this->remap = val;
__isset.remap = true;
}

void loader_job_create_detail::__set_detect_type(const disk_detect_type::type val) {
  this->detect_type = val;
__isset.detect_type = true;
}

void loader_job_create_detail::__set_worker_thread_number(const int32_t val) {
  this->worker_thread_number = val;
__isset.worker_thread_number = true;
}

void loader_job_create_detail::__set_host_name(const std::string& val) {
  this->host_name = val;
__isset.host_name = true;
}

void loader_job_create_detail::__set_export_disk_type(const virtual_disk_type::type val) {
  this->export_disk_type = val;
__isset.export_disk_type = true;
}

void loader_job_create_detail::__set_export_path(const std::string& val) {
  this->export_path = val;
__isset.export_path = true;
}

void loader_job_create_detail::__set_disks_size_mapping(const std::map<std::string, int64_t> & val) {
  this->disks_size_mapping = val;
__isset.disks_size_mapping = true;
}

void loader_job_create_detail::__set_keep_alive(const bool val) {
  this->keep_alive = val;
__isset.keep_alive = true;
}

void loader_job_create_detail::__set_time(const std::string& val) {
  this->time = val;
__isset.time = true;
}

void loader_job_create_detail::__set_is_continuous_data_replication(const bool val) {
  this->is_continuous_data_replication = val;
__isset.is_continuous_data_replication = true;
}

void loader_job_create_detail::__set_azure_storage_connection_string(const std::string& val) {
  this->azure_storage_connection_string = val;
__isset.azure_storage_connection_string = true;
}

uint32_t loader_job_create_detail::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->replica_id);
          this->__isset.replica_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->disks_lun_mapping.clear();
            uint32_t _size933;
            ::apache::thrift::protocol::TType _ktype934;
            ::apache::thrift::protocol::TType _vtype935;
            xfer += iprot->readMapBegin(_ktype934, _vtype935, _size933);
            uint32_t _i937;
            for (_i937 = 0; _i937 < _size933; ++_i937)
            {
              std::string _key938;
              xfer += iprot->readString(_key938);
              std::string& _val939 = this->disks_lun_mapping[_key938];
              xfer += iprot->readString(_val939);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.disks_lun_mapping = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->snapshots.clear();
            uint32_t _size940;
            ::apache::thrift::protocol::TType _etype943;
            xfer += iprot->readListBegin(_etype943, _size940);
            this->snapshots.resize(_size940);
            uint32_t _i944;
            for (_i944 = 0; _i944 < _size940; ++_i944)
            {
              xfer += iprot->readString(this->snapshots[_i944]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.snapshots = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->disks_snapshot_mapping.clear();
            uint32_t _size945;
            ::apache::thrift::protocol::TType _ktype946;
            ::apache::thrift::protocol::TType _vtype947;
            xfer += iprot->readMapBegin(_ktype946, _vtype947, _size945);
            uint32_t _i949;
            for (_i949 = 0; _i949 < _size945; ++_i949)
            {
              std::string _key950;
              xfer += iprot->readString(_key950);
              std::map<std::string, std::string> & _val951 = this->disks_snapshot_mapping[_key950];
              {
                _val951.clear();
                uint32_t _size952;
                ::apache::thrift::protocol::TType _ktype953;
                ::apache::thrift::protocol::TType _vtype954;
                xfer += iprot->readMapBegin(_ktype953, _vtype954, _size952);
                uint32_t _i956;
                for (_i956 = 0; _i956 < _size952; ++_i956)
                {
                  std::string _key957;
                  xfer += iprot->readString(_key957);
                  std::string& _val958 = _val951[_key957];
                  xfer += iprot->readString(_val958);
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.disks_snapshot_mapping = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->connection_id);
          this->__isset.connection_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->block_mode_enable);
          this->__isset.block_mode_enable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->purge_data);
          this->__isset.purge_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->remap);
          this->__isset.remap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast959;
          xfer += iprot->readI32(ecast959);
          this->detect_type = (disk_detect_type::type)ecast959;
          this->__isset.detect_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->worker_thread_number);
          this->__isset.worker_thread_number = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host_name);
          this->__isset.host_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast960;
          xfer += iprot->readI32(ecast960);
          this->export_disk_type = (virtual_disk_type::type)ecast960;
          this->__isset.export_disk_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->export_path);
          this->__isset.export_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->disks_size_mapping.clear();
            uint32_t _size961;
            ::apache::thrift::protocol::TType _ktype962;
            ::apache::thrift::protocol::TType _vtype963;
            xfer += iprot->readMapBegin(_ktype962, _vtype963, _size961);
            uint32_t _i965;
            for (_i965 = 0; _i965 < _size961; ++_i965)
            {
              std::string _key966;
              xfer += iprot->readString(_key966);
              int64_t& _val967 = this->disks_size_mapping[_key966];
              xfer += iprot->readI64(_val967);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.disks_size_mapping = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->keep_alive);
          this->__isset.keep_alive = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->time);
          this->__isset.time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_continuous_data_replication);
          this->__isset.is_continuous_data_replication = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->azure_storage_connection_string);
          this->__isset.azure_storage_connection_string = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t loader_job_create_detail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("loader_job_create_detail");

  if (this->__isset.replica_id) {
    xfer += oprot->writeFieldBegin("replica_id", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->replica_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.disks_lun_mapping) {
    xfer += oprot->writeFieldBegin("disks_lun_mapping", ::apache::thrift::protocol::T_MAP, 2);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->disks_lun_mapping.size()));
      std::map<std::string, std::string> ::const_iterator _iter968;
      for (_iter968 = this->disks_lun_mapping.begin(); _iter968 != this->disks_lun_mapping.end(); ++_iter968)
      {
        xfer += oprot->writeString(_iter968->first);
        xfer += oprot->writeString(_iter968->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.snapshots) {
    xfer += oprot->writeFieldBegin("snapshots", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->snapshots.size()));
      std::vector<std::string> ::const_iterator _iter969;
      for (_iter969 = this->snapshots.begin(); _iter969 != this->snapshots.end(); ++_iter969)
      {
        xfer += oprot->writeString((*_iter969));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.disks_snapshot_mapping) {
    xfer += oprot->writeFieldBegin("disks_snapshot_mapping", ::apache::thrift::protocol::T_MAP, 4);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->disks_snapshot_mapping.size()));
      std::map<std::string, std::map<std::string, std::string> > ::const_iterator _iter970;
      for (_iter970 = this->disks_snapshot_mapping.begin(); _iter970 != this->disks_snapshot_mapping.end(); ++_iter970)
      {
        xfer += oprot->writeString(_iter970->first);
        {
          xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter970->second.size()));
          std::map<std::string, std::string> ::const_iterator _iter971;
          for (_iter971 = _iter970->second.begin(); _iter971 != _iter970->second.end(); ++_iter971)
          {
            xfer += oprot->writeString(_iter971->first);
            xfer += oprot->writeString(_iter971->second);
          }
          xfer += oprot->writeMapEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.connection_id) {
    xfer += oprot->writeFieldBegin("connection_id", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->connection_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.block_mode_enable) {
    xfer += oprot->writeFieldBegin("block_mode_enable", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->block_mode_enable);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.purge_data) {
    xfer += oprot->writeFieldBegin("purge_data", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->purge_data);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.remap) {
    xfer += oprot->writeFieldBegin("remap", ::apache::thrift::protocol::T_BOOL, 8);
    xfer += oprot->writeBool(this->remap);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.detect_type) {
    xfer += oprot->writeFieldBegin("detect_type", ::apache::thrift::protocol::T_I32, 9);
    xfer += oprot->writeI32((int32_t)this->detect_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.worker_thread_number) {
    xfer += oprot->writeFieldBegin("worker_thread_number", ::apache::thrift::protocol::T_I32, 10);
    xfer += oprot->writeI32(this->worker_thread_number);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.host_name) {
    xfer += oprot->writeFieldBegin("host_name", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeString(this->host_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.export_disk_type) {
    xfer += oprot->writeFieldBegin("export_disk_type", ::apache::thrift::protocol::T_I32, 12);
    xfer += oprot->writeI32((int32_t)this->export_disk_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.export_path) {
    xfer += oprot->writeFieldBegin("export_path", ::apache::thrift::protocol::T_STRING, 13);
    xfer += oprot->writeString(this->export_path);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.disks_size_mapping) {
    xfer += oprot->writeFieldBegin("disks_size_mapping", ::apache::thrift::protocol::T_MAP, 14);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->disks_size_mapping.size()));
      std::map<std::string, int64_t> ::const_iterator _iter972;
      for (_iter972 = this->disks_size_mapping.begin(); _iter972 != this->disks_size_mapping.end(); ++_iter972)
      {
        xfer += oprot->writeString(_iter972->first);
        xfer += oprot->writeI64(_iter972->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.keep_alive) {
    xfer += oprot->writeFieldBegin("keep_alive", ::apache::thrift::protocol::T_BOOL, 15);
    xfer += oprot->writeBool(this->keep_alive);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.time) {
    xfer += oprot->writeFieldBegin("time", ::apache::thrift::protocol::T_STRING, 16);
    xfer += oprot->writeString(this->time);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_continuous_data_replication) {
    xfer += oprot->writeFieldBegin("is_continuous_data_replication", ::apache::thrift::protocol::T_BOOL, 17);
    xfer += oprot->writeBool(this->is_continuous_data_replication);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.azure_storage_connection_string) {
    xfer += oprot->writeFieldBegin("azure_storage_connection_string", ::apache::thrift::protocol::T_STRING, 18);
    xfer += oprot->writeString(this->azure_storage_connection_string);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(loader_job_create_detail &a, loader_job_create_detail &b) {
  using ::std::swap;
  swap(a.replica_id, b.replica_id);
  swap(a.disks_lun_mapping, b.disks_lun_mapping);
  swap(a.snapshots, b.snapshots);
  swap(a.disks_snapshot_mapping, b.disks_snapshot_mapping);
  swap(a.connection_id, b.connection_id);
  swap(a.block_mode_enable, b.block_mode_enable);
  swap(a.purge_data, b.purge_data);
  swap(a.remap, b.remap);
  swap(a.detect_type, b.detect_type);
  swap(a.worker_thread_number, b.worker_thread_number);
  swap(a.host_name, b.host_name);
  swap(a.export_disk_type, b.export_disk_type);
  swap(a.export_path, b.export_path);
  swap(a.disks_size_mapping, b.disks_size_mapping);
  swap(a.keep_alive, b.keep_alive);
  swap(a.time, b.time);
  swap(a.is_continuous_data_replication, b.is_continuous_data_replication);
  swap(a.azure_storage_connection_string, b.azure_storage_connection_string);
  swap(a.__isset, b.__isset);
}

loader_job_create_detail::loader_job_create_detail(const loader_job_create_detail& other973) {
  replica_id = other973.replica_id;
  disks_lun_mapping = other973.disks_lun_mapping;
  snapshots = other973.snapshots;
  disks_snapshot_mapping = other973.disks_snapshot_mapping;
  connection_id = other973.connection_id;
  block_mode_enable = other973.block_mode_enable;
  purge_data = other973.purge_data;
  remap = other973.remap;
  detect_type = other973.detect_type;
  worker_thread_number = other973.worker_thread_number;
  host_name = other973.host_name;
  export_disk_type = other973.export_disk_type;
  export_path = other973.export_path;
  disks_size_mapping = other973.disks_size_mapping;
  keep_alive = other973.keep_alive;
  time = other973.time;
  is_continuous_data_replication = other973.is_continuous_data_replication;
  azure_storage_connection_string = other973.azure_storage_connection_string;
  __isset = other973.__isset;
}
loader_job_create_detail& loader_job_create_detail::operator=(const loader_job_create_detail& other974) {
  replica_id = other974.replica_id;
  disks_lun_mapping = other974.disks_lun_mapping;
  snapshots = other974.snapshots;
  disks_snapshot_mapping = other974.disks_snapshot_mapping;
  connection_id = other974.connection_id;
  block_mode_enable = other974.block_mode_enable;
  purge_data = other974.purge_data;
  remap = other974.remap;
  detect_type = other974.detect_type;
  worker_thread_number = other974.worker_thread_number;
  host_name = other974.host_name;
  export_disk_type = other974.export_disk_type;
  export_path = other974.export_path;
  disks_size_mapping = other974.disks_size_mapping;
  keep_alive = other974.keep_alive;
  time = other974.time;
  is_continuous_data_replication = other974.is_continuous_data_replication;
  azure_storage_connection_string = other974.azure_storage_connection_string;
  __isset = other974.__isset;
  return *this;
}
void loader_job_create_detail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "loader_job_create_detail(";
  out << "replica_id="; (__isset.replica_id ? (out << to_string(replica_id)) : (out << "<null>"));
  out << ", " << "disks_lun_mapping="; (__isset.disks_lun_mapping ? (out << to_string(disks_lun_mapping)) : (out << "<null>"));
  out << ", " << "snapshots="; (__isset.snapshots ? (out << to_string(snapshots)) : (out << "<null>"));
  out << ", " << "disks_snapshot_mapping="; (__isset.disks_snapshot_mapping ? (out << to_string(disks_snapshot_mapping)) : (out << "<null>"));
  out << ", " << "connection_id="; (__isset.connection_id ? (out << to_string(connection_id)) : (out << "<null>"));
  out << ", " << "block_mode_enable="; (__isset.block_mode_enable ? (out << to_string(block_mode_enable)) : (out << "<null>"));
  out << ", " << "purge_data="; (__isset.purge_data ? (out << to_string(purge_data)) : (out << "<null>"));
  out << ", " << "remap="; (__isset.remap ? (out << to_string(remap)) : (out << "<null>"));
  out << ", " << "detect_type="; (__isset.detect_type ? (out << to_string(detect_type)) : (out << "<null>"));
  out << ", " << "worker_thread_number="; (__isset.worker_thread_number ? (out << to_string(worker_thread_number)) : (out << "<null>"));
  out << ", " << "host_name="; (__isset.host_name ? (out << to_string(host_name)) : (out << "<null>"));
  out << ", " << "export_disk_type="; (__isset.export_disk_type ? (out << to_string(export_disk_type)) : (out << "<null>"));
  out << ", " << "export_path="; (__isset.export_path ? (out << to_string(export_path)) : (out << "<null>"));
  out << ", " << "disks_size_mapping="; (__isset.disks_size_mapping ? (out << to_string(disks_size_mapping)) : (out << "<null>"));
  out << ", " << "keep_alive="; (__isset.keep_alive ? (out << to_string(keep_alive)) : (out << "<null>"));
  out << ", " << "time="; (__isset.time ? (out << to_string(time)) : (out << "<null>"));
  out << ", " << "is_continuous_data_replication="; (__isset.is_continuous_data_replication ? (out << to_string(is_continuous_data_replication)) : (out << "<null>"));
  out << ", " << "azure_storage_connection_string="; (__isset.azure_storage_connection_string ? (out << to_string(azure_storage_connection_string)) : (out << "<null>"));
  out << ")";
}


launcher_job_create_detail::~launcher_job_create_detail() throw() {
}


void launcher_job_create_detail::__set_replica_id(const std::string& val) {
  this->replica_id = val;
__isset.replica_id = true;
}

void launcher_job_create_detail::__set_disks_lun_mapping(const std::map<std::string, std::string> & val) {
  this->disks_lun_mapping = val;
__isset.disks_lun_mapping = true;
}

void launcher_job_create_detail::__set_is_sysvol_authoritative_restore(const bool val) {
  this->is_sysvol_authoritative_restore = val;
__isset.is_sysvol_authoritative_restore = true;
}

void launcher_job_create_detail::__set_is_enable_debug(const bool val) {
  this->is_enable_debug = val;
__isset.is_enable_debug = true;
}

void launcher_job_create_detail::__set_is_disable_machine_password_change(const bool val) {
  this->is_disable_machine_password_change = val;
__isset.is_disable_machine_password_change = true;
}

void launcher_job_create_detail::__set_is_force_normal_boot(const bool val) {
  this->is_force_normal_boot = val;
__isset.is_force_normal_boot = true;
}

void launcher_job_create_detail::__set_network_infos(const std::set<network_info> & val) {
  this->network_infos = val;
__isset.network_infos = true;
}

void launcher_job_create_detail::__set_config(const std::string& val) {
  this->config = val;
__isset.config = true;
}

void launcher_job_create_detail::__set_gpt_to_mbr(const bool val) {
  this->gpt_to_mbr = val;
__isset.gpt_to_mbr = true;
}

void launcher_job_create_detail::__set_detect_type(const disk_detect_type::type val) {
  this->detect_type = val;
__isset.detect_type = true;
}

void launcher_job_create_detail::__set_skip_system_injection(const bool val) {
  this->skip_system_injection = val;
__isset.skip_system_injection = true;
}

void launcher_job_create_detail::__set_reboot_winpe(const bool val) {
  this->reboot_winpe = val;
__isset.reboot_winpe = true;
}

void launcher_job_create_detail::__set_callbacks(const std::set<std::string> & val) {
  this->callbacks = val;
__isset.callbacks = true;
}

void launcher_job_create_detail::__set_callback_timeout(const int32_t val) {
  this->callback_timeout = val;
__isset.callback_timeout = true;
}

void launcher_job_create_detail::__set_host_name(const std::string& val) {
  this->host_name = val;
__isset.host_name = true;
}

void launcher_job_create_detail::__set_export_disk_type(const virtual_disk_type::type val) {
  this->export_disk_type = val;
__isset.export_disk_type = true;
}

void launcher_job_create_detail::__set_export_path(const std::string& val) {
  this->export_path = val;
__isset.export_path = true;
}

void launcher_job_create_detail::__set_target_type(const conversion_type::type val) {
  this->target_type = val;
__isset.target_type = true;
}

void launcher_job_create_detail::__set_os_type(const hv_guest_os_type::type val) {
  this->os_type = val;
__isset.os_type = true;
}

void launcher_job_create_detail::__set_is_update_ex(const bool val) {
  this->is_update_ex = val;
__isset.is_update_ex = true;
}

void launcher_job_create_detail::__set_options_type(const extra_options_type::type val) {
  this->options_type = val;
__isset.options_type = true;
}

void launcher_job_create_detail::__set_options(const extra_options& val) {
  this->options = val;
__isset.options = true;
}

void launcher_job_create_detail::__set_pre_scripts(const std::set<std::string> & val) {
  this->pre_scripts = val;
__isset.pre_scripts = true;
}

void launcher_job_create_detail::__set_post_scripts(const std::set<std::string> & val) {
  this->post_scripts = val;
__isset.post_scripts = true;
}

uint32_t launcher_job_create_detail::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->replica_id);
          this->__isset.replica_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->disks_lun_mapping.clear();
            uint32_t _size975;
            ::apache::thrift::protocol::TType _ktype976;
            ::apache::thrift::protocol::TType _vtype977;
            xfer += iprot->readMapBegin(_ktype976, _vtype977, _size975);
            uint32_t _i979;
            for (_i979 = 0; _i979 < _size975; ++_i979)
            {
              std::string _key980;
              xfer += iprot->readString(_key980);
              std::string& _val981 = this->disks_lun_mapping[_key980];
              xfer += iprot->readString(_val981);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.disks_lun_mapping = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_sysvol_authoritative_restore);
          this->__isset.is_sysvol_authoritative_restore = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_enable_debug);
          this->__isset.is_enable_debug = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_disable_machine_password_change);
          this->__isset.is_disable_machine_password_change = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_force_normal_boot);
          this->__isset.is_force_normal_boot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->network_infos.clear();
            uint32_t _size982;
            ::apache::thrift::protocol::TType _etype985;
            xfer += iprot->readSetBegin(_etype985, _size982);
            uint32_t _i986;
            for (_i986 = 0; _i986 < _size982; ++_i986)
            {
              network_info _elem987;
              xfer += _elem987.read(iprot);
              this->network_infos.insert(_elem987);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.network_infos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->config);
          this->__isset.config = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->gpt_to_mbr);
          this->__isset.gpt_to_mbr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast988;
          xfer += iprot->readI32(ecast988);
          this->detect_type = (disk_detect_type::type)ecast988;
          this->__isset.detect_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->skip_system_injection);
          this->__isset.skip_system_injection = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->reboot_winpe);
          this->__isset.reboot_winpe = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->callbacks.clear();
            uint32_t _size989;
            ::apache::thrift::protocol::TType _etype992;
            xfer += iprot->readSetBegin(_etype992, _size989);
            uint32_t _i993;
            for (_i993 = 0; _i993 < _size989; ++_i993)
            {
              std::string _elem994;
              xfer += iprot->readString(_elem994);
              this->callbacks.insert(_elem994);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.callbacks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->callback_timeout);
          this->__isset.callback_timeout = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host_name);
          this->__isset.host_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast995;
          xfer += iprot->readI32(ecast995);
          this->export_disk_type = (virtual_disk_type::type)ecast995;
          this->__isset.export_disk_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->export_path);
          this->__isset.export_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast996;
          xfer += iprot->readI32(ecast996);
          this->target_type = (conversion_type::type)ecast996;
          this->__isset.target_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast997;
          xfer += iprot->readI32(ecast997);
          this->os_type = (hv_guest_os_type::type)ecast997;
          this->__isset.os_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_update_ex);
          this->__isset.is_update_ex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast998;
          xfer += iprot->readI32(ecast998);
          this->options_type = (extra_options_type::type)ecast998;
          this->__isset.options_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->options.read(iprot);
          this->__isset.options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->pre_scripts.clear();
            uint32_t _size999;
            ::apache::thrift::protocol::TType _etype1002;
            xfer += iprot->readSetBegin(_etype1002, _size999);
            uint32_t _i1003;
            for (_i1003 = 0; _i1003 < _size999; ++_i1003)
            {
              std::string _elem1004;
              xfer += iprot->readString(_elem1004);
              this->pre_scripts.insert(_elem1004);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.pre_scripts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->post_scripts.clear();
            uint32_t _size1005;
            ::apache::thrift::protocol::TType _etype1008;
            xfer += iprot->readSetBegin(_etype1008, _size1005);
            uint32_t _i1009;
            for (_i1009 = 0; _i1009 < _size1005; ++_i1009)
            {
              std::string _elem1010;
              xfer += iprot->readString(_elem1010);
              this->post_scripts.insert(_elem1010);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.post_scripts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t launcher_job_create_detail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("launcher_job_create_detail");

  if (this->__isset.replica_id) {
    xfer += oprot->writeFieldBegin("replica_id", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->replica_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.disks_lun_mapping) {
    xfer += oprot->writeFieldBegin("disks_lun_mapping", ::apache::thrift::protocol::T_MAP, 2);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->disks_lun_mapping.size()));
      std::map<std::string, std::string> ::const_iterator _iter1011;
      for (_iter1011 = this->disks_lun_mapping.begin(); _iter1011 != this->disks_lun_mapping.end(); ++_iter1011)
      {
        xfer += oprot->writeString(_iter1011->first);
        xfer += oprot->writeString(_iter1011->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_sysvol_authoritative_restore) {
    xfer += oprot->writeFieldBegin("is_sysvol_authoritative_restore", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->is_sysvol_authoritative_restore);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_enable_debug) {
    xfer += oprot->writeFieldBegin("is_enable_debug", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->is_enable_debug);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_disable_machine_password_change) {
    xfer += oprot->writeFieldBegin("is_disable_machine_password_change", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->is_disable_machine_password_change);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_force_normal_boot) {
    xfer += oprot->writeFieldBegin("is_force_normal_boot", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->is_force_normal_boot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.network_infos) {
    xfer += oprot->writeFieldBegin("network_infos", ::apache::thrift::protocol::T_SET, 7);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->network_infos.size()));
      std::set<network_info> ::const_iterator _iter1012;
      for (_iter1012 = this->network_infos.begin(); _iter1012 != this->network_infos.end(); ++_iter1012)
      {
        xfer += (*_iter1012).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.config) {
    xfer += oprot->writeFieldBegin("config", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->config);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.gpt_to_mbr) {
    xfer += oprot->writeFieldBegin("gpt_to_mbr", ::apache::thrift::protocol::T_BOOL, 9);
    xfer += oprot->writeBool(this->gpt_to_mbr);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.detect_type) {
    xfer += oprot->writeFieldBegin("detect_type", ::apache::thrift::protocol::T_I32, 10);
    xfer += oprot->writeI32((int32_t)this->detect_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.skip_system_injection) {
    xfer += oprot->writeFieldBegin("skip_system_injection", ::apache::thrift::protocol::T_BOOL, 11);
    xfer += oprot->writeBool(this->skip_system_injection);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.reboot_winpe) {
    xfer += oprot->writeFieldBegin("reboot_winpe", ::apache::thrift::protocol::T_BOOL, 12);
    xfer += oprot->writeBool(this->reboot_winpe);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.callbacks) {
    xfer += oprot->writeFieldBegin("callbacks", ::apache::thrift::protocol::T_SET, 13);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->callbacks.size()));
      std::set<std::string> ::const_iterator _iter1013;
      for (_iter1013 = this->callbacks.begin(); _iter1013 != this->callbacks.end(); ++_iter1013)
      {
        xfer += oprot->writeString((*_iter1013));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.callback_timeout) {
    xfer += oprot->writeFieldBegin("callback_timeout", ::apache::thrift::protocol::T_I32, 14);
    xfer += oprot->writeI32(this->callback_timeout);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.host_name) {
    xfer += oprot->writeFieldBegin("host_name", ::apache::thrift::protocol::T_STRING, 15);
    xfer += oprot->writeString(this->host_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.export_disk_type) {
    xfer += oprot->writeFieldBegin("export_disk_type", ::apache::thrift::protocol::T_I32, 16);
    xfer += oprot->writeI32((int32_t)this->export_disk_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.export_path) {
    xfer += oprot->writeFieldBegin("export_path", ::apache::thrift::protocol::T_STRING, 17);
    xfer += oprot->writeString(this->export_path);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.target_type) {
    xfer += oprot->writeFieldBegin("target_type", ::apache::thrift::protocol::T_I32, 18);
    xfer += oprot->writeI32((int32_t)this->target_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.os_type) {
    xfer += oprot->writeFieldBegin("os_type", ::apache::thrift::protocol::T_I32, 19);
    xfer += oprot->writeI32((int32_t)this->os_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_update_ex) {
    xfer += oprot->writeFieldBegin("is_update_ex", ::apache::thrift::protocol::T_BOOL, 20);
    xfer += oprot->writeBool(this->is_update_ex);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.options_type) {
    xfer += oprot->writeFieldBegin("options_type", ::apache::thrift::protocol::T_I32, 21);
    xfer += oprot->writeI32((int32_t)this->options_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.options) {
    xfer += oprot->writeFieldBegin("options", ::apache::thrift::protocol::T_STRUCT, 22);
    xfer += this->options.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.pre_scripts) {
    xfer += oprot->writeFieldBegin("pre_scripts", ::apache::thrift::protocol::T_SET, 23);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->pre_scripts.size()));
      std::set<std::string> ::const_iterator _iter1014;
      for (_iter1014 = this->pre_scripts.begin(); _iter1014 != this->pre_scripts.end(); ++_iter1014)
      {
        xfer += oprot->writeString((*_iter1014));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.post_scripts) {
    xfer += oprot->writeFieldBegin("post_scripts", ::apache::thrift::protocol::T_SET, 24);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->post_scripts.size()));
      std::set<std::string> ::const_iterator _iter1015;
      for (_iter1015 = this->post_scripts.begin(); _iter1015 != this->post_scripts.end(); ++_iter1015)
      {
        xfer += oprot->writeString((*_iter1015));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(launcher_job_create_detail &a, launcher_job_create_detail &b) {
  using ::std::swap;
  swap(a.replica_id, b.replica_id);
  swap(a.disks_lun_mapping, b.disks_lun_mapping);
  swap(a.is_sysvol_authoritative_restore, b.is_sysvol_authoritative_restore);
  swap(a.is_enable_debug, b.is_enable_debug);
  swap(a.is_disable_machine_password_change, b.is_disable_machine_password_change);
  swap(a.is_force_normal_boot, b.is_force_normal_boot);
  swap(a.network_infos, b.network_infos);
  swap(a.config, b.config);
  swap(a.gpt_to_mbr, b.gpt_to_mbr);
  swap(a.detect_type, b.detect_type);
  swap(a.skip_system_injection, b.skip_system_injection);
  swap(a.reboot_winpe, b.reboot_winpe);
  swap(a.callbacks, b.callbacks);
  swap(a.callback_timeout, b.callback_timeout);
  swap(a.host_name, b.host_name);
  swap(a.export_disk_type, b.export_disk_type);
  swap(a.export_path, b.export_path);
  swap(a.target_type, b.target_type);
  swap(a.os_type, b.os_type);
  swap(a.is_update_ex, b.is_update_ex);
  swap(a.options_type, b.options_type);
  swap(a.options, b.options);
  swap(a.pre_scripts, b.pre_scripts);
  swap(a.post_scripts, b.post_scripts);
  swap(a.__isset, b.__isset);
}

launcher_job_create_detail::launcher_job_create_detail(const launcher_job_create_detail& other1016) {
  replica_id = other1016.replica_id;
  disks_lun_mapping = other1016.disks_lun_mapping;
  is_sysvol_authoritative_restore = other1016.is_sysvol_authoritative_restore;
  is_enable_debug = other1016.is_enable_debug;
  is_disable_machine_password_change = other1016.is_disable_machine_password_change;
  is_force_normal_boot = other1016.is_force_normal_boot;
  network_infos = other1016.network_infos;
  config = other1016.config;
  gpt_to_mbr = other1016.gpt_to_mbr;
  detect_type = other1016.detect_type;
  skip_system_injection = other1016.skip_system_injection;
  reboot_winpe = other1016.reboot_winpe;
  callbacks = other1016.callbacks;
  callback_timeout = other1016.callback_timeout;
  host_name = other1016.host_name;
  export_disk_type = other1016.export_disk_type;
  export_path = other1016.export_path;
  target_type = other1016.target_type;
  os_type = other1016.os_type;
  is_update_ex = other1016.is_update_ex;
  options_type = other1016.options_type;
  options = other1016.options;
  pre_scripts = other1016.pre_scripts;
  post_scripts = other1016.post_scripts;
  __isset = other1016.__isset;
}
launcher_job_create_detail& launcher_job_create_detail::operator=(const launcher_job_create_detail& other1017) {
  replica_id = other1017.replica_id;
  disks_lun_mapping = other1017.disks_lun_mapping;
  is_sysvol_authoritative_restore = other1017.is_sysvol_authoritative_restore;
  is_enable_debug = other1017.is_enable_debug;
  is_disable_machine_password_change = other1017.is_disable_machine_password_change;
  is_force_normal_boot = other1017.is_force_normal_boot;
  network_infos = other1017.network_infos;
  config = other1017.config;
  gpt_to_mbr = other1017.gpt_to_mbr;
  detect_type = other1017.detect_type;
  skip_system_injection = other1017.skip_system_injection;
  reboot_winpe = other1017.reboot_winpe;
  callbacks = other1017.callbacks;
  callback_timeout = other1017.callback_timeout;
  host_name = other1017.host_name;
  export_disk_type = other1017.export_disk_type;
  export_path = other1017.export_path;
  target_type = other1017.target_type;
  os_type = other1017.os_type;
  is_update_ex = other1017.is_update_ex;
  options_type = other1017.options_type;
  options = other1017.options;
  pre_scripts = other1017.pre_scripts;
  post_scripts = other1017.post_scripts;
  __isset = other1017.__isset;
  return *this;
}
void launcher_job_create_detail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "launcher_job_create_detail(";
  out << "replica_id="; (__isset.replica_id ? (out << to_string(replica_id)) : (out << "<null>"));
  out << ", " << "disks_lun_mapping="; (__isset.disks_lun_mapping ? (out << to_string(disks_lun_mapping)) : (out << "<null>"));
  out << ", " << "is_sysvol_authoritative_restore="; (__isset.is_sysvol_authoritative_restore ? (out << to_string(is_sysvol_authoritative_restore)) : (out << "<null>"));
  out << ", " << "is_enable_debug="; (__isset.is_enable_debug ? (out << to_string(is_enable_debug)) : (out << "<null>"));
  out << ", " << "is_disable_machine_password_change="; (__isset.is_disable_machine_password_change ? (out << to_string(is_disable_machine_password_change)) : (out << "<null>"));
  out << ", " << "is_force_normal_boot="; (__isset.is_force_normal_boot ? (out << to_string(is_force_normal_boot)) : (out << "<null>"));
  out << ", " << "network_infos="; (__isset.network_infos ? (out << to_string(network_infos)) : (out << "<null>"));
  out << ", " << "config="; (__isset.config ? (out << to_string(config)) : (out << "<null>"));
  out << ", " << "gpt_to_mbr="; (__isset.gpt_to_mbr ? (out << to_string(gpt_to_mbr)) : (out << "<null>"));
  out << ", " << "detect_type="; (__isset.detect_type ? (out << to_string(detect_type)) : (out << "<null>"));
  out << ", " << "skip_system_injection="; (__isset.skip_system_injection ? (out << to_string(skip_system_injection)) : (out << "<null>"));
  out << ", " << "reboot_winpe="; (__isset.reboot_winpe ? (out << to_string(reboot_winpe)) : (out << "<null>"));
  out << ", " << "callbacks="; (__isset.callbacks ? (out << to_string(callbacks)) : (out << "<null>"));
  out << ", " << "callback_timeout="; (__isset.callback_timeout ? (out << to_string(callback_timeout)) : (out << "<null>"));
  out << ", " << "host_name="; (__isset.host_name ? (out << to_string(host_name)) : (out << "<null>"));
  out << ", " << "export_disk_type="; (__isset.export_disk_type ? (out << to_string(export_disk_type)) : (out << "<null>"));
  out << ", " << "export_path="; (__isset.export_path ? (out << to_string(export_path)) : (out << "<null>"));
  out << ", " << "target_type="; (__isset.target_type ? (out << to_string(target_type)) : (out << "<null>"));
  out << ", " << "os_type="; (__isset.os_type ? (out << to_string(os_type)) : (out << "<null>"));
  out << ", " << "is_update_ex="; (__isset.is_update_ex ? (out << to_string(is_update_ex)) : (out << "<null>"));
  out << ", " << "options_type="; (__isset.options_type ? (out << to_string(options_type)) : (out << "<null>"));
  out << ", " << "options="; (__isset.options ? (out << to_string(options)) : (out << "<null>"));
  out << ", " << "pre_scripts="; (__isset.pre_scripts ? (out << to_string(pre_scripts)) : (out << "<null>"));
  out << ", " << "post_scripts="; (__isset.post_scripts ? (out << to_string(post_scripts)) : (out << "<null>"));
  out << ")";
}


register_service_info::~register_service_info() throw() {
}


void register_service_info::__set_mgmt_addr(const std::string& val) {
  this->mgmt_addr = val;
__isset.mgmt_addr = true;
}

void register_service_info::__set_username(const std::string& val) {
  this->username = val;
__isset.username = true;
}

void register_service_info::__set_password(const std::string& val) {
  this->password = val;
__isset.password = true;
}

void register_service_info::__set_service_types(const std::set<std::string> & val) {
  this->service_types = val;
__isset.service_types = true;
}

void register_service_info::__set_version(const std::string& val) {
  this->version = val;
__isset.version = true;
}

void register_service_info::__set_path(const std::string& val) {
  this->path = val;
__isset.path = true;
}

uint32_t register_service_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->mgmt_addr);
          this->__isset.mgmt_addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->username);
          this->__isset.username = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->password);
          this->__isset.password = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->service_types.clear();
            uint32_t _size1018;
            ::apache::thrift::protocol::TType _etype1021;
            xfer += iprot->readSetBegin(_etype1021, _size1018);
            uint32_t _i1022;
            for (_i1022 = 0; _i1022 < _size1018; ++_i1022)
            {
              std::string _elem1023;
              xfer += iprot->readString(_elem1023);
              this->service_types.insert(_elem1023);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.service_types = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->path);
          this->__isset.path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t register_service_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("register_service_info");

  if (this->__isset.mgmt_addr) {
    xfer += oprot->writeFieldBegin("mgmt_addr", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->mgmt_addr);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.username) {
    xfer += oprot->writeFieldBegin("username", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->username);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.password) {
    xfer += oprot->writeFieldBegin("password", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->password);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.service_types) {
    xfer += oprot->writeFieldBegin("service_types", ::apache::thrift::protocol::T_SET, 4);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->service_types.size()));
      std::set<std::string> ::const_iterator _iter1024;
      for (_iter1024 = this->service_types.begin(); _iter1024 != this->service_types.end(); ++_iter1024)
      {
        xfer += oprot->writeString((*_iter1024));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.version) {
    xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.path) {
    xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->path);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(register_service_info &a, register_service_info &b) {
  using ::std::swap;
  swap(a.mgmt_addr, b.mgmt_addr);
  swap(a.username, b.username);
  swap(a.password, b.password);
  swap(a.service_types, b.service_types);
  swap(a.version, b.version);
  swap(a.path, b.path);
  swap(a.__isset, b.__isset);
}

register_service_info::register_service_info(const register_service_info& other1025) {
  mgmt_addr = other1025.mgmt_addr;
  username = other1025.username;
  password = other1025.password;
  service_types = other1025.service_types;
  version = other1025.version;
  path = other1025.path;
  __isset = other1025.__isset;
}
register_service_info& register_service_info::operator=(const register_service_info& other1026) {
  mgmt_addr = other1026.mgmt_addr;
  username = other1026.username;
  password = other1026.password;
  service_types = other1026.service_types;
  version = other1026.version;
  path = other1026.path;
  __isset = other1026.__isset;
  return *this;
}
void register_service_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "register_service_info(";
  out << "mgmt_addr="; (__isset.mgmt_addr ? (out << to_string(mgmt_addr)) : (out << "<null>"));
  out << ", " << "username="; (__isset.username ? (out << to_string(username)) : (out << "<null>"));
  out << ", " << "password="; (__isset.password ? (out << to_string(password)) : (out << "<null>"));
  out << ", " << "service_types="; (__isset.service_types ? (out << to_string(service_types)) : (out << "<null>"));
  out << ", " << "version="; (__isset.version ? (out << to_string(version)) : (out << "<null>"));
  out << ", " << "path="; (__isset.path ? (out << to_string(path)) : (out << "<null>"));
  out << ")";
}


register_physical_packer_info::~register_physical_packer_info() throw() {
}


void register_physical_packer_info::__set_mgmt_addr(const std::string& val) {
  this->mgmt_addr = val;
__isset.mgmt_addr = true;
}

void register_physical_packer_info::__set_username(const std::string& val) {
  this->username = val;
__isset.username = true;
}

void register_physical_packer_info::__set_password(const std::string& val) {
  this->password = val;
__isset.password = true;
}

void register_physical_packer_info::__set_packer_addr(const std::string& val) {
  this->packer_addr = val;
__isset.packer_addr = true;
}

void register_physical_packer_info::__set_version(const std::string& val) {
  this->version = val;
__isset.version = true;
}

void register_physical_packer_info::__set_path(const std::string& val) {
  this->path = val;
__isset.path = true;
}

uint32_t register_physical_packer_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->mgmt_addr);
          this->__isset.mgmt_addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->username);
          this->__isset.username = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->password);
          this->__isset.password = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->packer_addr);
          this->__isset.packer_addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->path);
          this->__isset.path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t register_physical_packer_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("register_physical_packer_info");

  if (this->__isset.mgmt_addr) {
    xfer += oprot->writeFieldBegin("mgmt_addr", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->mgmt_addr);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.username) {
    xfer += oprot->writeFieldBegin("username", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->username);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.password) {
    xfer += oprot->writeFieldBegin("password", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->password);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.packer_addr) {
    xfer += oprot->writeFieldBegin("packer_addr", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->packer_addr);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.version) {
    xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.path) {
    xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->path);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(register_physical_packer_info &a, register_physical_packer_info &b) {
  using ::std::swap;
  swap(a.mgmt_addr, b.mgmt_addr);
  swap(a.username, b.username);
  swap(a.password, b.password);
  swap(a.packer_addr, b.packer_addr);
  swap(a.version, b.version);
  swap(a.path, b.path);
  swap(a.__isset, b.__isset);
}

register_physical_packer_info::register_physical_packer_info(const register_physical_packer_info& other1027) {
  mgmt_addr = other1027.mgmt_addr;
  username = other1027.username;
  password = other1027.password;
  packer_addr = other1027.packer_addr;
  version = other1027.version;
  path = other1027.path;
  __isset = other1027.__isset;
}
register_physical_packer_info& register_physical_packer_info::operator=(const register_physical_packer_info& other1028) {
  mgmt_addr = other1028.mgmt_addr;
  username = other1028.username;
  password = other1028.password;
  packer_addr = other1028.packer_addr;
  version = other1028.version;
  path = other1028.path;
  __isset = other1028.__isset;
  return *this;
}
void register_physical_packer_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "register_physical_packer_info(";
  out << "mgmt_addr="; (__isset.mgmt_addr ? (out << to_string(mgmt_addr)) : (out << "<null>"));
  out << ", " << "username="; (__isset.username ? (out << to_string(username)) : (out << "<null>"));
  out << ", " << "password="; (__isset.password ? (out << to_string(password)) : (out << "<null>"));
  out << ", " << "packer_addr="; (__isset.packer_addr ? (out << to_string(packer_addr)) : (out << "<null>"));
  out << ", " << "version="; (__isset.version ? (out << to_string(version)) : (out << "<null>"));
  out << ", " << "path="; (__isset.path ? (out << to_string(path)) : (out << "<null>"));
  out << ")";
}


command_empty::~command_empty() throw() {
}


uint32_t command_empty::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t command_empty::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("command_empty");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(command_empty &a, command_empty &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

command_empty::command_empty(const command_empty& other1029) : TException() {
  (void) other1029;
}
command_empty& command_empty::operator=(const command_empty& other1030) {
  (void) other1030;
  return *this;
}
void command_empty::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "command_empty(";
  out << ")";
}

const char* command_empty::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: command_empty";
  }
}


invalid_session::~invalid_session() throw() {
}


uint32_t invalid_session::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t invalid_session::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("invalid_session");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(invalid_session &a, invalid_session &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

invalid_session::invalid_session(const invalid_session& other1031) : TException() {
  (void) other1031;
}
invalid_session& invalid_session::operator=(const invalid_session& other1032) {
  (void) other1032;
  return *this;
}
void invalid_session::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "invalid_session(";
  out << ")";
}

const char* invalid_session::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: invalid_session";
  }
}


transport_message::~transport_message() throw() {
}


void transport_message::__set_id(const int64_t val) {
  this->id = val;
}

void transport_message::__set_message(const std::string& val) {
  this->message = val;
}

uint32_t transport_message::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t transport_message::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("transport_message");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(transport_message &a, transport_message &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

transport_message::transport_message(const transport_message& other1033) {
  id = other1033.id;
  message = other1033.message;
  __isset = other1033.__isset;
}
transport_message& transport_message::operator=(const transport_message& other1034) {
  id = other1034.id;
  message = other1034.message;
  __isset = other1034.__isset;
  return *this;
}
void transport_message::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "transport_message(";
  out << "id=" << to_string(id);
  out << ", " << "message=" << to_string(message);
  out << ")";
}


register_return::~register_return() throw() {
}


void register_return::__set_message(const std::string& val) {
  this->message = val;
__isset.message = true;
}

void register_return::__set_session(const std::string& val) {
  this->session = val;
__isset.session = true;
}

uint32_t register_return::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session);
          this->__isset.session = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t register_return::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("register_return");

  if (this->__isset.message) {
    xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->message);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.session) {
    xfer += oprot->writeFieldBegin("session", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->session);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(register_return &a, register_return &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.session, b.session);
  swap(a.__isset, b.__isset);
}

register_return::register_return(const register_return& other1035) {
  message = other1035.message;
  session = other1035.session;
  __isset = other1035.__isset;
}
register_return& register_return::operator=(const register_return& other1036) {
  message = other1036.message;
  session = other1036.session;
  __isset = other1036.__isset;
  return *this;
}
void register_return::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "register_return(";
  out << "message="; (__isset.message ? (out << to_string(message)) : (out << "<null>"));
  out << ", " << "session="; (__isset.session ? (out << to_string(session)) : (out << "<null>"));
  out << ")";
}


license_info::~license_info() throw() {
}


void license_info::__set_key(const std::string& val) {
  this->key = val;
__isset.key = true;
}

void license_info::__set_activated(const std::string& val) {
  this->activated = val;
__isset.activated = true;
}

void license_info::__set_count(const int32_t val) {
  this->count = val;
__isset.count = true;
}

void license_info::__set_expired_date(const std::string& val) {
  this->expired_date = val;
__isset.expired_date = true;
}

void license_info::__set_consumed(const int32_t val) {
  this->consumed = val;
__isset.consumed = true;
}

void license_info::__set_is_active(const bool val) {
  this->is_active = val;
__isset.is_active = true;
}

void license_info::__set_name(const std::string& val) {
  this->name = val;
__isset.name = true;
}

void license_info::__set_email(const std::string& val) {
  this->email = val;
__isset.email = true;
}

void license_info::__set_status(const std::string& val) {
  this->status = val;
__isset.status = true;
}

uint32_t license_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->activated);
          this->__isset.activated = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->count);
          this->__isset.count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->expired_date);
          this->__isset.expired_date = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->consumed);
          this->__isset.consumed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_active);
          this->__isset.is_active = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->email);
          this->__isset.email = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->status);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t license_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("license_info");

  if (this->__isset.key) {
    xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->key);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.activated) {
    xfer += oprot->writeFieldBegin("activated", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->activated);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.count) {
    xfer += oprot->writeFieldBegin("count", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->count);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.expired_date) {
    xfer += oprot->writeFieldBegin("expired_date", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->expired_date);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.consumed) {
    xfer += oprot->writeFieldBegin("consumed", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->consumed);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_active) {
    xfer += oprot->writeFieldBegin("is_active", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->is_active);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.email) {
    xfer += oprot->writeFieldBegin("email", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->email);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.status) {
    xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->status);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(license_info &a, license_info &b) {
  using ::std::swap;
  swap(a.key, b.key);
  swap(a.activated, b.activated);
  swap(a.count, b.count);
  swap(a.expired_date, b.expired_date);
  swap(a.consumed, b.consumed);
  swap(a.is_active, b.is_active);
  swap(a.name, b.name);
  swap(a.email, b.email);
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

license_info::license_info(const license_info& other1037) {
  key = other1037.key;
  activated = other1037.activated;
  count = other1037.count;
  expired_date = other1037.expired_date;
  consumed = other1037.consumed;
  is_active = other1037.is_active;
  name = other1037.name;
  email = other1037.email;
  status = other1037.status;
  __isset = other1037.__isset;
}
license_info& license_info::operator=(const license_info& other1038) {
  key = other1038.key;
  activated = other1038.activated;
  count = other1038.count;
  expired_date = other1038.expired_date;
  consumed = other1038.consumed;
  is_active = other1038.is_active;
  name = other1038.name;
  email = other1038.email;
  status = other1038.status;
  __isset = other1038.__isset;
  return *this;
}
void license_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "license_info(";
  out << "key="; (__isset.key ? (out << to_string(key)) : (out << "<null>"));
  out << ", " << "activated="; (__isset.activated ? (out << to_string(activated)) : (out << "<null>"));
  out << ", " << "count="; (__isset.count ? (out << to_string(count)) : (out << "<null>"));
  out << ", " << "expired_date="; (__isset.expired_date ? (out << to_string(expired_date)) : (out << "<null>"));
  out << ", " << "consumed="; (__isset.consumed ? (out << to_string(consumed)) : (out << "<null>"));
  out << ", " << "is_active="; (__isset.is_active ? (out << to_string(is_active)) : (out << "<null>"));
  out << ", " << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
  out << ", " << "email="; (__isset.email ? (out << to_string(email)) : (out << "<null>"));
  out << ", " << "status="; (__isset.status ? (out << to_string(status)) : (out << "<null>"));
  out << ")";
}


workload_history::~workload_history() throw() {
}


void workload_history::__set_machine_id(const std::string& val) {
  this->machine_id = val;
__isset.machine_id = true;
}

void workload_history::__set_name(const std::string& val) {
  this->name = val;
__isset.name = true;
}

void workload_history::__set_type(const std::string& val) {
  this->type = val;
__isset.type = true;
}

void workload_history::__set_histories(const std::vector<int32_t> & val) {
  this->histories = val;
__isset.histories = true;
}

uint32_t workload_history::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->machine_id);
          this->__isset.machine_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->histories.clear();
            uint32_t _size1039;
            ::apache::thrift::protocol::TType _etype1042;
            xfer += iprot->readListBegin(_etype1042, _size1039);
            this->histories.resize(_size1039);
            uint32_t _i1043;
            for (_i1043 = 0; _i1043 < _size1039; ++_i1043)
            {
              xfer += iprot->readI32(this->histories[_i1043]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.histories = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t workload_history::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("workload_history");

  if (this->__isset.machine_id) {
    xfer += oprot->writeFieldBegin("machine_id", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->machine_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.type) {
    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.histories) {
    xfer += oprot->writeFieldBegin("histories", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->histories.size()));
      std::vector<int32_t> ::const_iterator _iter1044;
      for (_iter1044 = this->histories.begin(); _iter1044 != this->histories.end(); ++_iter1044)
      {
        xfer += oprot->writeI32((*_iter1044));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(workload_history &a, workload_history &b) {
  using ::std::swap;
  swap(a.machine_id, b.machine_id);
  swap(a.name, b.name);
  swap(a.type, b.type);
  swap(a.histories, b.histories);
  swap(a.__isset, b.__isset);
}

workload_history::workload_history(const workload_history& other1045) {
  machine_id = other1045.machine_id;
  name = other1045.name;
  type = other1045.type;
  histories = other1045.histories;
  __isset = other1045.__isset;
}
workload_history& workload_history::operator=(const workload_history& other1046) {
  machine_id = other1046.machine_id;
  name = other1046.name;
  type = other1046.type;
  histories = other1046.histories;
  __isset = other1046.__isset;
  return *this;
}
void workload_history::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "workload_history(";
  out << "machine_id="; (__isset.machine_id ? (out << to_string(machine_id)) : (out << "<null>"));
  out << ", " << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
  out << ", " << "type="; (__isset.type ? (out << to_string(type)) : (out << "<null>"));
  out << ", " << "histories="; (__isset.histories ? (out << to_string(histories)) : (out << "<null>"));
  out << ")";
}


license_infos::~license_infos() throw() {
}


void license_infos::__set_licenses(const std::vector<license_info> & val) {
  this->licenses = val;
__isset.licenses = true;
}

void license_infos::__set_histories(const std::vector<workload_history> & val) {
  this->histories = val;
__isset.histories = true;
}

uint32_t license_infos::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->licenses.clear();
            uint32_t _size1047;
            ::apache::thrift::protocol::TType _etype1050;
            xfer += iprot->readListBegin(_etype1050, _size1047);
            this->licenses.resize(_size1047);
            uint32_t _i1051;
            for (_i1051 = 0; _i1051 < _size1047; ++_i1051)
            {
              xfer += this->licenses[_i1051].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.licenses = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->histories.clear();
            uint32_t _size1052;
            ::apache::thrift::protocol::TType _etype1055;
            xfer += iprot->readListBegin(_etype1055, _size1052);
            this->histories.resize(_size1052);
            uint32_t _i1056;
            for (_i1056 = 0; _i1056 < _size1052; ++_i1056)
            {
              xfer += this->histories[_i1056].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.histories = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t license_infos::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("license_infos");

  if (this->__isset.licenses) {
    xfer += oprot->writeFieldBegin("licenses", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->licenses.size()));
      std::vector<license_info> ::const_iterator _iter1057;
      for (_iter1057 = this->licenses.begin(); _iter1057 != this->licenses.end(); ++_iter1057)
      {
        xfer += (*_iter1057).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.histories) {
    xfer += oprot->writeFieldBegin("histories", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->histories.size()));
      std::vector<workload_history> ::const_iterator _iter1058;
      for (_iter1058 = this->histories.begin(); _iter1058 != this->histories.end(); ++_iter1058)
      {
        xfer += (*_iter1058).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(license_infos &a, license_infos &b) {
  using ::std::swap;
  swap(a.licenses, b.licenses);
  swap(a.histories, b.histories);
  swap(a.__isset, b.__isset);
}

license_infos::license_infos(const license_infos& other1059) {
  licenses = other1059.licenses;
  histories = other1059.histories;
  __isset = other1059.__isset;
}
license_infos& license_infos::operator=(const license_infos& other1060) {
  licenses = other1060.licenses;
  histories = other1060.histories;
  __isset = other1060.__isset;
  return *this;
}
void license_infos::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "license_infos(";
  out << "licenses="; (__isset.licenses ? (out << to_string(licenses)) : (out << "<null>"));
  out << ", " << "histories="; (__isset.histories ? (out << to_string(histories)) : (out << "<null>"));
  out << ")";
}


running_task::~running_task() throw() {
}


void running_task::__set_id(const std::string& val) {
  this->id = val;
__isset.id = true;
}

void running_task::__set_triggers(const std::vector<job_trigger> & val) {
  this->triggers = val;
__isset.triggers = true;
}

void running_task::__set_mgmt_addr(const std::string& val) {
  this->mgmt_addr = val;
__isset.mgmt_addr = true;
}

void running_task::__set_mgmt_port(const int32_t val) {
  this->mgmt_port = val;
__isset.mgmt_port = true;
}

void running_task::__set_is_ssl(const bool val) {
  this->is_ssl = val;
__isset.is_ssl = true;
}

void running_task::__set_parameters(const std::string& val) {
  this->parameters = val;
__isset.parameters = true;
}

uint32_t running_task::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->triggers.clear();
            uint32_t _size1061;
            ::apache::thrift::protocol::TType _etype1064;
            xfer += iprot->readListBegin(_etype1064, _size1061);
            this->triggers.resize(_size1061);
            uint32_t _i1065;
            for (_i1065 = 0; _i1065 < _size1061; ++_i1065)
            {
              xfer += this->triggers[_i1065].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.triggers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->mgmt_addr);
          this->__isset.mgmt_addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->mgmt_port);
          this->__isset.mgmt_port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_ssl);
          this->__isset.is_ssl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->parameters);
          this->__isset.parameters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t running_task::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("running_task");

  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.triggers) {
    xfer += oprot->writeFieldBegin("triggers", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->triggers.size()));
      std::vector<job_trigger> ::const_iterator _iter1066;
      for (_iter1066 = this->triggers.begin(); _iter1066 != this->triggers.end(); ++_iter1066)
      {
        xfer += (*_iter1066).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mgmt_addr) {
    xfer += oprot->writeFieldBegin("mgmt_addr", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->mgmt_addr);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mgmt_port) {
    xfer += oprot->writeFieldBegin("mgmt_port", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->mgmt_port);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_ssl) {
    xfer += oprot->writeFieldBegin("is_ssl", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->is_ssl);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.parameters) {
    xfer += oprot->writeFieldBegin("parameters", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->parameters);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(running_task &a, running_task &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.triggers, b.triggers);
  swap(a.mgmt_addr, b.mgmt_addr);
  swap(a.mgmt_port, b.mgmt_port);
  swap(a.is_ssl, b.is_ssl);
  swap(a.parameters, b.parameters);
  swap(a.__isset, b.__isset);
}

running_task::running_task(const running_task& other1067) {
  id = other1067.id;
  triggers = other1067.triggers;
  mgmt_addr = other1067.mgmt_addr;
  mgmt_port = other1067.mgmt_port;
  is_ssl = other1067.is_ssl;
  parameters = other1067.parameters;
  __isset = other1067.__isset;
}
running_task& running_task::operator=(const running_task& other1068) {
  id = other1068.id;
  triggers = other1068.triggers;
  mgmt_addr = other1068.mgmt_addr;
  mgmt_port = other1068.mgmt_port;
  is_ssl = other1068.is_ssl;
  parameters = other1068.parameters;
  __isset = other1068.__isset;
  return *this;
}
void running_task::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "running_task(";
  out << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "triggers="; (__isset.triggers ? (out << to_string(triggers)) : (out << "<null>"));
  out << ", " << "mgmt_addr="; (__isset.mgmt_addr ? (out << to_string(mgmt_addr)) : (out << "<null>"));
  out << ", " << "mgmt_port="; (__isset.mgmt_port ? (out << to_string(mgmt_port)) : (out << "<null>"));
  out << ", " << "is_ssl="; (__isset.is_ssl ? (out << to_string(is_ssl)) : (out << "<null>"));
  out << ", " << "parameters="; (__isset.parameters ? (out << to_string(parameters)) : (out << "<null>"));
  out << ")";
}

}} // namespace
