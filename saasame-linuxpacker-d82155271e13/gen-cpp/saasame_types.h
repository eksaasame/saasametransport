/**
 * Autogenerated by Thrift Compiler (0.10.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef saasame_TYPES_H
#define saasame_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace saasame { namespace transport {

struct enumerate_disk_filter_style {
  enum type {
    ALL_DISK = 0,
    UNINITIALIZED_DISK = 1
  };
};

extern const std::map<int, const char*> _enumerate_disk_filter_style_VALUES_TO_NAMES;

struct machine_detail_filter {
  enum type {
    FULL = 0,
    SIMPLE = 1
  };
};

extern const std::map<int, const char*> _machine_detail_filter_VALUES_TO_NAMES;

struct partition_style {
  enum type {
    PARTITION_UNKNOWN = 0,
    PARTITION_MBR = 1,
    PARTITION_GPT = 2
  };
};

extern const std::map<int, const char*> _partition_style_VALUES_TO_NAMES;

struct drive_type {
  enum type {
    DT_UNKNOWN = 0,
    DT_NO_ROOT_PATH = 1,
    DT_REMOVABLE = 2,
    DT_FIXED = 3,
    DT_REMOTE = 4,
    DT_CDROM = 5,
    DT_RAMDISK = 6
  };
};

extern const std::map<int, const char*> _drive_type_VALUES_TO_NAMES;

struct bus_type {
  enum type {
    Unknown = 0,
    SCSI = 1,
    ATAPI = 2,
    ATA = 3,
    IEEE_1394 = 4,
    SSA = 5,
    Fibre_Channel = 6,
    USB = 7,
    RAID = 8,
    iSCSI = 9,
    SAS = 10,
    SATA = 11,
    SD = 12,
    MMC = 13,
    Virtual = 14,
    File_Backed_Virtual = 15,
    Storage_Spaces = 16,
    NVMe = 17
  };
};

extern const std::map<int, const char*> _bus_type_VALUES_TO_NAMES;

struct hv_vm_tools_status {
  enum type {
    HV_VMTOOLS_UNKNOWN = 0,
    HV_VMTOOLS_OK = 1,
    HV_VMTOOLS_NOTINSTALLED = 2,
    HV_VMTOOLS_OLD = 3,
    HV_VMTOOLS_NOTRUNNING = 4,
    HV_VMTOOLS_NEEDUPGRADE = 5,
    HV_VMTOOLS_UNMANAGED = 6,
    HV_VMTOOLS_NEW = 7,
    HV_VMTOOLS_BLACKLISTED = 8
  };
};

extern const std::map<int, const char*> _hv_vm_tools_status_VALUES_TO_NAMES;

struct hv_vm_power_state {
  enum type {
    HV_VMPOWER_UNKNOWN = 0,
    HV_VMPOWER_ON = 1,
    HV_VMPOWER_OFF = 2,
    HV_VMPOWER_SUSPENDED = 3
  };
};

extern const std::map<int, const char*> _hv_vm_power_state_VALUES_TO_NAMES;

struct hv_vm_connection_state {
  enum type {
    HV_VMCONNECT_UNKNOWN = 0,
    HV_VMCONNECT_CONNECTED = 1,
    HV_VMCONNECT_DISCONNECTED = 2,
    HV_VMCONNECT_INACCESSIBLE = 3,
    HV_VMCONNECT_INVALID = 4,
    HV_VMCONNECT_ORPHANED = 5
  };
};

extern const std::map<int, const char*> _hv_vm_connection_state_VALUES_TO_NAMES;

struct hv_host_power_state {
  enum type {
    HV_HOSTPOWER_UNKNOWN = 0,
    HV_HOSTPOWER_ON = 1,
    HV_HOSTPOWER_OFF = 2,
    HV_HOSTPOWER_STANDBY = 3
  };
};

extern const std::map<int, const char*> _hv_host_power_state_VALUES_TO_NAMES;

struct hv_connection_type {
  enum type {
    HV_CONNECTION_TYPE_UNKNOWN = 0,
    HV_CONNECTION_TYPE_VCENTER = 1,
    HV_CONNECTION_TYPE_HOST = 2
  };
};

extern const std::map<int, const char*> _hv_connection_type_VALUES_TO_NAMES;

struct hv_guest_os_type {
  enum type {
    HV_OS_UNKNOWN = 0,
    HV_OS_WINDOWS = 1,
    HV_OS_LINUX = 2
  };
};

extern const std::map<int, const char*> _hv_guest_os_type_VALUES_TO_NAMES;

struct hv_vm_firmware {
  enum type {
    HV_VM_FIRMWARE_BIOS = 0,
    HV_VM_FIRMWARE_EFI = 1
  };
};

extern const std::map<int, const char*> _hv_vm_firmware_VALUES_TO_NAMES;

struct job_type {
  enum type {
    physical_packer_job_type = 1,
    virtual_packer_job_type = 2,
    physical_transport_type = 3,
    virtual_transport_type = 4,
    loader_job_type = 5,
    launcher_job_type = 6,
    winpe_packer_job_type = 7,
    winpe_transport_job_type = 8
  };
};

extern const std::map<int, const char*> _job_type_VALUES_TO_NAMES;

struct job_trigger_type {
  enum type {
    runonce_trigger = 0,
    interval_trigger = 1
  };
};

extern const std::map<int, const char*> _job_trigger_type_VALUES_TO_NAMES;

struct job_state {
  enum type {
    job_state_none = 1,
    job_state_initialed = 2,
    job_state_replicating = 4,
    job_state_replicated = 8,
    job_state_converting = 16,
    job_state_finished = 32,
    job_state_sche_completed = 64,
    job_state_recover = 128,
    job_state_resizing = 256,
    job_state_uploading = 512,
    job_state_upload_completed = 1024,
    job_state_discard = 1073741824
  };
};

extern const std::map<int, const char*> _job_state_VALUES_TO_NAMES;

struct error_codes {
  enum type {
    SAASAME_S_OK = 0,
    SAASAME_NOERROR = 0,
    SAASAME_E_FAIL = 4096,
    SAASAME_E_INITIAL_FAIL = 4097,
    SAASAME_E_DISK_FULL = 4098,
    SAASAME_E_INVALID_ARG = 4099,
    SAASAME_E_INVALID_AUTHENTICATION = 4100,
    SAASAME_E_INTERNAL_FAIL = 4101,
    SAASAME_E_CANNOT_CONNECT_TO_HOST = 4102,
    SAASAME_E_QUEUE_FULL = 4103,
    SAASAME_E_INVALID_LICENSE_KEY = 4104,
    SAASAME_E_INVALID_LICENSE = 4105,
    SAASAME_E_JOB_CREATE_FAIL = 12288,
    SAASAME_E_JOB_REMOVE_FAIL = 12289,
    SAASAME_E_JOB_NOTFOUND = 12290,
    SAASAME_E_JOB_CONFIG_NOTFOUND = 12291,
    SAASAME_E_JOB_STATUS_NOTFOUND = 12292,
    SAASAME_E_JOB_CANCELLED = 12293,
    SAASAME_E_JOB_CONVERT_FAIL = 12294,
    SAASAME_E_JOB_REPLICATE_FAIL = 12295,
    SAASAME_E_JOB_ID_DUPLICATED = 12296,
    SAASAME_E_JOB_INTERRUPTED = 12297,
    SAASAME_E_JOB_RUNNING = 12298,
    SAASAME_E_JOB_RESPONSE = 12299,
    SAASAME_E_PHYSICAL_CONFIG_FAILED = 16384,
    SAASAME_E_VIRTUAL_VM_NOTFOUND = 20480,
    SAASAME_E_IMAGE_NOTFOUND = 24576,
    SAASAME_E_IMAGE_CREATE_FAIL = 24577,
    SAASAME_E_IMAGE_OPEN_FAIL = 24578,
    SAASAME_E_IMAGE_READ = 24579,
    SAASAME_E_IMAGE_WRITE = 24580,
    SAASAME_E_IMAGE_OUTOFRANGE = 24581,
    SAASAME_E_IMAGE_ATTACH_FAIL = 24582,
    SAASAME_E_IMAGE_DETACH_FAIL = 24583,
    SAASAME_E_IMAGE_PROPERTY_FAIL = 24584,
    SAASAME_E_SNAPSHOT_CREATE_FAIL = 28672,
    SAASAME_E_SNAPSHOT_REMOVE_FAIL = 28673,
    SAASAME_E_SNAPSHOT_NOTFOUND = 28674,
    SAASAME_E_SNAPSHOT_INVALID = 28675
  };
};

extern const std::map<int, const char*> _error_codes_VALUES_TO_NAMES;

struct connection_type {
  enum type {
    LOCAL_FOLDER = 0,
    NFS_FOLDER = 1,
    CIFS_FOLDER = 1,
    WEBDAV = 1,
    S3_BUCKET = 2,
    WEBDAV_WITH_SSL = 3,
    WEBDAV_EX = 4,
    S3_BUCKET_EX = 5,
    LOCAL_FOLDER_EX = 6
  };
};

extern const std::map<int, const char*> _connection_type_VALUES_TO_NAMES;

struct aws_region {
  enum type {
    US_EAST_1 = 0,
    US_WEST_1 = 1,
    US_WEST_2 = 2,
    EU_WEST_1 = 3,
    EU_CENTRAL_1 = 4,
    AP_SOUTHEAST_1 = 5,
    AP_SOUTHEAST_2 = 6,
    AP_NORTHEAST_1 = 7,
    AP_NORTHEAST_2 = 8,
    SA_EAST_1 = 9
  };
};

extern const std::map<int, const char*> _aws_region_VALUES_TO_NAMES;

struct create_image_option {
  enum type {
    VERSION_1 = 0,
    VERSION_2 = 1
  };
};

extern const std::map<int, const char*> _create_image_option_VALUES_TO_NAMES;

struct disk_detect_type {
  enum type {
    SCSI_ADDRESS = 0,
    LINUX_DEVICE_PATH = 0,
    SERIAL_NUMBER = 1,
    EXPORT_IMAGE = 2,
    UNIQUE_ID = 3,
    CUSTOMIZED_ID = 4,
    AZURE_BLOB = 5
  };
};

extern const std::map<int, const char*> _disk_detect_type_VALUES_TO_NAMES;

struct virtual_disk_type {
  enum type {
    VHD = 0,
    VHDX = 1
  };
};

extern const std::map<int, const char*> _virtual_disk_type_VALUES_TO_NAMES;

struct conversion_type {
  enum type {
    ANY_TO_ANY = 0,
    OPENSTACK = 1,
    XEN = 2,
    VMWARE = 3,
    HYPERV = 4,
    AUTO = -1
  };
};

extern const std::map<int, const char*> _conversion_type_VALUES_TO_NAMES;

struct extra_options_type {
  enum type {
    UNKNOWN = 0,
    ALIYUN = 1,
    TENCENT = 2
  };
};

extern const std::map<int, const char*> _extra_options_type_VALUES_TO_NAMES;

class disk_info;

class partition_info;

class volume_info;

class network_info;

class cluster_network;

class cluster_group;

class cluster_info;

class os_version_info;

class snapshot;

class snapshot_result;

class volume_bit_map;

class replication_result;

class delete_snapshot_result;

class physical_machine_info;

class virtual_host;

class virtual_network_adapter;

class virtual_machine_snapshots;

class virtual_disk_info;

class virtual_machine;

class invalid_operation;

class job_trigger;

class job_history;

class create_job_detail;

class packer_disk_image;

class virtual_create_packer_job_detail;

class physical_vcbt_journal;

class io_changed_range;

class physical_create_packer_job_detail;

class _create_packer_job_detail;

class create_packer_job_detail;

class virtual_packer_job_detail;

class physical_packer_job_detail;

class _packer_job_detail;

class packer_job_detail;

class replica_job_detail;

class service_info;

class local_folder;

class network_folder;

class _detail;

class connection;

class image_map_info;

class create_image_info;

class loader_job_detail;

class upload_progress;

class launcher_job_detail;

class job_detail;

class replica_job_create_detail;

class aliyun_options;

class tencent_options;

class extra_options;

class vhd_snapshot;

class loader_job_create_detail;

class launcher_job_create_detail;

class register_service_info;

class register_physical_packer_info;

class command_empty;

class invalid_session;

class transport_message;

class register_return;

class license_info;

class workload_history;

class license_infos;

class running_task;

typedef struct _disk_info__isset {
  _disk_info__isset() : boot_from_disk(true), bus_type(true), cluster_owner(true), cylinders(true), friendly_name(true), guid(true), tracks_per_cylinder(true), is_boot(true), is_clustered(true), is_offline(true), is_readonly(true), is_snapshot(true), is_system(true), location(true), logical_sector_size(true), manufacturer(true), model(true), number(true), number_of_partitions(true), offline_reason(true), partition_style(true), path(true), physical_sector_size(true), sectors_per_track(true), serial_number(true), signature(true), size(true), uri(true), scsi_bus(true), scsi_logical_unit(true), scsi_port(true), scsi_target_id(true), unique_id(true), unique_id_format(true), customized_id(true) {}
  bool boot_from_disk :1;
  bool bus_type :1;
  bool cluster_owner :1;
  bool cylinders :1;
  bool friendly_name :1;
  bool guid :1;
  bool tracks_per_cylinder :1;
  bool is_boot :1;
  bool is_clustered :1;
  bool is_offline :1;
  bool is_readonly :1;
  bool is_snapshot :1;
  bool is_system :1;
  bool location :1;
  bool logical_sector_size :1;
  bool manufacturer :1;
  bool model :1;
  bool number :1;
  bool number_of_partitions :1;
  bool offline_reason :1;
  bool partition_style :1;
  bool path :1;
  bool physical_sector_size :1;
  bool sectors_per_track :1;
  bool serial_number :1;
  bool signature :1;
  bool size :1;
  bool uri :1;
  bool scsi_bus :1;
  bool scsi_logical_unit :1;
  bool scsi_port :1;
  bool scsi_target_id :1;
  bool unique_id :1;
  bool unique_id_format :1;
  bool customized_id :1;
} _disk_info__isset;

class disk_info : public virtual ::apache::thrift::TBase {
 public:

  disk_info(const disk_info&);
  disk_info& operator=(const disk_info&);
  disk_info() : boot_from_disk(false), bus_type((bus_type::type)0), cluster_owner(""), cylinders(0LL), friendly_name(""), guid(""), tracks_per_cylinder(0), is_boot(false), is_clustered(false), is_offline(false), is_readonly(false), is_snapshot(false), is_system(false), location(""), logical_sector_size(0), manufacturer(""), model(""), number(-1), number_of_partitions(-1), offline_reason(0), partition_style((partition_style::type)0), path(""), physical_sector_size(0), sectors_per_track(0), serial_number(""), signature(0), size(0LL), uri(""), scsi_bus(0), scsi_logical_unit(0), scsi_port(0), scsi_target_id(0), unique_id(""), unique_id_format(0), customized_id("") {
    bus_type = (bus_type::type)0;

    partition_style = (partition_style::type)0;

  }

  virtual ~disk_info() throw();
  bool boot_from_disk;
  bus_type::type bus_type;
  std::string cluster_owner;
  int64_t cylinders;
  std::string friendly_name;
  std::string guid;
  int32_t tracks_per_cylinder;
  bool is_boot;
  bool is_clustered;
  bool is_offline;
  bool is_readonly;
  bool is_snapshot;
  bool is_system;
  std::string location;
  int32_t logical_sector_size;
  std::string manufacturer;
  std::string model;
  int32_t number;
  int32_t number_of_partitions;
  int16_t offline_reason;
  partition_style::type partition_style;
  std::string path;
  int32_t physical_sector_size;
  int32_t sectors_per_track;
  std::string serial_number;
  int32_t signature;
  int64_t size;
  std::string uri;
  int32_t scsi_bus;
  int16_t scsi_logical_unit;
  int16_t scsi_port;
  int16_t scsi_target_id;
  std::string unique_id;
  int16_t unique_id_format;
  std::string customized_id;

  _disk_info__isset __isset;

  void __set_boot_from_disk(const bool val);

  void __set_bus_type(const bus_type::type val);

  void __set_cluster_owner(const std::string& val);

  void __set_cylinders(const int64_t val);

  void __set_friendly_name(const std::string& val);

  void __set_guid(const std::string& val);

  void __set_tracks_per_cylinder(const int32_t val);

  void __set_is_boot(const bool val);

  void __set_is_clustered(const bool val);

  void __set_is_offline(const bool val);

  void __set_is_readonly(const bool val);

  void __set_is_snapshot(const bool val);

  void __set_is_system(const bool val);

  void __set_location(const std::string& val);

  void __set_logical_sector_size(const int32_t val);

  void __set_manufacturer(const std::string& val);

  void __set_model(const std::string& val);

  void __set_number(const int32_t val);

  void __set_number_of_partitions(const int32_t val);

  void __set_offline_reason(const int16_t val);

  void __set_partition_style(const partition_style::type val);

  void __set_path(const std::string& val);

  void __set_physical_sector_size(const int32_t val);

  void __set_sectors_per_track(const int32_t val);

  void __set_serial_number(const std::string& val);

  void __set_signature(const int32_t val);

  void __set_size(const int64_t val);

  void __set_uri(const std::string& val);

  void __set_scsi_bus(const int32_t val);

  void __set_scsi_logical_unit(const int16_t val);

  void __set_scsi_port(const int16_t val);

  void __set_scsi_target_id(const int16_t val);

  void __set_unique_id(const std::string& val);

  void __set_unique_id_format(const int16_t val);

  void __set_customized_id(const std::string& val);

  bool operator == (const disk_info & rhs) const
  {
    if (__isset.boot_from_disk != rhs.__isset.boot_from_disk)
      return false;
    else if (__isset.boot_from_disk && !(boot_from_disk == rhs.boot_from_disk))
      return false;
    if (__isset.bus_type != rhs.__isset.bus_type)
      return false;
    else if (__isset.bus_type && !(bus_type == rhs.bus_type))
      return false;
    if (__isset.cluster_owner != rhs.__isset.cluster_owner)
      return false;
    else if (__isset.cluster_owner && !(cluster_owner == rhs.cluster_owner))
      return false;
    if (__isset.cylinders != rhs.__isset.cylinders)
      return false;
    else if (__isset.cylinders && !(cylinders == rhs.cylinders))
      return false;
    if (__isset.friendly_name != rhs.__isset.friendly_name)
      return false;
    else if (__isset.friendly_name && !(friendly_name == rhs.friendly_name))
      return false;
    if (__isset.guid != rhs.__isset.guid)
      return false;
    else if (__isset.guid && !(guid == rhs.guid))
      return false;
    if (__isset.tracks_per_cylinder != rhs.__isset.tracks_per_cylinder)
      return false;
    else if (__isset.tracks_per_cylinder && !(tracks_per_cylinder == rhs.tracks_per_cylinder))
      return false;
    if (__isset.is_boot != rhs.__isset.is_boot)
      return false;
    else if (__isset.is_boot && !(is_boot == rhs.is_boot))
      return false;
    if (__isset.is_clustered != rhs.__isset.is_clustered)
      return false;
    else if (__isset.is_clustered && !(is_clustered == rhs.is_clustered))
      return false;
    if (__isset.is_offline != rhs.__isset.is_offline)
      return false;
    else if (__isset.is_offline && !(is_offline == rhs.is_offline))
      return false;
    if (__isset.is_readonly != rhs.__isset.is_readonly)
      return false;
    else if (__isset.is_readonly && !(is_readonly == rhs.is_readonly))
      return false;
    if (__isset.is_snapshot != rhs.__isset.is_snapshot)
      return false;
    else if (__isset.is_snapshot && !(is_snapshot == rhs.is_snapshot))
      return false;
    if (__isset.is_system != rhs.__isset.is_system)
      return false;
    else if (__isset.is_system && !(is_system == rhs.is_system))
      return false;
    if (__isset.location != rhs.__isset.location)
      return false;
    else if (__isset.location && !(location == rhs.location))
      return false;
    if (__isset.logical_sector_size != rhs.__isset.logical_sector_size)
      return false;
    else if (__isset.logical_sector_size && !(logical_sector_size == rhs.logical_sector_size))
      return false;
    if (__isset.manufacturer != rhs.__isset.manufacturer)
      return false;
    else if (__isset.manufacturer && !(manufacturer == rhs.manufacturer))
      return false;
    if (__isset.model != rhs.__isset.model)
      return false;
    else if (__isset.model && !(model == rhs.model))
      return false;
    if (__isset.number != rhs.__isset.number)
      return false;
    else if (__isset.number && !(number == rhs.number))
      return false;
    if (__isset.number_of_partitions != rhs.__isset.number_of_partitions)
      return false;
    else if (__isset.number_of_partitions && !(number_of_partitions == rhs.number_of_partitions))
      return false;
    if (__isset.offline_reason != rhs.__isset.offline_reason)
      return false;
    else if (__isset.offline_reason && !(offline_reason == rhs.offline_reason))
      return false;
    if (__isset.partition_style != rhs.__isset.partition_style)
      return false;
    else if (__isset.partition_style && !(partition_style == rhs.partition_style))
      return false;
    if (__isset.path != rhs.__isset.path)
      return false;
    else if (__isset.path && !(path == rhs.path))
      return false;
    if (__isset.physical_sector_size != rhs.__isset.physical_sector_size)
      return false;
    else if (__isset.physical_sector_size && !(physical_sector_size == rhs.physical_sector_size))
      return false;
    if (__isset.sectors_per_track != rhs.__isset.sectors_per_track)
      return false;
    else if (__isset.sectors_per_track && !(sectors_per_track == rhs.sectors_per_track))
      return false;
    if (__isset.serial_number != rhs.__isset.serial_number)
      return false;
    else if (__isset.serial_number && !(serial_number == rhs.serial_number))
      return false;
    if (__isset.signature != rhs.__isset.signature)
      return false;
    else if (__isset.signature && !(signature == rhs.signature))
      return false;
    if (__isset.size != rhs.__isset.size)
      return false;
    else if (__isset.size && !(size == rhs.size))
      return false;
    if (__isset.uri != rhs.__isset.uri)
      return false;
    else if (__isset.uri && !(uri == rhs.uri))
      return false;
    if (__isset.scsi_bus != rhs.__isset.scsi_bus)
      return false;
    else if (__isset.scsi_bus && !(scsi_bus == rhs.scsi_bus))
      return false;
    if (__isset.scsi_logical_unit != rhs.__isset.scsi_logical_unit)
      return false;
    else if (__isset.scsi_logical_unit && !(scsi_logical_unit == rhs.scsi_logical_unit))
      return false;
    if (__isset.scsi_port != rhs.__isset.scsi_port)
      return false;
    else if (__isset.scsi_port && !(scsi_port == rhs.scsi_port))
      return false;
    if (__isset.scsi_target_id != rhs.__isset.scsi_target_id)
      return false;
    else if (__isset.scsi_target_id && !(scsi_target_id == rhs.scsi_target_id))
      return false;
    if (__isset.unique_id != rhs.__isset.unique_id)
      return false;
    else if (__isset.unique_id && !(unique_id == rhs.unique_id))
      return false;
    if (__isset.unique_id_format != rhs.__isset.unique_id_format)
      return false;
    else if (__isset.unique_id_format && !(unique_id_format == rhs.unique_id_format))
      return false;
    if (__isset.customized_id != rhs.__isset.customized_id)
      return false;
    else if (__isset.customized_id && !(customized_id == rhs.customized_id))
      return false;
    return true;
  }
  bool operator != (const disk_info &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const disk_info & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(disk_info &a, disk_info &b);

inline std::ostream& operator<<(std::ostream& out, const disk_info& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _partition_info__isset {
  _partition_info__isset() : access_paths(false), disk_number(true), drive_letter(true), gpt_type(true), guid(true), is_active(true), is_boot(true), is_hidden(true), is_offline(true), is_readonly(true), is_shadowcopy(true), is_system(true), mbr_type(true), offset(true), partition_number(true), size(true) {}
  bool access_paths :1;
  bool disk_number :1;
  bool drive_letter :1;
  bool gpt_type :1;
  bool guid :1;
  bool is_active :1;
  bool is_boot :1;
  bool is_hidden :1;
  bool is_offline :1;
  bool is_readonly :1;
  bool is_shadowcopy :1;
  bool is_system :1;
  bool mbr_type :1;
  bool offset :1;
  bool partition_number :1;
  bool size :1;
} _partition_info__isset;

class partition_info : public virtual ::apache::thrift::TBase {
 public:

  partition_info(const partition_info&);
  partition_info& operator=(const partition_info&);
  partition_info() : disk_number(-1), drive_letter(""), gpt_type(""), guid(""), is_active(false), is_boot(false), is_hidden(false), is_offline(false), is_readonly(false), is_shadowcopy(false), is_system(false), mbr_type(0), offset(0LL), partition_number(-1), size(0LL) {
  }

  virtual ~partition_info() throw();
  std::set<std::string>  access_paths;
  int32_t disk_number;
  std::string drive_letter;
  std::string gpt_type;
  std::string guid;
  bool is_active;
  bool is_boot;
  bool is_hidden;
  bool is_offline;
  bool is_readonly;
  bool is_shadowcopy;
  bool is_system;
  int16_t mbr_type;
  int64_t offset;
  int32_t partition_number;
  int64_t size;

  _partition_info__isset __isset;

  void __set_access_paths(const std::set<std::string> & val);

  void __set_disk_number(const int32_t val);

  void __set_drive_letter(const std::string& val);

  void __set_gpt_type(const std::string& val);

  void __set_guid(const std::string& val);

  void __set_is_active(const bool val);

  void __set_is_boot(const bool val);

  void __set_is_hidden(const bool val);

  void __set_is_offline(const bool val);

  void __set_is_readonly(const bool val);

  void __set_is_shadowcopy(const bool val);

  void __set_is_system(const bool val);

  void __set_mbr_type(const int16_t val);

  void __set_offset(const int64_t val);

  void __set_partition_number(const int32_t val);

  void __set_size(const int64_t val);

  bool operator == (const partition_info & rhs) const
  {
    if (__isset.access_paths != rhs.__isset.access_paths)
      return false;
    else if (__isset.access_paths && !(access_paths == rhs.access_paths))
      return false;
    if (__isset.disk_number != rhs.__isset.disk_number)
      return false;
    else if (__isset.disk_number && !(disk_number == rhs.disk_number))
      return false;
    if (__isset.drive_letter != rhs.__isset.drive_letter)
      return false;
    else if (__isset.drive_letter && !(drive_letter == rhs.drive_letter))
      return false;
    if (__isset.gpt_type != rhs.__isset.gpt_type)
      return false;
    else if (__isset.gpt_type && !(gpt_type == rhs.gpt_type))
      return false;
    if (__isset.guid != rhs.__isset.guid)
      return false;
    else if (__isset.guid && !(guid == rhs.guid))
      return false;
    if (__isset.is_active != rhs.__isset.is_active)
      return false;
    else if (__isset.is_active && !(is_active == rhs.is_active))
      return false;
    if (__isset.is_boot != rhs.__isset.is_boot)
      return false;
    else if (__isset.is_boot && !(is_boot == rhs.is_boot))
      return false;
    if (__isset.is_hidden != rhs.__isset.is_hidden)
      return false;
    else if (__isset.is_hidden && !(is_hidden == rhs.is_hidden))
      return false;
    if (__isset.is_offline != rhs.__isset.is_offline)
      return false;
    else if (__isset.is_offline && !(is_offline == rhs.is_offline))
      return false;
    if (__isset.is_readonly != rhs.__isset.is_readonly)
      return false;
    else if (__isset.is_readonly && !(is_readonly == rhs.is_readonly))
      return false;
    if (__isset.is_shadowcopy != rhs.__isset.is_shadowcopy)
      return false;
    else if (__isset.is_shadowcopy && !(is_shadowcopy == rhs.is_shadowcopy))
      return false;
    if (__isset.is_system != rhs.__isset.is_system)
      return false;
    else if (__isset.is_system && !(is_system == rhs.is_system))
      return false;
    if (__isset.mbr_type != rhs.__isset.mbr_type)
      return false;
    else if (__isset.mbr_type && !(mbr_type == rhs.mbr_type))
      return false;
    if (__isset.offset != rhs.__isset.offset)
      return false;
    else if (__isset.offset && !(offset == rhs.offset))
      return false;
    if (__isset.partition_number != rhs.__isset.partition_number)
      return false;
    else if (__isset.partition_number && !(partition_number == rhs.partition_number))
      return false;
    if (__isset.size != rhs.__isset.size)
      return false;
    else if (__isset.size && !(size == rhs.size))
      return false;
    return true;
  }
  bool operator != (const partition_info &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const partition_info & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(partition_info &a, partition_info &b);

inline std::ostream& operator<<(std::ostream& out, const partition_info& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _volume_info__isset {
  _volume_info__isset() : access_paths(false), cluster_access_path(true), drive_letter(true), drive_type(true), file_system(true), file_system_catalogid(true), file_system_label(true), object_id(true), path(true), size(true), size_remaining(true) {}
  bool access_paths :1;
  bool cluster_access_path :1;
  bool drive_letter :1;
  bool drive_type :1;
  bool file_system :1;
  bool file_system_catalogid :1;
  bool file_system_label :1;
  bool object_id :1;
  bool path :1;
  bool size :1;
  bool size_remaining :1;
} _volume_info__isset;

class volume_info : public virtual ::apache::thrift::TBase {
 public:

  volume_info(const volume_info&);
  volume_info& operator=(const volume_info&);
  volume_info() : cluster_access_path(""), drive_letter(""), drive_type((drive_type::type)0), file_system(""), file_system_catalogid(""), file_system_label(""), object_id(""), path(""), size(0LL), size_remaining(0LL) {
    drive_type = (drive_type::type)0;

  }

  virtual ~volume_info() throw();
  std::set<std::string>  access_paths;
  std::string cluster_access_path;
  std::string drive_letter;
  drive_type::type drive_type;
  std::string file_system;
  std::string file_system_catalogid;
  std::string file_system_label;
  std::string object_id;
  std::string path;
  int64_t size;
  int64_t size_remaining;

  _volume_info__isset __isset;

  void __set_access_paths(const std::set<std::string> & val);

  void __set_cluster_access_path(const std::string& val);

  void __set_drive_letter(const std::string& val);

  void __set_drive_type(const drive_type::type val);

  void __set_file_system(const std::string& val);

  void __set_file_system_catalogid(const std::string& val);

  void __set_file_system_label(const std::string& val);

  void __set_object_id(const std::string& val);

  void __set_path(const std::string& val);

  void __set_size(const int64_t val);

  void __set_size_remaining(const int64_t val);

  bool operator == (const volume_info & rhs) const
  {
    if (__isset.access_paths != rhs.__isset.access_paths)
      return false;
    else if (__isset.access_paths && !(access_paths == rhs.access_paths))
      return false;
    if (__isset.cluster_access_path != rhs.__isset.cluster_access_path)
      return false;
    else if (__isset.cluster_access_path && !(cluster_access_path == rhs.cluster_access_path))
      return false;
    if (__isset.drive_letter != rhs.__isset.drive_letter)
      return false;
    else if (__isset.drive_letter && !(drive_letter == rhs.drive_letter))
      return false;
    if (__isset.drive_type != rhs.__isset.drive_type)
      return false;
    else if (__isset.drive_type && !(drive_type == rhs.drive_type))
      return false;
    if (__isset.file_system != rhs.__isset.file_system)
      return false;
    else if (__isset.file_system && !(file_system == rhs.file_system))
      return false;
    if (__isset.file_system_catalogid != rhs.__isset.file_system_catalogid)
      return false;
    else if (__isset.file_system_catalogid && !(file_system_catalogid == rhs.file_system_catalogid))
      return false;
    if (__isset.file_system_label != rhs.__isset.file_system_label)
      return false;
    else if (__isset.file_system_label && !(file_system_label == rhs.file_system_label))
      return false;
    if (__isset.object_id != rhs.__isset.object_id)
      return false;
    else if (__isset.object_id && !(object_id == rhs.object_id))
      return false;
    if (__isset.path != rhs.__isset.path)
      return false;
    else if (__isset.path && !(path == rhs.path))
      return false;
    if (__isset.size != rhs.__isset.size)
      return false;
    else if (__isset.size && !(size == rhs.size))
      return false;
    if (__isset.size_remaining != rhs.__isset.size_remaining)
      return false;
    else if (__isset.size_remaining && !(size_remaining == rhs.size_remaining))
      return false;
    return true;
  }
  bool operator != (const volume_info &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const volume_info & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(volume_info &a, volume_info &b);

inline std::ostream& operator<<(std::ostream& out, const volume_info& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _network_info__isset {
  _network_info__isset() : adapter_name(true), description(true), dnss(false), gateways(false), ip_addresses(false), is_dhcp_v4(true), is_dhcp_v6(true), mac_address(true), subnet_masks(false) {}
  bool adapter_name :1;
  bool description :1;
  bool dnss :1;
  bool gateways :1;
  bool ip_addresses :1;
  bool is_dhcp_v4 :1;
  bool is_dhcp_v6 :1;
  bool mac_address :1;
  bool subnet_masks :1;
} _network_info__isset;

class network_info : public virtual ::apache::thrift::TBase {
 public:

  network_info(const network_info&);
  network_info& operator=(const network_info&);
  network_info() : adapter_name(""), description(""), is_dhcp_v4(false), is_dhcp_v6(false), mac_address("") {
  }

  virtual ~network_info() throw();
  std::string adapter_name;
  std::string description;
  std::vector<std::string>  dnss;
  std::vector<std::string>  gateways;
  std::vector<std::string>  ip_addresses;
  bool is_dhcp_v4;
  bool is_dhcp_v6;
  std::string mac_address;
  std::vector<std::string>  subnet_masks;

  _network_info__isset __isset;

  void __set_adapter_name(const std::string& val);

  void __set_description(const std::string& val);

  void __set_dnss(const std::vector<std::string> & val);

  void __set_gateways(const std::vector<std::string> & val);

  void __set_ip_addresses(const std::vector<std::string> & val);

  void __set_is_dhcp_v4(const bool val);

  void __set_is_dhcp_v6(const bool val);

  void __set_mac_address(const std::string& val);

  void __set_subnet_masks(const std::vector<std::string> & val);

  bool operator == (const network_info & rhs) const
  {
    if (__isset.adapter_name != rhs.__isset.adapter_name)
      return false;
    else if (__isset.adapter_name && !(adapter_name == rhs.adapter_name))
      return false;
    if (__isset.description != rhs.__isset.description)
      return false;
    else if (__isset.description && !(description == rhs.description))
      return false;
    if (__isset.dnss != rhs.__isset.dnss)
      return false;
    else if (__isset.dnss && !(dnss == rhs.dnss))
      return false;
    if (__isset.gateways != rhs.__isset.gateways)
      return false;
    else if (__isset.gateways && !(gateways == rhs.gateways))
      return false;
    if (__isset.ip_addresses != rhs.__isset.ip_addresses)
      return false;
    else if (__isset.ip_addresses && !(ip_addresses == rhs.ip_addresses))
      return false;
    if (__isset.is_dhcp_v4 != rhs.__isset.is_dhcp_v4)
      return false;
    else if (__isset.is_dhcp_v4 && !(is_dhcp_v4 == rhs.is_dhcp_v4))
      return false;
    if (__isset.is_dhcp_v6 != rhs.__isset.is_dhcp_v6)
      return false;
    else if (__isset.is_dhcp_v6 && !(is_dhcp_v6 == rhs.is_dhcp_v6))
      return false;
    if (__isset.mac_address != rhs.__isset.mac_address)
      return false;
    else if (__isset.mac_address && !(mac_address == rhs.mac_address))
      return false;
    if (__isset.subnet_masks != rhs.__isset.subnet_masks)
      return false;
    else if (__isset.subnet_masks && !(subnet_masks == rhs.subnet_masks))
      return false;
    return true;
  }
  bool operator != (const network_info &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const network_info & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(network_info &a, network_info &b);

inline std::ostream& operator<<(std::ostream& out, const network_info& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _cluster_network__isset {
  _cluster_network__isset() : cluster_network_name(true), cluster_network_id(true), cluster_network_address(true), cluster_network_address_mask(true), network_infos(false) {}
  bool cluster_network_name :1;
  bool cluster_network_id :1;
  bool cluster_network_address :1;
  bool cluster_network_address_mask :1;
  bool network_infos :1;
} _cluster_network__isset;

class cluster_network : public virtual ::apache::thrift::TBase {
 public:

  cluster_network(const cluster_network&);
  cluster_network& operator=(const cluster_network&);
  cluster_network() : cluster_network_name(""), cluster_network_id(""), cluster_network_address(""), cluster_network_address_mask("") {
  }

  virtual ~cluster_network() throw();
  std::string cluster_network_name;
  std::string cluster_network_id;
  std::string cluster_network_address;
  std::string cluster_network_address_mask;
  std::set<network_info>  network_infos;

  _cluster_network__isset __isset;

  void __set_cluster_network_name(const std::string& val);

  void __set_cluster_network_id(const std::string& val);

  void __set_cluster_network_address(const std::string& val);

  void __set_cluster_network_address_mask(const std::string& val);

  void __set_network_infos(const std::set<network_info> & val);

  bool operator == (const cluster_network & rhs) const
  {
    if (__isset.cluster_network_name != rhs.__isset.cluster_network_name)
      return false;
    else if (__isset.cluster_network_name && !(cluster_network_name == rhs.cluster_network_name))
      return false;
    if (__isset.cluster_network_id != rhs.__isset.cluster_network_id)
      return false;
    else if (__isset.cluster_network_id && !(cluster_network_id == rhs.cluster_network_id))
      return false;
    if (__isset.cluster_network_address != rhs.__isset.cluster_network_address)
      return false;
    else if (__isset.cluster_network_address && !(cluster_network_address == rhs.cluster_network_address))
      return false;
    if (__isset.cluster_network_address_mask != rhs.__isset.cluster_network_address_mask)
      return false;
    else if (__isset.cluster_network_address_mask && !(cluster_network_address_mask == rhs.cluster_network_address_mask))
      return false;
    if (__isset.network_infos != rhs.__isset.network_infos)
      return false;
    else if (__isset.network_infos && !(network_infos == rhs.network_infos))
      return false;
    return true;
  }
  bool operator != (const cluster_network &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const cluster_network & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(cluster_network &a, cluster_network &b);

inline std::ostream& operator<<(std::ostream& out, const cluster_network& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _cluster_group__isset {
  _cluster_group__isset() : group_id(true), group_name(true), group_owner(true), cluster_disks(false), cluster_partitions(false), cluster_network_infos(false) {}
  bool group_id :1;
  bool group_name :1;
  bool group_owner :1;
  bool cluster_disks :1;
  bool cluster_partitions :1;
  bool cluster_network_infos :1;
} _cluster_group__isset;

class cluster_group : public virtual ::apache::thrift::TBase {
 public:

  cluster_group(const cluster_group&);
  cluster_group& operator=(const cluster_group&);
  cluster_group() : group_id(""), group_name(""), group_owner("") {
  }

  virtual ~cluster_group() throw();
  std::string group_id;
  std::string group_name;
  std::string group_owner;
  std::set<disk_info>  cluster_disks;
  std::set<volume_info>  cluster_partitions;
  std::set<cluster_network>  cluster_network_infos;

  _cluster_group__isset __isset;

  void __set_group_id(const std::string& val);

  void __set_group_name(const std::string& val);

  void __set_group_owner(const std::string& val);

  void __set_cluster_disks(const std::set<disk_info> & val);

  void __set_cluster_partitions(const std::set<volume_info> & val);

  void __set_cluster_network_infos(const std::set<cluster_network> & val);

  bool operator == (const cluster_group & rhs) const
  {
    if (__isset.group_id != rhs.__isset.group_id)
      return false;
    else if (__isset.group_id && !(group_id == rhs.group_id))
      return false;
    if (__isset.group_name != rhs.__isset.group_name)
      return false;
    else if (__isset.group_name && !(group_name == rhs.group_name))
      return false;
    if (__isset.group_owner != rhs.__isset.group_owner)
      return false;
    else if (__isset.group_owner && !(group_owner == rhs.group_owner))
      return false;
    if (__isset.cluster_disks != rhs.__isset.cluster_disks)
      return false;
    else if (__isset.cluster_disks && !(cluster_disks == rhs.cluster_disks))
      return false;
    if (__isset.cluster_partitions != rhs.__isset.cluster_partitions)
      return false;
    else if (__isset.cluster_partitions && !(cluster_partitions == rhs.cluster_partitions))
      return false;
    if (__isset.cluster_network_infos != rhs.__isset.cluster_network_infos)
      return false;
    else if (__isset.cluster_network_infos && !(cluster_network_infos == rhs.cluster_network_infos))
      return false;
    return true;
  }
  bool operator != (const cluster_group &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const cluster_group & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(cluster_group &a, cluster_group &b);

inline std::ostream& operator<<(std::ostream& out, const cluster_group& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _cluster_info__isset {
  _cluster_info__isset() : cluster_name(true), quorum_disk(false), cluster_nodes(false), client_ids(false), machine_ids(false), cluster_network_infos(false), cluster_groups(false) {}
  bool cluster_name :1;
  bool quorum_disk :1;
  bool cluster_nodes :1;
  bool client_ids :1;
  bool machine_ids :1;
  bool cluster_network_infos :1;
  bool cluster_groups :1;
} _cluster_info__isset;

class cluster_info : public virtual ::apache::thrift::TBase {
 public:

  cluster_info(const cluster_info&);
  cluster_info& operator=(const cluster_info&);
  cluster_info() : cluster_name("") {
  }

  virtual ~cluster_info() throw();
  std::string cluster_name;
  disk_info quorum_disk;
  std::set<std::string>  cluster_nodes;
  std::set<std::string>  client_ids;
  std::set<std::string>  machine_ids;
  std::set<cluster_network>  cluster_network_infos;
  std::set<cluster_group>  cluster_groups;

  _cluster_info__isset __isset;

  void __set_cluster_name(const std::string& val);

  void __set_quorum_disk(const disk_info& val);

  void __set_cluster_nodes(const std::set<std::string> & val);

  void __set_client_ids(const std::set<std::string> & val);

  void __set_machine_ids(const std::set<std::string> & val);

  void __set_cluster_network_infos(const std::set<cluster_network> & val);

  void __set_cluster_groups(const std::set<cluster_group> & val);

  bool operator == (const cluster_info & rhs) const
  {
    if (__isset.cluster_name != rhs.__isset.cluster_name)
      return false;
    else if (__isset.cluster_name && !(cluster_name == rhs.cluster_name))
      return false;
    if (__isset.quorum_disk != rhs.__isset.quorum_disk)
      return false;
    else if (__isset.quorum_disk && !(quorum_disk == rhs.quorum_disk))
      return false;
    if (__isset.cluster_nodes != rhs.__isset.cluster_nodes)
      return false;
    else if (__isset.cluster_nodes && !(cluster_nodes == rhs.cluster_nodes))
      return false;
    if (__isset.client_ids != rhs.__isset.client_ids)
      return false;
    else if (__isset.client_ids && !(client_ids == rhs.client_ids))
      return false;
    if (__isset.machine_ids != rhs.__isset.machine_ids)
      return false;
    else if (__isset.machine_ids && !(machine_ids == rhs.machine_ids))
      return false;
    if (__isset.cluster_network_infos != rhs.__isset.cluster_network_infos)
      return false;
    else if (__isset.cluster_network_infos && !(cluster_network_infos == rhs.cluster_network_infos))
      return false;
    if (__isset.cluster_groups != rhs.__isset.cluster_groups)
      return false;
    else if (__isset.cluster_groups && !(cluster_groups == rhs.cluster_groups))
      return false;
    return true;
  }
  bool operator != (const cluster_info &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const cluster_info & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(cluster_info &a, cluster_info &b);

inline std::ostream& operator<<(std::ostream& out, const cluster_info& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _os_version_info__isset {
  _os_version_info__isset() : csd_version(true), build_number(true), major_version(true), minor_version(true), platform_id(true), product_type(true), servicepack_major(true), servicepack_minor(true), suite_mask(true) {}
  bool csd_version :1;
  bool build_number :1;
  bool major_version :1;
  bool minor_version :1;
  bool platform_id :1;
  bool product_type :1;
  bool servicepack_major :1;
  bool servicepack_minor :1;
  bool suite_mask :1;
} _os_version_info__isset;

class os_version_info : public virtual ::apache::thrift::TBase {
 public:

  os_version_info(const os_version_info&);
  os_version_info& operator=(const os_version_info&);
  os_version_info() : csd_version(""), build_number(-1), major_version(-1), minor_version(-1), platform_id(-1), product_type(-1), servicepack_major(-1), servicepack_minor(-1), suite_mask(-1) {
  }

  virtual ~os_version_info() throw();
  std::string csd_version;
  int32_t build_number;
  int32_t major_version;
  int32_t minor_version;
  int32_t platform_id;
  int16_t product_type;
  int32_t servicepack_major;
  int32_t servicepack_minor;
  int32_t suite_mask;

  _os_version_info__isset __isset;

  void __set_csd_version(const std::string& val);

  void __set_build_number(const int32_t val);

  void __set_major_version(const int32_t val);

  void __set_minor_version(const int32_t val);

  void __set_platform_id(const int32_t val);

  void __set_product_type(const int16_t val);

  void __set_servicepack_major(const int32_t val);

  void __set_servicepack_minor(const int32_t val);

  void __set_suite_mask(const int32_t val);

  bool operator == (const os_version_info & rhs) const
  {
    if (__isset.csd_version != rhs.__isset.csd_version)
      return false;
    else if (__isset.csd_version && !(csd_version == rhs.csd_version))
      return false;
    if (__isset.build_number != rhs.__isset.build_number)
      return false;
    else if (__isset.build_number && !(build_number == rhs.build_number))
      return false;
    if (__isset.major_version != rhs.__isset.major_version)
      return false;
    else if (__isset.major_version && !(major_version == rhs.major_version))
      return false;
    if (__isset.minor_version != rhs.__isset.minor_version)
      return false;
    else if (__isset.minor_version && !(minor_version == rhs.minor_version))
      return false;
    if (__isset.platform_id != rhs.__isset.platform_id)
      return false;
    else if (__isset.platform_id && !(platform_id == rhs.platform_id))
      return false;
    if (__isset.product_type != rhs.__isset.product_type)
      return false;
    else if (__isset.product_type && !(product_type == rhs.product_type))
      return false;
    if (__isset.servicepack_major != rhs.__isset.servicepack_major)
      return false;
    else if (__isset.servicepack_major && !(servicepack_major == rhs.servicepack_major))
      return false;
    if (__isset.servicepack_minor != rhs.__isset.servicepack_minor)
      return false;
    else if (__isset.servicepack_minor && !(servicepack_minor == rhs.servicepack_minor))
      return false;
    if (__isset.suite_mask != rhs.__isset.suite_mask)
      return false;
    else if (__isset.suite_mask && !(suite_mask == rhs.suite_mask))
      return false;
    return true;
  }
  bool operator != (const os_version_info &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const os_version_info & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(os_version_info &a, os_version_info &b);

inline std::ostream& operator<<(std::ostream& out, const os_version_info& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _snapshot__isset {
  _snapshot__isset() : snapshot_set_id(true), snapshot_id(true), original_volume_name(true), snapshot_device_object(true), creation_time_stamp(true), snapshots_count(true) {}
  bool snapshot_set_id :1;
  bool snapshot_id :1;
  bool original_volume_name :1;
  bool snapshot_device_object :1;
  bool creation_time_stamp :1;
  bool snapshots_count :1;
} _snapshot__isset;

class snapshot : public virtual ::apache::thrift::TBase {
 public:

  snapshot(const snapshot&);
  snapshot& operator=(const snapshot&);
  snapshot() : snapshot_set_id(""), snapshot_id(""), original_volume_name(""), snapshot_device_object(""), creation_time_stamp(""), snapshots_count(0) {
  }

  virtual ~snapshot() throw();
  std::string snapshot_set_id;
  std::string snapshot_id;
  std::string original_volume_name;
  std::string snapshot_device_object;
  std::string creation_time_stamp;
  int32_t snapshots_count;

  _snapshot__isset __isset;

  void __set_snapshot_set_id(const std::string& val);

  void __set_snapshot_id(const std::string& val);

  void __set_original_volume_name(const std::string& val);

  void __set_snapshot_device_object(const std::string& val);

  void __set_creation_time_stamp(const std::string& val);

  void __set_snapshots_count(const int32_t val);

  bool operator == (const snapshot & rhs) const
  {
    if (__isset.snapshot_set_id != rhs.__isset.snapshot_set_id)
      return false;
    else if (__isset.snapshot_set_id && !(snapshot_set_id == rhs.snapshot_set_id))
      return false;
    if (__isset.snapshot_id != rhs.__isset.snapshot_id)
      return false;
    else if (__isset.snapshot_id && !(snapshot_id == rhs.snapshot_id))
      return false;
    if (__isset.original_volume_name != rhs.__isset.original_volume_name)
      return false;
    else if (__isset.original_volume_name && !(original_volume_name == rhs.original_volume_name))
      return false;
    if (__isset.snapshot_device_object != rhs.__isset.snapshot_device_object)
      return false;
    else if (__isset.snapshot_device_object && !(snapshot_device_object == rhs.snapshot_device_object))
      return false;
    if (__isset.creation_time_stamp != rhs.__isset.creation_time_stamp)
      return false;
    else if (__isset.creation_time_stamp && !(creation_time_stamp == rhs.creation_time_stamp))
      return false;
    if (__isset.snapshots_count != rhs.__isset.snapshots_count)
      return false;
    else if (__isset.snapshots_count && !(snapshots_count == rhs.snapshots_count))
      return false;
    return true;
  }
  bool operator != (const snapshot &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const snapshot & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(snapshot &a, snapshot &b);

inline std::ostream& operator<<(std::ostream& out, const snapshot& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _snapshot_result__isset {
  _snapshot_result__isset() : snapshots(false) {}
  bool snapshots :1;
} _snapshot_result__isset;

class snapshot_result : public virtual ::apache::thrift::TBase {
 public:

  snapshot_result(const snapshot_result&);
  snapshot_result& operator=(const snapshot_result&);
  snapshot_result() {
  }

  virtual ~snapshot_result() throw();
  std::vector<snapshot>  snapshots;

  _snapshot_result__isset __isset;

  void __set_snapshots(const std::vector<snapshot> & val);

  bool operator == (const snapshot_result & rhs) const
  {
    if (!(snapshots == rhs.snapshots))
      return false;
    return true;
  }
  bool operator != (const snapshot_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const snapshot_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(snapshot_result &a, snapshot_result &b);

inline std::ostream& operator<<(std::ostream& out, const snapshot_result& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _volume_bit_map__isset {
  _volume_bit_map__isset() : cluster_size(true), starting_lcn(true), total_number_of_clusters(true), bit_map(true), compressed(true) {}
  bool cluster_size :1;
  bool starting_lcn :1;
  bool total_number_of_clusters :1;
  bool bit_map :1;
  bool compressed :1;
} _volume_bit_map__isset;

class volume_bit_map : public virtual ::apache::thrift::TBase {
 public:

  volume_bit_map(const volume_bit_map&);
  volume_bit_map& operator=(const volume_bit_map&);
  volume_bit_map() : cluster_size(0), starting_lcn(0LL), total_number_of_clusters(0LL), bit_map(""), compressed(false) {
  }

  virtual ~volume_bit_map() throw();
  int32_t cluster_size;
  int64_t starting_lcn;
  int64_t total_number_of_clusters;
  std::string bit_map;
  bool compressed;

  _volume_bit_map__isset __isset;

  void __set_cluster_size(const int32_t val);

  void __set_starting_lcn(const int64_t val);

  void __set_total_number_of_clusters(const int64_t val);

  void __set_bit_map(const std::string& val);

  void __set_compressed(const bool val);

  bool operator == (const volume_bit_map & rhs) const
  {
    if (__isset.cluster_size != rhs.__isset.cluster_size)
      return false;
    else if (__isset.cluster_size && !(cluster_size == rhs.cluster_size))
      return false;
    if (__isset.starting_lcn != rhs.__isset.starting_lcn)
      return false;
    else if (__isset.starting_lcn && !(starting_lcn == rhs.starting_lcn))
      return false;
    if (__isset.total_number_of_clusters != rhs.__isset.total_number_of_clusters)
      return false;
    else if (__isset.total_number_of_clusters && !(total_number_of_clusters == rhs.total_number_of_clusters))
      return false;
    if (__isset.bit_map != rhs.__isset.bit_map)
      return false;
    else if (__isset.bit_map && !(bit_map == rhs.bit_map))
      return false;
    if (__isset.compressed != rhs.__isset.compressed)
      return false;
    else if (__isset.compressed && !(compressed == rhs.compressed))
      return false;
    return true;
  }
  bool operator != (const volume_bit_map &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const volume_bit_map & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(volume_bit_map &a, volume_bit_map &b);

inline std::ostream& operator<<(std::ostream& out, const volume_bit_map& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _replication_result__isset {
  _replication_result__isset() : result(true), compressed(true) {}
  bool result :1;
  bool compressed :1;
} _replication_result__isset;

class replication_result : public virtual ::apache::thrift::TBase {
 public:

  replication_result(const replication_result&);
  replication_result& operator=(const replication_result&);
  replication_result() : result(""), compressed(false) {
  }

  virtual ~replication_result() throw();
  std::string result;
  bool compressed;

  _replication_result__isset __isset;

  void __set_result(const std::string& val);

  void __set_compressed(const bool val);

  bool operator == (const replication_result & rhs) const
  {
    if (__isset.result != rhs.__isset.result)
      return false;
    else if (__isset.result && !(result == rhs.result))
      return false;
    if (__isset.compressed != rhs.__isset.compressed)
      return false;
    else if (__isset.compressed && !(compressed == rhs.compressed))
      return false;
    return true;
  }
  bool operator != (const replication_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const replication_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(replication_result &a, replication_result &b);

inline std::ostream& operator<<(std::ostream& out, const replication_result& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _delete_snapshot_result__isset {
  _delete_snapshot_result__isset() : code(true), deleted_snapshots(true), non_deleted_snapshot_id(false) {}
  bool code :1;
  bool deleted_snapshots :1;
  bool non_deleted_snapshot_id :1;
} _delete_snapshot_result__isset;

class delete_snapshot_result : public virtual ::apache::thrift::TBase {
 public:

  delete_snapshot_result(const delete_snapshot_result&);
  delete_snapshot_result& operator=(const delete_snapshot_result&);
  delete_snapshot_result() : code(0), deleted_snapshots(0), non_deleted_snapshot_id() {
  }

  virtual ~delete_snapshot_result() throw();
  int32_t code;
  int32_t deleted_snapshots;
  std::string non_deleted_snapshot_id;

  _delete_snapshot_result__isset __isset;

  void __set_code(const int32_t val);

  void __set_deleted_snapshots(const int32_t val);

  void __set_non_deleted_snapshot_id(const std::string& val);

  bool operator == (const delete_snapshot_result & rhs) const
  {
    if (__isset.code != rhs.__isset.code)
      return false;
    else if (__isset.code && !(code == rhs.code))
      return false;
    if (__isset.deleted_snapshots != rhs.__isset.deleted_snapshots)
      return false;
    else if (__isset.deleted_snapshots && !(deleted_snapshots == rhs.deleted_snapshots))
      return false;
    if (__isset.non_deleted_snapshot_id != rhs.__isset.non_deleted_snapshot_id)
      return false;
    else if (__isset.non_deleted_snapshot_id && !(non_deleted_snapshot_id == rhs.non_deleted_snapshot_id))
      return false;
    return true;
  }
  bool operator != (const delete_snapshot_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const delete_snapshot_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(delete_snapshot_result &a, delete_snapshot_result &b);

inline std::ostream& operator<<(std::ostream& out, const delete_snapshot_result& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _physical_machine_info__isset {
  _physical_machine_info__isset() : architecture(true), client_id(true), client_name(true), domain(true), hal(true), initiator_name(true), is_oem(true), logical_processors(true), machine_id(true), manufacturer(true), os_name(true), os_type(true), os_system_info(false), physical_memory(true), processors(true), role(true), system_model(true), system_root(true), workgroup(true), os_version(false), cluster_infos(false), disk_infos(false), network_infos(false), partition_infos(false), volume_infos(false), is_vcbt_driver_installed(true), is_vcbt_enabled(true), current_vcbt_version(false), installed_vcbt_version(false), is_winpe(true) {}
  bool architecture :1;
  bool client_id :1;
  bool client_name :1;
  bool domain :1;
  bool hal :1;
  bool initiator_name :1;
  bool is_oem :1;
  bool logical_processors :1;
  bool machine_id :1;
  bool manufacturer :1;
  bool os_name :1;
  bool os_type :1;
  bool os_system_info :1;
  bool physical_memory :1;
  bool processors :1;
  bool role :1;
  bool system_model :1;
  bool system_root :1;
  bool workgroup :1;
  bool os_version :1;
  bool cluster_infos :1;
  bool disk_infos :1;
  bool network_infos :1;
  bool partition_infos :1;
  bool volume_infos :1;
  bool is_vcbt_driver_installed :1;
  bool is_vcbt_enabled :1;
  bool current_vcbt_version :1;
  bool installed_vcbt_version :1;
  bool is_winpe :1;
} _physical_machine_info__isset;

class physical_machine_info : public virtual ::apache::thrift::TBase {
 public:

  physical_machine_info(const physical_machine_info&);
  physical_machine_info& operator=(const physical_machine_info&);
  physical_machine_info() : architecture(""), client_id(""), client_name(""), domain(""), hal(""), initiator_name(""), is_oem(false), logical_processors(0), machine_id(""), manufacturer(""), os_name(""), os_type(0), os_system_info(), physical_memory(0LL), processors(0), role(0), system_model(""), system_root(""), workgroup(""), is_vcbt_driver_installed(false), is_vcbt_enabled(false), current_vcbt_version(), installed_vcbt_version(), is_winpe(false) {
  }

  virtual ~physical_machine_info() throw();
  std::string architecture;
  std::string client_id;
  std::string client_name;
  std::string domain;
  std::string hal;
  std::string initiator_name;
  bool is_oem;
  int16_t logical_processors;
  std::string machine_id;
  std::string manufacturer;
  std::string os_name;
  int32_t os_type;
  std::string os_system_info;
  int64_t physical_memory;
  int16_t processors;
  int32_t role;
  std::string system_model;
  std::string system_root;
  std::string workgroup;
  os_version_info os_version;
  std::set<cluster_info>  cluster_infos;
  std::set<disk_info>  disk_infos;
  std::set<network_info>  network_infos;
  std::set<partition_info>  partition_infos;
  std::set<volume_info>  volume_infos;
  bool is_vcbt_driver_installed;
  bool is_vcbt_enabled;
  std::string current_vcbt_version;
  std::string installed_vcbt_version;
  bool is_winpe;

  _physical_machine_info__isset __isset;

  void __set_architecture(const std::string& val);

  void __set_client_id(const std::string& val);

  void __set_client_name(const std::string& val);

  void __set_domain(const std::string& val);

  void __set_hal(const std::string& val);

  void __set_initiator_name(const std::string& val);

  void __set_is_oem(const bool val);

  void __set_logical_processors(const int16_t val);

  void __set_machine_id(const std::string& val);

  void __set_manufacturer(const std::string& val);

  void __set_os_name(const std::string& val);

  void __set_os_type(const int32_t val);

  void __set_os_system_info(const std::string& val);

  void __set_physical_memory(const int64_t val);

  void __set_processors(const int16_t val);

  void __set_role(const int32_t val);

  void __set_system_model(const std::string& val);

  void __set_system_root(const std::string& val);

  void __set_workgroup(const std::string& val);

  void __set_os_version(const os_version_info& val);

  void __set_cluster_infos(const std::set<cluster_info> & val);

  void __set_disk_infos(const std::set<disk_info> & val);

  void __set_network_infos(const std::set<network_info> & val);

  void __set_partition_infos(const std::set<partition_info> & val);

  void __set_volume_infos(const std::set<volume_info> & val);

  void __set_is_vcbt_driver_installed(const bool val);

  void __set_is_vcbt_enabled(const bool val);

  void __set_current_vcbt_version(const std::string& val);

  void __set_installed_vcbt_version(const std::string& val);

  void __set_is_winpe(const bool val);

  bool operator == (const physical_machine_info & rhs) const
  {
    if (__isset.architecture != rhs.__isset.architecture)
      return false;
    else if (__isset.architecture && !(architecture == rhs.architecture))
      return false;
    if (__isset.client_id != rhs.__isset.client_id)
      return false;
    else if (__isset.client_id && !(client_id == rhs.client_id))
      return false;
    if (__isset.client_name != rhs.__isset.client_name)
      return false;
    else if (__isset.client_name && !(client_name == rhs.client_name))
      return false;
    if (__isset.domain != rhs.__isset.domain)
      return false;
    else if (__isset.domain && !(domain == rhs.domain))
      return false;
    if (__isset.hal != rhs.__isset.hal)
      return false;
    else if (__isset.hal && !(hal == rhs.hal))
      return false;
    if (__isset.initiator_name != rhs.__isset.initiator_name)
      return false;
    else if (__isset.initiator_name && !(initiator_name == rhs.initiator_name))
      return false;
    if (__isset.is_oem != rhs.__isset.is_oem)
      return false;
    else if (__isset.is_oem && !(is_oem == rhs.is_oem))
      return false;
    if (__isset.logical_processors != rhs.__isset.logical_processors)
      return false;
    else if (__isset.logical_processors && !(logical_processors == rhs.logical_processors))
      return false;
    if (__isset.machine_id != rhs.__isset.machine_id)
      return false;
    else if (__isset.machine_id && !(machine_id == rhs.machine_id))
      return false;
    if (__isset.manufacturer != rhs.__isset.manufacturer)
      return false;
    else if (__isset.manufacturer && !(manufacturer == rhs.manufacturer))
      return false;
    if (__isset.os_name != rhs.__isset.os_name)
      return false;
    else if (__isset.os_name && !(os_name == rhs.os_name))
      return false;
    if (__isset.os_type != rhs.__isset.os_type)
      return false;
    else if (__isset.os_type && !(os_type == rhs.os_type))
      return false;
    if (__isset.os_system_info != rhs.__isset.os_system_info)
      return false;
    else if (__isset.os_system_info && !(os_system_info == rhs.os_system_info))
      return false;
    if (__isset.physical_memory != rhs.__isset.physical_memory)
      return false;
    else if (__isset.physical_memory && !(physical_memory == rhs.physical_memory))
      return false;
    if (__isset.processors != rhs.__isset.processors)
      return false;
    else if (__isset.processors && !(processors == rhs.processors))
      return false;
    if (__isset.role != rhs.__isset.role)
      return false;
    else if (__isset.role && !(role == rhs.role))
      return false;
    if (__isset.system_model != rhs.__isset.system_model)
      return false;
    else if (__isset.system_model && !(system_model == rhs.system_model))
      return false;
    if (__isset.system_root != rhs.__isset.system_root)
      return false;
    else if (__isset.system_root && !(system_root == rhs.system_root))
      return false;
    if (__isset.workgroup != rhs.__isset.workgroup)
      return false;
    else if (__isset.workgroup && !(workgroup == rhs.workgroup))
      return false;
    if (__isset.os_version != rhs.__isset.os_version)
      return false;
    else if (__isset.os_version && !(os_version == rhs.os_version))
      return false;
    if (__isset.cluster_infos != rhs.__isset.cluster_infos)
      return false;
    else if (__isset.cluster_infos && !(cluster_infos == rhs.cluster_infos))
      return false;
    if (__isset.disk_infos != rhs.__isset.disk_infos)
      return false;
    else if (__isset.disk_infos && !(disk_infos == rhs.disk_infos))
      return false;
    if (__isset.network_infos != rhs.__isset.network_infos)
      return false;
    else if (__isset.network_infos && !(network_infos == rhs.network_infos))
      return false;
    if (__isset.partition_infos != rhs.__isset.partition_infos)
      return false;
    else if (__isset.partition_infos && !(partition_infos == rhs.partition_infos))
      return false;
    if (__isset.volume_infos != rhs.__isset.volume_infos)
      return false;
    else if (__isset.volume_infos && !(volume_infos == rhs.volume_infos))
      return false;
    if (__isset.is_vcbt_driver_installed != rhs.__isset.is_vcbt_driver_installed)
      return false;
    else if (__isset.is_vcbt_driver_installed && !(is_vcbt_driver_installed == rhs.is_vcbt_driver_installed))
      return false;
    if (__isset.is_vcbt_enabled != rhs.__isset.is_vcbt_enabled)
      return false;
    else if (__isset.is_vcbt_enabled && !(is_vcbt_enabled == rhs.is_vcbt_enabled))
      return false;
    if (__isset.current_vcbt_version != rhs.__isset.current_vcbt_version)
      return false;
    else if (__isset.current_vcbt_version && !(current_vcbt_version == rhs.current_vcbt_version))
      return false;
    if (__isset.installed_vcbt_version != rhs.__isset.installed_vcbt_version)
      return false;
    else if (__isset.installed_vcbt_version && !(installed_vcbt_version == rhs.installed_vcbt_version))
      return false;
    if (__isset.is_winpe != rhs.__isset.is_winpe)
      return false;
    else if (__isset.is_winpe && !(is_winpe == rhs.is_winpe))
      return false;
    return true;
  }
  bool operator != (const physical_machine_info &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const physical_machine_info & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(physical_machine_info &a, physical_machine_info &b);

inline std::ostream& operator<<(std::ostream& out, const physical_machine_info& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _virtual_host__isset {
  _virtual_host__isset() : name_ref(true), name(true), ip_addresses(false), ip_address(true), product_name(true), version(true), power_state(true), state(true), in_maintenance_mode(true), vms(false), datastores(false), networks(false), datacenter_name(true), domain_name(true), cluster_key(true), full_name(true), lic_features(false), name_list(false), domain_name_list(false), connection_type(true), virtual_center_name(false), virtual_center_version(false), uuid(false) {}
  bool name_ref :1;
  bool name :1;
  bool ip_addresses :1;
  bool ip_address :1;
  bool product_name :1;
  bool version :1;
  bool power_state :1;
  bool state :1;
  bool in_maintenance_mode :1;
  bool vms :1;
  bool datastores :1;
  bool networks :1;
  bool datacenter_name :1;
  bool domain_name :1;
  bool cluster_key :1;
  bool full_name :1;
  bool lic_features :1;
  bool name_list :1;
  bool domain_name_list :1;
  bool connection_type :1;
  bool virtual_center_name :1;
  bool virtual_center_version :1;
  bool uuid :1;
} _virtual_host__isset;

class virtual_host : public virtual ::apache::thrift::TBase {
 public:

  virtual_host(const virtual_host&);
  virtual_host& operator=(const virtual_host&);
  virtual_host() : name_ref(""), name(""), ip_address(""), product_name(""), version(""), power_state((hv_host_power_state::type)0), state(""), in_maintenance_mode(false), datacenter_name(""), domain_name(""), cluster_key(""), full_name(""), connection_type((hv_connection_type::type)0), virtual_center_name(), virtual_center_version(), uuid() {
    power_state = (hv_host_power_state::type)0;

    connection_type = (hv_connection_type::type)0;

  }

  virtual ~virtual_host() throw();
  std::string name_ref;
  std::string name;
  std::vector<std::string>  ip_addresses;
  std::string ip_address;
  std::string product_name;
  std::string version;
  hv_host_power_state::type power_state;
  std::string state;
  bool in_maintenance_mode;
  std::map<std::string, std::string>  vms;
  std::map<std::string, std::string>  datastores;
  std::map<std::string, std::string>  networks;
  std::string datacenter_name;
  std::string domain_name;
  std::string cluster_key;
  std::string full_name;
  std::map<std::string, std::vector<std::string> >  lic_features;
  std::vector<std::string>  name_list;
  std::vector<std::string>  domain_name_list;
  hv_connection_type::type connection_type;
  std::string virtual_center_name;
  std::string virtual_center_version;
  std::string uuid;

  _virtual_host__isset __isset;

  void __set_name_ref(const std::string& val);

  void __set_name(const std::string& val);

  void __set_ip_addresses(const std::vector<std::string> & val);

  void __set_ip_address(const std::string& val);

  void __set_product_name(const std::string& val);

  void __set_version(const std::string& val);

  void __set_power_state(const hv_host_power_state::type val);

  void __set_state(const std::string& val);

  void __set_in_maintenance_mode(const bool val);

  void __set_vms(const std::map<std::string, std::string> & val);

  void __set_datastores(const std::map<std::string, std::string> & val);

  void __set_networks(const std::map<std::string, std::string> & val);

  void __set_datacenter_name(const std::string& val);

  void __set_domain_name(const std::string& val);

  void __set_cluster_key(const std::string& val);

  void __set_full_name(const std::string& val);

  void __set_lic_features(const std::map<std::string, std::vector<std::string> > & val);

  void __set_name_list(const std::vector<std::string> & val);

  void __set_domain_name_list(const std::vector<std::string> & val);

  void __set_connection_type(const hv_connection_type::type val);

  void __set_virtual_center_name(const std::string& val);

  void __set_virtual_center_version(const std::string& val);

  void __set_uuid(const std::string& val);

  bool operator == (const virtual_host & rhs) const
  {
    if (__isset.name_ref != rhs.__isset.name_ref)
      return false;
    else if (__isset.name_ref && !(name_ref == rhs.name_ref))
      return false;
    if (__isset.name != rhs.__isset.name)
      return false;
    else if (__isset.name && !(name == rhs.name))
      return false;
    if (__isset.ip_addresses != rhs.__isset.ip_addresses)
      return false;
    else if (__isset.ip_addresses && !(ip_addresses == rhs.ip_addresses))
      return false;
    if (__isset.ip_address != rhs.__isset.ip_address)
      return false;
    else if (__isset.ip_address && !(ip_address == rhs.ip_address))
      return false;
    if (__isset.product_name != rhs.__isset.product_name)
      return false;
    else if (__isset.product_name && !(product_name == rhs.product_name))
      return false;
    if (__isset.version != rhs.__isset.version)
      return false;
    else if (__isset.version && !(version == rhs.version))
      return false;
    if (__isset.power_state != rhs.__isset.power_state)
      return false;
    else if (__isset.power_state && !(power_state == rhs.power_state))
      return false;
    if (__isset.state != rhs.__isset.state)
      return false;
    else if (__isset.state && !(state == rhs.state))
      return false;
    if (__isset.in_maintenance_mode != rhs.__isset.in_maintenance_mode)
      return false;
    else if (__isset.in_maintenance_mode && !(in_maintenance_mode == rhs.in_maintenance_mode))
      return false;
    if (__isset.vms != rhs.__isset.vms)
      return false;
    else if (__isset.vms && !(vms == rhs.vms))
      return false;
    if (__isset.datastores != rhs.__isset.datastores)
      return false;
    else if (__isset.datastores && !(datastores == rhs.datastores))
      return false;
    if (__isset.networks != rhs.__isset.networks)
      return false;
    else if (__isset.networks && !(networks == rhs.networks))
      return false;
    if (__isset.datacenter_name != rhs.__isset.datacenter_name)
      return false;
    else if (__isset.datacenter_name && !(datacenter_name == rhs.datacenter_name))
      return false;
    if (__isset.domain_name != rhs.__isset.domain_name)
      return false;
    else if (__isset.domain_name && !(domain_name == rhs.domain_name))
      return false;
    if (__isset.cluster_key != rhs.__isset.cluster_key)
      return false;
    else if (__isset.cluster_key && !(cluster_key == rhs.cluster_key))
      return false;
    if (__isset.full_name != rhs.__isset.full_name)
      return false;
    else if (__isset.full_name && !(full_name == rhs.full_name))
      return false;
    if (__isset.lic_features != rhs.__isset.lic_features)
      return false;
    else if (__isset.lic_features && !(lic_features == rhs.lic_features))
      return false;
    if (__isset.name_list != rhs.__isset.name_list)
      return false;
    else if (__isset.name_list && !(name_list == rhs.name_list))
      return false;
    if (__isset.domain_name_list != rhs.__isset.domain_name_list)
      return false;
    else if (__isset.domain_name_list && !(domain_name_list == rhs.domain_name_list))
      return false;
    if (__isset.connection_type != rhs.__isset.connection_type)
      return false;
    else if (__isset.connection_type && !(connection_type == rhs.connection_type))
      return false;
    if (__isset.virtual_center_name != rhs.__isset.virtual_center_name)
      return false;
    else if (__isset.virtual_center_name && !(virtual_center_name == rhs.virtual_center_name))
      return false;
    if (__isset.virtual_center_version != rhs.__isset.virtual_center_version)
      return false;
    else if (__isset.virtual_center_version && !(virtual_center_version == rhs.virtual_center_version))
      return false;
    if (__isset.uuid != rhs.__isset.uuid)
      return false;
    else if (__isset.uuid && !(uuid == rhs.uuid))
      return false;
    return true;
  }
  bool operator != (const virtual_host &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const virtual_host & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(virtual_host &a, virtual_host &b);

inline std::ostream& operator<<(std::ostream& out, const virtual_host& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _virtual_network_adapter__isset {
  _virtual_network_adapter__isset() : key(true), name(true), mac_address(true), network(true), port_group(true), type(true), is_connected(true), is_start_connected(true), is_allow_guest_control(true), address_type(true), ip_addresses(false) {}
  bool key :1;
  bool name :1;
  bool mac_address :1;
  bool network :1;
  bool port_group :1;
  bool type :1;
  bool is_connected :1;
  bool is_start_connected :1;
  bool is_allow_guest_control :1;
  bool address_type :1;
  bool ip_addresses :1;
} _virtual_network_adapter__isset;

class virtual_network_adapter : public virtual ::apache::thrift::TBase {
 public:

  virtual_network_adapter(const virtual_network_adapter&);
  virtual_network_adapter& operator=(const virtual_network_adapter&);
  virtual_network_adapter() : key(0), name(""), mac_address(""), network(""), port_group(""), type(""), is_connected(false), is_start_connected(false), is_allow_guest_control(false), address_type("") {
  }

  virtual ~virtual_network_adapter() throw();
  int32_t key;
  std::string name;
  std::string mac_address;
  std::string network;
  std::string port_group;
  std::string type;
  bool is_connected;
  bool is_start_connected;
  bool is_allow_guest_control;
  std::string address_type;
  std::vector<std::string>  ip_addresses;

  _virtual_network_adapter__isset __isset;

  void __set_key(const int32_t val);

  void __set_name(const std::string& val);

  void __set_mac_address(const std::string& val);

  void __set_network(const std::string& val);

  void __set_port_group(const std::string& val);

  void __set_type(const std::string& val);

  void __set_is_connected(const bool val);

  void __set_is_start_connected(const bool val);

  void __set_is_allow_guest_control(const bool val);

  void __set_address_type(const std::string& val);

  void __set_ip_addresses(const std::vector<std::string> & val);

  bool operator == (const virtual_network_adapter & rhs) const
  {
    if (__isset.key != rhs.__isset.key)
      return false;
    else if (__isset.key && !(key == rhs.key))
      return false;
    if (__isset.name != rhs.__isset.name)
      return false;
    else if (__isset.name && !(name == rhs.name))
      return false;
    if (__isset.mac_address != rhs.__isset.mac_address)
      return false;
    else if (__isset.mac_address && !(mac_address == rhs.mac_address))
      return false;
    if (__isset.network != rhs.__isset.network)
      return false;
    else if (__isset.network && !(network == rhs.network))
      return false;
    if (__isset.port_group != rhs.__isset.port_group)
      return false;
    else if (__isset.port_group && !(port_group == rhs.port_group))
      return false;
    if (__isset.type != rhs.__isset.type)
      return false;
    else if (__isset.type && !(type == rhs.type))
      return false;
    if (__isset.is_connected != rhs.__isset.is_connected)
      return false;
    else if (__isset.is_connected && !(is_connected == rhs.is_connected))
      return false;
    if (__isset.is_start_connected != rhs.__isset.is_start_connected)
      return false;
    else if (__isset.is_start_connected && !(is_start_connected == rhs.is_start_connected))
      return false;
    if (__isset.is_allow_guest_control != rhs.__isset.is_allow_guest_control)
      return false;
    else if (__isset.is_allow_guest_control && !(is_allow_guest_control == rhs.is_allow_guest_control))
      return false;
    if (__isset.address_type != rhs.__isset.address_type)
      return false;
    else if (__isset.address_type && !(address_type == rhs.address_type))
      return false;
    if (__isset.ip_addresses != rhs.__isset.ip_addresses)
      return false;
    else if (__isset.ip_addresses && !(ip_addresses == rhs.ip_addresses))
      return false;
    return true;
  }
  bool operator != (const virtual_network_adapter &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const virtual_network_adapter & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(virtual_network_adapter &a, virtual_network_adapter &b);

inline std::ostream& operator<<(std::ostream& out, const virtual_network_adapter& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _virtual_machine_snapshots__isset {
  _virtual_machine_snapshots__isset() : name(true), description(true), create_time(true), quiesced(true), id(true), backup_manifest(true), replay_supported(true), child_snapshot_list(false) {}
  bool name :1;
  bool description :1;
  bool create_time :1;
  bool quiesced :1;
  bool id :1;
  bool backup_manifest :1;
  bool replay_supported :1;
  bool child_snapshot_list :1;
} _virtual_machine_snapshots__isset;

class virtual_machine_snapshots : public virtual ::apache::thrift::TBase {
 public:

  virtual_machine_snapshots(const virtual_machine_snapshots&);
  virtual_machine_snapshots& operator=(const virtual_machine_snapshots&);
  virtual_machine_snapshots() : name(""), description(""), create_time(""), quiesced(false), id(-1), backup_manifest(""), replay_supported(false) {
  }

  virtual ~virtual_machine_snapshots() throw();
  std::string name;
  std::string description;
  std::string create_time;
  bool quiesced;
  int32_t id;
  std::string backup_manifest;
  bool replay_supported;
  std::vector<virtual_machine_snapshots>  child_snapshot_list;

  _virtual_machine_snapshots__isset __isset;

  void __set_name(const std::string& val);

  void __set_description(const std::string& val);

  void __set_create_time(const std::string& val);

  void __set_quiesced(const bool val);

  void __set_id(const int32_t val);

  void __set_backup_manifest(const std::string& val);

  void __set_replay_supported(const bool val);

  void __set_child_snapshot_list(const std::vector<virtual_machine_snapshots> & val);

  bool operator == (const virtual_machine_snapshots & rhs) const
  {
    if (__isset.name != rhs.__isset.name)
      return false;
    else if (__isset.name && !(name == rhs.name))
      return false;
    if (__isset.description != rhs.__isset.description)
      return false;
    else if (__isset.description && !(description == rhs.description))
      return false;
    if (__isset.create_time != rhs.__isset.create_time)
      return false;
    else if (__isset.create_time && !(create_time == rhs.create_time))
      return false;
    if (__isset.quiesced != rhs.__isset.quiesced)
      return false;
    else if (__isset.quiesced && !(quiesced == rhs.quiesced))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.backup_manifest != rhs.__isset.backup_manifest)
      return false;
    else if (__isset.backup_manifest && !(backup_manifest == rhs.backup_manifest))
      return false;
    if (__isset.replay_supported != rhs.__isset.replay_supported)
      return false;
    else if (__isset.replay_supported && !(replay_supported == rhs.replay_supported))
      return false;
    if (__isset.child_snapshot_list != rhs.__isset.child_snapshot_list)
      return false;
    else if (__isset.child_snapshot_list && !(child_snapshot_list == rhs.child_snapshot_list))
      return false;
    return true;
  }
  bool operator != (const virtual_machine_snapshots &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const virtual_machine_snapshots & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(virtual_machine_snapshots &a, virtual_machine_snapshots &b);

inline std::ostream& operator<<(std::ostream& out, const virtual_machine_snapshots& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _virtual_disk_info__isset {
  _virtual_disk_info__isset() : key(true), name(true), id(true), size_kb(true), size(true) {}
  bool key :1;
  bool name :1;
  bool id :1;
  bool size_kb :1;
  bool size :1;
} _virtual_disk_info__isset;

class virtual_disk_info : public virtual ::apache::thrift::TBase {
 public:

  virtual_disk_info(const virtual_disk_info&);
  virtual_disk_info& operator=(const virtual_disk_info&);
  virtual_disk_info() : key(""), name(""), id(""), size_kb(0LL), size(0LL) {
  }

  virtual ~virtual_disk_info() throw();
  std::string key;
  std::string name;
  std::string id;
  int64_t size_kb;
  int64_t size;

  _virtual_disk_info__isset __isset;

  void __set_key(const std::string& val);

  void __set_name(const std::string& val);

  void __set_id(const std::string& val);

  void __set_size_kb(const int64_t val);

  void __set_size(const int64_t val);

  bool operator == (const virtual_disk_info & rhs) const
  {
    if (__isset.key != rhs.__isset.key)
      return false;
    else if (__isset.key && !(key == rhs.key))
      return false;
    if (__isset.name != rhs.__isset.name)
      return false;
    else if (__isset.name && !(name == rhs.name))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.size_kb != rhs.__isset.size_kb)
      return false;
    else if (__isset.size_kb && !(size_kb == rhs.size_kb))
      return false;
    if (__isset.size != rhs.__isset.size)
      return false;
    else if (__isset.size && !(size == rhs.size))
      return false;
    return true;
  }
  bool operator != (const virtual_disk_info &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const virtual_disk_info & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(virtual_disk_info &a, virtual_disk_info &b);

inline std::ostream& operator<<(std::ostream& out, const virtual_disk_info& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _virtual_machine__isset {
  _virtual_machine__isset() : uuid(true), name(true), host_key(true), host_ip(true), host_name(true), cluster_key(true), cluster_name(true), annotation(true), is_cpu_hot_add(true), is_cpu_hot_remove(true), memory_mb(true), number_of_cpu(true), is_template(true), config_path(true), config_path_file(true), version(true), power_state(true), connection_state(true), tools_status(true), firmware(true), guest_os_type(true), guest_id(true), guest_os_name(true), is_disk_uuid_enabled(true), folder_path(true), resource_pool_path(true), disks(false), networks(false), datacenter_name(true), network_adapters(false), root_snapshot_list(false), guest_host_name(true), guest_ip(true) {}
  bool uuid :1;
  bool name :1;
  bool host_key :1;
  bool host_ip :1;
  bool host_name :1;
  bool cluster_key :1;
  bool cluster_name :1;
  bool annotation :1;
  bool is_cpu_hot_add :1;
  bool is_cpu_hot_remove :1;
  bool memory_mb :1;
  bool number_of_cpu :1;
  bool is_template :1;
  bool config_path :1;
  bool config_path_file :1;
  bool version :1;
  bool power_state :1;
  bool connection_state :1;
  bool tools_status :1;
  bool firmware :1;
  bool guest_os_type :1;
  bool guest_id :1;
  bool guest_os_name :1;
  bool is_disk_uuid_enabled :1;
  bool folder_path :1;
  bool resource_pool_path :1;
  bool disks :1;
  bool networks :1;
  bool datacenter_name :1;
  bool network_adapters :1;
  bool root_snapshot_list :1;
  bool guest_host_name :1;
  bool guest_ip :1;
} _virtual_machine__isset;

class virtual_machine : public virtual ::apache::thrift::TBase {
 public:

  virtual_machine(const virtual_machine&);
  virtual_machine& operator=(const virtual_machine&);
  virtual_machine() : uuid(""), name(""), host_key(""), host_ip(""), host_name(""), cluster_key(""), cluster_name(""), annotation(""), is_cpu_hot_add(false), is_cpu_hot_remove(false), memory_mb(0), number_of_cpu(0), is_template(false), config_path(""), config_path_file(""), version(0), power_state((hv_vm_power_state::type)0), connection_state((hv_vm_connection_state::type)0), tools_status((hv_vm_tools_status::type)0), firmware((hv_vm_firmware::type)0), guest_os_type((hv_guest_os_type::type)0), guest_id(""), guest_os_name(""), is_disk_uuid_enabled(false), folder_path(""), resource_pool_path(""), datacenter_name(""), guest_host_name(""), guest_ip("") {
    power_state = (hv_vm_power_state::type)0;

    connection_state = (hv_vm_connection_state::type)0;

    tools_status = (hv_vm_tools_status::type)0;

    firmware = (hv_vm_firmware::type)0;

    guest_os_type = (hv_guest_os_type::type)0;

  }

  virtual ~virtual_machine() throw();
  std::string uuid;
  std::string name;
  std::string host_key;
  std::string host_ip;
  std::string host_name;
  std::string cluster_key;
  std::string cluster_name;
  std::string annotation;
  bool is_cpu_hot_add;
  bool is_cpu_hot_remove;
  int32_t memory_mb;
  int32_t number_of_cpu;
  bool is_template;
  std::string config_path;
  std::string config_path_file;
  int32_t version;
  hv_vm_power_state::type power_state;
  hv_vm_connection_state::type connection_state;
  hv_vm_tools_status::type tools_status;
  hv_vm_firmware::type firmware;
  hv_guest_os_type::type guest_os_type;
  std::string guest_id;
  std::string guest_os_name;
  bool is_disk_uuid_enabled;
  std::string folder_path;
  std::string resource_pool_path;
  std::vector<virtual_disk_info>  disks;
  std::map<std::string, std::string>  networks;
  std::string datacenter_name;
  std::vector<virtual_network_adapter>  network_adapters;
  std::vector<virtual_machine_snapshots>  root_snapshot_list;
  std::string guest_host_name;
  std::string guest_ip;

  _virtual_machine__isset __isset;

  void __set_uuid(const std::string& val);

  void __set_name(const std::string& val);

  void __set_host_key(const std::string& val);

  void __set_host_ip(const std::string& val);

  void __set_host_name(const std::string& val);

  void __set_cluster_key(const std::string& val);

  void __set_cluster_name(const std::string& val);

  void __set_annotation(const std::string& val);

  void __set_is_cpu_hot_add(const bool val);

  void __set_is_cpu_hot_remove(const bool val);

  void __set_memory_mb(const int32_t val);

  void __set_number_of_cpu(const int32_t val);

  void __set_is_template(const bool val);

  void __set_config_path(const std::string& val);

  void __set_config_path_file(const std::string& val);

  void __set_version(const int32_t val);

  void __set_power_state(const hv_vm_power_state::type val);

  void __set_connection_state(const hv_vm_connection_state::type val);

  void __set_tools_status(const hv_vm_tools_status::type val);

  void __set_firmware(const hv_vm_firmware::type val);

  void __set_guest_os_type(const hv_guest_os_type::type val);

  void __set_guest_id(const std::string& val);

  void __set_guest_os_name(const std::string& val);

  void __set_is_disk_uuid_enabled(const bool val);

  void __set_folder_path(const std::string& val);

  void __set_resource_pool_path(const std::string& val);

  void __set_disks(const std::vector<virtual_disk_info> & val);

  void __set_networks(const std::map<std::string, std::string> & val);

  void __set_datacenter_name(const std::string& val);

  void __set_network_adapters(const std::vector<virtual_network_adapter> & val);

  void __set_root_snapshot_list(const std::vector<virtual_machine_snapshots> & val);

  void __set_guest_host_name(const std::string& val);

  void __set_guest_ip(const std::string& val);

  bool operator == (const virtual_machine & rhs) const
  {
    if (__isset.uuid != rhs.__isset.uuid)
      return false;
    else if (__isset.uuid && !(uuid == rhs.uuid))
      return false;
    if (__isset.name != rhs.__isset.name)
      return false;
    else if (__isset.name && !(name == rhs.name))
      return false;
    if (__isset.host_key != rhs.__isset.host_key)
      return false;
    else if (__isset.host_key && !(host_key == rhs.host_key))
      return false;
    if (__isset.host_ip != rhs.__isset.host_ip)
      return false;
    else if (__isset.host_ip && !(host_ip == rhs.host_ip))
      return false;
    if (__isset.host_name != rhs.__isset.host_name)
      return false;
    else if (__isset.host_name && !(host_name == rhs.host_name))
      return false;
    if (__isset.cluster_key != rhs.__isset.cluster_key)
      return false;
    else if (__isset.cluster_key && !(cluster_key == rhs.cluster_key))
      return false;
    if (__isset.cluster_name != rhs.__isset.cluster_name)
      return false;
    else if (__isset.cluster_name && !(cluster_name == rhs.cluster_name))
      return false;
    if (__isset.annotation != rhs.__isset.annotation)
      return false;
    else if (__isset.annotation && !(annotation == rhs.annotation))
      return false;
    if (__isset.is_cpu_hot_add != rhs.__isset.is_cpu_hot_add)
      return false;
    else if (__isset.is_cpu_hot_add && !(is_cpu_hot_add == rhs.is_cpu_hot_add))
      return false;
    if (__isset.is_cpu_hot_remove != rhs.__isset.is_cpu_hot_remove)
      return false;
    else if (__isset.is_cpu_hot_remove && !(is_cpu_hot_remove == rhs.is_cpu_hot_remove))
      return false;
    if (__isset.memory_mb != rhs.__isset.memory_mb)
      return false;
    else if (__isset.memory_mb && !(memory_mb == rhs.memory_mb))
      return false;
    if (__isset.number_of_cpu != rhs.__isset.number_of_cpu)
      return false;
    else if (__isset.number_of_cpu && !(number_of_cpu == rhs.number_of_cpu))
      return false;
    if (__isset.is_template != rhs.__isset.is_template)
      return false;
    else if (__isset.is_template && !(is_template == rhs.is_template))
      return false;
    if (__isset.config_path != rhs.__isset.config_path)
      return false;
    else if (__isset.config_path && !(config_path == rhs.config_path))
      return false;
    if (__isset.config_path_file != rhs.__isset.config_path_file)
      return false;
    else if (__isset.config_path_file && !(config_path_file == rhs.config_path_file))
      return false;
    if (__isset.version != rhs.__isset.version)
      return false;
    else if (__isset.version && !(version == rhs.version))
      return false;
    if (__isset.power_state != rhs.__isset.power_state)
      return false;
    else if (__isset.power_state && !(power_state == rhs.power_state))
      return false;
    if (__isset.connection_state != rhs.__isset.connection_state)
      return false;
    else if (__isset.connection_state && !(connection_state == rhs.connection_state))
      return false;
    if (__isset.tools_status != rhs.__isset.tools_status)
      return false;
    else if (__isset.tools_status && !(tools_status == rhs.tools_status))
      return false;
    if (__isset.firmware != rhs.__isset.firmware)
      return false;
    else if (__isset.firmware && !(firmware == rhs.firmware))
      return false;
    if (__isset.guest_os_type != rhs.__isset.guest_os_type)
      return false;
    else if (__isset.guest_os_type && !(guest_os_type == rhs.guest_os_type))
      return false;
    if (__isset.guest_id != rhs.__isset.guest_id)
      return false;
    else if (__isset.guest_id && !(guest_id == rhs.guest_id))
      return false;
    if (__isset.guest_os_name != rhs.__isset.guest_os_name)
      return false;
    else if (__isset.guest_os_name && !(guest_os_name == rhs.guest_os_name))
      return false;
    if (__isset.is_disk_uuid_enabled != rhs.__isset.is_disk_uuid_enabled)
      return false;
    else if (__isset.is_disk_uuid_enabled && !(is_disk_uuid_enabled == rhs.is_disk_uuid_enabled))
      return false;
    if (__isset.folder_path != rhs.__isset.folder_path)
      return false;
    else if (__isset.folder_path && !(folder_path == rhs.folder_path))
      return false;
    if (__isset.resource_pool_path != rhs.__isset.resource_pool_path)
      return false;
    else if (__isset.resource_pool_path && !(resource_pool_path == rhs.resource_pool_path))
      return false;
    if (__isset.disks != rhs.__isset.disks)
      return false;
    else if (__isset.disks && !(disks == rhs.disks))
      return false;
    if (__isset.networks != rhs.__isset.networks)
      return false;
    else if (__isset.networks && !(networks == rhs.networks))
      return false;
    if (__isset.datacenter_name != rhs.__isset.datacenter_name)
      return false;
    else if (__isset.datacenter_name && !(datacenter_name == rhs.datacenter_name))
      return false;
    if (__isset.network_adapters != rhs.__isset.network_adapters)
      return false;
    else if (__isset.network_adapters && !(network_adapters == rhs.network_adapters))
      return false;
    if (__isset.root_snapshot_list != rhs.__isset.root_snapshot_list)
      return false;
    else if (__isset.root_snapshot_list && !(root_snapshot_list == rhs.root_snapshot_list))
      return false;
    if (__isset.guest_host_name != rhs.__isset.guest_host_name)
      return false;
    else if (__isset.guest_host_name && !(guest_host_name == rhs.guest_host_name))
      return false;
    if (__isset.guest_ip != rhs.__isset.guest_ip)
      return false;
    else if (__isset.guest_ip && !(guest_ip == rhs.guest_ip))
      return false;
    return true;
  }
  bool operator != (const virtual_machine &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const virtual_machine & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(virtual_machine &a, virtual_machine &b);

inline std::ostream& operator<<(std::ostream& out, const virtual_machine& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _invalid_operation__isset {
  _invalid_operation__isset() : what_op(false), why(false), format(true), arguments(false) {}
  bool what_op :1;
  bool why :1;
  bool format :1;
  bool arguments :1;
} _invalid_operation__isset;

class invalid_operation : public ::apache::thrift::TException {
 public:

  invalid_operation(const invalid_operation&);
  invalid_operation& operator=(const invalid_operation&);
  invalid_operation() : what_op(0), why(), format("") {
  }

  virtual ~invalid_operation() throw();
  int32_t what_op;
  std::string why;
  std::string format;
  std::vector<std::string>  arguments;

  _invalid_operation__isset __isset;

  void __set_what_op(const int32_t val);

  void __set_why(const std::string& val);

  void __set_format(const std::string& val);

  void __set_arguments(const std::vector<std::string> & val);

  bool operator == (const invalid_operation & rhs) const
  {
    if (!(what_op == rhs.what_op))
      return false;
    if (!(why == rhs.why))
      return false;
    if (__isset.format != rhs.__isset.format)
      return false;
    else if (__isset.format && !(format == rhs.format))
      return false;
    if (__isset.arguments != rhs.__isset.arguments)
      return false;
    else if (__isset.arguments && !(arguments == rhs.arguments))
      return false;
    return true;
  }
  bool operator != (const invalid_operation &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const invalid_operation & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(invalid_operation &a, invalid_operation &b);

inline std::ostream& operator<<(std::ostream& out, const invalid_operation& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _job_trigger__isset {
  _job_trigger__isset() : type(true), start(true), finish(true), interval(true), id(true), duration(true) {}
  bool type :1;
  bool start :1;
  bool finish :1;
  bool interval :1;
  bool id :1;
  bool duration :1;
} _job_trigger__isset;

class job_trigger : public virtual ::apache::thrift::TBase {
 public:

  job_trigger(const job_trigger&);
  job_trigger& operator=(const job_trigger&);
  job_trigger() : type((job_trigger_type::type)1), start(""), finish(""), interval(15), id(""), duration(0) {
    type = (job_trigger_type::type)1;

  }

  virtual ~job_trigger() throw();
  job_trigger_type::type type;
  std::string start;
  std::string finish;
  int32_t interval;
  std::string id;
  int32_t duration;

  _job_trigger__isset __isset;

  void __set_type(const job_trigger_type::type val);

  void __set_start(const std::string& val);

  void __set_finish(const std::string& val);

  void __set_interval(const int32_t val);

  void __set_id(const std::string& val);

  void __set_duration(const int32_t val);

  bool operator == (const job_trigger & rhs) const
  {
    if (__isset.type != rhs.__isset.type)
      return false;
    else if (__isset.type && !(type == rhs.type))
      return false;
    if (__isset.start != rhs.__isset.start)
      return false;
    else if (__isset.start && !(start == rhs.start))
      return false;
    if (__isset.finish != rhs.__isset.finish)
      return false;
    else if (__isset.finish && !(finish == rhs.finish))
      return false;
    if (__isset.interval != rhs.__isset.interval)
      return false;
    else if (__isset.interval && !(interval == rhs.interval))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.duration != rhs.__isset.duration)
      return false;
    else if (__isset.duration && !(duration == rhs.duration))
      return false;
    return true;
  }
  bool operator != (const job_trigger &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const job_trigger & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(job_trigger &a, job_trigger &b);

inline std::ostream& operator<<(std::ostream& out, const job_trigger& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _job_history__isset {
  _job_history__isset() : time(true), state(true), error(true), description(true), format(true), arguments(false), is_display(true) {}
  bool time :1;
  bool state :1;
  bool error :1;
  bool description :1;
  bool format :1;
  bool arguments :1;
  bool is_display :1;
} _job_history__isset;

class job_history : public virtual ::apache::thrift::TBase {
 public:

  job_history(const job_history&);
  job_history& operator=(const job_history&);
  job_history() : time(""), state((job_state::type)1), error(0), description(""), format(""), is_display(true) {
    state = (job_state::type)1;

  }

  virtual ~job_history() throw();
  std::string time;
  job_state::type state;
  int32_t error;
  std::string description;
  std::string format;
  std::vector<std::string>  arguments;
  bool is_display;

  _job_history__isset __isset;

  void __set_time(const std::string& val);

  void __set_state(const job_state::type val);

  void __set_error(const int32_t val);

  void __set_description(const std::string& val);

  void __set_format(const std::string& val);

  void __set_arguments(const std::vector<std::string> & val);

  void __set_is_display(const bool val);

  bool operator == (const job_history & rhs) const
  {
    if (__isset.time != rhs.__isset.time)
      return false;
    else if (__isset.time && !(time == rhs.time))
      return false;
    if (__isset.state != rhs.__isset.state)
      return false;
    else if (__isset.state && !(state == rhs.state))
      return false;
    if (__isset.error != rhs.__isset.error)
      return false;
    else if (__isset.error && !(error == rhs.error))
      return false;
    if (__isset.description != rhs.__isset.description)
      return false;
    else if (__isset.description && !(description == rhs.description))
      return false;
    if (__isset.format != rhs.__isset.format)
      return false;
    else if (__isset.format && !(format == rhs.format))
      return false;
    if (__isset.arguments != rhs.__isset.arguments)
      return false;
    else if (__isset.arguments && !(arguments == rhs.arguments))
      return false;
    if (__isset.is_display != rhs.__isset.is_display)
      return false;
    else if (__isset.is_display && !(is_display == rhs.is_display))
      return false;
    return true;
  }
  bool operator != (const job_history &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const job_history & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(job_history &a, job_history &b);

inline std::ostream& operator<<(std::ostream& out, const job_history& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _create_job_detail__isset {
  _create_job_detail__isset() : type(true), triggers(false), management_id(true), mgmt_addr(false), mgmt_port(true), is_ssl(true) {}
  bool type :1;
  bool triggers :1;
  bool management_id :1;
  bool mgmt_addr :1;
  bool mgmt_port :1;
  bool is_ssl :1;
} _create_job_detail__isset;

class create_job_detail : public virtual ::apache::thrift::TBase {
 public:

  create_job_detail(const create_job_detail&);
  create_job_detail& operator=(const create_job_detail&);
  create_job_detail() : type((job_type::type)1), management_id(""), mgmt_port(80), is_ssl(false) {
    type = (job_type::type)1;

  }

  virtual ~create_job_detail() throw();
  job_type::type type;
  std::vector<job_trigger>  triggers;
  std::string management_id;
  std::set<std::string>  mgmt_addr;
  int32_t mgmt_port;
  bool is_ssl;

  _create_job_detail__isset __isset;

  void __set_type(const job_type::type val);

  void __set_triggers(const std::vector<job_trigger> & val);

  void __set_management_id(const std::string& val);

  void __set_mgmt_addr(const std::set<std::string> & val);

  void __set_mgmt_port(const int32_t val);

  void __set_is_ssl(const bool val);

  bool operator == (const create_job_detail & rhs) const
  {
    if (__isset.type != rhs.__isset.type)
      return false;
    else if (__isset.type && !(type == rhs.type))
      return false;
    if (__isset.triggers != rhs.__isset.triggers)
      return false;
    else if (__isset.triggers && !(triggers == rhs.triggers))
      return false;
    if (__isset.management_id != rhs.__isset.management_id)
      return false;
    else if (__isset.management_id && !(management_id == rhs.management_id))
      return false;
    if (__isset.mgmt_addr != rhs.__isset.mgmt_addr)
      return false;
    else if (__isset.mgmt_addr && !(mgmt_addr == rhs.mgmt_addr))
      return false;
    if (__isset.mgmt_port != rhs.__isset.mgmt_port)
      return false;
    else if (__isset.mgmt_port && !(mgmt_port == rhs.mgmt_port))
      return false;
    if (__isset.is_ssl != rhs.__isset.is_ssl)
      return false;
    else if (__isset.is_ssl && !(is_ssl == rhs.is_ssl))
      return false;
    return true;
  }
  bool operator != (const create_job_detail &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const create_job_detail & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(create_job_detail &a, create_job_detail &b);

inline std::ostream& operator<<(std::ostream& out, const create_job_detail& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _packer_disk_image__isset {
  _packer_disk_image__isset() : name(true), parent(true), base(true) {}
  bool name :1;
  bool parent :1;
  bool base :1;
} _packer_disk_image__isset;

class packer_disk_image : public virtual ::apache::thrift::TBase {
 public:

  packer_disk_image(const packer_disk_image&);
  packer_disk_image& operator=(const packer_disk_image&);
  packer_disk_image() : name(""), parent(""), base("") {
  }

  virtual ~packer_disk_image() throw();
  std::string name;
  std::string parent;
  std::string base;

  _packer_disk_image__isset __isset;

  void __set_name(const std::string& val);

  void __set_parent(const std::string& val);

  void __set_base(const std::string& val);

  bool operator == (const packer_disk_image & rhs) const
  {
    if (__isset.name != rhs.__isset.name)
      return false;
    else if (__isset.name && !(name == rhs.name))
      return false;
    if (__isset.parent != rhs.__isset.parent)
      return false;
    else if (__isset.parent && !(parent == rhs.parent))
      return false;
    if (__isset.base != rhs.__isset.base)
      return false;
    else if (__isset.base && !(base == rhs.base))
      return false;
    return true;
  }
  bool operator != (const packer_disk_image &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const packer_disk_image & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(packer_disk_image &a, packer_disk_image &b);

inline std::ostream& operator<<(std::ostream& out, const packer_disk_image& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _virtual_create_packer_job_detail__isset {
  _virtual_create_packer_job_detail__isset() : disks(false), host(true), addr(false), username(true), password(true), virtual_machine_id(true), snapshot(true), images(false), backup_size(false), backup_progress(false), backup_image_offset(false), previous_change_ids(false), completed_blocks(false) {}
  bool disks :1;
  bool host :1;
  bool addr :1;
  bool username :1;
  bool password :1;
  bool virtual_machine_id :1;
  bool snapshot :1;
  bool images :1;
  bool backup_size :1;
  bool backup_progress :1;
  bool backup_image_offset :1;
  bool previous_change_ids :1;
  bool completed_blocks :1;
} _virtual_create_packer_job_detail__isset;

class virtual_create_packer_job_detail : public virtual ::apache::thrift::TBase {
 public:

  virtual_create_packer_job_detail(const virtual_create_packer_job_detail&);
  virtual_create_packer_job_detail& operator=(const virtual_create_packer_job_detail&);
  virtual_create_packer_job_detail() : host(""), username(""), password(""), virtual_machine_id(""), snapshot("") {
  }

  virtual ~virtual_create_packer_job_detail() throw();
  std::set<std::string>  disks;
  std::string host;
  std::set<std::string>  addr;
  std::string username;
  std::string password;
  std::string virtual_machine_id;
  std::string snapshot;
  std::map<std::string, packer_disk_image>  images;
  std::map<std::string, int64_t>  backup_size;
  std::map<std::string, int64_t>  backup_progress;
  std::map<std::string, int64_t>  backup_image_offset;
  std::map<std::string, std::string>  previous_change_ids;
  std::map<std::string, std::vector<io_changed_range> >  completed_blocks;

  _virtual_create_packer_job_detail__isset __isset;

  void __set_disks(const std::set<std::string> & val);

  void __set_host(const std::string& val);

  void __set_addr(const std::set<std::string> & val);

  void __set_username(const std::string& val);

  void __set_password(const std::string& val);

  void __set_virtual_machine_id(const std::string& val);

  void __set_snapshot(const std::string& val);

  void __set_images(const std::map<std::string, packer_disk_image> & val);

  void __set_backup_size(const std::map<std::string, int64_t> & val);

  void __set_backup_progress(const std::map<std::string, int64_t> & val);

  void __set_backup_image_offset(const std::map<std::string, int64_t> & val);

  void __set_previous_change_ids(const std::map<std::string, std::string> & val);

  void __set_completed_blocks(const std::map<std::string, std::vector<io_changed_range> > & val);

  bool operator == (const virtual_create_packer_job_detail & rhs) const
  {
    if (__isset.disks != rhs.__isset.disks)
      return false;
    else if (__isset.disks && !(disks == rhs.disks))
      return false;
    if (__isset.host != rhs.__isset.host)
      return false;
    else if (__isset.host && !(host == rhs.host))
      return false;
    if (__isset.addr != rhs.__isset.addr)
      return false;
    else if (__isset.addr && !(addr == rhs.addr))
      return false;
    if (__isset.username != rhs.__isset.username)
      return false;
    else if (__isset.username && !(username == rhs.username))
      return false;
    if (__isset.password != rhs.__isset.password)
      return false;
    else if (__isset.password && !(password == rhs.password))
      return false;
    if (__isset.virtual_machine_id != rhs.__isset.virtual_machine_id)
      return false;
    else if (__isset.virtual_machine_id && !(virtual_machine_id == rhs.virtual_machine_id))
      return false;
    if (__isset.snapshot != rhs.__isset.snapshot)
      return false;
    else if (__isset.snapshot && !(snapshot == rhs.snapshot))
      return false;
    if (__isset.images != rhs.__isset.images)
      return false;
    else if (__isset.images && !(images == rhs.images))
      return false;
    if (__isset.backup_size != rhs.__isset.backup_size)
      return false;
    else if (__isset.backup_size && !(backup_size == rhs.backup_size))
      return false;
    if (__isset.backup_progress != rhs.__isset.backup_progress)
      return false;
    else if (__isset.backup_progress && !(backup_progress == rhs.backup_progress))
      return false;
    if (__isset.backup_image_offset != rhs.__isset.backup_image_offset)
      return false;
    else if (__isset.backup_image_offset && !(backup_image_offset == rhs.backup_image_offset))
      return false;
    if (__isset.previous_change_ids != rhs.__isset.previous_change_ids)
      return false;
    else if (__isset.previous_change_ids && !(previous_change_ids == rhs.previous_change_ids))
      return false;
    if (__isset.completed_blocks != rhs.__isset.completed_blocks)
      return false;
    else if (__isset.completed_blocks && !(completed_blocks == rhs.completed_blocks))
      return false;
    return true;
  }
  bool operator != (const virtual_create_packer_job_detail &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const virtual_create_packer_job_detail & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(virtual_create_packer_job_detail &a, virtual_create_packer_job_detail &b);

inline std::ostream& operator<<(std::ostream& out, const virtual_create_packer_job_detail& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _physical_vcbt_journal__isset {
  _physical_vcbt_journal__isset() : id(true), first_key(true), latest_key(true), lowest_valid_key(true) {}
  bool id :1;
  bool first_key :1;
  bool latest_key :1;
  bool lowest_valid_key :1;
} _physical_vcbt_journal__isset;

class physical_vcbt_journal : public virtual ::apache::thrift::TBase {
 public:

  physical_vcbt_journal(const physical_vcbt_journal&);
  physical_vcbt_journal& operator=(const physical_vcbt_journal&);
  physical_vcbt_journal() : id(0LL), first_key(0LL), latest_key(0LL), lowest_valid_key(0LL) {
  }

  virtual ~physical_vcbt_journal() throw();
  int64_t id;
  int64_t first_key;
  int64_t latest_key;
  int64_t lowest_valid_key;

  _physical_vcbt_journal__isset __isset;

  void __set_id(const int64_t val);

  void __set_first_key(const int64_t val);

  void __set_latest_key(const int64_t val);

  void __set_lowest_valid_key(const int64_t val);

  bool operator == (const physical_vcbt_journal & rhs) const
  {
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.first_key != rhs.__isset.first_key)
      return false;
    else if (__isset.first_key && !(first_key == rhs.first_key))
      return false;
    if (__isset.latest_key != rhs.__isset.latest_key)
      return false;
    else if (__isset.latest_key && !(latest_key == rhs.latest_key))
      return false;
    if (__isset.lowest_valid_key != rhs.__isset.lowest_valid_key)
      return false;
    else if (__isset.lowest_valid_key && !(lowest_valid_key == rhs.lowest_valid_key))
      return false;
    return true;
  }
  bool operator != (const physical_vcbt_journal &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const physical_vcbt_journal & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(physical_vcbt_journal &a, physical_vcbt_journal &b);

inline std::ostream& operator<<(std::ostream& out, const physical_vcbt_journal& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _io_changed_range__isset {
  _io_changed_range__isset() : offset(true), start(true), length(true) {}
  bool offset :1;
  bool start :1;
  bool length :1;
} _io_changed_range__isset;

class io_changed_range : public virtual ::apache::thrift::TBase {
 public:

  io_changed_range(const io_changed_range&);
  io_changed_range& operator=(const io_changed_range&);
  io_changed_range() : offset(0LL), start(0LL), length(0LL) {
  }

  virtual ~io_changed_range() throw();
  int64_t offset;
  int64_t start;
  int64_t length;

  _io_changed_range__isset __isset;

  void __set_offset(const int64_t val);

  void __set_start(const int64_t val);

  void __set_length(const int64_t val);

  bool operator == (const io_changed_range & rhs) const
  {
    if (!(offset == rhs.offset))
      return false;
    if (!(start == rhs.start))
      return false;
    if (!(length == rhs.length))
      return false;
    return true;
  }
  bool operator != (const io_changed_range &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const io_changed_range & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(io_changed_range &a, io_changed_range &b);

inline std::ostream& operator<<(std::ostream& out, const io_changed_range& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _physical_create_packer_job_detail__isset {
  _physical_create_packer_job_detail__isset() : disks(false), snapshots(false), previous_journals(false), images(false), backup_size(false), backup_progress(false), backup_image_offset(false), cdr_journals(false), cdr_changed_ranges(false), completed_blocks(false) {}
  bool disks :1;
  bool snapshots :1;
  bool previous_journals :1;
  bool images :1;
  bool backup_size :1;
  bool backup_progress :1;
  bool backup_image_offset :1;
  bool cdr_journals :1;
  bool cdr_changed_ranges :1;
  bool completed_blocks :1;
} _physical_create_packer_job_detail__isset;

class physical_create_packer_job_detail : public virtual ::apache::thrift::TBase {
 public:

  physical_create_packer_job_detail(const physical_create_packer_job_detail&);
  physical_create_packer_job_detail& operator=(const physical_create_packer_job_detail&);
  physical_create_packer_job_detail() {
  }

  virtual ~physical_create_packer_job_detail() throw();
  std::set<std::string>  disks;
  std::vector<snapshot>  snapshots;
  std::map<int64_t, physical_vcbt_journal>  previous_journals;
  std::map<std::string, packer_disk_image>  images;
  std::map<std::string, int64_t>  backup_size;
  std::map<std::string, int64_t>  backup_progress;
  std::map<std::string, int64_t>  backup_image_offset;
  std::map<int64_t, physical_vcbt_journal>  cdr_journals;
  std::map<std::string, std::vector<io_changed_range> >  cdr_changed_ranges;
  std::map<std::string, std::vector<io_changed_range> >  completed_blocks;

  _physical_create_packer_job_detail__isset __isset;

  void __set_disks(const std::set<std::string> & val);

  void __set_snapshots(const std::vector<snapshot> & val);

  void __set_previous_journals(const std::map<int64_t, physical_vcbt_journal> & val);

  void __set_images(const std::map<std::string, packer_disk_image> & val);

  void __set_backup_size(const std::map<std::string, int64_t> & val);

  void __set_backup_progress(const std::map<std::string, int64_t> & val);

  void __set_backup_image_offset(const std::map<std::string, int64_t> & val);

  void __set_cdr_journals(const std::map<int64_t, physical_vcbt_journal> & val);

  void __set_cdr_changed_ranges(const std::map<std::string, std::vector<io_changed_range> > & val);

  void __set_completed_blocks(const std::map<std::string, std::vector<io_changed_range> > & val);

  bool operator == (const physical_create_packer_job_detail & rhs) const
  {
    if (__isset.disks != rhs.__isset.disks)
      return false;
    else if (__isset.disks && !(disks == rhs.disks))
      return false;
    if (__isset.snapshots != rhs.__isset.snapshots)
      return false;
    else if (__isset.snapshots && !(snapshots == rhs.snapshots))
      return false;
    if (__isset.previous_journals != rhs.__isset.previous_journals)
      return false;
    else if (__isset.previous_journals && !(previous_journals == rhs.previous_journals))
      return false;
    if (__isset.images != rhs.__isset.images)
      return false;
    else if (__isset.images && !(images == rhs.images))
      return false;
    if (__isset.backup_size != rhs.__isset.backup_size)
      return false;
    else if (__isset.backup_size && !(backup_size == rhs.backup_size))
      return false;
    if (__isset.backup_progress != rhs.__isset.backup_progress)
      return false;
    else if (__isset.backup_progress && !(backup_progress == rhs.backup_progress))
      return false;
    if (__isset.backup_image_offset != rhs.__isset.backup_image_offset)
      return false;
    else if (__isset.backup_image_offset && !(backup_image_offset == rhs.backup_image_offset))
      return false;
    if (__isset.cdr_journals != rhs.__isset.cdr_journals)
      return false;
    else if (__isset.cdr_journals && !(cdr_journals == rhs.cdr_journals))
      return false;
    if (__isset.cdr_changed_ranges != rhs.__isset.cdr_changed_ranges)
      return false;
    else if (__isset.cdr_changed_ranges && !(cdr_changed_ranges == rhs.cdr_changed_ranges))
      return false;
    if (__isset.completed_blocks != rhs.__isset.completed_blocks)
      return false;
    else if (__isset.completed_blocks && !(completed_blocks == rhs.completed_blocks))
      return false;
    return true;
  }
  bool operator != (const physical_create_packer_job_detail &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const physical_create_packer_job_detail & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(physical_create_packer_job_detail &a, physical_create_packer_job_detail &b);

inline std::ostream& operator<<(std::ostream& out, const physical_create_packer_job_detail& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct __create_packer_job_detail__isset {
  __create_packer_job_detail__isset() : p(false), v(false) {}
  bool p :1;
  bool v :1;
} __create_packer_job_detail__isset;

class _create_packer_job_detail : public virtual ::apache::thrift::TBase {
 public:

  _create_packer_job_detail(const _create_packer_job_detail&);
  _create_packer_job_detail& operator=(const _create_packer_job_detail&);
  _create_packer_job_detail() {
  }

  virtual ~_create_packer_job_detail() throw();
  physical_create_packer_job_detail p;
  virtual_create_packer_job_detail v;

  __create_packer_job_detail__isset __isset;

  void __set_p(const physical_create_packer_job_detail& val);

  void __set_v(const virtual_create_packer_job_detail& val);

  bool operator == (const _create_packer_job_detail & rhs) const
  {
    if (__isset.p != rhs.__isset.p)
      return false;
    else if (__isset.p && !(p == rhs.p))
      return false;
    if (__isset.v != rhs.__isset.v)
      return false;
    else if (__isset.v && !(v == rhs.v))
      return false;
    return true;
  }
  bool operator != (const _create_packer_job_detail &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const _create_packer_job_detail & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(_create_packer_job_detail &a, _create_packer_job_detail &b);

inline std::ostream& operator<<(std::ostream& out, const _create_packer_job_detail& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _create_packer_job_detail__isset {
  _create_packer_job_detail__isset() : type(false), connection_ids(false), carriers(false), detail(false), checksum_verify(true), timeout(true), is_encrypted(true), worker_thread_number(true), file_system_filter_enable(true), min_transport_size(true), full_min_transport_size(true), is_compressed(true), is_checksum(true), priority_carrier(false), is_only_single_system_disk(true), is_compressed_by_packer(true) {}
  bool type :1;
  bool connection_ids :1;
  bool carriers :1;
  bool detail :1;
  bool checksum_verify :1;
  bool timeout :1;
  bool is_encrypted :1;
  bool worker_thread_number :1;
  bool file_system_filter_enable :1;
  bool min_transport_size :1;
  bool full_min_transport_size :1;
  bool is_compressed :1;
  bool is_checksum :1;
  bool priority_carrier :1;
  bool is_only_single_system_disk :1;
  bool is_compressed_by_packer :1;
} _create_packer_job_detail__isset;

class create_packer_job_detail : public virtual ::apache::thrift::TBase {
 public:

  create_packer_job_detail(const create_packer_job_detail&);
  create_packer_job_detail& operator=(const create_packer_job_detail&);
  create_packer_job_detail() : type((job_type::type)0), checksum_verify(true), timeout(300), is_encrypted(false), worker_thread_number(0), file_system_filter_enable(true), min_transport_size(0), full_min_transport_size(0), is_compressed(true), is_checksum(false), is_only_single_system_disk(false), is_compressed_by_packer(false) {
  }

  virtual ~create_packer_job_detail() throw();
  job_type::type type;
  std::set<std::string>  connection_ids;
  std::map<std::string, std::set<std::string> >  carriers;
  _create_packer_job_detail detail;
  bool checksum_verify;
  int32_t timeout;
  bool is_encrypted;
  int32_t worker_thread_number;
  bool file_system_filter_enable;
  int32_t min_transport_size;
  int32_t full_min_transport_size;
  bool is_compressed;
  bool is_checksum;
  std::map<std::string, std::string>  priority_carrier;
  bool is_only_single_system_disk;
  bool is_compressed_by_packer;

  _create_packer_job_detail__isset __isset;

  void __set_type(const job_type::type val);

  void __set_connection_ids(const std::set<std::string> & val);

  void __set_carriers(const std::map<std::string, std::set<std::string> > & val);

  void __set_detail(const _create_packer_job_detail& val);

  void __set_checksum_verify(const bool val);

  void __set_timeout(const int32_t val);

  void __set_is_encrypted(const bool val);

  void __set_worker_thread_number(const int32_t val);

  void __set_file_system_filter_enable(const bool val);

  void __set_min_transport_size(const int32_t val);

  void __set_full_min_transport_size(const int32_t val);

  void __set_is_compressed(const bool val);

  void __set_is_checksum(const bool val);

  void __set_priority_carrier(const std::map<std::string, std::string> & val);

  void __set_is_only_single_system_disk(const bool val);

  void __set_is_compressed_by_packer(const bool val);

  bool operator == (const create_packer_job_detail & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    if (!(connection_ids == rhs.connection_ids))
      return false;
    if (!(carriers == rhs.carriers))
      return false;
    if (!(detail == rhs.detail))
      return false;
    if (__isset.checksum_verify != rhs.__isset.checksum_verify)
      return false;
    else if (__isset.checksum_verify && !(checksum_verify == rhs.checksum_verify))
      return false;
    if (__isset.timeout != rhs.__isset.timeout)
      return false;
    else if (__isset.timeout && !(timeout == rhs.timeout))
      return false;
    if (__isset.is_encrypted != rhs.__isset.is_encrypted)
      return false;
    else if (__isset.is_encrypted && !(is_encrypted == rhs.is_encrypted))
      return false;
    if (__isset.worker_thread_number != rhs.__isset.worker_thread_number)
      return false;
    else if (__isset.worker_thread_number && !(worker_thread_number == rhs.worker_thread_number))
      return false;
    if (__isset.file_system_filter_enable != rhs.__isset.file_system_filter_enable)
      return false;
    else if (__isset.file_system_filter_enable && !(file_system_filter_enable == rhs.file_system_filter_enable))
      return false;
    if (__isset.min_transport_size != rhs.__isset.min_transport_size)
      return false;
    else if (__isset.min_transport_size && !(min_transport_size == rhs.min_transport_size))
      return false;
    if (__isset.full_min_transport_size != rhs.__isset.full_min_transport_size)
      return false;
    else if (__isset.full_min_transport_size && !(full_min_transport_size == rhs.full_min_transport_size))
      return false;
    if (__isset.is_compressed != rhs.__isset.is_compressed)
      return false;
    else if (__isset.is_compressed && !(is_compressed == rhs.is_compressed))
      return false;
    if (__isset.is_checksum != rhs.__isset.is_checksum)
      return false;
    else if (__isset.is_checksum && !(is_checksum == rhs.is_checksum))
      return false;
    if (__isset.priority_carrier != rhs.__isset.priority_carrier)
      return false;
    else if (__isset.priority_carrier && !(priority_carrier == rhs.priority_carrier))
      return false;
    if (__isset.is_only_single_system_disk != rhs.__isset.is_only_single_system_disk)
      return false;
    else if (__isset.is_only_single_system_disk && !(is_only_single_system_disk == rhs.is_only_single_system_disk))
      return false;
    if (__isset.is_compressed_by_packer != rhs.__isset.is_compressed_by_packer)
      return false;
    else if (__isset.is_compressed_by_packer && !(is_compressed_by_packer == rhs.is_compressed_by_packer))
      return false;
    return true;
  }
  bool operator != (const create_packer_job_detail &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const create_packer_job_detail & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(create_packer_job_detail &a, create_packer_job_detail &b);

inline std::ostream& operator<<(std::ostream& out, const create_packer_job_detail& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _virtual_packer_job_detail__isset {
  _virtual_packer_job_detail__isset() : original_size(false), backup_size(false), backup_progress(false), backup_image_offset(false), change_ids(false), guest_os_type(true), completed_blocks(false) {}
  bool original_size :1;
  bool backup_size :1;
  bool backup_progress :1;
  bool backup_image_offset :1;
  bool change_ids :1;
  bool guest_os_type :1;
  bool completed_blocks :1;
} _virtual_packer_job_detail__isset;

class virtual_packer_job_detail : public virtual ::apache::thrift::TBase {
 public:

  virtual_packer_job_detail(const virtual_packer_job_detail&);
  virtual_packer_job_detail& operator=(const virtual_packer_job_detail&);
  virtual_packer_job_detail() : guest_os_type((hv_guest_os_type::type)0) {
    guest_os_type = (hv_guest_os_type::type)0;

  }

  virtual ~virtual_packer_job_detail() throw();
  std::map<std::string, int64_t>  original_size;
  std::map<std::string, int64_t>  backup_size;
  std::map<std::string, int64_t>  backup_progress;
  std::map<std::string, int64_t>  backup_image_offset;
  std::map<std::string, std::string>  change_ids;
  hv_guest_os_type::type guest_os_type;
  std::map<std::string, std::vector<io_changed_range> >  completed_blocks;

  _virtual_packer_job_detail__isset __isset;

  void __set_original_size(const std::map<std::string, int64_t> & val);

  void __set_backup_size(const std::map<std::string, int64_t> & val);

  void __set_backup_progress(const std::map<std::string, int64_t> & val);

  void __set_backup_image_offset(const std::map<std::string, int64_t> & val);

  void __set_change_ids(const std::map<std::string, std::string> & val);

  void __set_guest_os_type(const hv_guest_os_type::type val);

  void __set_completed_blocks(const std::map<std::string, std::vector<io_changed_range> > & val);

  bool operator == (const virtual_packer_job_detail & rhs) const
  {
    if (__isset.original_size != rhs.__isset.original_size)
      return false;
    else if (__isset.original_size && !(original_size == rhs.original_size))
      return false;
    if (__isset.backup_size != rhs.__isset.backup_size)
      return false;
    else if (__isset.backup_size && !(backup_size == rhs.backup_size))
      return false;
    if (__isset.backup_progress != rhs.__isset.backup_progress)
      return false;
    else if (__isset.backup_progress && !(backup_progress == rhs.backup_progress))
      return false;
    if (__isset.backup_image_offset != rhs.__isset.backup_image_offset)
      return false;
    else if (__isset.backup_image_offset && !(backup_image_offset == rhs.backup_image_offset))
      return false;
    if (__isset.change_ids != rhs.__isset.change_ids)
      return false;
    else if (__isset.change_ids && !(change_ids == rhs.change_ids))
      return false;
    if (__isset.guest_os_type != rhs.__isset.guest_os_type)
      return false;
    else if (__isset.guest_os_type && !(guest_os_type == rhs.guest_os_type))
      return false;
    if (__isset.completed_blocks != rhs.__isset.completed_blocks)
      return false;
    else if (__isset.completed_blocks && !(completed_blocks == rhs.completed_blocks))
      return false;
    return true;
  }
  bool operator != (const virtual_packer_job_detail &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const virtual_packer_job_detail & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(virtual_packer_job_detail &a, virtual_packer_job_detail &b);

inline std::ostream& operator<<(std::ostream& out, const virtual_packer_job_detail& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _physical_packer_job_detail__isset {
  _physical_packer_job_detail__isset() : original_size(false), backup_size(false), backup_progress(false), backup_image_offset(false), vcbt_journals(false), guest_os_type(true), cdr_changed_ranges(false), completed_blocks(false) {}
  bool original_size :1;
  bool backup_size :1;
  bool backup_progress :1;
  bool backup_image_offset :1;
  bool vcbt_journals :1;
  bool guest_os_type :1;
  bool cdr_changed_ranges :1;
  bool completed_blocks :1;
} _physical_packer_job_detail__isset;

class physical_packer_job_detail : public virtual ::apache::thrift::TBase {
 public:

  physical_packer_job_detail(const physical_packer_job_detail&);
  physical_packer_job_detail& operator=(const physical_packer_job_detail&);
  physical_packer_job_detail() : guest_os_type((hv_guest_os_type::type)1) {
    guest_os_type = (hv_guest_os_type::type)1;

  }

  virtual ~physical_packer_job_detail() throw();
  std::map<std::string, int64_t>  original_size;
  std::map<std::string, int64_t>  backup_size;
  std::map<std::string, int64_t>  backup_progress;
  std::map<std::string, int64_t>  backup_image_offset;
  std::map<int64_t, physical_vcbt_journal>  vcbt_journals;
  hv_guest_os_type::type guest_os_type;
  std::map<std::string, std::vector<io_changed_range> >  cdr_changed_ranges;
  std::map<std::string, std::vector<io_changed_range> >  completed_blocks;

  _physical_packer_job_detail__isset __isset;

  void __set_original_size(const std::map<std::string, int64_t> & val);

  void __set_backup_size(const std::map<std::string, int64_t> & val);

  void __set_backup_progress(const std::map<std::string, int64_t> & val);

  void __set_backup_image_offset(const std::map<std::string, int64_t> & val);

  void __set_vcbt_journals(const std::map<int64_t, physical_vcbt_journal> & val);

  void __set_guest_os_type(const hv_guest_os_type::type val);

  void __set_cdr_changed_ranges(const std::map<std::string, std::vector<io_changed_range> > & val);

  void __set_completed_blocks(const std::map<std::string, std::vector<io_changed_range> > & val);

  bool operator == (const physical_packer_job_detail & rhs) const
  {
    if (__isset.original_size != rhs.__isset.original_size)
      return false;
    else if (__isset.original_size && !(original_size == rhs.original_size))
      return false;
    if (__isset.backup_size != rhs.__isset.backup_size)
      return false;
    else if (__isset.backup_size && !(backup_size == rhs.backup_size))
      return false;
    if (__isset.backup_progress != rhs.__isset.backup_progress)
      return false;
    else if (__isset.backup_progress && !(backup_progress == rhs.backup_progress))
      return false;
    if (__isset.backup_image_offset != rhs.__isset.backup_image_offset)
      return false;
    else if (__isset.backup_image_offset && !(backup_image_offset == rhs.backup_image_offset))
      return false;
    if (__isset.vcbt_journals != rhs.__isset.vcbt_journals)
      return false;
    else if (__isset.vcbt_journals && !(vcbt_journals == rhs.vcbt_journals))
      return false;
    if (__isset.guest_os_type != rhs.__isset.guest_os_type)
      return false;
    else if (__isset.guest_os_type && !(guest_os_type == rhs.guest_os_type))
      return false;
    if (__isset.cdr_changed_ranges != rhs.__isset.cdr_changed_ranges)
      return false;
    else if (__isset.cdr_changed_ranges && !(cdr_changed_ranges == rhs.cdr_changed_ranges))
      return false;
    if (__isset.completed_blocks != rhs.__isset.completed_blocks)
      return false;
    else if (__isset.completed_blocks && !(completed_blocks == rhs.completed_blocks))
      return false;
    return true;
  }
  bool operator != (const physical_packer_job_detail &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const physical_packer_job_detail & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(physical_packer_job_detail &a, physical_packer_job_detail &b);

inline std::ostream& operator<<(std::ostream& out, const physical_packer_job_detail& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct __packer_job_detail__isset {
  __packer_job_detail__isset() : p(false), v(false) {}
  bool p :1;
  bool v :1;
} __packer_job_detail__isset;

class _packer_job_detail : public virtual ::apache::thrift::TBase {
 public:

  _packer_job_detail(const _packer_job_detail&);
  _packer_job_detail& operator=(const _packer_job_detail&);
  _packer_job_detail() {
  }

  virtual ~_packer_job_detail() throw();
  physical_packer_job_detail p;
  virtual_packer_job_detail v;

  __packer_job_detail__isset __isset;

  void __set_p(const physical_packer_job_detail& val);

  void __set_v(const virtual_packer_job_detail& val);

  bool operator == (const _packer_job_detail & rhs) const
  {
    if (__isset.p != rhs.__isset.p)
      return false;
    else if (__isset.p && !(p == rhs.p))
      return false;
    if (__isset.v != rhs.__isset.v)
      return false;
    else if (__isset.v && !(v == rhs.v))
      return false;
    return true;
  }
  bool operator != (const _packer_job_detail &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const _packer_job_detail & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(_packer_job_detail &a, _packer_job_detail &b);

inline std::ostream& operator<<(std::ostream& out, const _packer_job_detail& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _packer_job_detail__isset {
  _packer_job_detail__isset() : id(true), type(false), state(true), created_time(true), updated_time(true), histories(false), detail(false), is_error(true), boot_disk(true), system_disks(false), completed_blocks(false) {}
  bool id :1;
  bool type :1;
  bool state :1;
  bool created_time :1;
  bool updated_time :1;
  bool histories :1;
  bool detail :1;
  bool is_error :1;
  bool boot_disk :1;
  bool system_disks :1;
  bool completed_blocks :1;
} _packer_job_detail__isset;

class packer_job_detail : public virtual ::apache::thrift::TBase {
 public:

  packer_job_detail(const packer_job_detail&);
  packer_job_detail& operator=(const packer_job_detail&);
  packer_job_detail() : id(""), type((job_type::type)0), state((job_state::type)1), created_time(""), updated_time(""), is_error(false), boot_disk("") {
    state = (job_state::type)1;

  }

  virtual ~packer_job_detail() throw();
  std::string id;
  job_type::type type;
  job_state::type state;
  std::string created_time;
  std::string updated_time;
  std::vector<job_history>  histories;
  _packer_job_detail detail;
  bool is_error;
  std::string boot_disk;
  std::vector<std::string>  system_disks;
  std::map<std::string, std::vector<io_changed_range> >  completed_blocks;

  _packer_job_detail__isset __isset;

  void __set_id(const std::string& val);

  void __set_type(const job_type::type val);

  void __set_state(const job_state::type val);

  void __set_created_time(const std::string& val);

  void __set_updated_time(const std::string& val);

  void __set_histories(const std::vector<job_history> & val);

  void __set_detail(const _packer_job_detail& val);

  void __set_is_error(const bool val);

  void __set_boot_disk(const std::string& val);

  void __set_system_disks(const std::vector<std::string> & val);

  void __set_completed_blocks(const std::map<std::string, std::vector<io_changed_range> > & val);

  bool operator == (const packer_job_detail & rhs) const
  {
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.type != rhs.__isset.type)
      return false;
    else if (__isset.type && !(type == rhs.type))
      return false;
    if (__isset.state != rhs.__isset.state)
      return false;
    else if (__isset.state && !(state == rhs.state))
      return false;
    if (__isset.created_time != rhs.__isset.created_time)
      return false;
    else if (__isset.created_time && !(created_time == rhs.created_time))
      return false;
    if (__isset.updated_time != rhs.__isset.updated_time)
      return false;
    else if (__isset.updated_time && !(updated_time == rhs.updated_time))
      return false;
    if (__isset.histories != rhs.__isset.histories)
      return false;
    else if (__isset.histories && !(histories == rhs.histories))
      return false;
    if (__isset.detail != rhs.__isset.detail)
      return false;
    else if (__isset.detail && !(detail == rhs.detail))
      return false;
    if (__isset.is_error != rhs.__isset.is_error)
      return false;
    else if (__isset.is_error && !(is_error == rhs.is_error))
      return false;
    if (__isset.boot_disk != rhs.__isset.boot_disk)
      return false;
    else if (__isset.boot_disk && !(boot_disk == rhs.boot_disk))
      return false;
    if (__isset.system_disks != rhs.__isset.system_disks)
      return false;
    else if (__isset.system_disks && !(system_disks == rhs.system_disks))
      return false;
    if (__isset.completed_blocks != rhs.__isset.completed_blocks)
      return false;
    else if (__isset.completed_blocks && !(completed_blocks == rhs.completed_blocks))
      return false;
    return true;
  }
  bool operator != (const packer_job_detail &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const packer_job_detail & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(packer_job_detail &a, packer_job_detail &b);

inline std::ostream& operator<<(std::ostream& out, const packer_job_detail& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _replica_job_detail__isset {
  _replica_job_detail__isset() : replica_id(true), host(true), id(true), type(false), state(true), is_error(true), created_time(true), updated_time(true), virtual_machine_id(true), disks(false), connection_id(false), original_size(false), backup_progress(false), snapshot_mapping(false), backup_size(false), backup_image_offset(false), cbt_info(true), histories(false), snapshot_time(true), snapshot_info(true), boot_disk(true), system_disks(false), is_pending_rerun(true), is_cdr(true) {}
  bool replica_id :1;
  bool host :1;
  bool id :1;
  bool type :1;
  bool state :1;
  bool is_error :1;
  bool created_time :1;
  bool updated_time :1;
  bool virtual_machine_id :1;
  bool disks :1;
  bool connection_id :1;
  bool original_size :1;
  bool backup_progress :1;
  bool snapshot_mapping :1;
  bool backup_size :1;
  bool backup_image_offset :1;
  bool cbt_info :1;
  bool histories :1;
  bool snapshot_time :1;
  bool snapshot_info :1;
  bool boot_disk :1;
  bool system_disks :1;
  bool is_pending_rerun :1;
  bool is_cdr :1;
} _replica_job_detail__isset;

class replica_job_detail : public virtual ::apache::thrift::TBase {
 public:

  replica_job_detail(const replica_job_detail&);
  replica_job_detail& operator=(const replica_job_detail&);
  replica_job_detail() : replica_id(""), host(""), id(""), type((job_type::type)0), state((job_state::type)1), is_error(false), created_time(""), updated_time(""), virtual_machine_id(""), connection_id(), cbt_info(""), snapshot_time(""), snapshot_info(""), boot_disk(""), is_pending_rerun(false), is_cdr(false) {
    state = (job_state::type)1;

  }

  virtual ~replica_job_detail() throw();
  std::string replica_id;
  std::string host;
  std::string id;
  job_type::type type;
  job_state::type state;
  bool is_error;
  std::string created_time;
  std::string updated_time;
  std::string virtual_machine_id;
  std::set<std::string>  disks;
  std::string connection_id;
  std::map<std::string, int64_t>  original_size;
  std::map<std::string, int64_t>  backup_progress;
  std::map<std::string, std::string>  snapshot_mapping;
  std::map<std::string, int64_t>  backup_size;
  std::map<std::string, int64_t>  backup_image_offset;
  std::string cbt_info;
  std::vector<job_history>  histories;
  std::string snapshot_time;
  std::string snapshot_info;
  std::string boot_disk;
  std::vector<std::string>  system_disks;
  bool is_pending_rerun;
  bool is_cdr;

  _replica_job_detail__isset __isset;

  void __set_replica_id(const std::string& val);

  void __set_host(const std::string& val);

  void __set_id(const std::string& val);

  void __set_type(const job_type::type val);

  void __set_state(const job_state::type val);

  void __set_is_error(const bool val);

  void __set_created_time(const std::string& val);

  void __set_updated_time(const std::string& val);

  void __set_virtual_machine_id(const std::string& val);

  void __set_disks(const std::set<std::string> & val);

  void __set_connection_id(const std::string& val);

  void __set_original_size(const std::map<std::string, int64_t> & val);

  void __set_backup_progress(const std::map<std::string, int64_t> & val);

  void __set_snapshot_mapping(const std::map<std::string, std::string> & val);

  void __set_backup_size(const std::map<std::string, int64_t> & val);

  void __set_backup_image_offset(const std::map<std::string, int64_t> & val);

  void __set_cbt_info(const std::string& val);

  void __set_histories(const std::vector<job_history> & val);

  void __set_snapshot_time(const std::string& val);

  void __set_snapshot_info(const std::string& val);

  void __set_boot_disk(const std::string& val);

  void __set_system_disks(const std::vector<std::string> & val);

  void __set_is_pending_rerun(const bool val);

  void __set_is_cdr(const bool val);

  bool operator == (const replica_job_detail & rhs) const
  {
    if (__isset.replica_id != rhs.__isset.replica_id)
      return false;
    else if (__isset.replica_id && !(replica_id == rhs.replica_id))
      return false;
    if (__isset.host != rhs.__isset.host)
      return false;
    else if (__isset.host && !(host == rhs.host))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.type != rhs.__isset.type)
      return false;
    else if (__isset.type && !(type == rhs.type))
      return false;
    if (__isset.state != rhs.__isset.state)
      return false;
    else if (__isset.state && !(state == rhs.state))
      return false;
    if (__isset.is_error != rhs.__isset.is_error)
      return false;
    else if (__isset.is_error && !(is_error == rhs.is_error))
      return false;
    if (__isset.created_time != rhs.__isset.created_time)
      return false;
    else if (__isset.created_time && !(created_time == rhs.created_time))
      return false;
    if (__isset.updated_time != rhs.__isset.updated_time)
      return false;
    else if (__isset.updated_time && !(updated_time == rhs.updated_time))
      return false;
    if (__isset.virtual_machine_id != rhs.__isset.virtual_machine_id)
      return false;
    else if (__isset.virtual_machine_id && !(virtual_machine_id == rhs.virtual_machine_id))
      return false;
    if (__isset.disks != rhs.__isset.disks)
      return false;
    else if (__isset.disks && !(disks == rhs.disks))
      return false;
    if (__isset.connection_id != rhs.__isset.connection_id)
      return false;
    else if (__isset.connection_id && !(connection_id == rhs.connection_id))
      return false;
    if (__isset.original_size != rhs.__isset.original_size)
      return false;
    else if (__isset.original_size && !(original_size == rhs.original_size))
      return false;
    if (__isset.backup_progress != rhs.__isset.backup_progress)
      return false;
    else if (__isset.backup_progress && !(backup_progress == rhs.backup_progress))
      return false;
    if (__isset.snapshot_mapping != rhs.__isset.snapshot_mapping)
      return false;
    else if (__isset.snapshot_mapping && !(snapshot_mapping == rhs.snapshot_mapping))
      return false;
    if (__isset.backup_size != rhs.__isset.backup_size)
      return false;
    else if (__isset.backup_size && !(backup_size == rhs.backup_size))
      return false;
    if (__isset.backup_image_offset != rhs.__isset.backup_image_offset)
      return false;
    else if (__isset.backup_image_offset && !(backup_image_offset == rhs.backup_image_offset))
      return false;
    if (__isset.cbt_info != rhs.__isset.cbt_info)
      return false;
    else if (__isset.cbt_info && !(cbt_info == rhs.cbt_info))
      return false;
    if (__isset.histories != rhs.__isset.histories)
      return false;
    else if (__isset.histories && !(histories == rhs.histories))
      return false;
    if (__isset.snapshot_time != rhs.__isset.snapshot_time)
      return false;
    else if (__isset.snapshot_time && !(snapshot_time == rhs.snapshot_time))
      return false;
    if (__isset.snapshot_info != rhs.__isset.snapshot_info)
      return false;
    else if (__isset.snapshot_info && !(snapshot_info == rhs.snapshot_info))
      return false;
    if (__isset.boot_disk != rhs.__isset.boot_disk)
      return false;
    else if (__isset.boot_disk && !(boot_disk == rhs.boot_disk))
      return false;
    if (__isset.system_disks != rhs.__isset.system_disks)
      return false;
    else if (__isset.system_disks && !(system_disks == rhs.system_disks))
      return false;
    if (__isset.is_pending_rerun != rhs.__isset.is_pending_rerun)
      return false;
    else if (__isset.is_pending_rerun && !(is_pending_rerun == rhs.is_pending_rerun))
      return false;
    if (__isset.is_cdr != rhs.__isset.is_cdr)
      return false;
    else if (__isset.is_cdr && !(is_cdr == rhs.is_cdr))
      return false;
    return true;
  }
  bool operator != (const replica_job_detail &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const replica_job_detail & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(replica_job_detail &a, replica_job_detail &b);

inline std::ostream& operator<<(std::ostream& out, const replica_job_detail& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _service_info__isset {
  _service_info__isset() : id(false), version(false), path(false) {}
  bool id :1;
  bool version :1;
  bool path :1;
} _service_info__isset;

class service_info : public virtual ::apache::thrift::TBase {
 public:

  service_info(const service_info&);
  service_info& operator=(const service_info&);
  service_info() : id(), version(), path() {
  }

  virtual ~service_info() throw();
  std::string id;
  std::string version;
  std::string path;

  _service_info__isset __isset;

  void __set_id(const std::string& val);

  void __set_version(const std::string& val);

  void __set_path(const std::string& val);

  bool operator == (const service_info & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(version == rhs.version))
      return false;
    if (!(path == rhs.path))
      return false;
    return true;
  }
  bool operator != (const service_info &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const service_info & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(service_info &a, service_info &b);

inline std::ostream& operator<<(std::ostream& out, const service_info& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _local_folder__isset {
  _local_folder__isset() : path(true) {}
  bool path :1;
} _local_folder__isset;

class local_folder : public virtual ::apache::thrift::TBase {
 public:

  local_folder(const local_folder&);
  local_folder& operator=(const local_folder&);
  local_folder() : path("") {
  }

  virtual ~local_folder() throw();
  std::string path;

  _local_folder__isset __isset;

  void __set_path(const std::string& val);

  bool operator == (const local_folder & rhs) const
  {
    if (__isset.path != rhs.__isset.path)
      return false;
    else if (__isset.path && !(path == rhs.path))
      return false;
    return true;
  }
  bool operator != (const local_folder &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const local_folder & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(local_folder &a, local_folder &b);

inline std::ostream& operator<<(std::ostream& out, const local_folder& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _network_folder__isset {
  _network_folder__isset() : path(true), username(true), password(true), port(true), proxy_host(true), proxy_port(true), proxy_username(true), proxy_password(true), s3_region(true), timeout(true) {}
  bool path :1;
  bool username :1;
  bool password :1;
  bool port :1;
  bool proxy_host :1;
  bool proxy_port :1;
  bool proxy_username :1;
  bool proxy_password :1;
  bool s3_region :1;
  bool timeout :1;
} _network_folder__isset;

class network_folder : public virtual ::apache::thrift::TBase {
 public:

  network_folder(const network_folder&);
  network_folder& operator=(const network_folder&);
  network_folder() : path(""), username(""), password(""), port(0), proxy_host(""), proxy_port(0), proxy_username(""), proxy_password(""), s3_region((aws_region::type)0), timeout(300) {
    s3_region = (aws_region::type)0;

  }

  virtual ~network_folder() throw();
  std::string path;
  std::string username;
  std::string password;
  int32_t port;
  std::string proxy_host;
  int32_t proxy_port;
  std::string proxy_username;
  std::string proxy_password;
  aws_region::type s3_region;
  int32_t timeout;

  _network_folder__isset __isset;

  void __set_path(const std::string& val);

  void __set_username(const std::string& val);

  void __set_password(const std::string& val);

  void __set_port(const int32_t val);

  void __set_proxy_host(const std::string& val);

  void __set_proxy_port(const int32_t val);

  void __set_proxy_username(const std::string& val);

  void __set_proxy_password(const std::string& val);

  void __set_s3_region(const aws_region::type val);

  void __set_timeout(const int32_t val);

  bool operator == (const network_folder & rhs) const
  {
    if (__isset.path != rhs.__isset.path)
      return false;
    else if (__isset.path && !(path == rhs.path))
      return false;
    if (__isset.username != rhs.__isset.username)
      return false;
    else if (__isset.username && !(username == rhs.username))
      return false;
    if (__isset.password != rhs.__isset.password)
      return false;
    else if (__isset.password && !(password == rhs.password))
      return false;
    if (__isset.port != rhs.__isset.port)
      return false;
    else if (__isset.port && !(port == rhs.port))
      return false;
    if (__isset.proxy_host != rhs.__isset.proxy_host)
      return false;
    else if (__isset.proxy_host && !(proxy_host == rhs.proxy_host))
      return false;
    if (__isset.proxy_port != rhs.__isset.proxy_port)
      return false;
    else if (__isset.proxy_port && !(proxy_port == rhs.proxy_port))
      return false;
    if (__isset.proxy_username != rhs.__isset.proxy_username)
      return false;
    else if (__isset.proxy_username && !(proxy_username == rhs.proxy_username))
      return false;
    if (__isset.proxy_password != rhs.__isset.proxy_password)
      return false;
    else if (__isset.proxy_password && !(proxy_password == rhs.proxy_password))
      return false;
    if (__isset.s3_region != rhs.__isset.s3_region)
      return false;
    else if (__isset.s3_region && !(s3_region == rhs.s3_region))
      return false;
    if (__isset.timeout != rhs.__isset.timeout)
      return false;
    else if (__isset.timeout && !(timeout == rhs.timeout))
      return false;
    return true;
  }
  bool operator != (const network_folder &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const network_folder & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(network_folder &a, network_folder &b);

inline std::ostream& operator<<(std::ostream& out, const network_folder& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct __detail__isset {
  __detail__isset() : local(false), remote(false) {}
  bool local :1;
  bool remote :1;
} __detail__isset;

class _detail : public virtual ::apache::thrift::TBase {
 public:

  _detail(const _detail&);
  _detail& operator=(const _detail&);
  _detail() {
  }

  virtual ~_detail() throw();
  local_folder local;
  network_folder remote;

  __detail__isset __isset;

  void __set_local(const local_folder& val);

  void __set_remote(const network_folder& val);

  bool operator == (const _detail & rhs) const
  {
    if (!(local == rhs.local))
      return false;
    if (!(remote == rhs.remote))
      return false;
    return true;
  }
  bool operator != (const _detail &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const _detail & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(_detail &a, _detail &b);

inline std::ostream& operator<<(std::ostream& out, const _detail& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _connection__isset {
  _connection__isset() : type(true), id(true), options(false), compressed(true), checksum(true), encrypted(true), detail(false) {}
  bool type :1;
  bool id :1;
  bool options :1;
  bool compressed :1;
  bool checksum :1;
  bool encrypted :1;
  bool detail :1;
} _connection__isset;

class connection : public virtual ::apache::thrift::TBase {
 public:

  connection(const connection&);
  connection& operator=(const connection&);
  connection() : type((connection_type::type)0), id(""), compressed(true), checksum(false), encrypted(false) {
    type = (connection_type::type)0;

  }

  virtual ~connection() throw();
  connection_type::type type;
  std::string id;
  std::map<std::string, std::string>  options;
  bool compressed;
  bool checksum;
  bool encrypted;
  _detail detail;

  _connection__isset __isset;

  void __set_type(const connection_type::type val);

  void __set_id(const std::string& val);

  void __set_options(const std::map<std::string, std::string> & val);

  void __set_compressed(const bool val);

  void __set_checksum(const bool val);

  void __set_encrypted(const bool val);

  void __set_detail(const _detail& val);

  bool operator == (const connection & rhs) const
  {
    if (__isset.type != rhs.__isset.type)
      return false;
    else if (__isset.type && !(type == rhs.type))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.options != rhs.__isset.options)
      return false;
    else if (__isset.options && !(options == rhs.options))
      return false;
    if (__isset.compressed != rhs.__isset.compressed)
      return false;
    else if (__isset.compressed && !(compressed == rhs.compressed))
      return false;
    if (__isset.checksum != rhs.__isset.checksum)
      return false;
    else if (__isset.checksum && !(checksum == rhs.checksum))
      return false;
    if (__isset.encrypted != rhs.__isset.encrypted)
      return false;
    else if (__isset.encrypted && !(encrypted == rhs.encrypted))
      return false;
    if (__isset.detail != rhs.__isset.detail)
      return false;
    else if (__isset.detail && !(detail == rhs.detail))
      return false;
    return true;
  }
  bool operator != (const connection &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const connection & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(connection &a, connection &b);

inline std::ostream& operator<<(std::ostream& out, const connection& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _image_map_info__isset {
  _image_map_info__isset() : image(true), base_image(true), connection_ids(false) {}
  bool image :1;
  bool base_image :1;
  bool connection_ids :1;
} _image_map_info__isset;

class image_map_info : public virtual ::apache::thrift::TBase {
 public:

  image_map_info(const image_map_info&);
  image_map_info& operator=(const image_map_info&);
  image_map_info() : image(""), base_image("") {
  }

  virtual ~image_map_info() throw();
  std::string image;
  std::string base_image;
  std::set<std::string>  connection_ids;

  _image_map_info__isset __isset;

  void __set_image(const std::string& val);

  void __set_base_image(const std::string& val);

  void __set_connection_ids(const std::set<std::string> & val);

  bool operator == (const image_map_info & rhs) const
  {
    if (__isset.image != rhs.__isset.image)
      return false;
    else if (__isset.image && !(image == rhs.image))
      return false;
    if (__isset.base_image != rhs.__isset.base_image)
      return false;
    else if (__isset.base_image && !(base_image == rhs.base_image))
      return false;
    if (__isset.connection_ids != rhs.__isset.connection_ids)
      return false;
    else if (__isset.connection_ids && !(connection_ids == rhs.connection_ids))
      return false;
    return true;
  }
  bool operator != (const image_map_info &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const image_map_info & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(image_map_info &a, image_map_info &b);

inline std::ostream& operator<<(std::ostream& out, const image_map_info& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _create_image_info__isset {
  _create_image_info__isset() : name(true), base(true), parent(true), connection_ids(false), size(true), block_size(true), checksum_verify(true), comment(true), version(true), compressed(true), checksum(true), cdr(true), mode(true) {}
  bool name :1;
  bool base :1;
  bool parent :1;
  bool connection_ids :1;
  bool size :1;
  bool block_size :1;
  bool checksum_verify :1;
  bool comment :1;
  bool version :1;
  bool compressed :1;
  bool checksum :1;
  bool cdr :1;
  bool mode :1;
} _create_image_info__isset;

class create_image_info : public virtual ::apache::thrift::TBase {
 public:

  create_image_info(const create_image_info&);
  create_image_info& operator=(const create_image_info&);
  create_image_info() : name(""), base(""), parent(""), size(0LL), block_size(0), checksum_verify(true), comment(""), version((create_image_option::type)0), compressed(true), checksum(false), cdr(false), mode(2) {
    version = (create_image_option::type)0;

  }

  virtual ~create_image_info() throw();
  std::string name;
  std::string base;
  std::string parent;
  std::set<std::string>  connection_ids;
  int64_t size;
  int32_t block_size;
  bool checksum_verify;
  std::string comment;
  create_image_option::type version;
  bool compressed;
  bool checksum;
  bool cdr;
  int8_t mode;

  _create_image_info__isset __isset;

  void __set_name(const std::string& val);

  void __set_base(const std::string& val);

  void __set_parent(const std::string& val);

  void __set_connection_ids(const std::set<std::string> & val);

  void __set_size(const int64_t val);

  void __set_block_size(const int32_t val);

  void __set_checksum_verify(const bool val);

  void __set_comment(const std::string& val);

  void __set_version(const create_image_option::type val);

  void __set_compressed(const bool val);

  void __set_checksum(const bool val);

  void __set_cdr(const bool val);

  void __set_mode(const int8_t val);

  bool operator == (const create_image_info & rhs) const
  {
    if (__isset.name != rhs.__isset.name)
      return false;
    else if (__isset.name && !(name == rhs.name))
      return false;
    if (__isset.base != rhs.__isset.base)
      return false;
    else if (__isset.base && !(base == rhs.base))
      return false;
    if (__isset.parent != rhs.__isset.parent)
      return false;
    else if (__isset.parent && !(parent == rhs.parent))
      return false;
    if (__isset.connection_ids != rhs.__isset.connection_ids)
      return false;
    else if (__isset.connection_ids && !(connection_ids == rhs.connection_ids))
      return false;
    if (__isset.size != rhs.__isset.size)
      return false;
    else if (__isset.size && !(size == rhs.size))
      return false;
    if (__isset.block_size != rhs.__isset.block_size)
      return false;
    else if (__isset.block_size && !(block_size == rhs.block_size))
      return false;
    if (__isset.checksum_verify != rhs.__isset.checksum_verify)
      return false;
    else if (__isset.checksum_verify && !(checksum_verify == rhs.checksum_verify))
      return false;
    if (__isset.comment != rhs.__isset.comment)
      return false;
    else if (__isset.comment && !(comment == rhs.comment))
      return false;
    if (__isset.version != rhs.__isset.version)
      return false;
    else if (__isset.version && !(version == rhs.version))
      return false;
    if (__isset.compressed != rhs.__isset.compressed)
      return false;
    else if (__isset.compressed && !(compressed == rhs.compressed))
      return false;
    if (__isset.checksum != rhs.__isset.checksum)
      return false;
    else if (__isset.checksum && !(checksum == rhs.checksum))
      return false;
    if (__isset.cdr != rhs.__isset.cdr)
      return false;
    else if (__isset.cdr && !(cdr == rhs.cdr))
      return false;
    if (__isset.mode != rhs.__isset.mode)
      return false;
    else if (__isset.mode && !(mode == rhs.mode))
      return false;
    return true;
  }
  bool operator != (const create_image_info &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const create_image_info & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(create_image_info &a, create_image_info &b);

inline std::ostream& operator<<(std::ostream& out, const create_image_info& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _loader_job_detail__isset {
  _loader_job_detail__isset() : replica_id(true), id(true), state(true), created_time(true), updated_time(true), progress(false), histories(false), connection_id(false), data(false), snapshot_id(true), duplicated_data(false), transport_data(false) {}
  bool replica_id :1;
  bool id :1;
  bool state :1;
  bool created_time :1;
  bool updated_time :1;
  bool progress :1;
  bool histories :1;
  bool connection_id :1;
  bool data :1;
  bool snapshot_id :1;
  bool duplicated_data :1;
  bool transport_data :1;
} _loader_job_detail__isset;

class loader_job_detail : public virtual ::apache::thrift::TBase {
 public:

  loader_job_detail(const loader_job_detail&);
  loader_job_detail& operator=(const loader_job_detail&);
  loader_job_detail() : replica_id(""), id(""), state((job_state::type)1), created_time(""), updated_time(""), connection_id(), snapshot_id("") {
    state = (job_state::type)1;

  }

  virtual ~loader_job_detail() throw();
  std::string replica_id;
  std::string id;
  job_state::type state;
  std::string created_time;
  std::string updated_time;
  std::map<std::string, int64_t>  progress;
  std::vector<job_history>  histories;
  std::string connection_id;
  std::map<std::string, int64_t>  data;
  std::string snapshot_id;
  std::map<std::string, int64_t>  duplicated_data;
  std::map<std::string, int64_t>  transport_data;

  _loader_job_detail__isset __isset;

  void __set_replica_id(const std::string& val);

  void __set_id(const std::string& val);

  void __set_state(const job_state::type val);

  void __set_created_time(const std::string& val);

  void __set_updated_time(const std::string& val);

  void __set_progress(const std::map<std::string, int64_t> & val);

  void __set_histories(const std::vector<job_history> & val);

  void __set_connection_id(const std::string& val);

  void __set_data(const std::map<std::string, int64_t> & val);

  void __set_snapshot_id(const std::string& val);

  void __set_duplicated_data(const std::map<std::string, int64_t> & val);

  void __set_transport_data(const std::map<std::string, int64_t> & val);

  bool operator == (const loader_job_detail & rhs) const
  {
    if (__isset.replica_id != rhs.__isset.replica_id)
      return false;
    else if (__isset.replica_id && !(replica_id == rhs.replica_id))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.state != rhs.__isset.state)
      return false;
    else if (__isset.state && !(state == rhs.state))
      return false;
    if (__isset.created_time != rhs.__isset.created_time)
      return false;
    else if (__isset.created_time && !(created_time == rhs.created_time))
      return false;
    if (__isset.updated_time != rhs.__isset.updated_time)
      return false;
    else if (__isset.updated_time && !(updated_time == rhs.updated_time))
      return false;
    if (__isset.progress != rhs.__isset.progress)
      return false;
    else if (__isset.progress && !(progress == rhs.progress))
      return false;
    if (__isset.histories != rhs.__isset.histories)
      return false;
    else if (__isset.histories && !(histories == rhs.histories))
      return false;
    if (__isset.connection_id != rhs.__isset.connection_id)
      return false;
    else if (__isset.connection_id && !(connection_id == rhs.connection_id))
      return false;
    if (__isset.data != rhs.__isset.data)
      return false;
    else if (__isset.data && !(data == rhs.data))
      return false;
    if (__isset.snapshot_id != rhs.__isset.snapshot_id)
      return false;
    else if (__isset.snapshot_id && !(snapshot_id == rhs.snapshot_id))
      return false;
    if (__isset.duplicated_data != rhs.__isset.duplicated_data)
      return false;
    else if (__isset.duplicated_data && !(duplicated_data == rhs.duplicated_data))
      return false;
    if (__isset.transport_data != rhs.__isset.transport_data)
      return false;
    else if (__isset.transport_data && !(transport_data == rhs.transport_data))
      return false;
    return true;
  }
  bool operator != (const loader_job_detail &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const loader_job_detail & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(loader_job_detail &a, loader_job_detail &b);

inline std::ostream& operator<<(std::ostream& out, const loader_job_detail& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _upload_progress__isset {
  _upload_progress__isset() : size(true), progress(true), vhd_size(true), upload_id(true), completed(true) {}
  bool size :1;
  bool progress :1;
  bool vhd_size :1;
  bool upload_id :1;
  bool completed :1;
} _upload_progress__isset;

class upload_progress : public virtual ::apache::thrift::TBase {
 public:

  upload_progress(const upload_progress&);
  upload_progress& operator=(const upload_progress&);
  upload_progress() : size(0LL), progress(0LL), vhd_size(0LL), upload_id(""), completed(false) {
  }

  virtual ~upload_progress() throw();
  int64_t size;
  int64_t progress;
  int64_t vhd_size;
  std::string upload_id;
  bool completed;

  _upload_progress__isset __isset;

  void __set_size(const int64_t val);

  void __set_progress(const int64_t val);

  void __set_vhd_size(const int64_t val);

  void __set_upload_id(const std::string& val);

  void __set_completed(const bool val);

  bool operator == (const upload_progress & rhs) const
  {
    if (__isset.size != rhs.__isset.size)
      return false;
    else if (__isset.size && !(size == rhs.size))
      return false;
    if (__isset.progress != rhs.__isset.progress)
      return false;
    else if (__isset.progress && !(progress == rhs.progress))
      return false;
    if (__isset.vhd_size != rhs.__isset.vhd_size)
      return false;
    else if (__isset.vhd_size && !(vhd_size == rhs.vhd_size))
      return false;
    if (__isset.upload_id != rhs.__isset.upload_id)
      return false;
    else if (__isset.upload_id && !(upload_id == rhs.upload_id))
      return false;
    if (__isset.completed != rhs.__isset.completed)
      return false;
    else if (__isset.completed && !(completed == rhs.completed))
      return false;
    return true;
  }
  bool operator != (const upload_progress &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const upload_progress & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(upload_progress &a, upload_progress &b);

inline std::ostream& operator<<(std::ostream& out, const upload_progress& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _launcher_job_detail__isset {
  _launcher_job_detail__isset() : replica_id(true), id(true), state(true), created_time(true), updated_time(true), boot_disk(true), histories(false), is_error(true), is_windows_update(true), platform(true), architecture(true), size(true), progress(true), vhd_size(true), upload_id(true), host_name(false), vhd_upload_progress(false) {}
  bool replica_id :1;
  bool id :1;
  bool state :1;
  bool created_time :1;
  bool updated_time :1;
  bool boot_disk :1;
  bool histories :1;
  bool is_error :1;
  bool is_windows_update :1;
  bool platform :1;
  bool architecture :1;
  bool size :1;
  bool progress :1;
  bool vhd_size :1;
  bool upload_id :1;
  bool host_name :1;
  bool vhd_upload_progress :1;
} _launcher_job_detail__isset;

class launcher_job_detail : public virtual ::apache::thrift::TBase {
 public:

  launcher_job_detail(const launcher_job_detail&);
  launcher_job_detail& operator=(const launcher_job_detail&);
  launcher_job_detail() : replica_id(""), id(""), state((job_state::type)1), created_time(""), updated_time(""), boot_disk(""), is_error(false), is_windows_update(false), platform(""), architecture(""), size(0LL), progress(0LL), vhd_size(0LL), upload_id(""), host_name() {
    state = (job_state::type)1;

  }

  virtual ~launcher_job_detail() throw();
  std::string replica_id;
  std::string id;
  job_state::type state;
  std::string created_time;
  std::string updated_time;
  std::string boot_disk;
  std::vector<job_history>  histories;
  bool is_error;
  bool is_windows_update;
  std::string platform;
  std::string architecture;
  int64_t size;
  int64_t progress;
  int64_t vhd_size;
  std::string upload_id;
  std::string host_name;
  std::map<std::string, upload_progress>  vhd_upload_progress;

  _launcher_job_detail__isset __isset;

  void __set_replica_id(const std::string& val);

  void __set_id(const std::string& val);

  void __set_state(const job_state::type val);

  void __set_created_time(const std::string& val);

  void __set_updated_time(const std::string& val);

  void __set_boot_disk(const std::string& val);

  void __set_histories(const std::vector<job_history> & val);

  void __set_is_error(const bool val);

  void __set_is_windows_update(const bool val);

  void __set_platform(const std::string& val);

  void __set_architecture(const std::string& val);

  void __set_size(const int64_t val);

  void __set_progress(const int64_t val);

  void __set_vhd_size(const int64_t val);

  void __set_upload_id(const std::string& val);

  void __set_host_name(const std::string& val);

  void __set_vhd_upload_progress(const std::map<std::string, upload_progress> & val);

  bool operator == (const launcher_job_detail & rhs) const
  {
    if (__isset.replica_id != rhs.__isset.replica_id)
      return false;
    else if (__isset.replica_id && !(replica_id == rhs.replica_id))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.state != rhs.__isset.state)
      return false;
    else if (__isset.state && !(state == rhs.state))
      return false;
    if (__isset.created_time != rhs.__isset.created_time)
      return false;
    else if (__isset.created_time && !(created_time == rhs.created_time))
      return false;
    if (__isset.updated_time != rhs.__isset.updated_time)
      return false;
    else if (__isset.updated_time && !(updated_time == rhs.updated_time))
      return false;
    if (__isset.boot_disk != rhs.__isset.boot_disk)
      return false;
    else if (__isset.boot_disk && !(boot_disk == rhs.boot_disk))
      return false;
    if (__isset.histories != rhs.__isset.histories)
      return false;
    else if (__isset.histories && !(histories == rhs.histories))
      return false;
    if (__isset.is_error != rhs.__isset.is_error)
      return false;
    else if (__isset.is_error && !(is_error == rhs.is_error))
      return false;
    if (__isset.is_windows_update != rhs.__isset.is_windows_update)
      return false;
    else if (__isset.is_windows_update && !(is_windows_update == rhs.is_windows_update))
      return false;
    if (__isset.platform != rhs.__isset.platform)
      return false;
    else if (__isset.platform && !(platform == rhs.platform))
      return false;
    if (__isset.architecture != rhs.__isset.architecture)
      return false;
    else if (__isset.architecture && !(architecture == rhs.architecture))
      return false;
    if (__isset.size != rhs.__isset.size)
      return false;
    else if (__isset.size && !(size == rhs.size))
      return false;
    if (__isset.progress != rhs.__isset.progress)
      return false;
    else if (__isset.progress && !(progress == rhs.progress))
      return false;
    if (__isset.vhd_size != rhs.__isset.vhd_size)
      return false;
    else if (__isset.vhd_size && !(vhd_size == rhs.vhd_size))
      return false;
    if (__isset.upload_id != rhs.__isset.upload_id)
      return false;
    else if (__isset.upload_id && !(upload_id == rhs.upload_id))
      return false;
    if (__isset.host_name != rhs.__isset.host_name)
      return false;
    else if (__isset.host_name && !(host_name == rhs.host_name))
      return false;
    if (__isset.vhd_upload_progress != rhs.__isset.vhd_upload_progress)
      return false;
    else if (__isset.vhd_upload_progress && !(vhd_upload_progress == rhs.vhd_upload_progress))
      return false;
    return true;
  }
  bool operator != (const launcher_job_detail &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const launcher_job_detail & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(launcher_job_detail &a, launcher_job_detail &b);

inline std::ostream& operator<<(std::ostream& out, const launcher_job_detail& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _job_detail__isset {
  _job_detail__isset() : scheduler(false), launcher(false), loader(false) {}
  bool scheduler :1;
  bool launcher :1;
  bool loader :1;
} _job_detail__isset;

class job_detail : public virtual ::apache::thrift::TBase {
 public:

  job_detail(const job_detail&);
  job_detail& operator=(const job_detail&);
  job_detail() {
  }

  virtual ~job_detail() throw();
  replica_job_detail scheduler;
  launcher_job_detail launcher;
  loader_job_detail loader;

  _job_detail__isset __isset;

  void __set_scheduler(const replica_job_detail& val);

  void __set_launcher(const launcher_job_detail& val);

  void __set_loader(const loader_job_detail& val);

  bool operator == (const job_detail & rhs) const
  {
    if (__isset.scheduler != rhs.__isset.scheduler)
      return false;
    else if (__isset.scheduler && !(scheduler == rhs.scheduler))
      return false;
    if (__isset.launcher != rhs.__isset.launcher)
      return false;
    else if (__isset.launcher && !(launcher == rhs.launcher))
      return false;
    if (__isset.loader != rhs.__isset.loader)
      return false;
    else if (__isset.loader && !(loader == rhs.loader))
      return false;
    return true;
  }
  bool operator != (const job_detail &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const job_detail & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(job_detail &a, job_detail &b);

inline std::ostream& operator<<(std::ostream& out, const job_detail& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _replica_job_create_detail__isset {
  _replica_job_create_detail__isset() : host(true), addr(false), username(true), password(true), type(false), virtual_machine_id(true), disks(false), targets(false), carriers(false), full_replicas(false), disk_ids(false), cbt_info(true), snapshot_info(true), checksum_verify(true), always_retry(true), timeout(true), is_encrypted(true), is_paused(true), worker_thread_number(true), block_mode_enable(true), file_system_filter_enable(true), min_transport_size(true), full_min_transport_size(true), is_full_replica(true), buffer_size(true), is_compressed(true), is_checksum(true), time(true), priority_carrier(false), is_only_single_system_disk(true), is_continuous_data_replication(true), pre_snapshot_script(false), post_snapshot_script(false), is_compressed_by_packer(true) {}
  bool host :1;
  bool addr :1;
  bool username :1;
  bool password :1;
  bool type :1;
  bool virtual_machine_id :1;
  bool disks :1;
  bool targets :1;
  bool carriers :1;
  bool full_replicas :1;
  bool disk_ids :1;
  bool cbt_info :1;
  bool snapshot_info :1;
  bool checksum_verify :1;
  bool always_retry :1;
  bool timeout :1;
  bool is_encrypted :1;
  bool is_paused :1;
  bool worker_thread_number :1;
  bool block_mode_enable :1;
  bool file_system_filter_enable :1;
  bool min_transport_size :1;
  bool full_min_transport_size :1;
  bool is_full_replica :1;
  bool buffer_size :1;
  bool is_compressed :1;
  bool is_checksum :1;
  bool time :1;
  bool priority_carrier :1;
  bool is_only_single_system_disk :1;
  bool is_continuous_data_replication :1;
  bool pre_snapshot_script :1;
  bool post_snapshot_script :1;
  bool is_compressed_by_packer :1;
} _replica_job_create_detail__isset;

class replica_job_create_detail : public virtual ::apache::thrift::TBase {
 public:

  replica_job_create_detail(const replica_job_create_detail&);
  replica_job_create_detail& operator=(const replica_job_create_detail&);
  replica_job_create_detail() : host(""), username(""), password(""), type((job_type::type)0), virtual_machine_id(""), cbt_info(""), snapshot_info(""), checksum_verify(true), always_retry(false), timeout(300), is_encrypted(false), is_paused(false), worker_thread_number(0), block_mode_enable(false), file_system_filter_enable(true), min_transport_size(0), full_min_transport_size(0), is_full_replica(false), buffer_size(0), is_compressed(true), is_checksum(false), time(""), is_only_single_system_disk(false), is_continuous_data_replication(false), pre_snapshot_script(), post_snapshot_script(), is_compressed_by_packer(false) {
  }

  virtual ~replica_job_create_detail() throw();
  std::string host;
  std::set<std::string>  addr;
  std::string username;
  std::string password;
  job_type::type type;
  std::string virtual_machine_id;
  std::set<std::string>  disks;
  std::map<std::string, std::string>  targets;
  std::map<std::string, std::set<std::string> >  carriers;
  std::set<std::string>  full_replicas;
  std::map<std::string, std::string>  disk_ids;
  std::string cbt_info;
  std::string snapshot_info;
  bool checksum_verify;
  bool always_retry;
  int32_t timeout;
  bool is_encrypted;
  bool is_paused;
  int32_t worker_thread_number;
  bool block_mode_enable;
  bool file_system_filter_enable;
  int32_t min_transport_size;
  int32_t full_min_transport_size;
  bool is_full_replica;
  int32_t buffer_size;
  bool is_compressed;
  bool is_checksum;
  std::string time;
  std::map<std::string, std::string>  priority_carrier;
  bool is_only_single_system_disk;
  bool is_continuous_data_replication;
  std::string pre_snapshot_script;
  std::string post_snapshot_script;
  bool is_compressed_by_packer;

  _replica_job_create_detail__isset __isset;

  void __set_host(const std::string& val);

  void __set_addr(const std::set<std::string> & val);

  void __set_username(const std::string& val);

  void __set_password(const std::string& val);

  void __set_type(const job_type::type val);

  void __set_virtual_machine_id(const std::string& val);

  void __set_disks(const std::set<std::string> & val);

  void __set_targets(const std::map<std::string, std::string> & val);

  void __set_carriers(const std::map<std::string, std::set<std::string> > & val);

  void __set_full_replicas(const std::set<std::string> & val);

  void __set_disk_ids(const std::map<std::string, std::string> & val);

  void __set_cbt_info(const std::string& val);

  void __set_snapshot_info(const std::string& val);

  void __set_checksum_verify(const bool val);

  void __set_always_retry(const bool val);

  void __set_timeout(const int32_t val);

  void __set_is_encrypted(const bool val);

  void __set_is_paused(const bool val);

  void __set_worker_thread_number(const int32_t val);

  void __set_block_mode_enable(const bool val);

  void __set_file_system_filter_enable(const bool val);

  void __set_min_transport_size(const int32_t val);

  void __set_full_min_transport_size(const int32_t val);

  void __set_is_full_replica(const bool val);

  void __set_buffer_size(const int32_t val);

  void __set_is_compressed(const bool val);

  void __set_is_checksum(const bool val);

  void __set_time(const std::string& val);

  void __set_priority_carrier(const std::map<std::string, std::string> & val);

  void __set_is_only_single_system_disk(const bool val);

  void __set_is_continuous_data_replication(const bool val);

  void __set_pre_snapshot_script(const std::string& val);

  void __set_post_snapshot_script(const std::string& val);

  void __set_is_compressed_by_packer(const bool val);

  bool operator == (const replica_job_create_detail & rhs) const
  {
    if (__isset.host != rhs.__isset.host)
      return false;
    else if (__isset.host && !(host == rhs.host))
      return false;
    if (__isset.addr != rhs.__isset.addr)
      return false;
    else if (__isset.addr && !(addr == rhs.addr))
      return false;
    if (__isset.username != rhs.__isset.username)
      return false;
    else if (__isset.username && !(username == rhs.username))
      return false;
    if (__isset.password != rhs.__isset.password)
      return false;
    else if (__isset.password && !(password == rhs.password))
      return false;
    if (__isset.type != rhs.__isset.type)
      return false;
    else if (__isset.type && !(type == rhs.type))
      return false;
    if (__isset.virtual_machine_id != rhs.__isset.virtual_machine_id)
      return false;
    else if (__isset.virtual_machine_id && !(virtual_machine_id == rhs.virtual_machine_id))
      return false;
    if (__isset.disks != rhs.__isset.disks)
      return false;
    else if (__isset.disks && !(disks == rhs.disks))
      return false;
    if (__isset.targets != rhs.__isset.targets)
      return false;
    else if (__isset.targets && !(targets == rhs.targets))
      return false;
    if (__isset.carriers != rhs.__isset.carriers)
      return false;
    else if (__isset.carriers && !(carriers == rhs.carriers))
      return false;
    if (__isset.full_replicas != rhs.__isset.full_replicas)
      return false;
    else if (__isset.full_replicas && !(full_replicas == rhs.full_replicas))
      return false;
    if (__isset.disk_ids != rhs.__isset.disk_ids)
      return false;
    else if (__isset.disk_ids && !(disk_ids == rhs.disk_ids))
      return false;
    if (__isset.cbt_info != rhs.__isset.cbt_info)
      return false;
    else if (__isset.cbt_info && !(cbt_info == rhs.cbt_info))
      return false;
    if (__isset.snapshot_info != rhs.__isset.snapshot_info)
      return false;
    else if (__isset.snapshot_info && !(snapshot_info == rhs.snapshot_info))
      return false;
    if (__isset.checksum_verify != rhs.__isset.checksum_verify)
      return false;
    else if (__isset.checksum_verify && !(checksum_verify == rhs.checksum_verify))
      return false;
    if (__isset.always_retry != rhs.__isset.always_retry)
      return false;
    else if (__isset.always_retry && !(always_retry == rhs.always_retry))
      return false;
    if (__isset.timeout != rhs.__isset.timeout)
      return false;
    else if (__isset.timeout && !(timeout == rhs.timeout))
      return false;
    if (__isset.is_encrypted != rhs.__isset.is_encrypted)
      return false;
    else if (__isset.is_encrypted && !(is_encrypted == rhs.is_encrypted))
      return false;
    if (__isset.is_paused != rhs.__isset.is_paused)
      return false;
    else if (__isset.is_paused && !(is_paused == rhs.is_paused))
      return false;
    if (__isset.worker_thread_number != rhs.__isset.worker_thread_number)
      return false;
    else if (__isset.worker_thread_number && !(worker_thread_number == rhs.worker_thread_number))
      return false;
    if (__isset.block_mode_enable != rhs.__isset.block_mode_enable)
      return false;
    else if (__isset.block_mode_enable && !(block_mode_enable == rhs.block_mode_enable))
      return false;
    if (__isset.file_system_filter_enable != rhs.__isset.file_system_filter_enable)
      return false;
    else if (__isset.file_system_filter_enable && !(file_system_filter_enable == rhs.file_system_filter_enable))
      return false;
    if (__isset.min_transport_size != rhs.__isset.min_transport_size)
      return false;
    else if (__isset.min_transport_size && !(min_transport_size == rhs.min_transport_size))
      return false;
    if (__isset.full_min_transport_size != rhs.__isset.full_min_transport_size)
      return false;
    else if (__isset.full_min_transport_size && !(full_min_transport_size == rhs.full_min_transport_size))
      return false;
    if (__isset.is_full_replica != rhs.__isset.is_full_replica)
      return false;
    else if (__isset.is_full_replica && !(is_full_replica == rhs.is_full_replica))
      return false;
    if (__isset.buffer_size != rhs.__isset.buffer_size)
      return false;
    else if (__isset.buffer_size && !(buffer_size == rhs.buffer_size))
      return false;
    if (__isset.is_compressed != rhs.__isset.is_compressed)
      return false;
    else if (__isset.is_compressed && !(is_compressed == rhs.is_compressed))
      return false;
    if (__isset.is_checksum != rhs.__isset.is_checksum)
      return false;
    else if (__isset.is_checksum && !(is_checksum == rhs.is_checksum))
      return false;
    if (__isset.time != rhs.__isset.time)
      return false;
    else if (__isset.time && !(time == rhs.time))
      return false;
    if (__isset.priority_carrier != rhs.__isset.priority_carrier)
      return false;
    else if (__isset.priority_carrier && !(priority_carrier == rhs.priority_carrier))
      return false;
    if (__isset.is_only_single_system_disk != rhs.__isset.is_only_single_system_disk)
      return false;
    else if (__isset.is_only_single_system_disk && !(is_only_single_system_disk == rhs.is_only_single_system_disk))
      return false;
    if (__isset.is_continuous_data_replication != rhs.__isset.is_continuous_data_replication)
      return false;
    else if (__isset.is_continuous_data_replication && !(is_continuous_data_replication == rhs.is_continuous_data_replication))
      return false;
    if (__isset.pre_snapshot_script != rhs.__isset.pre_snapshot_script)
      return false;
    else if (__isset.pre_snapshot_script && !(pre_snapshot_script == rhs.pre_snapshot_script))
      return false;
    if (__isset.post_snapshot_script != rhs.__isset.post_snapshot_script)
      return false;
    else if (__isset.post_snapshot_script && !(post_snapshot_script == rhs.post_snapshot_script))
      return false;
    if (__isset.is_compressed_by_packer != rhs.__isset.is_compressed_by_packer)
      return false;
    else if (__isset.is_compressed_by_packer && !(is_compressed_by_packer == rhs.is_compressed_by_packer))
      return false;
    return true;
  }
  bool operator != (const replica_job_create_detail &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const replica_job_create_detail & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(replica_job_create_detail &a, replica_job_create_detail &b);

inline std::ostream& operator<<(std::ostream& out, const replica_job_create_detail& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _aliyun_options__isset {
  _aliyun_options__isset() : access_key(true), secret_key(true), objectname(true), bucketname(true), region(true), max_size(true), file_system_filter_enable(true), number_of_upload_threads(true), disks_object_name_mapping(false) {}
  bool access_key :1;
  bool secret_key :1;
  bool objectname :1;
  bool bucketname :1;
  bool region :1;
  bool max_size :1;
  bool file_system_filter_enable :1;
  bool number_of_upload_threads :1;
  bool disks_object_name_mapping :1;
} _aliyun_options__isset;

class aliyun_options : public virtual ::apache::thrift::TBase {
 public:

  aliyun_options(const aliyun_options&);
  aliyun_options& operator=(const aliyun_options&);
  aliyun_options() : access_key(""), secret_key(""), objectname(""), bucketname(""), region(""), max_size(500), file_system_filter_enable(true), number_of_upload_threads(0) {
  }

  virtual ~aliyun_options() throw();
  std::string access_key;
  std::string secret_key;
  std::string objectname;
  std::string bucketname;
  std::string region;
  int32_t max_size;
  bool file_system_filter_enable;
  int16_t number_of_upload_threads;
  std::map<std::string, std::string>  disks_object_name_mapping;

  _aliyun_options__isset __isset;

  void __set_access_key(const std::string& val);

  void __set_secret_key(const std::string& val);

  void __set_objectname(const std::string& val);

  void __set_bucketname(const std::string& val);

  void __set_region(const std::string& val);

  void __set_max_size(const int32_t val);

  void __set_file_system_filter_enable(const bool val);

  void __set_number_of_upload_threads(const int16_t val);

  void __set_disks_object_name_mapping(const std::map<std::string, std::string> & val);

  bool operator == (const aliyun_options & rhs) const
  {
    if (__isset.access_key != rhs.__isset.access_key)
      return false;
    else if (__isset.access_key && !(access_key == rhs.access_key))
      return false;
    if (__isset.secret_key != rhs.__isset.secret_key)
      return false;
    else if (__isset.secret_key && !(secret_key == rhs.secret_key))
      return false;
    if (__isset.objectname != rhs.__isset.objectname)
      return false;
    else if (__isset.objectname && !(objectname == rhs.objectname))
      return false;
    if (__isset.bucketname != rhs.__isset.bucketname)
      return false;
    else if (__isset.bucketname && !(bucketname == rhs.bucketname))
      return false;
    if (__isset.region != rhs.__isset.region)
      return false;
    else if (__isset.region && !(region == rhs.region))
      return false;
    if (__isset.max_size != rhs.__isset.max_size)
      return false;
    else if (__isset.max_size && !(max_size == rhs.max_size))
      return false;
    if (__isset.file_system_filter_enable != rhs.__isset.file_system_filter_enable)
      return false;
    else if (__isset.file_system_filter_enable && !(file_system_filter_enable == rhs.file_system_filter_enable))
      return false;
    if (__isset.number_of_upload_threads != rhs.__isset.number_of_upload_threads)
      return false;
    else if (__isset.number_of_upload_threads && !(number_of_upload_threads == rhs.number_of_upload_threads))
      return false;
    if (__isset.disks_object_name_mapping != rhs.__isset.disks_object_name_mapping)
      return false;
    else if (__isset.disks_object_name_mapping && !(disks_object_name_mapping == rhs.disks_object_name_mapping))
      return false;
    return true;
  }
  bool operator != (const aliyun_options &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const aliyun_options & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(aliyun_options &a, aliyun_options &b);

inline std::ostream& operator<<(std::ostream& out, const aliyun_options& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _tencent_options__isset {
  _tencent_options__isset() : access_key(true), secret_key(true), objectname(true), bucketname(true), region(true), max_size(true), file_system_filter_enable(true), number_of_upload_threads(true), disks_object_name_mapping(false) {}
  bool access_key :1;
  bool secret_key :1;
  bool objectname :1;
  bool bucketname :1;
  bool region :1;
  bool max_size :1;
  bool file_system_filter_enable :1;
  bool number_of_upload_threads :1;
  bool disks_object_name_mapping :1;
} _tencent_options__isset;

class tencent_options : public virtual ::apache::thrift::TBase {
 public:

  tencent_options(const tencent_options&);
  tencent_options& operator=(const tencent_options&);
  tencent_options() : access_key(""), secret_key(""), objectname(""), bucketname(""), region(""), max_size(500), file_system_filter_enable(true), number_of_upload_threads(0) {
  }

  virtual ~tencent_options() throw();
  std::string access_key;
  std::string secret_key;
  std::string objectname;
  std::string bucketname;
  std::string region;
  int32_t max_size;
  bool file_system_filter_enable;
  int16_t number_of_upload_threads;
  std::map<std::string, std::string>  disks_object_name_mapping;

  _tencent_options__isset __isset;

  void __set_access_key(const std::string& val);

  void __set_secret_key(const std::string& val);

  void __set_objectname(const std::string& val);

  void __set_bucketname(const std::string& val);

  void __set_region(const std::string& val);

  void __set_max_size(const int32_t val);

  void __set_file_system_filter_enable(const bool val);

  void __set_number_of_upload_threads(const int16_t val);

  void __set_disks_object_name_mapping(const std::map<std::string, std::string> & val);

  bool operator == (const tencent_options & rhs) const
  {
    if (__isset.access_key != rhs.__isset.access_key)
      return false;
    else if (__isset.access_key && !(access_key == rhs.access_key))
      return false;
    if (__isset.secret_key != rhs.__isset.secret_key)
      return false;
    else if (__isset.secret_key && !(secret_key == rhs.secret_key))
      return false;
    if (__isset.objectname != rhs.__isset.objectname)
      return false;
    else if (__isset.objectname && !(objectname == rhs.objectname))
      return false;
    if (__isset.bucketname != rhs.__isset.bucketname)
      return false;
    else if (__isset.bucketname && !(bucketname == rhs.bucketname))
      return false;
    if (__isset.region != rhs.__isset.region)
      return false;
    else if (__isset.region && !(region == rhs.region))
      return false;
    if (__isset.max_size != rhs.__isset.max_size)
      return false;
    else if (__isset.max_size && !(max_size == rhs.max_size))
      return false;
    if (__isset.file_system_filter_enable != rhs.__isset.file_system_filter_enable)
      return false;
    else if (__isset.file_system_filter_enable && !(file_system_filter_enable == rhs.file_system_filter_enable))
      return false;
    if (__isset.number_of_upload_threads != rhs.__isset.number_of_upload_threads)
      return false;
    else if (__isset.number_of_upload_threads && !(number_of_upload_threads == rhs.number_of_upload_threads))
      return false;
    if (__isset.disks_object_name_mapping != rhs.__isset.disks_object_name_mapping)
      return false;
    else if (__isset.disks_object_name_mapping && !(disks_object_name_mapping == rhs.disks_object_name_mapping))
      return false;
    return true;
  }
  bool operator != (const tencent_options &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const tencent_options & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(tencent_options &a, tencent_options &b);

inline std::ostream& operator<<(std::ostream& out, const tencent_options& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _extra_options__isset {
  _extra_options__isset() : aliyun(false), tencent(false) {}
  bool aliyun :1;
  bool tencent :1;
} _extra_options__isset;

class extra_options : public virtual ::apache::thrift::TBase {
 public:

  extra_options(const extra_options&);
  extra_options& operator=(const extra_options&);
  extra_options() {
  }

  virtual ~extra_options() throw();
  aliyun_options aliyun;
  tencent_options tencent;

  _extra_options__isset __isset;

  void __set_aliyun(const aliyun_options& val);

  void __set_tencent(const tencent_options& val);

  bool operator == (const extra_options & rhs) const
  {
    if (__isset.aliyun != rhs.__isset.aliyun)
      return false;
    else if (__isset.aliyun && !(aliyun == rhs.aliyun))
      return false;
    if (__isset.tencent != rhs.__isset.tencent)
      return false;
    else if (__isset.tencent && !(tencent == rhs.tencent))
      return false;
    return true;
  }
  bool operator != (const extra_options &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const extra_options & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(extra_options &a, extra_options &b);

inline std::ostream& operator<<(std::ostream& out, const extra_options& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _vhd_snapshot__isset {
  _vhd_snapshot__isset() : id(true), datetime(true), name(true) {}
  bool id :1;
  bool datetime :1;
  bool name :1;
} _vhd_snapshot__isset;

class vhd_snapshot : public virtual ::apache::thrift::TBase {
 public:

  vhd_snapshot(const vhd_snapshot&);
  vhd_snapshot& operator=(const vhd_snapshot&);
  vhd_snapshot() : id(""), datetime(""), name("") {
  }

  virtual ~vhd_snapshot() throw();
  std::string id;
  std::string datetime;
  std::string name;

  _vhd_snapshot__isset __isset;

  void __set_id(const std::string& val);

  void __set_datetime(const std::string& val);

  void __set_name(const std::string& val);

  bool operator == (const vhd_snapshot & rhs) const
  {
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.datetime != rhs.__isset.datetime)
      return false;
    else if (__isset.datetime && !(datetime == rhs.datetime))
      return false;
    if (__isset.name != rhs.__isset.name)
      return false;
    else if (__isset.name && !(name == rhs.name))
      return false;
    return true;
  }
  bool operator != (const vhd_snapshot &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const vhd_snapshot & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(vhd_snapshot &a, vhd_snapshot &b);

inline std::ostream& operator<<(std::ostream& out, const vhd_snapshot& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _loader_job_create_detail__isset {
  _loader_job_create_detail__isset() : replica_id(true), disks_lun_mapping(false), snapshots(false), disks_snapshot_mapping(false), connection_id(false), block_mode_enable(true), purge_data(true), remap(true), detect_type(true), worker_thread_number(true), host_name(true), export_disk_type(true), export_path(true), disks_size_mapping(false), keep_alive(true), time(true), is_continuous_data_replication(true), azure_storage_connection_string(true) {}
  bool replica_id :1;
  bool disks_lun_mapping :1;
  bool snapshots :1;
  bool disks_snapshot_mapping :1;
  bool connection_id :1;
  bool block_mode_enable :1;
  bool purge_data :1;
  bool remap :1;
  bool detect_type :1;
  bool worker_thread_number :1;
  bool host_name :1;
  bool export_disk_type :1;
  bool export_path :1;
  bool disks_size_mapping :1;
  bool keep_alive :1;
  bool time :1;
  bool is_continuous_data_replication :1;
  bool azure_storage_connection_string :1;
} _loader_job_create_detail__isset;

class loader_job_create_detail : public virtual ::apache::thrift::TBase {
 public:

  loader_job_create_detail(const loader_job_create_detail&);
  loader_job_create_detail& operator=(const loader_job_create_detail&);
  loader_job_create_detail() : replica_id(""), connection_id(), block_mode_enable(false), purge_data(true), remap(false), detect_type((disk_detect_type::type)0), worker_thread_number(0), host_name(""), export_disk_type((virtual_disk_type::type)0), export_path(""), keep_alive(true), time(""), is_continuous_data_replication(false), azure_storage_connection_string("") {
    detect_type = (disk_detect_type::type)0;

    export_disk_type = (virtual_disk_type::type)0;

  }

  virtual ~loader_job_create_detail() throw();
  std::string replica_id;
  std::map<std::string, std::string>  disks_lun_mapping;
  std::vector<std::string>  snapshots;
  std::map<std::string, std::map<std::string, std::string> >  disks_snapshot_mapping;
  std::string connection_id;
  bool block_mode_enable;
  bool purge_data;
  bool remap;
  disk_detect_type::type detect_type;
  int32_t worker_thread_number;
  std::string host_name;
  virtual_disk_type::type export_disk_type;
  std::string export_path;
  std::map<std::string, int64_t>  disks_size_mapping;
  bool keep_alive;
  std::string time;
  bool is_continuous_data_replication;
  std::string azure_storage_connection_string;

  _loader_job_create_detail__isset __isset;

  void __set_replica_id(const std::string& val);

  void __set_disks_lun_mapping(const std::map<std::string, std::string> & val);

  void __set_snapshots(const std::vector<std::string> & val);

  void __set_disks_snapshot_mapping(const std::map<std::string, std::map<std::string, std::string> > & val);

  void __set_connection_id(const std::string& val);

  void __set_block_mode_enable(const bool val);

  void __set_purge_data(const bool val);

  void __set_remap(const bool val);

  void __set_detect_type(const disk_detect_type::type val);

  void __set_worker_thread_number(const int32_t val);

  void __set_host_name(const std::string& val);

  void __set_export_disk_type(const virtual_disk_type::type val);

  void __set_export_path(const std::string& val);

  void __set_disks_size_mapping(const std::map<std::string, int64_t> & val);

  void __set_keep_alive(const bool val);

  void __set_time(const std::string& val);

  void __set_is_continuous_data_replication(const bool val);

  void __set_azure_storage_connection_string(const std::string& val);

  bool operator == (const loader_job_create_detail & rhs) const
  {
    if (__isset.replica_id != rhs.__isset.replica_id)
      return false;
    else if (__isset.replica_id && !(replica_id == rhs.replica_id))
      return false;
    if (__isset.disks_lun_mapping != rhs.__isset.disks_lun_mapping)
      return false;
    else if (__isset.disks_lun_mapping && !(disks_lun_mapping == rhs.disks_lun_mapping))
      return false;
    if (__isset.snapshots != rhs.__isset.snapshots)
      return false;
    else if (__isset.snapshots && !(snapshots == rhs.snapshots))
      return false;
    if (__isset.disks_snapshot_mapping != rhs.__isset.disks_snapshot_mapping)
      return false;
    else if (__isset.disks_snapshot_mapping && !(disks_snapshot_mapping == rhs.disks_snapshot_mapping))
      return false;
    if (__isset.connection_id != rhs.__isset.connection_id)
      return false;
    else if (__isset.connection_id && !(connection_id == rhs.connection_id))
      return false;
    if (__isset.block_mode_enable != rhs.__isset.block_mode_enable)
      return false;
    else if (__isset.block_mode_enable && !(block_mode_enable == rhs.block_mode_enable))
      return false;
    if (__isset.purge_data != rhs.__isset.purge_data)
      return false;
    else if (__isset.purge_data && !(purge_data == rhs.purge_data))
      return false;
    if (__isset.remap != rhs.__isset.remap)
      return false;
    else if (__isset.remap && !(remap == rhs.remap))
      return false;
    if (__isset.detect_type != rhs.__isset.detect_type)
      return false;
    else if (__isset.detect_type && !(detect_type == rhs.detect_type))
      return false;
    if (__isset.worker_thread_number != rhs.__isset.worker_thread_number)
      return false;
    else if (__isset.worker_thread_number && !(worker_thread_number == rhs.worker_thread_number))
      return false;
    if (__isset.host_name != rhs.__isset.host_name)
      return false;
    else if (__isset.host_name && !(host_name == rhs.host_name))
      return false;
    if (__isset.export_disk_type != rhs.__isset.export_disk_type)
      return false;
    else if (__isset.export_disk_type && !(export_disk_type == rhs.export_disk_type))
      return false;
    if (__isset.export_path != rhs.__isset.export_path)
      return false;
    else if (__isset.export_path && !(export_path == rhs.export_path))
      return false;
    if (__isset.disks_size_mapping != rhs.__isset.disks_size_mapping)
      return false;
    else if (__isset.disks_size_mapping && !(disks_size_mapping == rhs.disks_size_mapping))
      return false;
    if (__isset.keep_alive != rhs.__isset.keep_alive)
      return false;
    else if (__isset.keep_alive && !(keep_alive == rhs.keep_alive))
      return false;
    if (__isset.time != rhs.__isset.time)
      return false;
    else if (__isset.time && !(time == rhs.time))
      return false;
    if (__isset.is_continuous_data_replication != rhs.__isset.is_continuous_data_replication)
      return false;
    else if (__isset.is_continuous_data_replication && !(is_continuous_data_replication == rhs.is_continuous_data_replication))
      return false;
    if (__isset.azure_storage_connection_string != rhs.__isset.azure_storage_connection_string)
      return false;
    else if (__isset.azure_storage_connection_string && !(azure_storage_connection_string == rhs.azure_storage_connection_string))
      return false;
    return true;
  }
  bool operator != (const loader_job_create_detail &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const loader_job_create_detail & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(loader_job_create_detail &a, loader_job_create_detail &b);

inline std::ostream& operator<<(std::ostream& out, const loader_job_create_detail& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _launcher_job_create_detail__isset {
  _launcher_job_create_detail__isset() : replica_id(true), disks_lun_mapping(false), is_sysvol_authoritative_restore(true), is_enable_debug(true), is_disable_machine_password_change(true), is_force_normal_boot(true), network_infos(false), config(false), gpt_to_mbr(true), detect_type(true), skip_system_injection(true), reboot_winpe(true), callbacks(false), callback_timeout(true), host_name(true), export_disk_type(true), export_path(true), target_type(true), os_type(true), is_update_ex(true), options_type(true), options(false), pre_scripts(false), post_scripts(false) {}
  bool replica_id :1;
  bool disks_lun_mapping :1;
  bool is_sysvol_authoritative_restore :1;
  bool is_enable_debug :1;
  bool is_disable_machine_password_change :1;
  bool is_force_normal_boot :1;
  bool network_infos :1;
  bool config :1;
  bool gpt_to_mbr :1;
  bool detect_type :1;
  bool skip_system_injection :1;
  bool reboot_winpe :1;
  bool callbacks :1;
  bool callback_timeout :1;
  bool host_name :1;
  bool export_disk_type :1;
  bool export_path :1;
  bool target_type :1;
  bool os_type :1;
  bool is_update_ex :1;
  bool options_type :1;
  bool options :1;
  bool pre_scripts :1;
  bool post_scripts :1;
} _launcher_job_create_detail__isset;

class launcher_job_create_detail : public virtual ::apache::thrift::TBase {
 public:

  launcher_job_create_detail(const launcher_job_create_detail&);
  launcher_job_create_detail& operator=(const launcher_job_create_detail&);
  launcher_job_create_detail() : replica_id(""), is_sysvol_authoritative_restore(false), is_enable_debug(false), is_disable_machine_password_change(false), is_force_normal_boot(false), config(), gpt_to_mbr(true), detect_type((disk_detect_type::type)0), skip_system_injection(false), reboot_winpe(false), callback_timeout(30), host_name(""), export_disk_type((virtual_disk_type::type)0), export_path(""), target_type((conversion_type::type)-1), os_type((hv_guest_os_type::type)1), is_update_ex(false), options_type((extra_options_type::type)0) {
    detect_type = (disk_detect_type::type)0;

    export_disk_type = (virtual_disk_type::type)0;

    target_type = (conversion_type::type)-1;

    os_type = (hv_guest_os_type::type)1;

    options_type = (extra_options_type::type)0;

  }

  virtual ~launcher_job_create_detail() throw();
  std::string replica_id;
  std::map<std::string, std::string>  disks_lun_mapping;
  bool is_sysvol_authoritative_restore;
  bool is_enable_debug;
  bool is_disable_machine_password_change;
  bool is_force_normal_boot;
  std::set<network_info>  network_infos;
  std::string config;
  bool gpt_to_mbr;
  disk_detect_type::type detect_type;
  bool skip_system_injection;
  bool reboot_winpe;
  std::set<std::string>  callbacks;
  int32_t callback_timeout;
  std::string host_name;
  virtual_disk_type::type export_disk_type;
  std::string export_path;
  conversion_type::type target_type;
  hv_guest_os_type::type os_type;
  bool is_update_ex;
  extra_options_type::type options_type;
  extra_options options;
  std::set<std::string>  pre_scripts;
  std::set<std::string>  post_scripts;

  _launcher_job_create_detail__isset __isset;

  void __set_replica_id(const std::string& val);

  void __set_disks_lun_mapping(const std::map<std::string, std::string> & val);

  void __set_is_sysvol_authoritative_restore(const bool val);

  void __set_is_enable_debug(const bool val);

  void __set_is_disable_machine_password_change(const bool val);

  void __set_is_force_normal_boot(const bool val);

  void __set_network_infos(const std::set<network_info> & val);

  void __set_config(const std::string& val);

  void __set_gpt_to_mbr(const bool val);

  void __set_detect_type(const disk_detect_type::type val);

  void __set_skip_system_injection(const bool val);

  void __set_reboot_winpe(const bool val);

  void __set_callbacks(const std::set<std::string> & val);

  void __set_callback_timeout(const int32_t val);

  void __set_host_name(const std::string& val);

  void __set_export_disk_type(const virtual_disk_type::type val);

  void __set_export_path(const std::string& val);

  void __set_target_type(const conversion_type::type val);

  void __set_os_type(const hv_guest_os_type::type val);

  void __set_is_update_ex(const bool val);

  void __set_options_type(const extra_options_type::type val);

  void __set_options(const extra_options& val);

  void __set_pre_scripts(const std::set<std::string> & val);

  void __set_post_scripts(const std::set<std::string> & val);

  bool operator == (const launcher_job_create_detail & rhs) const
  {
    if (__isset.replica_id != rhs.__isset.replica_id)
      return false;
    else if (__isset.replica_id && !(replica_id == rhs.replica_id))
      return false;
    if (__isset.disks_lun_mapping != rhs.__isset.disks_lun_mapping)
      return false;
    else if (__isset.disks_lun_mapping && !(disks_lun_mapping == rhs.disks_lun_mapping))
      return false;
    if (__isset.is_sysvol_authoritative_restore != rhs.__isset.is_sysvol_authoritative_restore)
      return false;
    else if (__isset.is_sysvol_authoritative_restore && !(is_sysvol_authoritative_restore == rhs.is_sysvol_authoritative_restore))
      return false;
    if (__isset.is_enable_debug != rhs.__isset.is_enable_debug)
      return false;
    else if (__isset.is_enable_debug && !(is_enable_debug == rhs.is_enable_debug))
      return false;
    if (__isset.is_disable_machine_password_change != rhs.__isset.is_disable_machine_password_change)
      return false;
    else if (__isset.is_disable_machine_password_change && !(is_disable_machine_password_change == rhs.is_disable_machine_password_change))
      return false;
    if (__isset.is_force_normal_boot != rhs.__isset.is_force_normal_boot)
      return false;
    else if (__isset.is_force_normal_boot && !(is_force_normal_boot == rhs.is_force_normal_boot))
      return false;
    if (__isset.network_infos != rhs.__isset.network_infos)
      return false;
    else if (__isset.network_infos && !(network_infos == rhs.network_infos))
      return false;
    if (__isset.config != rhs.__isset.config)
      return false;
    else if (__isset.config && !(config == rhs.config))
      return false;
    if (__isset.gpt_to_mbr != rhs.__isset.gpt_to_mbr)
      return false;
    else if (__isset.gpt_to_mbr && !(gpt_to_mbr == rhs.gpt_to_mbr))
      return false;
    if (__isset.detect_type != rhs.__isset.detect_type)
      return false;
    else if (__isset.detect_type && !(detect_type == rhs.detect_type))
      return false;
    if (__isset.skip_system_injection != rhs.__isset.skip_system_injection)
      return false;
    else if (__isset.skip_system_injection && !(skip_system_injection == rhs.skip_system_injection))
      return false;
    if (__isset.reboot_winpe != rhs.__isset.reboot_winpe)
      return false;
    else if (__isset.reboot_winpe && !(reboot_winpe == rhs.reboot_winpe))
      return false;
    if (__isset.callbacks != rhs.__isset.callbacks)
      return false;
    else if (__isset.callbacks && !(callbacks == rhs.callbacks))
      return false;
    if (__isset.callback_timeout != rhs.__isset.callback_timeout)
      return false;
    else if (__isset.callback_timeout && !(callback_timeout == rhs.callback_timeout))
      return false;
    if (__isset.host_name != rhs.__isset.host_name)
      return false;
    else if (__isset.host_name && !(host_name == rhs.host_name))
      return false;
    if (__isset.export_disk_type != rhs.__isset.export_disk_type)
      return false;
    else if (__isset.export_disk_type && !(export_disk_type == rhs.export_disk_type))
      return false;
    if (__isset.export_path != rhs.__isset.export_path)
      return false;
    else if (__isset.export_path && !(export_path == rhs.export_path))
      return false;
    if (__isset.target_type != rhs.__isset.target_type)
      return false;
    else if (__isset.target_type && !(target_type == rhs.target_type))
      return false;
    if (__isset.os_type != rhs.__isset.os_type)
      return false;
    else if (__isset.os_type && !(os_type == rhs.os_type))
      return false;
    if (__isset.is_update_ex != rhs.__isset.is_update_ex)
      return false;
    else if (__isset.is_update_ex && !(is_update_ex == rhs.is_update_ex))
      return false;
    if (__isset.options_type != rhs.__isset.options_type)
      return false;
    else if (__isset.options_type && !(options_type == rhs.options_type))
      return false;
    if (__isset.options != rhs.__isset.options)
      return false;
    else if (__isset.options && !(options == rhs.options))
      return false;
    if (__isset.pre_scripts != rhs.__isset.pre_scripts)
      return false;
    else if (__isset.pre_scripts && !(pre_scripts == rhs.pre_scripts))
      return false;
    if (__isset.post_scripts != rhs.__isset.post_scripts)
      return false;
    else if (__isset.post_scripts && !(post_scripts == rhs.post_scripts))
      return false;
    return true;
  }
  bool operator != (const launcher_job_create_detail &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const launcher_job_create_detail & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(launcher_job_create_detail &a, launcher_job_create_detail &b);

inline std::ostream& operator<<(std::ostream& out, const launcher_job_create_detail& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _register_service_info__isset {
  _register_service_info__isset() : mgmt_addr(true), username(true), password(true), service_types(false), version(true), path(true) {}
  bool mgmt_addr :1;
  bool username :1;
  bool password :1;
  bool service_types :1;
  bool version :1;
  bool path :1;
} _register_service_info__isset;

class register_service_info : public virtual ::apache::thrift::TBase {
 public:

  register_service_info(const register_service_info&);
  register_service_info& operator=(const register_service_info&);
  register_service_info() : mgmt_addr(""), username(""), password(""), version(""), path("") {
  }

  virtual ~register_service_info() throw();
  std::string mgmt_addr;
  std::string username;
  std::string password;
  std::set<std::string>  service_types;
  std::string version;
  std::string path;

  _register_service_info__isset __isset;

  void __set_mgmt_addr(const std::string& val);

  void __set_username(const std::string& val);

  void __set_password(const std::string& val);

  void __set_service_types(const std::set<std::string> & val);

  void __set_version(const std::string& val);

  void __set_path(const std::string& val);

  bool operator == (const register_service_info & rhs) const
  {
    if (__isset.mgmt_addr != rhs.__isset.mgmt_addr)
      return false;
    else if (__isset.mgmt_addr && !(mgmt_addr == rhs.mgmt_addr))
      return false;
    if (__isset.username != rhs.__isset.username)
      return false;
    else if (__isset.username && !(username == rhs.username))
      return false;
    if (__isset.password != rhs.__isset.password)
      return false;
    else if (__isset.password && !(password == rhs.password))
      return false;
    if (__isset.service_types != rhs.__isset.service_types)
      return false;
    else if (__isset.service_types && !(service_types == rhs.service_types))
      return false;
    if (__isset.version != rhs.__isset.version)
      return false;
    else if (__isset.version && !(version == rhs.version))
      return false;
    if (__isset.path != rhs.__isset.path)
      return false;
    else if (__isset.path && !(path == rhs.path))
      return false;
    return true;
  }
  bool operator != (const register_service_info &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const register_service_info & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(register_service_info &a, register_service_info &b);

inline std::ostream& operator<<(std::ostream& out, const register_service_info& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _register_physical_packer_info__isset {
  _register_physical_packer_info__isset() : mgmt_addr(true), username(true), password(true), packer_addr(true), version(true), path(true) {}
  bool mgmt_addr :1;
  bool username :1;
  bool password :1;
  bool packer_addr :1;
  bool version :1;
  bool path :1;
} _register_physical_packer_info__isset;

class register_physical_packer_info : public virtual ::apache::thrift::TBase {
 public:

  register_physical_packer_info(const register_physical_packer_info&);
  register_physical_packer_info& operator=(const register_physical_packer_info&);
  register_physical_packer_info() : mgmt_addr(""), username(""), password(""), packer_addr(""), version(""), path("") {
  }

  virtual ~register_physical_packer_info() throw();
  std::string mgmt_addr;
  std::string username;
  std::string password;
  std::string packer_addr;
  std::string version;
  std::string path;

  _register_physical_packer_info__isset __isset;

  void __set_mgmt_addr(const std::string& val);

  void __set_username(const std::string& val);

  void __set_password(const std::string& val);

  void __set_packer_addr(const std::string& val);

  void __set_version(const std::string& val);

  void __set_path(const std::string& val);

  bool operator == (const register_physical_packer_info & rhs) const
  {
    if (__isset.mgmt_addr != rhs.__isset.mgmt_addr)
      return false;
    else if (__isset.mgmt_addr && !(mgmt_addr == rhs.mgmt_addr))
      return false;
    if (__isset.username != rhs.__isset.username)
      return false;
    else if (__isset.username && !(username == rhs.username))
      return false;
    if (__isset.password != rhs.__isset.password)
      return false;
    else if (__isset.password && !(password == rhs.password))
      return false;
    if (__isset.packer_addr != rhs.__isset.packer_addr)
      return false;
    else if (__isset.packer_addr && !(packer_addr == rhs.packer_addr))
      return false;
    if (__isset.version != rhs.__isset.version)
      return false;
    else if (__isset.version && !(version == rhs.version))
      return false;
    if (__isset.path != rhs.__isset.path)
      return false;
    else if (__isset.path && !(path == rhs.path))
      return false;
    return true;
  }
  bool operator != (const register_physical_packer_info &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const register_physical_packer_info & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(register_physical_packer_info &a, register_physical_packer_info &b);

inline std::ostream& operator<<(std::ostream& out, const register_physical_packer_info& obj)
{
  obj.printTo(out);
  return out;
}


class command_empty : public ::apache::thrift::TException {
 public:

  command_empty(const command_empty&);
  command_empty& operator=(const command_empty&);
  command_empty() {
  }

  virtual ~command_empty() throw();

  bool operator == (const command_empty & /* rhs */) const
  {
    return true;
  }
  bool operator != (const command_empty &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const command_empty & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(command_empty &a, command_empty &b);

inline std::ostream& operator<<(std::ostream& out, const command_empty& obj)
{
  obj.printTo(out);
  return out;
}


class invalid_session : public ::apache::thrift::TException {
 public:

  invalid_session(const invalid_session&);
  invalid_session& operator=(const invalid_session&);
  invalid_session() {
  }

  virtual ~invalid_session() throw();

  bool operator == (const invalid_session & /* rhs */) const
  {
    return true;
  }
  bool operator != (const invalid_session &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const invalid_session & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(invalid_session &a, invalid_session &b);

inline std::ostream& operator<<(std::ostream& out, const invalid_session& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _transport_message__isset {
  _transport_message__isset() : id(true), message(true) {}
  bool id :1;
  bool message :1;
} _transport_message__isset;

class transport_message : public virtual ::apache::thrift::TBase {
 public:

  transport_message(const transport_message&);
  transport_message& operator=(const transport_message&);
  transport_message() : id(0LL), message("") {
  }

  virtual ~transport_message() throw();
  int64_t id;
  std::string message;

  _transport_message__isset __isset;

  void __set_id(const int64_t val);

  void __set_message(const std::string& val);

  bool operator == (const transport_message & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const transport_message &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const transport_message & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(transport_message &a, transport_message &b);

inline std::ostream& operator<<(std::ostream& out, const transport_message& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _register_return__isset {
  _register_return__isset() : message(true), session(true) {}
  bool message :1;
  bool session :1;
} _register_return__isset;

class register_return : public virtual ::apache::thrift::TBase {
 public:

  register_return(const register_return&);
  register_return& operator=(const register_return&);
  register_return() : message(""), session("") {
  }

  virtual ~register_return() throw();
  std::string message;
  std::string session;

  _register_return__isset __isset;

  void __set_message(const std::string& val);

  void __set_session(const std::string& val);

  bool operator == (const register_return & rhs) const
  {
    if (__isset.message != rhs.__isset.message)
      return false;
    else if (__isset.message && !(message == rhs.message))
      return false;
    if (__isset.session != rhs.__isset.session)
      return false;
    else if (__isset.session && !(session == rhs.session))
      return false;
    return true;
  }
  bool operator != (const register_return &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const register_return & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(register_return &a, register_return &b);

inline std::ostream& operator<<(std::ostream& out, const register_return& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _license_info__isset {
  _license_info__isset() : key(true), activated(true), count(true), expired_date(true), consumed(true), is_active(true), name(true), email(true), status(true) {}
  bool key :1;
  bool activated :1;
  bool count :1;
  bool expired_date :1;
  bool consumed :1;
  bool is_active :1;
  bool name :1;
  bool email :1;
  bool status :1;
} _license_info__isset;

class license_info : public virtual ::apache::thrift::TBase {
 public:

  license_info(const license_info&);
  license_info& operator=(const license_info&);
  license_info() : key(""), activated(""), count(0), expired_date(""), consumed(0), is_active(false), name(""), email(""), status("") {
  }

  virtual ~license_info() throw();
  std::string key;
  std::string activated;
  int32_t count;
  std::string expired_date;
  int32_t consumed;
  bool is_active;
  std::string name;
  std::string email;
  std::string status;

  _license_info__isset __isset;

  void __set_key(const std::string& val);

  void __set_activated(const std::string& val);

  void __set_count(const int32_t val);

  void __set_expired_date(const std::string& val);

  void __set_consumed(const int32_t val);

  void __set_is_active(const bool val);

  void __set_name(const std::string& val);

  void __set_email(const std::string& val);

  void __set_status(const std::string& val);

  bool operator == (const license_info & rhs) const
  {
    if (__isset.key != rhs.__isset.key)
      return false;
    else if (__isset.key && !(key == rhs.key))
      return false;
    if (__isset.activated != rhs.__isset.activated)
      return false;
    else if (__isset.activated && !(activated == rhs.activated))
      return false;
    if (__isset.count != rhs.__isset.count)
      return false;
    else if (__isset.count && !(count == rhs.count))
      return false;
    if (__isset.expired_date != rhs.__isset.expired_date)
      return false;
    else if (__isset.expired_date && !(expired_date == rhs.expired_date))
      return false;
    if (__isset.consumed != rhs.__isset.consumed)
      return false;
    else if (__isset.consumed && !(consumed == rhs.consumed))
      return false;
    if (__isset.is_active != rhs.__isset.is_active)
      return false;
    else if (__isset.is_active && !(is_active == rhs.is_active))
      return false;
    if (__isset.name != rhs.__isset.name)
      return false;
    else if (__isset.name && !(name == rhs.name))
      return false;
    if (__isset.email != rhs.__isset.email)
      return false;
    else if (__isset.email && !(email == rhs.email))
      return false;
    if (__isset.status != rhs.__isset.status)
      return false;
    else if (__isset.status && !(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const license_info &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const license_info & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(license_info &a, license_info &b);

inline std::ostream& operator<<(std::ostream& out, const license_info& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _workload_history__isset {
  _workload_history__isset() : machine_id(true), name(true), type(true), histories(false) {}
  bool machine_id :1;
  bool name :1;
  bool type :1;
  bool histories :1;
} _workload_history__isset;

class workload_history : public virtual ::apache::thrift::TBase {
 public:

  workload_history(const workload_history&);
  workload_history& operator=(const workload_history&);
  workload_history() : machine_id(""), name(""), type("") {
  }

  virtual ~workload_history() throw();
  std::string machine_id;
  std::string name;
  std::string type;
  std::vector<int32_t>  histories;

  _workload_history__isset __isset;

  void __set_machine_id(const std::string& val);

  void __set_name(const std::string& val);

  void __set_type(const std::string& val);

  void __set_histories(const std::vector<int32_t> & val);

  bool operator == (const workload_history & rhs) const
  {
    if (__isset.machine_id != rhs.__isset.machine_id)
      return false;
    else if (__isset.machine_id && !(machine_id == rhs.machine_id))
      return false;
    if (__isset.name != rhs.__isset.name)
      return false;
    else if (__isset.name && !(name == rhs.name))
      return false;
    if (__isset.type != rhs.__isset.type)
      return false;
    else if (__isset.type && !(type == rhs.type))
      return false;
    if (__isset.histories != rhs.__isset.histories)
      return false;
    else if (__isset.histories && !(histories == rhs.histories))
      return false;
    return true;
  }
  bool operator != (const workload_history &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const workload_history & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(workload_history &a, workload_history &b);

inline std::ostream& operator<<(std::ostream& out, const workload_history& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _license_infos__isset {
  _license_infos__isset() : licenses(false), histories(false) {}
  bool licenses :1;
  bool histories :1;
} _license_infos__isset;

class license_infos : public virtual ::apache::thrift::TBase {
 public:

  license_infos(const license_infos&);
  license_infos& operator=(const license_infos&);
  license_infos() {
  }

  virtual ~license_infos() throw();
  std::vector<license_info>  licenses;
  std::vector<workload_history>  histories;

  _license_infos__isset __isset;

  void __set_licenses(const std::vector<license_info> & val);

  void __set_histories(const std::vector<workload_history> & val);

  bool operator == (const license_infos & rhs) const
  {
    if (__isset.licenses != rhs.__isset.licenses)
      return false;
    else if (__isset.licenses && !(licenses == rhs.licenses))
      return false;
    if (__isset.histories != rhs.__isset.histories)
      return false;
    else if (__isset.histories && !(histories == rhs.histories))
      return false;
    return true;
  }
  bool operator != (const license_infos &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const license_infos & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(license_infos &a, license_infos &b);

inline std::ostream& operator<<(std::ostream& out, const license_infos& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _running_task__isset {
  _running_task__isset() : id(false), triggers(false), mgmt_addr(false), mgmt_port(true), is_ssl(true), parameters(false) {}
  bool id :1;
  bool triggers :1;
  bool mgmt_addr :1;
  bool mgmt_port :1;
  bool is_ssl :1;
  bool parameters :1;
} _running_task__isset;

class running_task : public virtual ::apache::thrift::TBase {
 public:

  running_task(const running_task&);
  running_task& operator=(const running_task&);
  running_task() : id(), mgmt_addr(), mgmt_port(80), is_ssl(false), parameters() {
  }

  virtual ~running_task() throw();
  std::string id;
  std::vector<job_trigger>  triggers;
  std::string mgmt_addr;
  int32_t mgmt_port;
  bool is_ssl;
  std::string parameters;

  _running_task__isset __isset;

  void __set_id(const std::string& val);

  void __set_triggers(const std::vector<job_trigger> & val);

  void __set_mgmt_addr(const std::string& val);

  void __set_mgmt_port(const int32_t val);

  void __set_is_ssl(const bool val);

  void __set_parameters(const std::string& val);

  bool operator == (const running_task & rhs) const
  {
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.triggers != rhs.__isset.triggers)
      return false;
    else if (__isset.triggers && !(triggers == rhs.triggers))
      return false;
    if (__isset.mgmt_addr != rhs.__isset.mgmt_addr)
      return false;
    else if (__isset.mgmt_addr && !(mgmt_addr == rhs.mgmt_addr))
      return false;
    if (__isset.mgmt_port != rhs.__isset.mgmt_port)
      return false;
    else if (__isset.mgmt_port && !(mgmt_port == rhs.mgmt_port))
      return false;
    if (__isset.is_ssl != rhs.__isset.is_ssl)
      return false;
    else if (__isset.is_ssl && !(is_ssl == rhs.is_ssl))
      return false;
    if (__isset.parameters != rhs.__isset.parameters)
      return false;
    else if (__isset.parameters && !(parameters == rhs.parameters))
      return false;
    return true;
  }
  bool operator != (const running_task &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const running_task & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(running_task &a, running_task &b);

inline std::ostream& operator<<(std::ostream& out, const running_task& obj)
{
  obj.printTo(out);
  return out;
}

}} // namespace

#endif
