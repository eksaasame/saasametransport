/**
 * Autogenerated by Thrift Compiler (0.10.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "physical_packer_service_proxy.h"
#include "thrift/async/TAsyncChannel.h"

namespace saasame { namespace transport {


physical_packer_service_proxy_packer_ping_p_args::~physical_packer_service_proxy_packer_ping_p_args() throw() {
}


uint32_t physical_packer_service_proxy_packer_ping_p_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->addr);
          this->__isset.addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_packer_ping_p_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_packer_ping_p_args");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->addr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_packer_ping_p_pargs::~physical_packer_service_proxy_packer_ping_p_pargs() throw() {
}


uint32_t physical_packer_service_proxy_packer_ping_p_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_packer_ping_p_pargs");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->session_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->addr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_packer_ping_p_result::~physical_packer_service_proxy_packer_ping_p_result() throw() {
}


uint32_t physical_packer_service_proxy_packer_ping_p_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_packer_ping_p_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("physical_packer_service_proxy_packer_ping_p_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_packer_ping_p_presult::~physical_packer_service_proxy_packer_ping_p_presult() throw() {
}


uint32_t physical_packer_service_proxy_packer_ping_p_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_packer_ping_p_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_packer_ping_p_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
  xfer += (*(this->success)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_take_snapshots_p_args::~physical_packer_service_proxy_take_snapshots_p_args() throw() {
}


uint32_t physical_packer_service_proxy_take_snapshots_p_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->addr);
          this->__isset.addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->disks.clear();
            uint32_t _size1291;
            ::apache::thrift::protocol::TType _etype1294;
            xfer += iprot->readSetBegin(_etype1294, _size1291);
            uint32_t _i1295;
            for (_i1295 = 0; _i1295 < _size1291; ++_i1295)
            {
              std::string _elem1296;
              xfer += iprot->readString(_elem1296);
              this->disks.insert(_elem1296);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.disks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_take_snapshots_p_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_take_snapshots_p_args");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->addr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("disks", ::apache::thrift::protocol::T_SET, 3);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->disks.size()));
    std::set<std::string> ::const_iterator _iter1297;
    for (_iter1297 = this->disks.begin(); _iter1297 != this->disks.end(); ++_iter1297)
    {
      xfer += oprot->writeString((*_iter1297));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_take_snapshots_p_pargs::~physical_packer_service_proxy_take_snapshots_p_pargs() throw() {
}


uint32_t physical_packer_service_proxy_take_snapshots_p_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_take_snapshots_p_pargs");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->session_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->addr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("disks", ::apache::thrift::protocol::T_SET, 3);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->disks)).size()));
    std::set<std::string> ::const_iterator _iter1298;
    for (_iter1298 = (*(this->disks)).begin(); _iter1298 != (*(this->disks)).end(); ++_iter1298)
    {
      xfer += oprot->writeString((*_iter1298));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_take_snapshots_p_result::~physical_packer_service_proxy_take_snapshots_p_result() throw() {
}


uint32_t physical_packer_service_proxy_take_snapshots_p_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size1299;
            ::apache::thrift::protocol::TType _etype1302;
            xfer += iprot->readListBegin(_etype1302, _size1299);
            this->success.resize(_size1299);
            uint32_t _i1303;
            for (_i1303 = 0; _i1303 < _size1299; ++_i1303)
            {
              xfer += this->success[_i1303].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_take_snapshots_p_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("physical_packer_service_proxy_take_snapshots_p_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector<snapshot> ::const_iterator _iter1304;
      for (_iter1304 = this->success.begin(); _iter1304 != this->success.end(); ++_iter1304)
      {
        xfer += (*_iter1304).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_take_snapshots_p_presult::~physical_packer_service_proxy_take_snapshots_p_presult() throw() {
}


uint32_t physical_packer_service_proxy_take_snapshots_p_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size1305;
            ::apache::thrift::protocol::TType _etype1308;
            xfer += iprot->readListBegin(_etype1308, _size1305);
            (*(this->success)).resize(_size1305);
            uint32_t _i1309;
            for (_i1309 = 0; _i1309 < _size1305; ++_i1309)
            {
              xfer += (*(this->success))[_i1309].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_take_snapshots_p_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_take_snapshots_p_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->success)).size()));
    std::vector<snapshot> ::const_iterator _iter1310;
    for (_iter1310 = (*(this->success)).begin(); _iter1310 != (*(this->success)).end(); ++_iter1310)
    {
      xfer += (*_iter1310).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_take_snapshots_ex_p_args::~physical_packer_service_proxy_take_snapshots_ex_p_args() throw() {
}


uint32_t physical_packer_service_proxy_take_snapshots_ex_p_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->addr);
          this->__isset.addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->disks.clear();
            uint32_t _size1311;
            ::apache::thrift::protocol::TType _etype1314;
            xfer += iprot->readSetBegin(_etype1314, _size1311);
            uint32_t _i1315;
            for (_i1315 = 0; _i1315 < _size1311; ++_i1315)
            {
              std::string _elem1316;
              xfer += iprot->readString(_elem1316);
              this->disks.insert(_elem1316);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.disks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pre_script);
          this->__isset.pre_script = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->post_script);
          this->__isset.post_script = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_take_snapshots_ex_p_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_take_snapshots_ex_p_args");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->addr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("disks", ::apache::thrift::protocol::T_SET, 3);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->disks.size()));
    std::set<std::string> ::const_iterator _iter1317;
    for (_iter1317 = this->disks.begin(); _iter1317 != this->disks.end(); ++_iter1317)
    {
      xfer += oprot->writeString((*_iter1317));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pre_script", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->pre_script);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("post_script", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->post_script);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_take_snapshots_ex_p_pargs::~physical_packer_service_proxy_take_snapshots_ex_p_pargs() throw() {
}


uint32_t physical_packer_service_proxy_take_snapshots_ex_p_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_take_snapshots_ex_p_pargs");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->session_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->addr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("disks", ::apache::thrift::protocol::T_SET, 3);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->disks)).size()));
    std::set<std::string> ::const_iterator _iter1318;
    for (_iter1318 = (*(this->disks)).begin(); _iter1318 != (*(this->disks)).end(); ++_iter1318)
    {
      xfer += oprot->writeString((*_iter1318));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pre_script", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->pre_script)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("post_script", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString((*(this->post_script)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_take_snapshots_ex_p_result::~physical_packer_service_proxy_take_snapshots_ex_p_result() throw() {
}


uint32_t physical_packer_service_proxy_take_snapshots_ex_p_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size1319;
            ::apache::thrift::protocol::TType _etype1322;
            xfer += iprot->readListBegin(_etype1322, _size1319);
            this->success.resize(_size1319);
            uint32_t _i1323;
            for (_i1323 = 0; _i1323 < _size1319; ++_i1323)
            {
              xfer += this->success[_i1323].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_take_snapshots_ex_p_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("physical_packer_service_proxy_take_snapshots_ex_p_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector<snapshot> ::const_iterator _iter1324;
      for (_iter1324 = this->success.begin(); _iter1324 != this->success.end(); ++_iter1324)
      {
        xfer += (*_iter1324).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_take_snapshots_ex_p_presult::~physical_packer_service_proxy_take_snapshots_ex_p_presult() throw() {
}


uint32_t physical_packer_service_proxy_take_snapshots_ex_p_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size1325;
            ::apache::thrift::protocol::TType _etype1328;
            xfer += iprot->readListBegin(_etype1328, _size1325);
            (*(this->success)).resize(_size1325);
            uint32_t _i1329;
            for (_i1329 = 0; _i1329 < _size1325; ++_i1329)
            {
              xfer += (*(this->success))[_i1329].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_take_snapshots_ex_p_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_take_snapshots_ex_p_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->success)).size()));
    std::vector<snapshot> ::const_iterator _iter1330;
    for (_iter1330 = (*(this->success)).begin(); _iter1330 != (*(this->success)).end(); ++_iter1330)
    {
      xfer += (*_iter1330).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_delete_snapshot_p_args::~physical_packer_service_proxy_delete_snapshot_p_args() throw() {
}


uint32_t physical_packer_service_proxy_delete_snapshot_p_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->addr);
          this->__isset.addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->snapshot_id);
          this->__isset.snapshot_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_delete_snapshot_p_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_delete_snapshot_p_args");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->addr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("snapshot_id", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->snapshot_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_delete_snapshot_p_pargs::~physical_packer_service_proxy_delete_snapshot_p_pargs() throw() {
}


uint32_t physical_packer_service_proxy_delete_snapshot_p_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_delete_snapshot_p_pargs");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->session_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->addr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("snapshot_id", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->snapshot_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_delete_snapshot_p_result::~physical_packer_service_proxy_delete_snapshot_p_result() throw() {
}


uint32_t physical_packer_service_proxy_delete_snapshot_p_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_delete_snapshot_p_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("physical_packer_service_proxy_delete_snapshot_p_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_delete_snapshot_p_presult::~physical_packer_service_proxy_delete_snapshot_p_presult() throw() {
}


uint32_t physical_packer_service_proxy_delete_snapshot_p_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_delete_snapshot_p_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_delete_snapshot_p_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
  xfer += (*(this->success)).write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_delete_snapshot_set_p_args::~physical_packer_service_proxy_delete_snapshot_set_p_args() throw() {
}


uint32_t physical_packer_service_proxy_delete_snapshot_set_p_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->addr);
          this->__isset.addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->snapshot_set_id);
          this->__isset.snapshot_set_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_delete_snapshot_set_p_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_delete_snapshot_set_p_args");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->addr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("snapshot_set_id", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->snapshot_set_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_delete_snapshot_set_p_pargs::~physical_packer_service_proxy_delete_snapshot_set_p_pargs() throw() {
}


uint32_t physical_packer_service_proxy_delete_snapshot_set_p_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_delete_snapshot_set_p_pargs");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->session_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->addr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("snapshot_set_id", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->snapshot_set_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_delete_snapshot_set_p_result::~physical_packer_service_proxy_delete_snapshot_set_p_result() throw() {
}


uint32_t physical_packer_service_proxy_delete_snapshot_set_p_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_delete_snapshot_set_p_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("physical_packer_service_proxy_delete_snapshot_set_p_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_delete_snapshot_set_p_presult::~physical_packer_service_proxy_delete_snapshot_set_p_presult() throw() {
}


uint32_t physical_packer_service_proxy_delete_snapshot_set_p_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_delete_snapshot_set_p_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_delete_snapshot_set_p_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
  xfer += (*(this->success)).write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_get_all_snapshots_p_args::~physical_packer_service_proxy_get_all_snapshots_p_args() throw() {
}


uint32_t physical_packer_service_proxy_get_all_snapshots_p_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->addr);
          this->__isset.addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_get_all_snapshots_p_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_get_all_snapshots_p_args");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->addr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_get_all_snapshots_p_pargs::~physical_packer_service_proxy_get_all_snapshots_p_pargs() throw() {
}


uint32_t physical_packer_service_proxy_get_all_snapshots_p_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_get_all_snapshots_p_pargs");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->session_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->addr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_get_all_snapshots_p_result::~physical_packer_service_proxy_get_all_snapshots_p_result() throw() {
}


uint32_t physical_packer_service_proxy_get_all_snapshots_p_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->success.clear();
            uint32_t _size1331;
            ::apache::thrift::protocol::TType _ktype1332;
            ::apache::thrift::protocol::TType _vtype1333;
            xfer += iprot->readMapBegin(_ktype1332, _vtype1333, _size1331);
            uint32_t _i1335;
            for (_i1335 = 0; _i1335 < _size1331; ++_i1335)
            {
              std::string _key1336;
              xfer += iprot->readString(_key1336);
              std::vector<snapshot> & _val1337 = this->success[_key1336];
              {
                _val1337.clear();
                uint32_t _size1338;
                ::apache::thrift::protocol::TType _etype1341;
                xfer += iprot->readListBegin(_etype1341, _size1338);
                _val1337.resize(_size1338);
                uint32_t _i1342;
                for (_i1342 = 0; _i1342 < _size1338; ++_i1342)
                {
                  xfer += _val1337[_i1342].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_get_all_snapshots_p_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("physical_packer_service_proxy_get_all_snapshots_p_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->success.size()));
      std::map<std::string, std::vector<snapshot> > ::const_iterator _iter1343;
      for (_iter1343 = this->success.begin(); _iter1343 != this->success.end(); ++_iter1343)
      {
        xfer += oprot->writeString(_iter1343->first);
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter1343->second.size()));
          std::vector<snapshot> ::const_iterator _iter1344;
          for (_iter1344 = _iter1343->second.begin(); _iter1344 != _iter1343->second.end(); ++_iter1344)
          {
            xfer += (*_iter1344).write(oprot);
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_get_all_snapshots_p_presult::~physical_packer_service_proxy_get_all_snapshots_p_presult() throw() {
}


uint32_t physical_packer_service_proxy_get_all_snapshots_p_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            (*(this->success)).clear();
            uint32_t _size1345;
            ::apache::thrift::protocol::TType _ktype1346;
            ::apache::thrift::protocol::TType _vtype1347;
            xfer += iprot->readMapBegin(_ktype1346, _vtype1347, _size1345);
            uint32_t _i1349;
            for (_i1349 = 0; _i1349 < _size1345; ++_i1349)
            {
              std::string _key1350;
              xfer += iprot->readString(_key1350);
              std::vector<snapshot> & _val1351 = (*(this->success))[_key1350];
              {
                _val1351.clear();
                uint32_t _size1352;
                ::apache::thrift::protocol::TType _etype1355;
                xfer += iprot->readListBegin(_etype1355, _size1352);
                _val1351.resize(_size1352);
                uint32_t _i1356;
                for (_i1356 = 0; _i1356 < _size1352; ++_i1356)
                {
                  xfer += _val1351[_i1356].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_get_all_snapshots_p_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_get_all_snapshots_p_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>((*(this->success)).size()));
    std::map<std::string, std::vector<snapshot> > ::const_iterator _iter1357;
    for (_iter1357 = (*(this->success)).begin(); _iter1357 != (*(this->success)).end(); ++_iter1357)
    {
      xfer += oprot->writeString(_iter1357->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter1357->second.size()));
        std::vector<snapshot> ::const_iterator _iter1358;
        for (_iter1358 = _iter1357->second.begin(); _iter1358 != _iter1357->second.end(); ++_iter1358)
        {
          xfer += (*_iter1358).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_create_packer_job_ex_p_args::~physical_packer_service_proxy_create_packer_job_ex_p_args() throw() {
}


uint32_t physical_packer_service_proxy_create_packer_job_ex_p_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->addr);
          this->__isset.addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->job_id);
          this->__isset.job_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->create_job.read(iprot);
          this->__isset.create_job = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_create_packer_job_ex_p_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_create_packer_job_ex_p_args");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->addr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("job_id", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->job_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("create_job", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->create_job.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_create_packer_job_ex_p_pargs::~physical_packer_service_proxy_create_packer_job_ex_p_pargs() throw() {
}


uint32_t physical_packer_service_proxy_create_packer_job_ex_p_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_create_packer_job_ex_p_pargs");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->session_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->addr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("job_id", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->job_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("create_job", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += (*(this->create_job)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_create_packer_job_ex_p_result::~physical_packer_service_proxy_create_packer_job_ex_p_result() throw() {
}


uint32_t physical_packer_service_proxy_create_packer_job_ex_p_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_create_packer_job_ex_p_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("physical_packer_service_proxy_create_packer_job_ex_p_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_create_packer_job_ex_p_presult::~physical_packer_service_proxy_create_packer_job_ex_p_presult() throw() {
}


uint32_t physical_packer_service_proxy_create_packer_job_ex_p_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_create_packer_job_ex_p_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_create_packer_job_ex_p_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
  xfer += (*(this->success)).write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_get_packer_job_p_args::~physical_packer_service_proxy_get_packer_job_p_args() throw() {
}


uint32_t physical_packer_service_proxy_get_packer_job_p_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->addr);
          this->__isset.addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->job_id);
          this->__isset.job_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->previous_updated_time);
          this->__isset.previous_updated_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_get_packer_job_p_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_get_packer_job_p_args");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->addr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("job_id", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->job_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("previous_updated_time", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->previous_updated_time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_get_packer_job_p_pargs::~physical_packer_service_proxy_get_packer_job_p_pargs() throw() {
}


uint32_t physical_packer_service_proxy_get_packer_job_p_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_get_packer_job_p_pargs");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->session_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->addr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("job_id", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->job_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("previous_updated_time", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->previous_updated_time)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_get_packer_job_p_result::~physical_packer_service_proxy_get_packer_job_p_result() throw() {
}


uint32_t physical_packer_service_proxy_get_packer_job_p_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_get_packer_job_p_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("physical_packer_service_proxy_get_packer_job_p_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_get_packer_job_p_presult::~physical_packer_service_proxy_get_packer_job_p_presult() throw() {
}


uint32_t physical_packer_service_proxy_get_packer_job_p_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_get_packer_job_p_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_get_packer_job_p_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
  xfer += (*(this->success)).write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_interrupt_packer_job_p_args::~physical_packer_service_proxy_interrupt_packer_job_p_args() throw() {
}


uint32_t physical_packer_service_proxy_interrupt_packer_job_p_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->addr);
          this->__isset.addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->job_id);
          this->__isset.job_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_interrupt_packer_job_p_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_interrupt_packer_job_p_args");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->addr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("job_id", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->job_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_interrupt_packer_job_p_pargs::~physical_packer_service_proxy_interrupt_packer_job_p_pargs() throw() {
}


uint32_t physical_packer_service_proxy_interrupt_packer_job_p_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_interrupt_packer_job_p_pargs");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->session_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->addr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("job_id", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->job_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_interrupt_packer_job_p_result::~physical_packer_service_proxy_interrupt_packer_job_p_result() throw() {
}


uint32_t physical_packer_service_proxy_interrupt_packer_job_p_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_interrupt_packer_job_p_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("physical_packer_service_proxy_interrupt_packer_job_p_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_interrupt_packer_job_p_presult::~physical_packer_service_proxy_interrupt_packer_job_p_presult() throw() {
}


uint32_t physical_packer_service_proxy_interrupt_packer_job_p_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_interrupt_packer_job_p_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_interrupt_packer_job_p_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
  xfer += oprot->writeBool((*(this->success)));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_resume_packer_job_p_args::~physical_packer_service_proxy_resume_packer_job_p_args() throw() {
}


uint32_t physical_packer_service_proxy_resume_packer_job_p_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->addr);
          this->__isset.addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->job_id);
          this->__isset.job_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_resume_packer_job_p_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_resume_packer_job_p_args");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->addr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("job_id", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->job_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_resume_packer_job_p_pargs::~physical_packer_service_proxy_resume_packer_job_p_pargs() throw() {
}


uint32_t physical_packer_service_proxy_resume_packer_job_p_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_resume_packer_job_p_pargs");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->session_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->addr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("job_id", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->job_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_resume_packer_job_p_result::~physical_packer_service_proxy_resume_packer_job_p_result() throw() {
}


uint32_t physical_packer_service_proxy_resume_packer_job_p_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_resume_packer_job_p_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("physical_packer_service_proxy_resume_packer_job_p_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_resume_packer_job_p_presult::~physical_packer_service_proxy_resume_packer_job_p_presult() throw() {
}


uint32_t physical_packer_service_proxy_resume_packer_job_p_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_resume_packer_job_p_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_resume_packer_job_p_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
  xfer += oprot->writeBool((*(this->success)));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_remove_packer_job_p_args::~physical_packer_service_proxy_remove_packer_job_p_args() throw() {
}


uint32_t physical_packer_service_proxy_remove_packer_job_p_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->addr);
          this->__isset.addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->job_id);
          this->__isset.job_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_remove_packer_job_p_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_remove_packer_job_p_args");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->addr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("job_id", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->job_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_remove_packer_job_p_pargs::~physical_packer_service_proxy_remove_packer_job_p_pargs() throw() {
}


uint32_t physical_packer_service_proxy_remove_packer_job_p_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_remove_packer_job_p_pargs");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->session_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->addr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("job_id", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->job_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_remove_packer_job_p_result::~physical_packer_service_proxy_remove_packer_job_p_result() throw() {
}


uint32_t physical_packer_service_proxy_remove_packer_job_p_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_remove_packer_job_p_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("physical_packer_service_proxy_remove_packer_job_p_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_remove_packer_job_p_presult::~physical_packer_service_proxy_remove_packer_job_p_presult() throw() {
}


uint32_t physical_packer_service_proxy_remove_packer_job_p_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_remove_packer_job_p_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_remove_packer_job_p_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
  xfer += oprot->writeBool((*(this->success)));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_running_packer_job_p_args::~physical_packer_service_proxy_running_packer_job_p_args() throw() {
}


uint32_t physical_packer_service_proxy_running_packer_job_p_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->addr);
          this->__isset.addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->job_id);
          this->__isset.job_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_running_packer_job_p_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_running_packer_job_p_args");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->addr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("job_id", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->job_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_running_packer_job_p_pargs::~physical_packer_service_proxy_running_packer_job_p_pargs() throw() {
}


uint32_t physical_packer_service_proxy_running_packer_job_p_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_running_packer_job_p_pargs");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->session_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->addr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("job_id", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->job_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_running_packer_job_p_result::~physical_packer_service_proxy_running_packer_job_p_result() throw() {
}


uint32_t physical_packer_service_proxy_running_packer_job_p_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_running_packer_job_p_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("physical_packer_service_proxy_running_packer_job_p_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_running_packer_job_p_presult::~physical_packer_service_proxy_running_packer_job_p_presult() throw() {
}


uint32_t physical_packer_service_proxy_running_packer_job_p_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_running_packer_job_p_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_running_packer_job_p_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
  xfer += oprot->writeBool((*(this->success)));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_enumerate_packer_disks_p_args::~physical_packer_service_proxy_enumerate_packer_disks_p_args() throw() {
}


uint32_t physical_packer_service_proxy_enumerate_packer_disks_p_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->addr);
          this->__isset.addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1359;
          xfer += iprot->readI32(ecast1359);
          this->filter = (enumerate_disk_filter_style::type)ecast1359;
          this->__isset.filter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_enumerate_packer_disks_p_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_enumerate_packer_disks_p_args");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->addr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("filter", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->filter);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_enumerate_packer_disks_p_pargs::~physical_packer_service_proxy_enumerate_packer_disks_p_pargs() throw() {
}


uint32_t physical_packer_service_proxy_enumerate_packer_disks_p_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_enumerate_packer_disks_p_pargs");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->session_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->addr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("filter", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)(*(this->filter)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_enumerate_packer_disks_p_result::~physical_packer_service_proxy_enumerate_packer_disks_p_result() throw() {
}


uint32_t physical_packer_service_proxy_enumerate_packer_disks_p_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->success.clear();
            uint32_t _size1360;
            ::apache::thrift::protocol::TType _etype1363;
            xfer += iprot->readSetBegin(_etype1363, _size1360);
            uint32_t _i1364;
            for (_i1364 = 0; _i1364 < _size1360; ++_i1364)
            {
              disk_info _elem1365;
              xfer += _elem1365.read(iprot);
              this->success.insert(_elem1365);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_enumerate_packer_disks_p_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("physical_packer_service_proxy_enumerate_packer_disks_p_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_SET, 0);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::set<disk_info> ::const_iterator _iter1366;
      for (_iter1366 = this->success.begin(); _iter1366 != this->success.end(); ++_iter1366)
      {
        xfer += (*_iter1366).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_enumerate_packer_disks_p_presult::~physical_packer_service_proxy_enumerate_packer_disks_p_presult() throw() {
}


uint32_t physical_packer_service_proxy_enumerate_packer_disks_p_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            (*(this->success)).clear();
            uint32_t _size1367;
            ::apache::thrift::protocol::TType _etype1370;
            xfer += iprot->readSetBegin(_etype1370, _size1367);
            uint32_t _i1371;
            for (_i1371 = 0; _i1371 < _size1367; ++_i1371)
            {
              disk_info _elem1372;
              xfer += _elem1372.read(iprot);
              (*(this->success)).insert(_elem1372);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_enumerate_packer_disks_p_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_enumerate_packer_disks_p_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_SET, 0);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->success)).size()));
    std::set<disk_info> ::const_iterator _iter1373;
    for (_iter1373 = (*(this->success)).begin(); _iter1373 != (*(this->success)).end(); ++_iter1373)
    {
      xfer += (*_iter1373).write(oprot);
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_verify_packer_carrier_p_args::~physical_packer_service_proxy_verify_packer_carrier_p_args() throw() {
}


uint32_t physical_packer_service_proxy_verify_packer_carrier_p_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->addr);
          this->__isset.addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->carrier);
          this->__isset.carrier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_ssl);
          this->__isset.is_ssl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_verify_packer_carrier_p_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_verify_packer_carrier_p_args");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->addr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("carrier", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->carrier);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_ssl", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->is_ssl);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_verify_packer_carrier_p_pargs::~physical_packer_service_proxy_verify_packer_carrier_p_pargs() throw() {
}


uint32_t physical_packer_service_proxy_verify_packer_carrier_p_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_verify_packer_carrier_p_pargs");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->session_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->addr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("carrier", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->carrier)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_ssl", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool((*(this->is_ssl)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_verify_packer_carrier_p_result::~physical_packer_service_proxy_verify_packer_carrier_p_result() throw() {
}


uint32_t physical_packer_service_proxy_verify_packer_carrier_p_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_verify_packer_carrier_p_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("physical_packer_service_proxy_verify_packer_carrier_p_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_verify_packer_carrier_p_presult::~physical_packer_service_proxy_verify_packer_carrier_p_presult() throw() {
}


uint32_t physical_packer_service_proxy_verify_packer_carrier_p_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_verify_packer_carrier_p_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_verify_packer_carrier_p_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
  xfer += oprot->writeBool((*(this->success)));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_get_packer_host_detail_p_args::~physical_packer_service_proxy_get_packer_host_detail_p_args() throw() {
}


uint32_t physical_packer_service_proxy_get_packer_host_detail_p_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->addr);
          this->__isset.addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1374;
          xfer += iprot->readI32(ecast1374);
          this->filter = (machine_detail_filter::type)ecast1374;
          this->__isset.filter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_get_packer_host_detail_p_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_get_packer_host_detail_p_args");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->addr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("filter", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->filter);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_get_packer_host_detail_p_pargs::~physical_packer_service_proxy_get_packer_host_detail_p_pargs() throw() {
}


uint32_t physical_packer_service_proxy_get_packer_host_detail_p_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_get_packer_host_detail_p_pargs");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->session_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->addr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("filter", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)(*(this->filter)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_get_packer_host_detail_p_result::~physical_packer_service_proxy_get_packer_host_detail_p_result() throw() {
}


uint32_t physical_packer_service_proxy_get_packer_host_detail_p_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_get_packer_host_detail_p_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("physical_packer_service_proxy_get_packer_host_detail_p_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_get_packer_host_detail_p_presult::~physical_packer_service_proxy_get_packer_host_detail_p_presult() throw() {
}


uint32_t physical_packer_service_proxy_get_packer_host_detail_p_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_get_packer_host_detail_p_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_get_packer_host_detail_p_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
  xfer += (*(this->success)).write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void physical_packer_service_proxyClient::packer_ping_p(service_info& _return, const std::string& session_id, const std::string& addr)
{
  send_packer_ping_p(session_id, addr);
  recv_packer_ping_p(_return);
}

void physical_packer_service_proxyClient::send_packer_ping_p(const std::string& session_id, const std::string& addr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("packer_ping_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_packer_ping_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyClient::recv_packer_ping_p(service_info& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("packer_ping_p") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  physical_packer_service_proxy_packer_ping_p_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "packer_ping_p failed: unknown result");
}

void physical_packer_service_proxyClient::take_snapshots_p(std::vector<snapshot> & _return, const std::string& session_id, const std::string& addr, const std::set<std::string> & disks)
{
  send_take_snapshots_p(session_id, addr, disks);
  recv_take_snapshots_p(_return);
}

void physical_packer_service_proxyClient::send_take_snapshots_p(const std::string& session_id, const std::string& addr, const std::set<std::string> & disks)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("take_snapshots_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_take_snapshots_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.disks = &disks;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyClient::recv_take_snapshots_p(std::vector<snapshot> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("take_snapshots_p") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  physical_packer_service_proxy_take_snapshots_p_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.ouch) {
    throw result.ouch;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "take_snapshots_p failed: unknown result");
}

void physical_packer_service_proxyClient::take_snapshots_ex_p(std::vector<snapshot> & _return, const std::string& session_id, const std::string& addr, const std::set<std::string> & disks, const std::string& pre_script, const std::string& post_script)
{
  send_take_snapshots_ex_p(session_id, addr, disks, pre_script, post_script);
  recv_take_snapshots_ex_p(_return);
}

void physical_packer_service_proxyClient::send_take_snapshots_ex_p(const std::string& session_id, const std::string& addr, const std::set<std::string> & disks, const std::string& pre_script, const std::string& post_script)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("take_snapshots_ex_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_take_snapshots_ex_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.disks = &disks;
  args.pre_script = &pre_script;
  args.post_script = &post_script;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyClient::recv_take_snapshots_ex_p(std::vector<snapshot> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("take_snapshots_ex_p") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  physical_packer_service_proxy_take_snapshots_ex_p_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.ouch) {
    throw result.ouch;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "take_snapshots_ex_p failed: unknown result");
}

void physical_packer_service_proxyClient::delete_snapshot_p(delete_snapshot_result& _return, const std::string& session_id, const std::string& addr, const std::string& snapshot_id)
{
  send_delete_snapshot_p(session_id, addr, snapshot_id);
  recv_delete_snapshot_p(_return);
}

void physical_packer_service_proxyClient::send_delete_snapshot_p(const std::string& session_id, const std::string& addr, const std::string& snapshot_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("delete_snapshot_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_delete_snapshot_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.snapshot_id = &snapshot_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyClient::recv_delete_snapshot_p(delete_snapshot_result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("delete_snapshot_p") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  physical_packer_service_proxy_delete_snapshot_p_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.ouch) {
    throw result.ouch;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "delete_snapshot_p failed: unknown result");
}

void physical_packer_service_proxyClient::delete_snapshot_set_p(delete_snapshot_result& _return, const std::string& session_id, const std::string& addr, const std::string& snapshot_set_id)
{
  send_delete_snapshot_set_p(session_id, addr, snapshot_set_id);
  recv_delete_snapshot_set_p(_return);
}

void physical_packer_service_proxyClient::send_delete_snapshot_set_p(const std::string& session_id, const std::string& addr, const std::string& snapshot_set_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("delete_snapshot_set_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_delete_snapshot_set_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.snapshot_set_id = &snapshot_set_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyClient::recv_delete_snapshot_set_p(delete_snapshot_result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("delete_snapshot_set_p") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  physical_packer_service_proxy_delete_snapshot_set_p_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.ouch) {
    throw result.ouch;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "delete_snapshot_set_p failed: unknown result");
}

void physical_packer_service_proxyClient::get_all_snapshots_p(std::map<std::string, std::vector<snapshot> > & _return, const std::string& session_id, const std::string& addr)
{
  send_get_all_snapshots_p(session_id, addr);
  recv_get_all_snapshots_p(_return);
}

void physical_packer_service_proxyClient::send_get_all_snapshots_p(const std::string& session_id, const std::string& addr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("get_all_snapshots_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_get_all_snapshots_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyClient::recv_get_all_snapshots_p(std::map<std::string, std::vector<snapshot> > & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("get_all_snapshots_p") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  physical_packer_service_proxy_get_all_snapshots_p_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.ouch) {
    throw result.ouch;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_all_snapshots_p failed: unknown result");
}

void physical_packer_service_proxyClient::create_packer_job_ex_p(packer_job_detail& _return, const std::string& session_id, const std::string& addr, const std::string& job_id, const create_packer_job_detail& create_job)
{
  send_create_packer_job_ex_p(session_id, addr, job_id, create_job);
  recv_create_packer_job_ex_p(_return);
}

void physical_packer_service_proxyClient::send_create_packer_job_ex_p(const std::string& session_id, const std::string& addr, const std::string& job_id, const create_packer_job_detail& create_job)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("create_packer_job_ex_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_create_packer_job_ex_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.job_id = &job_id;
  args.create_job = &create_job;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyClient::recv_create_packer_job_ex_p(packer_job_detail& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("create_packer_job_ex_p") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  physical_packer_service_proxy_create_packer_job_ex_p_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.ouch) {
    throw result.ouch;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "create_packer_job_ex_p failed: unknown result");
}

void physical_packer_service_proxyClient::get_packer_job_p(packer_job_detail& _return, const std::string& session_id, const std::string& addr, const std::string& job_id, const std::string& previous_updated_time)
{
  send_get_packer_job_p(session_id, addr, job_id, previous_updated_time);
  recv_get_packer_job_p(_return);
}

void physical_packer_service_proxyClient::send_get_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id, const std::string& previous_updated_time)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("get_packer_job_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_get_packer_job_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.job_id = &job_id;
  args.previous_updated_time = &previous_updated_time;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyClient::recv_get_packer_job_p(packer_job_detail& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("get_packer_job_p") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  physical_packer_service_proxy_get_packer_job_p_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.ouch) {
    throw result.ouch;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_packer_job_p failed: unknown result");
}

bool physical_packer_service_proxyClient::interrupt_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  send_interrupt_packer_job_p(session_id, addr, job_id);
  return recv_interrupt_packer_job_p();
}

void physical_packer_service_proxyClient::send_interrupt_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("interrupt_packer_job_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_interrupt_packer_job_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.job_id = &job_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool physical_packer_service_proxyClient::recv_interrupt_packer_job_p()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("interrupt_packer_job_p") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  physical_packer_service_proxy_interrupt_packer_job_p_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.ouch) {
    throw result.ouch;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "interrupt_packer_job_p failed: unknown result");
}

bool physical_packer_service_proxyClient::resume_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  send_resume_packer_job_p(session_id, addr, job_id);
  return recv_resume_packer_job_p();
}

void physical_packer_service_proxyClient::send_resume_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("resume_packer_job_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_resume_packer_job_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.job_id = &job_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool physical_packer_service_proxyClient::recv_resume_packer_job_p()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("resume_packer_job_p") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  physical_packer_service_proxy_resume_packer_job_p_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.ouch) {
    throw result.ouch;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "resume_packer_job_p failed: unknown result");
}

bool physical_packer_service_proxyClient::remove_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  send_remove_packer_job_p(session_id, addr, job_id);
  return recv_remove_packer_job_p();
}

void physical_packer_service_proxyClient::send_remove_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("remove_packer_job_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_remove_packer_job_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.job_id = &job_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool physical_packer_service_proxyClient::recv_remove_packer_job_p()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("remove_packer_job_p") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  physical_packer_service_proxy_remove_packer_job_p_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.ouch) {
    throw result.ouch;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "remove_packer_job_p failed: unknown result");
}

bool physical_packer_service_proxyClient::running_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  send_running_packer_job_p(session_id, addr, job_id);
  return recv_running_packer_job_p();
}

void physical_packer_service_proxyClient::send_running_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("running_packer_job_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_running_packer_job_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.job_id = &job_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool physical_packer_service_proxyClient::recv_running_packer_job_p()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("running_packer_job_p") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  physical_packer_service_proxy_running_packer_job_p_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.ouch) {
    throw result.ouch;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "running_packer_job_p failed: unknown result");
}

void physical_packer_service_proxyClient::enumerate_packer_disks_p(std::set<disk_info> & _return, const std::string& session_id, const std::string& addr, const enumerate_disk_filter_style::type filter)
{
  send_enumerate_packer_disks_p(session_id, addr, filter);
  recv_enumerate_packer_disks_p(_return);
}

void physical_packer_service_proxyClient::send_enumerate_packer_disks_p(const std::string& session_id, const std::string& addr, const enumerate_disk_filter_style::type filter)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("enumerate_packer_disks_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_enumerate_packer_disks_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.filter = &filter;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyClient::recv_enumerate_packer_disks_p(std::set<disk_info> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("enumerate_packer_disks_p") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  physical_packer_service_proxy_enumerate_packer_disks_p_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.ouch) {
    throw result.ouch;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "enumerate_packer_disks_p failed: unknown result");
}

bool physical_packer_service_proxyClient::verify_packer_carrier_p(const std::string& session_id, const std::string& addr, const std::string& carrier, const bool is_ssl)
{
  send_verify_packer_carrier_p(session_id, addr, carrier, is_ssl);
  return recv_verify_packer_carrier_p();
}

void physical_packer_service_proxyClient::send_verify_packer_carrier_p(const std::string& session_id, const std::string& addr, const std::string& carrier, const bool is_ssl)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("verify_packer_carrier_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_verify_packer_carrier_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.carrier = &carrier;
  args.is_ssl = &is_ssl;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool physical_packer_service_proxyClient::recv_verify_packer_carrier_p()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("verify_packer_carrier_p") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  physical_packer_service_proxy_verify_packer_carrier_p_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.ouch) {
    throw result.ouch;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "verify_packer_carrier_p failed: unknown result");
}

void physical_packer_service_proxyClient::get_packer_host_detail_p(physical_machine_info& _return, const std::string& session_id, const std::string& addr, const machine_detail_filter::type filter)
{
  send_get_packer_host_detail_p(session_id, addr, filter);
  recv_get_packer_host_detail_p(_return);
}

void physical_packer_service_proxyClient::send_get_packer_host_detail_p(const std::string& session_id, const std::string& addr, const machine_detail_filter::type filter)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("get_packer_host_detail_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_get_packer_host_detail_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.filter = &filter;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyClient::recv_get_packer_host_detail_p(physical_machine_info& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("get_packer_host_detail_p") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  physical_packer_service_proxy_get_packer_host_detail_p_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.ouch) {
    throw result.ouch;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_packer_host_detail_p failed: unknown result");
}

bool physical_packer_service_proxyProcessor::dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext) {
  ProcessMap::iterator pfn;
  pfn = processMap_.find(fname);
  if (pfn == processMap_.end()) {
    return common_serviceProcessor::dispatchCall(iprot, oprot, fname, seqid, callContext);
  }
  (this->*(pfn->second))(seqid, iprot, oprot, callContext);
  return true;
}

void physical_packer_service_proxyProcessor::process_packer_ping_p(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.packer_ping_p", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.packer_ping_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.packer_ping_p");
  }

  physical_packer_service_proxy_packer_ping_p_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.packer_ping_p", bytes);
  }

  physical_packer_service_proxy_packer_ping_p_result result;
  try {
    iface_->packer_ping_p(result.success, args.session_id, args.addr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.packer_ping_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("packer_ping_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.packer_ping_p");
  }

  oprot->writeMessageBegin("packer_ping_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.packer_ping_p", bytes);
  }
}

void physical_packer_service_proxyProcessor::process_take_snapshots_p(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.take_snapshots_p", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.take_snapshots_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.take_snapshots_p");
  }

  physical_packer_service_proxy_take_snapshots_p_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.take_snapshots_p", bytes);
  }

  physical_packer_service_proxy_take_snapshots_p_result result;
  try {
    iface_->take_snapshots_p(result.success, args.session_id, args.addr, args.disks);
    result.__isset.success = true;
  } catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.take_snapshots_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("take_snapshots_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.take_snapshots_p");
  }

  oprot->writeMessageBegin("take_snapshots_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.take_snapshots_p", bytes);
  }
}

void physical_packer_service_proxyProcessor::process_take_snapshots_ex_p(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.take_snapshots_ex_p", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.take_snapshots_ex_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.take_snapshots_ex_p");
  }

  physical_packer_service_proxy_take_snapshots_ex_p_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.take_snapshots_ex_p", bytes);
  }

  physical_packer_service_proxy_take_snapshots_ex_p_result result;
  try {
    iface_->take_snapshots_ex_p(result.success, args.session_id, args.addr, args.disks, args.pre_script, args.post_script);
    result.__isset.success = true;
  } catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.take_snapshots_ex_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("take_snapshots_ex_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.take_snapshots_ex_p");
  }

  oprot->writeMessageBegin("take_snapshots_ex_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.take_snapshots_ex_p", bytes);
  }
}

void physical_packer_service_proxyProcessor::process_delete_snapshot_p(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.delete_snapshot_p", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.delete_snapshot_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.delete_snapshot_p");
  }

  physical_packer_service_proxy_delete_snapshot_p_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.delete_snapshot_p", bytes);
  }

  physical_packer_service_proxy_delete_snapshot_p_result result;
  try {
    iface_->delete_snapshot_p(result.success, args.session_id, args.addr, args.snapshot_id);
    result.__isset.success = true;
  } catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.delete_snapshot_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("delete_snapshot_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.delete_snapshot_p");
  }

  oprot->writeMessageBegin("delete_snapshot_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.delete_snapshot_p", bytes);
  }
}

void physical_packer_service_proxyProcessor::process_delete_snapshot_set_p(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.delete_snapshot_set_p", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.delete_snapshot_set_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.delete_snapshot_set_p");
  }

  physical_packer_service_proxy_delete_snapshot_set_p_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.delete_snapshot_set_p", bytes);
  }

  physical_packer_service_proxy_delete_snapshot_set_p_result result;
  try {
    iface_->delete_snapshot_set_p(result.success, args.session_id, args.addr, args.snapshot_set_id);
    result.__isset.success = true;
  } catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.delete_snapshot_set_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("delete_snapshot_set_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.delete_snapshot_set_p");
  }

  oprot->writeMessageBegin("delete_snapshot_set_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.delete_snapshot_set_p", bytes);
  }
}

void physical_packer_service_proxyProcessor::process_get_all_snapshots_p(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.get_all_snapshots_p", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.get_all_snapshots_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.get_all_snapshots_p");
  }

  physical_packer_service_proxy_get_all_snapshots_p_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.get_all_snapshots_p", bytes);
  }

  physical_packer_service_proxy_get_all_snapshots_p_result result;
  try {
    iface_->get_all_snapshots_p(result.success, args.session_id, args.addr);
    result.__isset.success = true;
  } catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.get_all_snapshots_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("get_all_snapshots_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.get_all_snapshots_p");
  }

  oprot->writeMessageBegin("get_all_snapshots_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.get_all_snapshots_p", bytes);
  }
}

void physical_packer_service_proxyProcessor::process_create_packer_job_ex_p(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.create_packer_job_ex_p", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.create_packer_job_ex_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.create_packer_job_ex_p");
  }

  physical_packer_service_proxy_create_packer_job_ex_p_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.create_packer_job_ex_p", bytes);
  }

  physical_packer_service_proxy_create_packer_job_ex_p_result result;
  try {
    iface_->create_packer_job_ex_p(result.success, args.session_id, args.addr, args.job_id, args.create_job);
    result.__isset.success = true;
  } catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.create_packer_job_ex_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("create_packer_job_ex_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.create_packer_job_ex_p");
  }

  oprot->writeMessageBegin("create_packer_job_ex_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.create_packer_job_ex_p", bytes);
  }
}

void physical_packer_service_proxyProcessor::process_get_packer_job_p(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.get_packer_job_p", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.get_packer_job_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.get_packer_job_p");
  }

  physical_packer_service_proxy_get_packer_job_p_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.get_packer_job_p", bytes);
  }

  physical_packer_service_proxy_get_packer_job_p_result result;
  try {
    iface_->get_packer_job_p(result.success, args.session_id, args.addr, args.job_id, args.previous_updated_time);
    result.__isset.success = true;
  } catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.get_packer_job_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("get_packer_job_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.get_packer_job_p");
  }

  oprot->writeMessageBegin("get_packer_job_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.get_packer_job_p", bytes);
  }
}

void physical_packer_service_proxyProcessor::process_interrupt_packer_job_p(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.interrupt_packer_job_p", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.interrupt_packer_job_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.interrupt_packer_job_p");
  }

  physical_packer_service_proxy_interrupt_packer_job_p_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.interrupt_packer_job_p", bytes);
  }

  physical_packer_service_proxy_interrupt_packer_job_p_result result;
  try {
    result.success = iface_->interrupt_packer_job_p(args.session_id, args.addr, args.job_id);
    result.__isset.success = true;
  } catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.interrupt_packer_job_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("interrupt_packer_job_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.interrupt_packer_job_p");
  }

  oprot->writeMessageBegin("interrupt_packer_job_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.interrupt_packer_job_p", bytes);
  }
}

void physical_packer_service_proxyProcessor::process_resume_packer_job_p(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.resume_packer_job_p", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.resume_packer_job_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.resume_packer_job_p");
  }

  physical_packer_service_proxy_resume_packer_job_p_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.resume_packer_job_p", bytes);
  }

  physical_packer_service_proxy_resume_packer_job_p_result result;
  try {
    result.success = iface_->resume_packer_job_p(args.session_id, args.addr, args.job_id);
    result.__isset.success = true;
  } catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.resume_packer_job_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("resume_packer_job_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.resume_packer_job_p");
  }

  oprot->writeMessageBegin("resume_packer_job_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.resume_packer_job_p", bytes);
  }
}

void physical_packer_service_proxyProcessor::process_remove_packer_job_p(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.remove_packer_job_p", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.remove_packer_job_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.remove_packer_job_p");
  }

  physical_packer_service_proxy_remove_packer_job_p_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.remove_packer_job_p", bytes);
  }

  physical_packer_service_proxy_remove_packer_job_p_result result;
  try {
    result.success = iface_->remove_packer_job_p(args.session_id, args.addr, args.job_id);
    result.__isset.success = true;
  } catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.remove_packer_job_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("remove_packer_job_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.remove_packer_job_p");
  }

  oprot->writeMessageBegin("remove_packer_job_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.remove_packer_job_p", bytes);
  }
}

void physical_packer_service_proxyProcessor::process_running_packer_job_p(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.running_packer_job_p", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.running_packer_job_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.running_packer_job_p");
  }

  physical_packer_service_proxy_running_packer_job_p_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.running_packer_job_p", bytes);
  }

  physical_packer_service_proxy_running_packer_job_p_result result;
  try {
    result.success = iface_->running_packer_job_p(args.session_id, args.addr, args.job_id);
    result.__isset.success = true;
  } catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.running_packer_job_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("running_packer_job_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.running_packer_job_p");
  }

  oprot->writeMessageBegin("running_packer_job_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.running_packer_job_p", bytes);
  }
}

void physical_packer_service_proxyProcessor::process_enumerate_packer_disks_p(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.enumerate_packer_disks_p", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.enumerate_packer_disks_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.enumerate_packer_disks_p");
  }

  physical_packer_service_proxy_enumerate_packer_disks_p_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.enumerate_packer_disks_p", bytes);
  }

  physical_packer_service_proxy_enumerate_packer_disks_p_result result;
  try {
    iface_->enumerate_packer_disks_p(result.success, args.session_id, args.addr, args.filter);
    result.__isset.success = true;
  } catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.enumerate_packer_disks_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("enumerate_packer_disks_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.enumerate_packer_disks_p");
  }

  oprot->writeMessageBegin("enumerate_packer_disks_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.enumerate_packer_disks_p", bytes);
  }
}

void physical_packer_service_proxyProcessor::process_verify_packer_carrier_p(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.verify_packer_carrier_p", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.verify_packer_carrier_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.verify_packer_carrier_p");
  }

  physical_packer_service_proxy_verify_packer_carrier_p_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.verify_packer_carrier_p", bytes);
  }

  physical_packer_service_proxy_verify_packer_carrier_p_result result;
  try {
    result.success = iface_->verify_packer_carrier_p(args.session_id, args.addr, args.carrier, args.is_ssl);
    result.__isset.success = true;
  } catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.verify_packer_carrier_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("verify_packer_carrier_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.verify_packer_carrier_p");
  }

  oprot->writeMessageBegin("verify_packer_carrier_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.verify_packer_carrier_p", bytes);
  }
}

void physical_packer_service_proxyProcessor::process_get_packer_host_detail_p(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.get_packer_host_detail_p", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.get_packer_host_detail_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.get_packer_host_detail_p");
  }

  physical_packer_service_proxy_get_packer_host_detail_p_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.get_packer_host_detail_p", bytes);
  }

  physical_packer_service_proxy_get_packer_host_detail_p_result result;
  try {
    iface_->get_packer_host_detail_p(result.success, args.session_id, args.addr, args.filter);
    result.__isset.success = true;
  } catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.get_packer_host_detail_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("get_packer_host_detail_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.get_packer_host_detail_p");
  }

  oprot->writeMessageBegin("get_packer_host_detail_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.get_packer_host_detail_p", bytes);
  }
}

::boost::shared_ptr< ::apache::thrift::TProcessor > physical_packer_service_proxyProcessorFactory::getProcessor(const ::apache::thrift::TConnectionInfo& connInfo) {
  ::apache::thrift::ReleaseHandler< physical_packer_service_proxyIfFactory > cleanup(handlerFactory_);
  ::boost::shared_ptr< physical_packer_service_proxyIf > handler(handlerFactory_->getHandler(connInfo), cleanup);
  ::boost::shared_ptr< ::apache::thrift::TProcessor > processor(new physical_packer_service_proxyProcessor(handler));
  return processor;
}

void physical_packer_service_proxyConcurrentClient::packer_ping_p(service_info& _return, const std::string& session_id, const std::string& addr)
{
  int32_t seqid = send_packer_ping_p(session_id, addr);
  recv_packer_ping_p(_return, seqid);
}

int32_t physical_packer_service_proxyConcurrentClient::send_packer_ping_p(const std::string& session_id, const std::string& addr)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("packer_ping_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_packer_ping_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void physical_packer_service_proxyConcurrentClient::recv_packer_ping_p(service_info& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("packer_ping_p") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      physical_packer_service_proxy_packer_ping_p_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "packer_ping_p failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void physical_packer_service_proxyConcurrentClient::take_snapshots_p(std::vector<snapshot> & _return, const std::string& session_id, const std::string& addr, const std::set<std::string> & disks)
{
  int32_t seqid = send_take_snapshots_p(session_id, addr, disks);
  recv_take_snapshots_p(_return, seqid);
}

int32_t physical_packer_service_proxyConcurrentClient::send_take_snapshots_p(const std::string& session_id, const std::string& addr, const std::set<std::string> & disks)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("take_snapshots_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_take_snapshots_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.disks = &disks;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void physical_packer_service_proxyConcurrentClient::recv_take_snapshots_p(std::vector<snapshot> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("take_snapshots_p") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      physical_packer_service_proxy_take_snapshots_p_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.ouch) {
        sentry.commit();
        throw result.ouch;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "take_snapshots_p failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void physical_packer_service_proxyConcurrentClient::take_snapshots_ex_p(std::vector<snapshot> & _return, const std::string& session_id, const std::string& addr, const std::set<std::string> & disks, const std::string& pre_script, const std::string& post_script)
{
  int32_t seqid = send_take_snapshots_ex_p(session_id, addr, disks, pre_script, post_script);
  recv_take_snapshots_ex_p(_return, seqid);
}

int32_t physical_packer_service_proxyConcurrentClient::send_take_snapshots_ex_p(const std::string& session_id, const std::string& addr, const std::set<std::string> & disks, const std::string& pre_script, const std::string& post_script)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("take_snapshots_ex_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_take_snapshots_ex_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.disks = &disks;
  args.pre_script = &pre_script;
  args.post_script = &post_script;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void physical_packer_service_proxyConcurrentClient::recv_take_snapshots_ex_p(std::vector<snapshot> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("take_snapshots_ex_p") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      physical_packer_service_proxy_take_snapshots_ex_p_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.ouch) {
        sentry.commit();
        throw result.ouch;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "take_snapshots_ex_p failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void physical_packer_service_proxyConcurrentClient::delete_snapshot_p(delete_snapshot_result& _return, const std::string& session_id, const std::string& addr, const std::string& snapshot_id)
{
  int32_t seqid = send_delete_snapshot_p(session_id, addr, snapshot_id);
  recv_delete_snapshot_p(_return, seqid);
}

int32_t physical_packer_service_proxyConcurrentClient::send_delete_snapshot_p(const std::string& session_id, const std::string& addr, const std::string& snapshot_id)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("delete_snapshot_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_delete_snapshot_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.snapshot_id = &snapshot_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void physical_packer_service_proxyConcurrentClient::recv_delete_snapshot_p(delete_snapshot_result& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("delete_snapshot_p") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      physical_packer_service_proxy_delete_snapshot_p_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.ouch) {
        sentry.commit();
        throw result.ouch;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "delete_snapshot_p failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void physical_packer_service_proxyConcurrentClient::delete_snapshot_set_p(delete_snapshot_result& _return, const std::string& session_id, const std::string& addr, const std::string& snapshot_set_id)
{
  int32_t seqid = send_delete_snapshot_set_p(session_id, addr, snapshot_set_id);
  recv_delete_snapshot_set_p(_return, seqid);
}

int32_t physical_packer_service_proxyConcurrentClient::send_delete_snapshot_set_p(const std::string& session_id, const std::string& addr, const std::string& snapshot_set_id)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("delete_snapshot_set_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_delete_snapshot_set_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.snapshot_set_id = &snapshot_set_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void physical_packer_service_proxyConcurrentClient::recv_delete_snapshot_set_p(delete_snapshot_result& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("delete_snapshot_set_p") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      physical_packer_service_proxy_delete_snapshot_set_p_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.ouch) {
        sentry.commit();
        throw result.ouch;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "delete_snapshot_set_p failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void physical_packer_service_proxyConcurrentClient::get_all_snapshots_p(std::map<std::string, std::vector<snapshot> > & _return, const std::string& session_id, const std::string& addr)
{
  int32_t seqid = send_get_all_snapshots_p(session_id, addr);
  recv_get_all_snapshots_p(_return, seqid);
}

int32_t physical_packer_service_proxyConcurrentClient::send_get_all_snapshots_p(const std::string& session_id, const std::string& addr)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("get_all_snapshots_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_get_all_snapshots_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void physical_packer_service_proxyConcurrentClient::recv_get_all_snapshots_p(std::map<std::string, std::vector<snapshot> > & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("get_all_snapshots_p") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      physical_packer_service_proxy_get_all_snapshots_p_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.ouch) {
        sentry.commit();
        throw result.ouch;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_all_snapshots_p failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void physical_packer_service_proxyConcurrentClient::create_packer_job_ex_p(packer_job_detail& _return, const std::string& session_id, const std::string& addr, const std::string& job_id, const create_packer_job_detail& create_job)
{
  int32_t seqid = send_create_packer_job_ex_p(session_id, addr, job_id, create_job);
  recv_create_packer_job_ex_p(_return, seqid);
}

int32_t physical_packer_service_proxyConcurrentClient::send_create_packer_job_ex_p(const std::string& session_id, const std::string& addr, const std::string& job_id, const create_packer_job_detail& create_job)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("create_packer_job_ex_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_create_packer_job_ex_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.job_id = &job_id;
  args.create_job = &create_job;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void physical_packer_service_proxyConcurrentClient::recv_create_packer_job_ex_p(packer_job_detail& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("create_packer_job_ex_p") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      physical_packer_service_proxy_create_packer_job_ex_p_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.ouch) {
        sentry.commit();
        throw result.ouch;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "create_packer_job_ex_p failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void physical_packer_service_proxyConcurrentClient::get_packer_job_p(packer_job_detail& _return, const std::string& session_id, const std::string& addr, const std::string& job_id, const std::string& previous_updated_time)
{
  int32_t seqid = send_get_packer_job_p(session_id, addr, job_id, previous_updated_time);
  recv_get_packer_job_p(_return, seqid);
}

int32_t physical_packer_service_proxyConcurrentClient::send_get_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id, const std::string& previous_updated_time)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("get_packer_job_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_get_packer_job_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.job_id = &job_id;
  args.previous_updated_time = &previous_updated_time;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void physical_packer_service_proxyConcurrentClient::recv_get_packer_job_p(packer_job_detail& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("get_packer_job_p") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      physical_packer_service_proxy_get_packer_job_p_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.ouch) {
        sentry.commit();
        throw result.ouch;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_packer_job_p failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

bool physical_packer_service_proxyConcurrentClient::interrupt_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  int32_t seqid = send_interrupt_packer_job_p(session_id, addr, job_id);
  return recv_interrupt_packer_job_p(seqid);
}

int32_t physical_packer_service_proxyConcurrentClient::send_interrupt_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("interrupt_packer_job_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_interrupt_packer_job_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.job_id = &job_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool physical_packer_service_proxyConcurrentClient::recv_interrupt_packer_job_p(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("interrupt_packer_job_p") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      physical_packer_service_proxy_interrupt_packer_job_p_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      if (result.__isset.ouch) {
        sentry.commit();
        throw result.ouch;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "interrupt_packer_job_p failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

bool physical_packer_service_proxyConcurrentClient::resume_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  int32_t seqid = send_resume_packer_job_p(session_id, addr, job_id);
  return recv_resume_packer_job_p(seqid);
}

int32_t physical_packer_service_proxyConcurrentClient::send_resume_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("resume_packer_job_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_resume_packer_job_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.job_id = &job_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool physical_packer_service_proxyConcurrentClient::recv_resume_packer_job_p(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("resume_packer_job_p") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      physical_packer_service_proxy_resume_packer_job_p_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      if (result.__isset.ouch) {
        sentry.commit();
        throw result.ouch;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "resume_packer_job_p failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

bool physical_packer_service_proxyConcurrentClient::remove_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  int32_t seqid = send_remove_packer_job_p(session_id, addr, job_id);
  return recv_remove_packer_job_p(seqid);
}

int32_t physical_packer_service_proxyConcurrentClient::send_remove_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("remove_packer_job_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_remove_packer_job_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.job_id = &job_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool physical_packer_service_proxyConcurrentClient::recv_remove_packer_job_p(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("remove_packer_job_p") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      physical_packer_service_proxy_remove_packer_job_p_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      if (result.__isset.ouch) {
        sentry.commit();
        throw result.ouch;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "remove_packer_job_p failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

bool physical_packer_service_proxyConcurrentClient::running_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  int32_t seqid = send_running_packer_job_p(session_id, addr, job_id);
  return recv_running_packer_job_p(seqid);
}

int32_t physical_packer_service_proxyConcurrentClient::send_running_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("running_packer_job_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_running_packer_job_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.job_id = &job_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool physical_packer_service_proxyConcurrentClient::recv_running_packer_job_p(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("running_packer_job_p") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      physical_packer_service_proxy_running_packer_job_p_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      if (result.__isset.ouch) {
        sentry.commit();
        throw result.ouch;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "running_packer_job_p failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void physical_packer_service_proxyConcurrentClient::enumerate_packer_disks_p(std::set<disk_info> & _return, const std::string& session_id, const std::string& addr, const enumerate_disk_filter_style::type filter)
{
  int32_t seqid = send_enumerate_packer_disks_p(session_id, addr, filter);
  recv_enumerate_packer_disks_p(_return, seqid);
}

int32_t physical_packer_service_proxyConcurrentClient::send_enumerate_packer_disks_p(const std::string& session_id, const std::string& addr, const enumerate_disk_filter_style::type filter)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("enumerate_packer_disks_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_enumerate_packer_disks_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.filter = &filter;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void physical_packer_service_proxyConcurrentClient::recv_enumerate_packer_disks_p(std::set<disk_info> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("enumerate_packer_disks_p") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      physical_packer_service_proxy_enumerate_packer_disks_p_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.ouch) {
        sentry.commit();
        throw result.ouch;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "enumerate_packer_disks_p failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

bool physical_packer_service_proxyConcurrentClient::verify_packer_carrier_p(const std::string& session_id, const std::string& addr, const std::string& carrier, const bool is_ssl)
{
  int32_t seqid = send_verify_packer_carrier_p(session_id, addr, carrier, is_ssl);
  return recv_verify_packer_carrier_p(seqid);
}

int32_t physical_packer_service_proxyConcurrentClient::send_verify_packer_carrier_p(const std::string& session_id, const std::string& addr, const std::string& carrier, const bool is_ssl)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("verify_packer_carrier_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_verify_packer_carrier_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.carrier = &carrier;
  args.is_ssl = &is_ssl;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool physical_packer_service_proxyConcurrentClient::recv_verify_packer_carrier_p(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("verify_packer_carrier_p") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      physical_packer_service_proxy_verify_packer_carrier_p_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      if (result.__isset.ouch) {
        sentry.commit();
        throw result.ouch;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "verify_packer_carrier_p failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void physical_packer_service_proxyConcurrentClient::get_packer_host_detail_p(physical_machine_info& _return, const std::string& session_id, const std::string& addr, const machine_detail_filter::type filter)
{
  int32_t seqid = send_get_packer_host_detail_p(session_id, addr, filter);
  recv_get_packer_host_detail_p(_return, seqid);
}

int32_t physical_packer_service_proxyConcurrentClient::send_get_packer_host_detail_p(const std::string& session_id, const std::string& addr, const machine_detail_filter::type filter)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("get_packer_host_detail_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_get_packer_host_detail_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.filter = &filter;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void physical_packer_service_proxyConcurrentClient::recv_get_packer_host_detail_p(physical_machine_info& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("get_packer_host_detail_p") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      physical_packer_service_proxy_get_packer_host_detail_p_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.ouch) {
        sentry.commit();
        throw result.ouch;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_packer_host_detail_p failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void physical_packer_service_proxyCobClient::packer_ping_p(tcxx::function<void(physical_packer_service_proxyCobClient* client)> cob, const std::string& session_id, const std::string& addr)
{
  send_packer_ping_p(session_id, addr);
  channel_->sendAndRecvMessage(tcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void physical_packer_service_proxyCobClient::send_packer_ping_p(const std::string& session_id, const std::string& addr)
{
  int32_t cseqid = 0;
  otrans_->resetBuffer();
  oprot_->writeMessageBegin("packer_ping_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_packer_ping_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyCobClient::recv_packer_ping_p(service_info& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("packer_ping_p") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    physical_packer_service_proxy_packer_ping_p_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "packer_ping_p failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void physical_packer_service_proxyCobClient::take_snapshots_p(tcxx::function<void(physical_packer_service_proxyCobClient* client)> cob, const std::string& session_id, const std::string& addr, const std::set<std::string> & disks)
{
  send_take_snapshots_p(session_id, addr, disks);
  channel_->sendAndRecvMessage(tcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void physical_packer_service_proxyCobClient::send_take_snapshots_p(const std::string& session_id, const std::string& addr, const std::set<std::string> & disks)
{
  int32_t cseqid = 0;
  otrans_->resetBuffer();
  oprot_->writeMessageBegin("take_snapshots_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_take_snapshots_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.disks = &disks;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyCobClient::recv_take_snapshots_p(std::vector<snapshot> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("take_snapshots_p") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    physical_packer_service_proxy_take_snapshots_p_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    if (result.__isset.ouch) {
      completed = true;
      completed__(true);
      throw result.ouch;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "take_snapshots_p failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void physical_packer_service_proxyCobClient::take_snapshots_ex_p(tcxx::function<void(physical_packer_service_proxyCobClient* client)> cob, const std::string& session_id, const std::string& addr, const std::set<std::string> & disks, const std::string& pre_script, const std::string& post_script)
{
  send_take_snapshots_ex_p(session_id, addr, disks, pre_script, post_script);
  channel_->sendAndRecvMessage(tcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void physical_packer_service_proxyCobClient::send_take_snapshots_ex_p(const std::string& session_id, const std::string& addr, const std::set<std::string> & disks, const std::string& pre_script, const std::string& post_script)
{
  int32_t cseqid = 0;
  otrans_->resetBuffer();
  oprot_->writeMessageBegin("take_snapshots_ex_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_take_snapshots_ex_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.disks = &disks;
  args.pre_script = &pre_script;
  args.post_script = &post_script;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyCobClient::recv_take_snapshots_ex_p(std::vector<snapshot> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("take_snapshots_ex_p") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    physical_packer_service_proxy_take_snapshots_ex_p_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    if (result.__isset.ouch) {
      completed = true;
      completed__(true);
      throw result.ouch;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "take_snapshots_ex_p failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void physical_packer_service_proxyCobClient::delete_snapshot_p(tcxx::function<void(physical_packer_service_proxyCobClient* client)> cob, const std::string& session_id, const std::string& addr, const std::string& snapshot_id)
{
  send_delete_snapshot_p(session_id, addr, snapshot_id);
  channel_->sendAndRecvMessage(tcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void physical_packer_service_proxyCobClient::send_delete_snapshot_p(const std::string& session_id, const std::string& addr, const std::string& snapshot_id)
{
  int32_t cseqid = 0;
  otrans_->resetBuffer();
  oprot_->writeMessageBegin("delete_snapshot_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_delete_snapshot_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.snapshot_id = &snapshot_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyCobClient::recv_delete_snapshot_p(delete_snapshot_result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("delete_snapshot_p") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    physical_packer_service_proxy_delete_snapshot_p_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    if (result.__isset.ouch) {
      completed = true;
      completed__(true);
      throw result.ouch;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "delete_snapshot_p failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void physical_packer_service_proxyCobClient::delete_snapshot_set_p(tcxx::function<void(physical_packer_service_proxyCobClient* client)> cob, const std::string& session_id, const std::string& addr, const std::string& snapshot_set_id)
{
  send_delete_snapshot_set_p(session_id, addr, snapshot_set_id);
  channel_->sendAndRecvMessage(tcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void physical_packer_service_proxyCobClient::send_delete_snapshot_set_p(const std::string& session_id, const std::string& addr, const std::string& snapshot_set_id)
{
  int32_t cseqid = 0;
  otrans_->resetBuffer();
  oprot_->writeMessageBegin("delete_snapshot_set_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_delete_snapshot_set_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.snapshot_set_id = &snapshot_set_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyCobClient::recv_delete_snapshot_set_p(delete_snapshot_result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("delete_snapshot_set_p") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    physical_packer_service_proxy_delete_snapshot_set_p_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    if (result.__isset.ouch) {
      completed = true;
      completed__(true);
      throw result.ouch;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "delete_snapshot_set_p failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void physical_packer_service_proxyCobClient::get_all_snapshots_p(tcxx::function<void(physical_packer_service_proxyCobClient* client)> cob, const std::string& session_id, const std::string& addr)
{
  send_get_all_snapshots_p(session_id, addr);
  channel_->sendAndRecvMessage(tcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void physical_packer_service_proxyCobClient::send_get_all_snapshots_p(const std::string& session_id, const std::string& addr)
{
  int32_t cseqid = 0;
  otrans_->resetBuffer();
  oprot_->writeMessageBegin("get_all_snapshots_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_get_all_snapshots_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyCobClient::recv_get_all_snapshots_p(std::map<std::string, std::vector<snapshot> > & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("get_all_snapshots_p") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    physical_packer_service_proxy_get_all_snapshots_p_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    if (result.__isset.ouch) {
      completed = true;
      completed__(true);
      throw result.ouch;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_all_snapshots_p failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void physical_packer_service_proxyCobClient::create_packer_job_ex_p(tcxx::function<void(physical_packer_service_proxyCobClient* client)> cob, const std::string& session_id, const std::string& addr, const std::string& job_id, const create_packer_job_detail& create_job)
{
  send_create_packer_job_ex_p(session_id, addr, job_id, create_job);
  channel_->sendAndRecvMessage(tcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void physical_packer_service_proxyCobClient::send_create_packer_job_ex_p(const std::string& session_id, const std::string& addr, const std::string& job_id, const create_packer_job_detail& create_job)
{
  int32_t cseqid = 0;
  otrans_->resetBuffer();
  oprot_->writeMessageBegin("create_packer_job_ex_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_create_packer_job_ex_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.job_id = &job_id;
  args.create_job = &create_job;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyCobClient::recv_create_packer_job_ex_p(packer_job_detail& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("create_packer_job_ex_p") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    physical_packer_service_proxy_create_packer_job_ex_p_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    if (result.__isset.ouch) {
      completed = true;
      completed__(true);
      throw result.ouch;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "create_packer_job_ex_p failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void physical_packer_service_proxyCobClient::get_packer_job_p(tcxx::function<void(physical_packer_service_proxyCobClient* client)> cob, const std::string& session_id, const std::string& addr, const std::string& job_id, const std::string& previous_updated_time)
{
  send_get_packer_job_p(session_id, addr, job_id, previous_updated_time);
  channel_->sendAndRecvMessage(tcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void physical_packer_service_proxyCobClient::send_get_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id, const std::string& previous_updated_time)
{
  int32_t cseqid = 0;
  otrans_->resetBuffer();
  oprot_->writeMessageBegin("get_packer_job_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_get_packer_job_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.job_id = &job_id;
  args.previous_updated_time = &previous_updated_time;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyCobClient::recv_get_packer_job_p(packer_job_detail& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("get_packer_job_p") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    physical_packer_service_proxy_get_packer_job_p_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    if (result.__isset.ouch) {
      completed = true;
      completed__(true);
      throw result.ouch;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_packer_job_p failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void physical_packer_service_proxyCobClient::interrupt_packer_job_p(tcxx::function<void(physical_packer_service_proxyCobClient* client)> cob, const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  send_interrupt_packer_job_p(session_id, addr, job_id);
  channel_->sendAndRecvMessage(tcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void physical_packer_service_proxyCobClient::send_interrupt_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  int32_t cseqid = 0;
  otrans_->resetBuffer();
  oprot_->writeMessageBegin("interrupt_packer_job_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_interrupt_packer_job_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.job_id = &job_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool physical_packer_service_proxyCobClient::recv_interrupt_packer_job_p()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("interrupt_packer_job_p") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    bool _return;
    physical_packer_service_proxy_interrupt_packer_job_p_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      completed = true;
      completed__(true);
      return _return;
    }
    if (result.__isset.ouch) {
      completed = true;
      completed__(true);
      throw result.ouch;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "interrupt_packer_job_p failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void physical_packer_service_proxyCobClient::resume_packer_job_p(tcxx::function<void(physical_packer_service_proxyCobClient* client)> cob, const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  send_resume_packer_job_p(session_id, addr, job_id);
  channel_->sendAndRecvMessage(tcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void physical_packer_service_proxyCobClient::send_resume_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  int32_t cseqid = 0;
  otrans_->resetBuffer();
  oprot_->writeMessageBegin("resume_packer_job_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_resume_packer_job_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.job_id = &job_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool physical_packer_service_proxyCobClient::recv_resume_packer_job_p()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("resume_packer_job_p") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    bool _return;
    physical_packer_service_proxy_resume_packer_job_p_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      completed = true;
      completed__(true);
      return _return;
    }
    if (result.__isset.ouch) {
      completed = true;
      completed__(true);
      throw result.ouch;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "resume_packer_job_p failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void physical_packer_service_proxyCobClient::remove_packer_job_p(tcxx::function<void(physical_packer_service_proxyCobClient* client)> cob, const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  send_remove_packer_job_p(session_id, addr, job_id);
  channel_->sendAndRecvMessage(tcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void physical_packer_service_proxyCobClient::send_remove_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  int32_t cseqid = 0;
  otrans_->resetBuffer();
  oprot_->writeMessageBegin("remove_packer_job_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_remove_packer_job_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.job_id = &job_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool physical_packer_service_proxyCobClient::recv_remove_packer_job_p()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("remove_packer_job_p") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    bool _return;
    physical_packer_service_proxy_remove_packer_job_p_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      completed = true;
      completed__(true);
      return _return;
    }
    if (result.__isset.ouch) {
      completed = true;
      completed__(true);
      throw result.ouch;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "remove_packer_job_p failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void physical_packer_service_proxyCobClient::running_packer_job_p(tcxx::function<void(physical_packer_service_proxyCobClient* client)> cob, const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  send_running_packer_job_p(session_id, addr, job_id);
  channel_->sendAndRecvMessage(tcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void physical_packer_service_proxyCobClient::send_running_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  int32_t cseqid = 0;
  otrans_->resetBuffer();
  oprot_->writeMessageBegin("running_packer_job_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_running_packer_job_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.job_id = &job_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool physical_packer_service_proxyCobClient::recv_running_packer_job_p()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("running_packer_job_p") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    bool _return;
    physical_packer_service_proxy_running_packer_job_p_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      completed = true;
      completed__(true);
      return _return;
    }
    if (result.__isset.ouch) {
      completed = true;
      completed__(true);
      throw result.ouch;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "running_packer_job_p failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void physical_packer_service_proxyCobClient::enumerate_packer_disks_p(tcxx::function<void(physical_packer_service_proxyCobClient* client)> cob, const std::string& session_id, const std::string& addr, const enumerate_disk_filter_style::type filter)
{
  send_enumerate_packer_disks_p(session_id, addr, filter);
  channel_->sendAndRecvMessage(tcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void physical_packer_service_proxyCobClient::send_enumerate_packer_disks_p(const std::string& session_id, const std::string& addr, const enumerate_disk_filter_style::type filter)
{
  int32_t cseqid = 0;
  otrans_->resetBuffer();
  oprot_->writeMessageBegin("enumerate_packer_disks_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_enumerate_packer_disks_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.filter = &filter;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyCobClient::recv_enumerate_packer_disks_p(std::set<disk_info> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("enumerate_packer_disks_p") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    physical_packer_service_proxy_enumerate_packer_disks_p_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    if (result.__isset.ouch) {
      completed = true;
      completed__(true);
      throw result.ouch;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "enumerate_packer_disks_p failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void physical_packer_service_proxyCobClient::verify_packer_carrier_p(tcxx::function<void(physical_packer_service_proxyCobClient* client)> cob, const std::string& session_id, const std::string& addr, const std::string& carrier, const bool is_ssl)
{
  send_verify_packer_carrier_p(session_id, addr, carrier, is_ssl);
  channel_->sendAndRecvMessage(tcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void physical_packer_service_proxyCobClient::send_verify_packer_carrier_p(const std::string& session_id, const std::string& addr, const std::string& carrier, const bool is_ssl)
{
  int32_t cseqid = 0;
  otrans_->resetBuffer();
  oprot_->writeMessageBegin("verify_packer_carrier_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_verify_packer_carrier_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.carrier = &carrier;
  args.is_ssl = &is_ssl;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool physical_packer_service_proxyCobClient::recv_verify_packer_carrier_p()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("verify_packer_carrier_p") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    bool _return;
    physical_packer_service_proxy_verify_packer_carrier_p_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      completed = true;
      completed__(true);
      return _return;
    }
    if (result.__isset.ouch) {
      completed = true;
      completed__(true);
      throw result.ouch;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "verify_packer_carrier_p failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void physical_packer_service_proxyCobClient::get_packer_host_detail_p(tcxx::function<void(physical_packer_service_proxyCobClient* client)> cob, const std::string& session_id, const std::string& addr, const machine_detail_filter::type filter)
{
  send_get_packer_host_detail_p(session_id, addr, filter);
  channel_->sendAndRecvMessage(tcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void physical_packer_service_proxyCobClient::send_get_packer_host_detail_p(const std::string& session_id, const std::string& addr, const machine_detail_filter::type filter)
{
  int32_t cseqid = 0;
  otrans_->resetBuffer();
  oprot_->writeMessageBegin("get_packer_host_detail_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_get_packer_host_detail_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.filter = &filter;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyCobClient::recv_get_packer_host_detail_p(physical_machine_info& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("get_packer_host_detail_p") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    physical_packer_service_proxy_get_packer_host_detail_p_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    if (result.__isset.ouch) {
      completed = true;
      completed__(true);
      throw result.ouch;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_packer_host_detail_p failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void physical_packer_service_proxyAsyncProcessor::dispatchCall(tcxx::function<void(bool ok)> cob, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid) {
  ProcessMap::iterator pfn;
  pfn = processMap_.find(fname);
  if (pfn == processMap_.end()) {
    return common_serviceAsyncProcessor::dispatchCall(cob, iprot, oprot, fname, seqid);
  }
  (this->*(pfn->second))(cob, seqid, iprot, oprot);
  return;
}

void physical_packer_service_proxyAsyncProcessor::process_packer_ping_p(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  physical_packer_service_proxy_packer_ping_p_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.packer_ping_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.packer_ping_p");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.packer_ping_p");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.packer_ping_p", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.packer_ping_p");
    }
    return cob(false);
  }
  freer.unregister();
  void (physical_packer_service_proxyAsyncProcessor::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const service_info& _return) =
    &physical_packer_service_proxyAsyncProcessor::return_packer_ping_p;
  iface_->packer_ping_p(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.session_id,
      args.addr);
}

void physical_packer_service_proxyAsyncProcessor::return_packer_ping_p(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const service_info& _return)
{
  physical_packer_service_proxy_packer_ping_p_presult result;
  result.success = const_cast<service_info*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.packer_ping_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.packer_ping_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.packer_ping_p");
  }

  oprot->writeMessageBegin("packer_ping_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.packer_ping_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::process_take_snapshots_p(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  physical_packer_service_proxy_take_snapshots_p_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.take_snapshots_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.take_snapshots_p");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.take_snapshots_p");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.take_snapshots_p", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.take_snapshots_p");
    }
    return cob(false);
  }
  freer.unregister();
  void (physical_packer_service_proxyAsyncProcessor::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::vector<snapshot> & _return) =
    &physical_packer_service_proxyAsyncProcessor::return_take_snapshots_p;
  void (physical_packer_service_proxyAsyncProcessor::*throw_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &physical_packer_service_proxyAsyncProcessor::throw_take_snapshots_p;
  iface_->take_snapshots_p(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      tcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.session_id,
      args.addr,
      args.disks);
}

void physical_packer_service_proxyAsyncProcessor::return_take_snapshots_p(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::vector<snapshot> & _return)
{
  physical_packer_service_proxy_take_snapshots_p_presult result;
  result.success = const_cast<std::vector<snapshot> *>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.take_snapshots_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.take_snapshots_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.take_snapshots_p");
  }

  oprot->writeMessageBegin("take_snapshots_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.take_snapshots_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::throw_take_snapshots_p(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.take_snapshots_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.take_snapshots_p");

  physical_packer_service_proxy_take_snapshots_p_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.take_snapshots_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("take_snapshots_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.take_snapshots_p");
  }

  oprot->writeMessageBegin("take_snapshots_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.take_snapshots_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::process_take_snapshots_ex_p(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  physical_packer_service_proxy_take_snapshots_ex_p_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.take_snapshots_ex_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.take_snapshots_ex_p");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.take_snapshots_ex_p");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.take_snapshots_ex_p", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.take_snapshots_ex_p");
    }
    return cob(false);
  }
  freer.unregister();
  void (physical_packer_service_proxyAsyncProcessor::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::vector<snapshot> & _return) =
    &physical_packer_service_proxyAsyncProcessor::return_take_snapshots_ex_p;
  void (physical_packer_service_proxyAsyncProcessor::*throw_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &physical_packer_service_proxyAsyncProcessor::throw_take_snapshots_ex_p;
  iface_->take_snapshots_ex_p(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      tcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.session_id,
      args.addr,
      args.disks,
      args.pre_script,
      args.post_script);
}

void physical_packer_service_proxyAsyncProcessor::return_take_snapshots_ex_p(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::vector<snapshot> & _return)
{
  physical_packer_service_proxy_take_snapshots_ex_p_presult result;
  result.success = const_cast<std::vector<snapshot> *>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.take_snapshots_ex_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.take_snapshots_ex_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.take_snapshots_ex_p");
  }

  oprot->writeMessageBegin("take_snapshots_ex_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.take_snapshots_ex_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::throw_take_snapshots_ex_p(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.take_snapshots_ex_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.take_snapshots_ex_p");

  physical_packer_service_proxy_take_snapshots_ex_p_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.take_snapshots_ex_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("take_snapshots_ex_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.take_snapshots_ex_p");
  }

  oprot->writeMessageBegin("take_snapshots_ex_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.take_snapshots_ex_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::process_delete_snapshot_p(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  physical_packer_service_proxy_delete_snapshot_p_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.delete_snapshot_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.delete_snapshot_p");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.delete_snapshot_p");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.delete_snapshot_p", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.delete_snapshot_p");
    }
    return cob(false);
  }
  freer.unregister();
  void (physical_packer_service_proxyAsyncProcessor::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const delete_snapshot_result& _return) =
    &physical_packer_service_proxyAsyncProcessor::return_delete_snapshot_p;
  void (physical_packer_service_proxyAsyncProcessor::*throw_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &physical_packer_service_proxyAsyncProcessor::throw_delete_snapshot_p;
  iface_->delete_snapshot_p(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      tcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.session_id,
      args.addr,
      args.snapshot_id);
}

void physical_packer_service_proxyAsyncProcessor::return_delete_snapshot_p(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const delete_snapshot_result& _return)
{
  physical_packer_service_proxy_delete_snapshot_p_presult result;
  result.success = const_cast<delete_snapshot_result*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.delete_snapshot_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.delete_snapshot_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.delete_snapshot_p");
  }

  oprot->writeMessageBegin("delete_snapshot_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.delete_snapshot_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::throw_delete_snapshot_p(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.delete_snapshot_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.delete_snapshot_p");

  physical_packer_service_proxy_delete_snapshot_p_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.delete_snapshot_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("delete_snapshot_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.delete_snapshot_p");
  }

  oprot->writeMessageBegin("delete_snapshot_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.delete_snapshot_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::process_delete_snapshot_set_p(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  physical_packer_service_proxy_delete_snapshot_set_p_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.delete_snapshot_set_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.delete_snapshot_set_p");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.delete_snapshot_set_p");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.delete_snapshot_set_p", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.delete_snapshot_set_p");
    }
    return cob(false);
  }
  freer.unregister();
  void (physical_packer_service_proxyAsyncProcessor::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const delete_snapshot_result& _return) =
    &physical_packer_service_proxyAsyncProcessor::return_delete_snapshot_set_p;
  void (physical_packer_service_proxyAsyncProcessor::*throw_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &physical_packer_service_proxyAsyncProcessor::throw_delete_snapshot_set_p;
  iface_->delete_snapshot_set_p(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      tcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.session_id,
      args.addr,
      args.snapshot_set_id);
}

void physical_packer_service_proxyAsyncProcessor::return_delete_snapshot_set_p(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const delete_snapshot_result& _return)
{
  physical_packer_service_proxy_delete_snapshot_set_p_presult result;
  result.success = const_cast<delete_snapshot_result*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.delete_snapshot_set_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.delete_snapshot_set_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.delete_snapshot_set_p");
  }

  oprot->writeMessageBegin("delete_snapshot_set_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.delete_snapshot_set_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::throw_delete_snapshot_set_p(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.delete_snapshot_set_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.delete_snapshot_set_p");

  physical_packer_service_proxy_delete_snapshot_set_p_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.delete_snapshot_set_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("delete_snapshot_set_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.delete_snapshot_set_p");
  }

  oprot->writeMessageBegin("delete_snapshot_set_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.delete_snapshot_set_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::process_get_all_snapshots_p(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  physical_packer_service_proxy_get_all_snapshots_p_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.get_all_snapshots_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.get_all_snapshots_p");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.get_all_snapshots_p");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.get_all_snapshots_p", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.get_all_snapshots_p");
    }
    return cob(false);
  }
  freer.unregister();
  void (physical_packer_service_proxyAsyncProcessor::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::map<std::string, std::vector<snapshot> > & _return) =
    &physical_packer_service_proxyAsyncProcessor::return_get_all_snapshots_p;
  void (physical_packer_service_proxyAsyncProcessor::*throw_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &physical_packer_service_proxyAsyncProcessor::throw_get_all_snapshots_p;
  iface_->get_all_snapshots_p(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      tcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.session_id,
      args.addr);
}

void physical_packer_service_proxyAsyncProcessor::return_get_all_snapshots_p(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::map<std::string, std::vector<snapshot> > & _return)
{
  physical_packer_service_proxy_get_all_snapshots_p_presult result;
  result.success = const_cast<std::map<std::string, std::vector<snapshot> > *>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.get_all_snapshots_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.get_all_snapshots_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.get_all_snapshots_p");
  }

  oprot->writeMessageBegin("get_all_snapshots_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.get_all_snapshots_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::throw_get_all_snapshots_p(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.get_all_snapshots_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.get_all_snapshots_p");

  physical_packer_service_proxy_get_all_snapshots_p_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.get_all_snapshots_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("get_all_snapshots_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.get_all_snapshots_p");
  }

  oprot->writeMessageBegin("get_all_snapshots_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.get_all_snapshots_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::process_create_packer_job_ex_p(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  physical_packer_service_proxy_create_packer_job_ex_p_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.create_packer_job_ex_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.create_packer_job_ex_p");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.create_packer_job_ex_p");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.create_packer_job_ex_p", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.create_packer_job_ex_p");
    }
    return cob(false);
  }
  freer.unregister();
  void (physical_packer_service_proxyAsyncProcessor::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const packer_job_detail& _return) =
    &physical_packer_service_proxyAsyncProcessor::return_create_packer_job_ex_p;
  void (physical_packer_service_proxyAsyncProcessor::*throw_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &physical_packer_service_proxyAsyncProcessor::throw_create_packer_job_ex_p;
  iface_->create_packer_job_ex_p(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      tcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.session_id,
      args.addr,
      args.job_id,
      args.create_job);
}

void physical_packer_service_proxyAsyncProcessor::return_create_packer_job_ex_p(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const packer_job_detail& _return)
{
  physical_packer_service_proxy_create_packer_job_ex_p_presult result;
  result.success = const_cast<packer_job_detail*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.create_packer_job_ex_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.create_packer_job_ex_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.create_packer_job_ex_p");
  }

  oprot->writeMessageBegin("create_packer_job_ex_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.create_packer_job_ex_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::throw_create_packer_job_ex_p(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.create_packer_job_ex_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.create_packer_job_ex_p");

  physical_packer_service_proxy_create_packer_job_ex_p_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.create_packer_job_ex_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("create_packer_job_ex_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.create_packer_job_ex_p");
  }

  oprot->writeMessageBegin("create_packer_job_ex_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.create_packer_job_ex_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::process_get_packer_job_p(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  physical_packer_service_proxy_get_packer_job_p_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.get_packer_job_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.get_packer_job_p");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.get_packer_job_p");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.get_packer_job_p", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.get_packer_job_p");
    }
    return cob(false);
  }
  freer.unregister();
  void (physical_packer_service_proxyAsyncProcessor::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const packer_job_detail& _return) =
    &physical_packer_service_proxyAsyncProcessor::return_get_packer_job_p;
  void (physical_packer_service_proxyAsyncProcessor::*throw_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &physical_packer_service_proxyAsyncProcessor::throw_get_packer_job_p;
  iface_->get_packer_job_p(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      tcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.session_id,
      args.addr,
      args.job_id,
      args.previous_updated_time);
}

void physical_packer_service_proxyAsyncProcessor::return_get_packer_job_p(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const packer_job_detail& _return)
{
  physical_packer_service_proxy_get_packer_job_p_presult result;
  result.success = const_cast<packer_job_detail*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.get_packer_job_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.get_packer_job_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.get_packer_job_p");
  }

  oprot->writeMessageBegin("get_packer_job_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.get_packer_job_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::throw_get_packer_job_p(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.get_packer_job_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.get_packer_job_p");

  physical_packer_service_proxy_get_packer_job_p_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.get_packer_job_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("get_packer_job_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.get_packer_job_p");
  }

  oprot->writeMessageBegin("get_packer_job_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.get_packer_job_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::process_interrupt_packer_job_p(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  physical_packer_service_proxy_interrupt_packer_job_p_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.interrupt_packer_job_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.interrupt_packer_job_p");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.interrupt_packer_job_p");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.interrupt_packer_job_p", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.interrupt_packer_job_p");
    }
    return cob(false);
  }
  freer.unregister();
  void (physical_packer_service_proxyAsyncProcessor::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const bool& _return) =
    &physical_packer_service_proxyAsyncProcessor::return_interrupt_packer_job_p;
  void (physical_packer_service_proxyAsyncProcessor::*throw_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &physical_packer_service_proxyAsyncProcessor::throw_interrupt_packer_job_p;
  iface_->interrupt_packer_job_p(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      tcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.session_id,
      args.addr,
      args.job_id);
}

void physical_packer_service_proxyAsyncProcessor::return_interrupt_packer_job_p(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const bool& _return)
{
  physical_packer_service_proxy_interrupt_packer_job_p_presult result;
  result.success = const_cast<bool*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.interrupt_packer_job_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.interrupt_packer_job_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.interrupt_packer_job_p");
  }

  oprot->writeMessageBegin("interrupt_packer_job_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.interrupt_packer_job_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::throw_interrupt_packer_job_p(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.interrupt_packer_job_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.interrupt_packer_job_p");

  physical_packer_service_proxy_interrupt_packer_job_p_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.interrupt_packer_job_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("interrupt_packer_job_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.interrupt_packer_job_p");
  }

  oprot->writeMessageBegin("interrupt_packer_job_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.interrupt_packer_job_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::process_resume_packer_job_p(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  physical_packer_service_proxy_resume_packer_job_p_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.resume_packer_job_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.resume_packer_job_p");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.resume_packer_job_p");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.resume_packer_job_p", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.resume_packer_job_p");
    }
    return cob(false);
  }
  freer.unregister();
  void (physical_packer_service_proxyAsyncProcessor::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const bool& _return) =
    &physical_packer_service_proxyAsyncProcessor::return_resume_packer_job_p;
  void (physical_packer_service_proxyAsyncProcessor::*throw_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &physical_packer_service_proxyAsyncProcessor::throw_resume_packer_job_p;
  iface_->resume_packer_job_p(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      tcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.session_id,
      args.addr,
      args.job_id);
}

void physical_packer_service_proxyAsyncProcessor::return_resume_packer_job_p(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const bool& _return)
{
  physical_packer_service_proxy_resume_packer_job_p_presult result;
  result.success = const_cast<bool*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.resume_packer_job_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.resume_packer_job_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.resume_packer_job_p");
  }

  oprot->writeMessageBegin("resume_packer_job_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.resume_packer_job_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::throw_resume_packer_job_p(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.resume_packer_job_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.resume_packer_job_p");

  physical_packer_service_proxy_resume_packer_job_p_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.resume_packer_job_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("resume_packer_job_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.resume_packer_job_p");
  }

  oprot->writeMessageBegin("resume_packer_job_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.resume_packer_job_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::process_remove_packer_job_p(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  physical_packer_service_proxy_remove_packer_job_p_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.remove_packer_job_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.remove_packer_job_p");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.remove_packer_job_p");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.remove_packer_job_p", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.remove_packer_job_p");
    }
    return cob(false);
  }
  freer.unregister();
  void (physical_packer_service_proxyAsyncProcessor::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const bool& _return) =
    &physical_packer_service_proxyAsyncProcessor::return_remove_packer_job_p;
  void (physical_packer_service_proxyAsyncProcessor::*throw_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &physical_packer_service_proxyAsyncProcessor::throw_remove_packer_job_p;
  iface_->remove_packer_job_p(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      tcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.session_id,
      args.addr,
      args.job_id);
}

void physical_packer_service_proxyAsyncProcessor::return_remove_packer_job_p(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const bool& _return)
{
  physical_packer_service_proxy_remove_packer_job_p_presult result;
  result.success = const_cast<bool*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.remove_packer_job_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.remove_packer_job_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.remove_packer_job_p");
  }

  oprot->writeMessageBegin("remove_packer_job_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.remove_packer_job_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::throw_remove_packer_job_p(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.remove_packer_job_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.remove_packer_job_p");

  physical_packer_service_proxy_remove_packer_job_p_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.remove_packer_job_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("remove_packer_job_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.remove_packer_job_p");
  }

  oprot->writeMessageBegin("remove_packer_job_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.remove_packer_job_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::process_running_packer_job_p(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  physical_packer_service_proxy_running_packer_job_p_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.running_packer_job_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.running_packer_job_p");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.running_packer_job_p");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.running_packer_job_p", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.running_packer_job_p");
    }
    return cob(false);
  }
  freer.unregister();
  void (physical_packer_service_proxyAsyncProcessor::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const bool& _return) =
    &physical_packer_service_proxyAsyncProcessor::return_running_packer_job_p;
  void (physical_packer_service_proxyAsyncProcessor::*throw_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &physical_packer_service_proxyAsyncProcessor::throw_running_packer_job_p;
  iface_->running_packer_job_p(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      tcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.session_id,
      args.addr,
      args.job_id);
}

void physical_packer_service_proxyAsyncProcessor::return_running_packer_job_p(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const bool& _return)
{
  physical_packer_service_proxy_running_packer_job_p_presult result;
  result.success = const_cast<bool*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.running_packer_job_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.running_packer_job_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.running_packer_job_p");
  }

  oprot->writeMessageBegin("running_packer_job_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.running_packer_job_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::throw_running_packer_job_p(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.running_packer_job_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.running_packer_job_p");

  physical_packer_service_proxy_running_packer_job_p_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.running_packer_job_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("running_packer_job_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.running_packer_job_p");
  }

  oprot->writeMessageBegin("running_packer_job_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.running_packer_job_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::process_enumerate_packer_disks_p(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  physical_packer_service_proxy_enumerate_packer_disks_p_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.enumerate_packer_disks_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.enumerate_packer_disks_p");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.enumerate_packer_disks_p");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.enumerate_packer_disks_p", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.enumerate_packer_disks_p");
    }
    return cob(false);
  }
  freer.unregister();
  void (physical_packer_service_proxyAsyncProcessor::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::set<disk_info> & _return) =
    &physical_packer_service_proxyAsyncProcessor::return_enumerate_packer_disks_p;
  void (physical_packer_service_proxyAsyncProcessor::*throw_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &physical_packer_service_proxyAsyncProcessor::throw_enumerate_packer_disks_p;
  iface_->enumerate_packer_disks_p(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      tcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.session_id,
      args.addr,
      args.filter);
}

void physical_packer_service_proxyAsyncProcessor::return_enumerate_packer_disks_p(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::set<disk_info> & _return)
{
  physical_packer_service_proxy_enumerate_packer_disks_p_presult result;
  result.success = const_cast<std::set<disk_info> *>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.enumerate_packer_disks_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.enumerate_packer_disks_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.enumerate_packer_disks_p");
  }

  oprot->writeMessageBegin("enumerate_packer_disks_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.enumerate_packer_disks_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::throw_enumerate_packer_disks_p(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.enumerate_packer_disks_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.enumerate_packer_disks_p");

  physical_packer_service_proxy_enumerate_packer_disks_p_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.enumerate_packer_disks_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("enumerate_packer_disks_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.enumerate_packer_disks_p");
  }

  oprot->writeMessageBegin("enumerate_packer_disks_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.enumerate_packer_disks_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::process_verify_packer_carrier_p(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  physical_packer_service_proxy_verify_packer_carrier_p_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.verify_packer_carrier_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.verify_packer_carrier_p");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.verify_packer_carrier_p");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.verify_packer_carrier_p", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.verify_packer_carrier_p");
    }
    return cob(false);
  }
  freer.unregister();
  void (physical_packer_service_proxyAsyncProcessor::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const bool& _return) =
    &physical_packer_service_proxyAsyncProcessor::return_verify_packer_carrier_p;
  void (physical_packer_service_proxyAsyncProcessor::*throw_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &physical_packer_service_proxyAsyncProcessor::throw_verify_packer_carrier_p;
  iface_->verify_packer_carrier_p(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      tcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.session_id,
      args.addr,
      args.carrier,
      args.is_ssl);
}

void physical_packer_service_proxyAsyncProcessor::return_verify_packer_carrier_p(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const bool& _return)
{
  physical_packer_service_proxy_verify_packer_carrier_p_presult result;
  result.success = const_cast<bool*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.verify_packer_carrier_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.verify_packer_carrier_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.verify_packer_carrier_p");
  }

  oprot->writeMessageBegin("verify_packer_carrier_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.verify_packer_carrier_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::throw_verify_packer_carrier_p(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.verify_packer_carrier_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.verify_packer_carrier_p");

  physical_packer_service_proxy_verify_packer_carrier_p_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.verify_packer_carrier_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("verify_packer_carrier_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.verify_packer_carrier_p");
  }

  oprot->writeMessageBegin("verify_packer_carrier_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.verify_packer_carrier_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::process_get_packer_host_detail_p(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  physical_packer_service_proxy_get_packer_host_detail_p_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.get_packer_host_detail_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.get_packer_host_detail_p");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.get_packer_host_detail_p");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.get_packer_host_detail_p", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.get_packer_host_detail_p");
    }
    return cob(false);
  }
  freer.unregister();
  void (physical_packer_service_proxyAsyncProcessor::*return_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const physical_machine_info& _return) =
    &physical_packer_service_proxyAsyncProcessor::return_get_packer_host_detail_p;
  void (physical_packer_service_proxyAsyncProcessor::*throw_fn)(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &physical_packer_service_proxyAsyncProcessor::throw_get_packer_host_detail_p;
  iface_->get_packer_host_detail_p(
      tcxx::bind(return_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      tcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, tcxx::placeholders::_1),
      args.session_id,
      args.addr,
      args.filter);
}

void physical_packer_service_proxyAsyncProcessor::return_get_packer_host_detail_p(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const physical_machine_info& _return)
{
  physical_packer_service_proxy_get_packer_host_detail_p_presult result;
  result.success = const_cast<physical_machine_info*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.get_packer_host_detail_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.get_packer_host_detail_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.get_packer_host_detail_p");
  }

  oprot->writeMessageBegin("get_packer_host_detail_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.get_packer_host_detail_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::throw_get_packer_host_detail_p(tcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.get_packer_host_detail_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.get_packer_host_detail_p");

  physical_packer_service_proxy_get_packer_host_detail_p_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.get_packer_host_detail_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("get_packer_host_detail_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.get_packer_host_detail_p");
  }

  oprot->writeMessageBegin("get_packer_host_detail_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.get_packer_host_detail_p", bytes);
  }
  return cob(true);
}

::boost::shared_ptr< ::apache::thrift::async::TAsyncProcessor > physical_packer_service_proxyAsyncProcessorFactory::getProcessor(const ::apache::thrift::TConnectionInfo& connInfo) {
  ::apache::thrift::ReleaseHandler< physical_packer_service_proxyCobSvIfFactory > cleanup(handlerFactory_);
  ::boost::shared_ptr< physical_packer_service_proxyCobSvIf > handler(handlerFactory_->getHandler(connInfo), cleanup);
  ::boost::shared_ptr< ::apache::thrift::async::TAsyncProcessor > processor(new physical_packer_service_proxyAsyncProcessor(handler));
  return processor;
}

}} // namespace

