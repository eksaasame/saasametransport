// This autogenerated skeleton file illustrates one way to adapt a synchronous
// interface into an asynchronous interface. You should copy it to another
// filename to avoid overwriting it and rewrite as asynchronous any functions
// that would otherwise introduce unwanted latency.

#include "message_switch.h"
#include <thrift/protocol/TBinaryProtocol.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::async;

using boost::shared_ptr;

using namespace  ::mwdc::ironman::remoting::thrift;

class message_switchAsyncHandler : public message_switchCobSvIf {
 public:
  message_switchAsyncHandler() {
    syncHandler_ = std::auto_ptr<message_switchHandler>(new message_switchHandler);
    // Your initialization goes here
  }
  virtual ~message_switchAsyncHandler();

  void login(tcxx::function<void(std::string const& _return)> cob, const std::string& account, const std::string& password) {
    std::string _return;
    syncHandler_->login(_return, account, password);
    return cob(_return);
  }

  void logout(tcxx::function<void()> cob, const std::string& session_id) {
    syncHandler_->logout(session_id);
    return cob();
  }

  void ping(tcxx::function<void(std::set<command_request>  const& _return)> cob, const std::string& session_id, const std::string& client_id, const std::string& machine_id, const int32_t status) {
    std::set<command_request>  _return;
    syncHandler_->ping(_return, session_id, client_id, machine_id, status);
    return cob(_return);
  }

  void upload_info(tcxx::function<void(std::set<command_request>  const& _return)> cob, const std::string& session_id, const std::string& client_id, const std::string& machine_id, const std::string& event_id, const client_info& client) {
    std::set<command_request>  _return;
    syncHandler_->upload_info(_return, session_id, client_id, machine_id, event_id, client);
    return cob(_return);
  }

  void get_serverinfo(tcxx::function<void(std::set<server_info>  const& _return)> cob, const std::string& session_id) {
    std::set<server_info>  _return;
    syncHandler_->get_serverinfo(_return, session_id);
    return cob(_return);
  }

  void upload_result(tcxx::function<void()> cob, const std::string& session_id, const std::string& client_id, const std::string& machine_id, const std::set<command_result> & results) {
    syncHandler_->upload_result(session_id, client_id, machine_id, results);
    return cob();
  }

 protected:
  std::auto_ptr<message_switchHandler> syncHandler_;
};

