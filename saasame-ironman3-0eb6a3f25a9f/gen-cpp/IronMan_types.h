/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef IronMan_TYPES_H
#define IronMan_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace mwdc { namespace ironman { namespace remoting { namespace thrift {

class disk_info;

class partition_info;

class volume_info;

class protection_relationship;

class protection_set;

class network_info;

class storage_info;

class server_info;

class cluster_network;

class cluster_group;

class cluster_info;

class agent_info;

class os_version_info;

class client_info;

class command_request;

class command_result;

typedef struct _disk_info__isset {
  _disk_info__isset() : boot_from_disk(true), bus_type(true), cluster_owner(true), cylinders(true), friend_name(true), guid(true), tracks_per_cylinder(true), is_boot(true), is_clustered(true), is_offline(true), is_readonly(true), is_snapshot(true), is_system(true), location(true), logical_sector_size(true), manufacturer(true), model(true), number(true), number_of_partitions(true), offline_reason(true), partition_style(true), path(true), physical_sector_size(true), sectors_per_track(true), serial_number(true), signature(true), size(true), storage_device_id(true), storage_server(true), uri(true) {}
  bool boot_from_disk :1;
  bool bus_type :1;
  bool cluster_owner :1;
  bool cylinders :1;
  bool friend_name :1;
  bool guid :1;
  bool tracks_per_cylinder :1;
  bool is_boot :1;
  bool is_clustered :1;
  bool is_offline :1;
  bool is_readonly :1;
  bool is_snapshot :1;
  bool is_system :1;
  bool location :1;
  bool logical_sector_size :1;
  bool manufacturer :1;
  bool model :1;
  bool number :1;
  bool number_of_partitions :1;
  bool offline_reason :1;
  bool partition_style :1;
  bool path :1;
  bool physical_sector_size :1;
  bool sectors_per_track :1;
  bool serial_number :1;
  bool signature :1;
  bool size :1;
  bool storage_device_id :1;
  bool storage_server :1;
  bool uri :1;
} _disk_info__isset;

class disk_info {
 public:

  static const char* ascii_fingerprint; // = "09DB4A5DED6A00DC0C8F72E3830808A3";
  static const uint8_t binary_fingerprint[16]; // = {0x09,0xDB,0x4A,0x5D,0xED,0x6A,0x00,0xDC,0x0C,0x8F,0x72,0xE3,0x83,0x08,0x08,0xA3};

  disk_info(const disk_info&);
  disk_info& operator=(const disk_info&);
  disk_info() : boot_from_disk(false), bus_type(-1), cluster_owner(""), cylinders(0LL), friend_name(""), guid(""), tracks_per_cylinder(0), is_boot(false), is_clustered(false), is_offline(false), is_readonly(false), is_snapshot(false), is_system(false), location(""), logical_sector_size(0LL), manufacturer(""), model(""), number(-1), number_of_partitions(-1), offline_reason(0), partition_style(2), path(""), physical_sector_size(0LL), sectors_per_track(0), serial_number(""), signature(0), size(0LL), storage_device_id(""), storage_server(""), uri("") {
  }

  virtual ~disk_info() throw();
  bool boot_from_disk;
  int16_t bus_type;
  std::string cluster_owner;
  int64_t cylinders;
  std::string friend_name;
  std::string guid;
  int32_t tracks_per_cylinder;
  bool is_boot;
  bool is_clustered;
  bool is_offline;
  bool is_readonly;
  bool is_snapshot;
  bool is_system;
  std::string location;
  int64_t logical_sector_size;
  std::string manufacturer;
  std::string model;
  int32_t number;
  int32_t number_of_partitions;
  int16_t offline_reason;
  int16_t partition_style;
  std::string path;
  int64_t physical_sector_size;
  int32_t sectors_per_track;
  std::string serial_number;
  int32_t signature;
  int64_t size;
  std::string storage_device_id;
  std::string storage_server;
  std::string uri;

  _disk_info__isset __isset;

  void __set_boot_from_disk(const bool val);

  void __set_bus_type(const int16_t val);

  void __set_cluster_owner(const std::string& val);

  void __set_cylinders(const int64_t val);

  void __set_friend_name(const std::string& val);

  void __set_guid(const std::string& val);

  void __set_tracks_per_cylinder(const int32_t val);

  void __set_is_boot(const bool val);

  void __set_is_clustered(const bool val);

  void __set_is_offline(const bool val);

  void __set_is_readonly(const bool val);

  void __set_is_snapshot(const bool val);

  void __set_is_system(const bool val);

  void __set_location(const std::string& val);

  void __set_logical_sector_size(const int64_t val);

  void __set_manufacturer(const std::string& val);

  void __set_model(const std::string& val);

  void __set_number(const int32_t val);

  void __set_number_of_partitions(const int32_t val);

  void __set_offline_reason(const int16_t val);

  void __set_partition_style(const int16_t val);

  void __set_path(const std::string& val);

  void __set_physical_sector_size(const int64_t val);

  void __set_sectors_per_track(const int32_t val);

  void __set_serial_number(const std::string& val);

  void __set_signature(const int32_t val);

  void __set_size(const int64_t val);

  void __set_storage_device_id(const std::string& val);

  void __set_storage_server(const std::string& val);

  void __set_uri(const std::string& val);

  bool operator == (const disk_info & rhs) const
  {
    if (__isset.boot_from_disk != rhs.__isset.boot_from_disk)
      return false;
    else if (__isset.boot_from_disk && !(boot_from_disk == rhs.boot_from_disk))
      return false;
    if (__isset.bus_type != rhs.__isset.bus_type)
      return false;
    else if (__isset.bus_type && !(bus_type == rhs.bus_type))
      return false;
    if (__isset.cluster_owner != rhs.__isset.cluster_owner)
      return false;
    else if (__isset.cluster_owner && !(cluster_owner == rhs.cluster_owner))
      return false;
    if (__isset.cylinders != rhs.__isset.cylinders)
      return false;
    else if (__isset.cylinders && !(cylinders == rhs.cylinders))
      return false;
    if (__isset.friend_name != rhs.__isset.friend_name)
      return false;
    else if (__isset.friend_name && !(friend_name == rhs.friend_name))
      return false;
    if (__isset.guid != rhs.__isset.guid)
      return false;
    else if (__isset.guid && !(guid == rhs.guid))
      return false;
    if (__isset.tracks_per_cylinder != rhs.__isset.tracks_per_cylinder)
      return false;
    else if (__isset.tracks_per_cylinder && !(tracks_per_cylinder == rhs.tracks_per_cylinder))
      return false;
    if (__isset.is_boot != rhs.__isset.is_boot)
      return false;
    else if (__isset.is_boot && !(is_boot == rhs.is_boot))
      return false;
    if (__isset.is_clustered != rhs.__isset.is_clustered)
      return false;
    else if (__isset.is_clustered && !(is_clustered == rhs.is_clustered))
      return false;
    if (__isset.is_offline != rhs.__isset.is_offline)
      return false;
    else if (__isset.is_offline && !(is_offline == rhs.is_offline))
      return false;
    if (__isset.is_readonly != rhs.__isset.is_readonly)
      return false;
    else if (__isset.is_readonly && !(is_readonly == rhs.is_readonly))
      return false;
    if (__isset.is_snapshot != rhs.__isset.is_snapshot)
      return false;
    else if (__isset.is_snapshot && !(is_snapshot == rhs.is_snapshot))
      return false;
    if (__isset.is_system != rhs.__isset.is_system)
      return false;
    else if (__isset.is_system && !(is_system == rhs.is_system))
      return false;
    if (__isset.location != rhs.__isset.location)
      return false;
    else if (__isset.location && !(location == rhs.location))
      return false;
    if (__isset.logical_sector_size != rhs.__isset.logical_sector_size)
      return false;
    else if (__isset.logical_sector_size && !(logical_sector_size == rhs.logical_sector_size))
      return false;
    if (__isset.manufacturer != rhs.__isset.manufacturer)
      return false;
    else if (__isset.manufacturer && !(manufacturer == rhs.manufacturer))
      return false;
    if (__isset.model != rhs.__isset.model)
      return false;
    else if (__isset.model && !(model == rhs.model))
      return false;
    if (__isset.number != rhs.__isset.number)
      return false;
    else if (__isset.number && !(number == rhs.number))
      return false;
    if (__isset.number_of_partitions != rhs.__isset.number_of_partitions)
      return false;
    else if (__isset.number_of_partitions && !(number_of_partitions == rhs.number_of_partitions))
      return false;
    if (__isset.offline_reason != rhs.__isset.offline_reason)
      return false;
    else if (__isset.offline_reason && !(offline_reason == rhs.offline_reason))
      return false;
    if (__isset.partition_style != rhs.__isset.partition_style)
      return false;
    else if (__isset.partition_style && !(partition_style == rhs.partition_style))
      return false;
    if (__isset.path != rhs.__isset.path)
      return false;
    else if (__isset.path && !(path == rhs.path))
      return false;
    if (__isset.physical_sector_size != rhs.__isset.physical_sector_size)
      return false;
    else if (__isset.physical_sector_size && !(physical_sector_size == rhs.physical_sector_size))
      return false;
    if (__isset.sectors_per_track != rhs.__isset.sectors_per_track)
      return false;
    else if (__isset.sectors_per_track && !(sectors_per_track == rhs.sectors_per_track))
      return false;
    if (__isset.serial_number != rhs.__isset.serial_number)
      return false;
    else if (__isset.serial_number && !(serial_number == rhs.serial_number))
      return false;
    if (__isset.signature != rhs.__isset.signature)
      return false;
    else if (__isset.signature && !(signature == rhs.signature))
      return false;
    if (__isset.size != rhs.__isset.size)
      return false;
    else if (__isset.size && !(size == rhs.size))
      return false;
    if (__isset.storage_device_id != rhs.__isset.storage_device_id)
      return false;
    else if (__isset.storage_device_id && !(storage_device_id == rhs.storage_device_id))
      return false;
    if (__isset.storage_server != rhs.__isset.storage_server)
      return false;
    else if (__isset.storage_server && !(storage_server == rhs.storage_server))
      return false;
    if (__isset.uri != rhs.__isset.uri)
      return false;
    else if (__isset.uri && !(uri == rhs.uri))
      return false;
    return true;
  }
  bool operator != (const disk_info &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const disk_info & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const disk_info& obj);
};

void swap(disk_info &a, disk_info &b);

typedef struct _partition_info__isset {
  _partition_info__isset() : access_paths(false), disk_number(true), drive_letter(true), gpt_type(true), guid(true), is_active(true), is_boot(true), is_hidden(true), is_offline(true), is_readonly(true), is_shadowcopy(true), is_system(true), mbr_type(true), offset(true), partition_number(true), size(true) {}
  bool access_paths :1;
  bool disk_number :1;
  bool drive_letter :1;
  bool gpt_type :1;
  bool guid :1;
  bool is_active :1;
  bool is_boot :1;
  bool is_hidden :1;
  bool is_offline :1;
  bool is_readonly :1;
  bool is_shadowcopy :1;
  bool is_system :1;
  bool mbr_type :1;
  bool offset :1;
  bool partition_number :1;
  bool size :1;
} _partition_info__isset;

class partition_info {
 public:

  static const char* ascii_fingerprint; // = "2838EA5A45F046B99982FD60699BA459";
  static const uint8_t binary_fingerprint[16]; // = {0x28,0x38,0xEA,0x5A,0x45,0xF0,0x46,0xB9,0x99,0x82,0xFD,0x60,0x69,0x9B,0xA4,0x59};

  partition_info(const partition_info&);
  partition_info& operator=(const partition_info&);
  partition_info() : disk_number(-1), drive_letter(""), gpt_type(""), guid(""), is_active(false), is_boot(false), is_hidden(false), is_offline(false), is_readonly(false), is_shadowcopy(false), is_system(false), mbr_type(0), offset(0LL), partition_number(-1), size(0LL) {
  }

  virtual ~partition_info() throw();
  std::set<std::string>  access_paths;
  int32_t disk_number;
  std::string drive_letter;
  std::string gpt_type;
  std::string guid;
  bool is_active;
  bool is_boot;
  bool is_hidden;
  bool is_offline;
  bool is_readonly;
  bool is_shadowcopy;
  bool is_system;
  int16_t mbr_type;
  int64_t offset;
  int32_t partition_number;
  int64_t size;

  _partition_info__isset __isset;

  void __set_access_paths(const std::set<std::string> & val);

  void __set_disk_number(const int32_t val);

  void __set_drive_letter(const std::string& val);

  void __set_gpt_type(const std::string& val);

  void __set_guid(const std::string& val);

  void __set_is_active(const bool val);

  void __set_is_boot(const bool val);

  void __set_is_hidden(const bool val);

  void __set_is_offline(const bool val);

  void __set_is_readonly(const bool val);

  void __set_is_shadowcopy(const bool val);

  void __set_is_system(const bool val);

  void __set_mbr_type(const int16_t val);

  void __set_offset(const int64_t val);

  void __set_partition_number(const int32_t val);

  void __set_size(const int64_t val);

  bool operator == (const partition_info & rhs) const
  {
    if (__isset.access_paths != rhs.__isset.access_paths)
      return false;
    else if (__isset.access_paths && !(access_paths == rhs.access_paths))
      return false;
    if (__isset.disk_number != rhs.__isset.disk_number)
      return false;
    else if (__isset.disk_number && !(disk_number == rhs.disk_number))
      return false;
    if (__isset.drive_letter != rhs.__isset.drive_letter)
      return false;
    else if (__isset.drive_letter && !(drive_letter == rhs.drive_letter))
      return false;
    if (__isset.gpt_type != rhs.__isset.gpt_type)
      return false;
    else if (__isset.gpt_type && !(gpt_type == rhs.gpt_type))
      return false;
    if (__isset.guid != rhs.__isset.guid)
      return false;
    else if (__isset.guid && !(guid == rhs.guid))
      return false;
    if (__isset.is_active != rhs.__isset.is_active)
      return false;
    else if (__isset.is_active && !(is_active == rhs.is_active))
      return false;
    if (__isset.is_boot != rhs.__isset.is_boot)
      return false;
    else if (__isset.is_boot && !(is_boot == rhs.is_boot))
      return false;
    if (__isset.is_hidden != rhs.__isset.is_hidden)
      return false;
    else if (__isset.is_hidden && !(is_hidden == rhs.is_hidden))
      return false;
    if (__isset.is_offline != rhs.__isset.is_offline)
      return false;
    else if (__isset.is_offline && !(is_offline == rhs.is_offline))
      return false;
    if (__isset.is_readonly != rhs.__isset.is_readonly)
      return false;
    else if (__isset.is_readonly && !(is_readonly == rhs.is_readonly))
      return false;
    if (__isset.is_shadowcopy != rhs.__isset.is_shadowcopy)
      return false;
    else if (__isset.is_shadowcopy && !(is_shadowcopy == rhs.is_shadowcopy))
      return false;
    if (__isset.is_system != rhs.__isset.is_system)
      return false;
    else if (__isset.is_system && !(is_system == rhs.is_system))
      return false;
    if (__isset.mbr_type != rhs.__isset.mbr_type)
      return false;
    else if (__isset.mbr_type && !(mbr_type == rhs.mbr_type))
      return false;
    if (__isset.offset != rhs.__isset.offset)
      return false;
    else if (__isset.offset && !(offset == rhs.offset))
      return false;
    if (__isset.partition_number != rhs.__isset.partition_number)
      return false;
    else if (__isset.partition_number && !(partition_number == rhs.partition_number))
      return false;
    if (__isset.size != rhs.__isset.size)
      return false;
    else if (__isset.size && !(size == rhs.size))
      return false;
    return true;
  }
  bool operator != (const partition_info &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const partition_info & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const partition_info& obj);
};

void swap(partition_info &a, partition_info &b);

typedef struct _volume_info__isset {
  _volume_info__isset() : access_paths(false), cluster_access_path(true), drive_letter(true), drive_type(true), file_system(true), file_system_catalogid(true), file_system_label(true), object_id(true), path(true), size(true), size_remaining(true) {}
  bool access_paths :1;
  bool cluster_access_path :1;
  bool drive_letter :1;
  bool drive_type :1;
  bool file_system :1;
  bool file_system_catalogid :1;
  bool file_system_label :1;
  bool object_id :1;
  bool path :1;
  bool size :1;
  bool size_remaining :1;
} _volume_info__isset;

class volume_info {
 public:

  static const char* ascii_fingerprint; // = "7E703337DA196F91F548DE52BCCDB580";
  static const uint8_t binary_fingerprint[16]; // = {0x7E,0x70,0x33,0x37,0xDA,0x19,0x6F,0x91,0xF5,0x48,0xDE,0x52,0xBC,0xCD,0xB5,0x80};

  volume_info(const volume_info&);
  volume_info& operator=(const volume_info&);
  volume_info() : cluster_access_path(""), drive_letter(""), drive_type(-1), file_system(""), file_system_catalogid(""), file_system_label(""), object_id(""), path(""), size(0LL), size_remaining(0LL) {
  }

  virtual ~volume_info() throw();
  std::set<std::string>  access_paths;
  std::string cluster_access_path;
  std::string drive_letter;
  int32_t drive_type;
  std::string file_system;
  std::string file_system_catalogid;
  std::string file_system_label;
  std::string object_id;
  std::string path;
  int64_t size;
  int64_t size_remaining;

  _volume_info__isset __isset;

  void __set_access_paths(const std::set<std::string> & val);

  void __set_cluster_access_path(const std::string& val);

  void __set_drive_letter(const std::string& val);

  void __set_drive_type(const int32_t val);

  void __set_file_system(const std::string& val);

  void __set_file_system_catalogid(const std::string& val);

  void __set_file_system_label(const std::string& val);

  void __set_object_id(const std::string& val);

  void __set_path(const std::string& val);

  void __set_size(const int64_t val);

  void __set_size_remaining(const int64_t val);

  bool operator == (const volume_info & rhs) const
  {
    if (__isset.access_paths != rhs.__isset.access_paths)
      return false;
    else if (__isset.access_paths && !(access_paths == rhs.access_paths))
      return false;
    if (__isset.cluster_access_path != rhs.__isset.cluster_access_path)
      return false;
    else if (__isset.cluster_access_path && !(cluster_access_path == rhs.cluster_access_path))
      return false;
    if (__isset.drive_letter != rhs.__isset.drive_letter)
      return false;
    else if (__isset.drive_letter && !(drive_letter == rhs.drive_letter))
      return false;
    if (__isset.drive_type != rhs.__isset.drive_type)
      return false;
    else if (__isset.drive_type && !(drive_type == rhs.drive_type))
      return false;
    if (__isset.file_system != rhs.__isset.file_system)
      return false;
    else if (__isset.file_system && !(file_system == rhs.file_system))
      return false;
    if (__isset.file_system_catalogid != rhs.__isset.file_system_catalogid)
      return false;
    else if (__isset.file_system_catalogid && !(file_system_catalogid == rhs.file_system_catalogid))
      return false;
    if (__isset.file_system_label != rhs.__isset.file_system_label)
      return false;
    else if (__isset.file_system_label && !(file_system_label == rhs.file_system_label))
      return false;
    if (__isset.object_id != rhs.__isset.object_id)
      return false;
    else if (__isset.object_id && !(object_id == rhs.object_id))
      return false;
    if (__isset.path != rhs.__isset.path)
      return false;
    else if (__isset.path && !(path == rhs.path))
      return false;
    if (__isset.size != rhs.__isset.size)
      return false;
    else if (__isset.size && !(size == rhs.size))
      return false;
    if (__isset.size_remaining != rhs.__isset.size_remaining)
      return false;
    else if (__isset.size_remaining && !(size_remaining == rhs.size_remaining))
      return false;
    return true;
  }
  bool operator != (const volume_info &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const volume_info & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const volume_info& obj);
};

void swap(volume_info &a, volume_info &b);

typedef struct _protection_relationship__isset {
  _protection_relationship__isset() : cluster_protection(true), mirror_serial(true), mirror_server(true), mirror_start_offset(true), mirror_uri(true), mirror_vid(true), primary_serial(true), primary_start_offset(true), primary_uri(true), site_id(true), site_ids(true) {}
  bool cluster_protection :1;
  bool mirror_serial :1;
  bool mirror_server :1;
  bool mirror_start_offset :1;
  bool mirror_uri :1;
  bool mirror_vid :1;
  bool primary_serial :1;
  bool primary_start_offset :1;
  bool primary_uri :1;
  bool site_id :1;
  bool site_ids :1;
} _protection_relationship__isset;

class protection_relationship {
 public:

  static const char* ascii_fingerprint; // = "6F136D548D07491F6ACD1DA6BB69F74F";
  static const uint8_t binary_fingerprint[16]; // = {0x6F,0x13,0x6D,0x54,0x8D,0x07,0x49,0x1F,0x6A,0xCD,0x1D,0xA6,0xBB,0x69,0xF7,0x4F};

  protection_relationship(const protection_relationship&);
  protection_relationship& operator=(const protection_relationship&);
  protection_relationship() : guid(""), cluster_protection(false), mirror_serial(""), mirror_server(""), mirror_start_offset(0LL), mirror_uri(""), mirror_vid(0LL), primary_serial(""), primary_start_offset(0LL), primary_uri(""), site_id(""), site_ids("") {
  }

  virtual ~protection_relationship() throw();
  std::string guid;
  bool cluster_protection;
  std::string mirror_serial;
  std::string mirror_server;
  int64_t mirror_start_offset;
  std::string mirror_uri;
  int64_t mirror_vid;
  std::string primary_serial;
  int64_t primary_start_offset;
  std::string primary_uri;
  std::string site_id;
  std::string site_ids;

  _protection_relationship__isset __isset;

  void __set_guid(const std::string& val);

  void __set_cluster_protection(const bool val);

  void __set_mirror_serial(const std::string& val);

  void __set_mirror_server(const std::string& val);

  void __set_mirror_start_offset(const int64_t val);

  void __set_mirror_uri(const std::string& val);

  void __set_mirror_vid(const int64_t val);

  void __set_primary_serial(const std::string& val);

  void __set_primary_start_offset(const int64_t val);

  void __set_primary_uri(const std::string& val);

  void __set_site_id(const std::string& val);

  void __set_site_ids(const std::string& val);

  bool operator == (const protection_relationship & rhs) const
  {
    if (!(guid == rhs.guid))
      return false;
    if (__isset.cluster_protection != rhs.__isset.cluster_protection)
      return false;
    else if (__isset.cluster_protection && !(cluster_protection == rhs.cluster_protection))
      return false;
    if (__isset.mirror_serial != rhs.__isset.mirror_serial)
      return false;
    else if (__isset.mirror_serial && !(mirror_serial == rhs.mirror_serial))
      return false;
    if (__isset.mirror_server != rhs.__isset.mirror_server)
      return false;
    else if (__isset.mirror_server && !(mirror_server == rhs.mirror_server))
      return false;
    if (__isset.mirror_start_offset != rhs.__isset.mirror_start_offset)
      return false;
    else if (__isset.mirror_start_offset && !(mirror_start_offset == rhs.mirror_start_offset))
      return false;
    if (__isset.mirror_uri != rhs.__isset.mirror_uri)
      return false;
    else if (__isset.mirror_uri && !(mirror_uri == rhs.mirror_uri))
      return false;
    if (__isset.mirror_vid != rhs.__isset.mirror_vid)
      return false;
    else if (__isset.mirror_vid && !(mirror_vid == rhs.mirror_vid))
      return false;
    if (__isset.primary_serial != rhs.__isset.primary_serial)
      return false;
    else if (__isset.primary_serial && !(primary_serial == rhs.primary_serial))
      return false;
    if (__isset.primary_start_offset != rhs.__isset.primary_start_offset)
      return false;
    else if (__isset.primary_start_offset && !(primary_start_offset == rhs.primary_start_offset))
      return false;
    if (__isset.primary_uri != rhs.__isset.primary_uri)
      return false;
    else if (__isset.primary_uri && !(primary_uri == rhs.primary_uri))
      return false;
    if (__isset.site_id != rhs.__isset.site_id)
      return false;
    else if (__isset.site_id && !(site_id == rhs.site_id))
      return false;
    if (__isset.site_ids != rhs.__isset.site_ids)
      return false;
    else if (__isset.site_ids && !(site_ids == rhs.site_ids))
      return false;
    return true;
  }
  bool operator != (const protection_relationship &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const protection_relationship & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const protection_relationship& obj);
};

void swap(protection_relationship &a, protection_relationship &b);

typedef struct _protection_set__isset {
  _protection_set__isset() : comment(true), mode(true), site_ids(true), site_name(true), protection_relationships(false) {}
  bool comment :1;
  bool mode :1;
  bool site_ids :1;
  bool site_name :1;
  bool protection_relationships :1;
} _protection_set__isset;

class protection_set {
 public:

  static const char* ascii_fingerprint; // = "6AFFFCD88F56575E4CFCCB7CB7DA2EA4";
  static const uint8_t binary_fingerprint[16]; // = {0x6A,0xFF,0xFC,0xD8,0x8F,0x56,0x57,0x5E,0x4C,0xFC,0xCB,0x7C,0xB7,0xDA,0x2E,0xA4};

  protection_set(const protection_set&);
  protection_set& operator=(const protection_set&);
  protection_set() : comment(""), mode(-1), site_ids(""), site_name("") {
  }

  virtual ~protection_set() throw();
  std::string comment;
  int32_t mode;
  std::string site_ids;
  std::string site_name;
  std::map<std::string, protection_relationship>  protection_relationships;

  _protection_set__isset __isset;

  void __set_comment(const std::string& val);

  void __set_mode(const int32_t val);

  void __set_site_ids(const std::string& val);

  void __set_site_name(const std::string& val);

  void __set_protection_relationships(const std::map<std::string, protection_relationship> & val);

  bool operator == (const protection_set & rhs) const
  {
    if (__isset.comment != rhs.__isset.comment)
      return false;
    else if (__isset.comment && !(comment == rhs.comment))
      return false;
    if (__isset.mode != rhs.__isset.mode)
      return false;
    else if (__isset.mode && !(mode == rhs.mode))
      return false;
    if (__isset.site_ids != rhs.__isset.site_ids)
      return false;
    else if (__isset.site_ids && !(site_ids == rhs.site_ids))
      return false;
    if (__isset.site_name != rhs.__isset.site_name)
      return false;
    else if (__isset.site_name && !(site_name == rhs.site_name))
      return false;
    if (__isset.protection_relationships != rhs.__isset.protection_relationships)
      return false;
    else if (__isset.protection_relationships && !(protection_relationships == rhs.protection_relationships))
      return false;
    return true;
  }
  bool operator != (const protection_set &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const protection_set & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const protection_set& obj);
};

void swap(protection_set &a, protection_set &b);

typedef struct _network_info__isset {
  _network_info__isset() : adapter_name(true), description(true), dnss(false), gateways(false), ip_addresses(false), is_dhcp_v4(true), is_dhcp_v6(true), mac_address(true), subnet_masks(false) {}
  bool adapter_name :1;
  bool description :1;
  bool dnss :1;
  bool gateways :1;
  bool ip_addresses :1;
  bool is_dhcp_v4 :1;
  bool is_dhcp_v6 :1;
  bool mac_address :1;
  bool subnet_masks :1;
} _network_info__isset;

class network_info {
 public:

  static const char* ascii_fingerprint; // = "DDDA7A540FF28949AE68C66C5FBB71E0";
  static const uint8_t binary_fingerprint[16]; // = {0xDD,0xDA,0x7A,0x54,0x0F,0xF2,0x89,0x49,0xAE,0x68,0xC6,0x6C,0x5F,0xBB,0x71,0xE0};

  network_info(const network_info&);
  network_info& operator=(const network_info&);
  network_info() : adapter_name(""), description(""), is_dhcp_v4(false), is_dhcp_v6(false), mac_address("") {
  }

  virtual ~network_info() throw();
  std::string adapter_name;
  std::string description;
  std::vector<std::string>  dnss;
  std::vector<std::string>  gateways;
  std::vector<std::string>  ip_addresses;
  bool is_dhcp_v4;
  bool is_dhcp_v6;
  std::string mac_address;
  std::vector<std::string>  subnet_masks;

  _network_info__isset __isset;

  void __set_adapter_name(const std::string& val);

  void __set_description(const std::string& val);

  void __set_dnss(const std::vector<std::string> & val);

  void __set_gateways(const std::vector<std::string> & val);

  void __set_ip_addresses(const std::vector<std::string> & val);

  void __set_is_dhcp_v4(const bool val);

  void __set_is_dhcp_v6(const bool val);

  void __set_mac_address(const std::string& val);

  void __set_subnet_masks(const std::vector<std::string> & val);

  bool operator == (const network_info & rhs) const
  {
    if (__isset.adapter_name != rhs.__isset.adapter_name)
      return false;
    else if (__isset.adapter_name && !(adapter_name == rhs.adapter_name))
      return false;
    if (__isset.description != rhs.__isset.description)
      return false;
    else if (__isset.description && !(description == rhs.description))
      return false;
    if (__isset.dnss != rhs.__isset.dnss)
      return false;
    else if (__isset.dnss && !(dnss == rhs.dnss))
      return false;
    if (__isset.gateways != rhs.__isset.gateways)
      return false;
    else if (__isset.gateways && !(gateways == rhs.gateways))
      return false;
    if (__isset.ip_addresses != rhs.__isset.ip_addresses)
      return false;
    else if (__isset.ip_addresses && !(ip_addresses == rhs.ip_addresses))
      return false;
    if (__isset.is_dhcp_v4 != rhs.__isset.is_dhcp_v4)
      return false;
    else if (__isset.is_dhcp_v4 && !(is_dhcp_v4 == rhs.is_dhcp_v4))
      return false;
    if (__isset.is_dhcp_v6 != rhs.__isset.is_dhcp_v6)
      return false;
    else if (__isset.is_dhcp_v6 && !(is_dhcp_v6 == rhs.is_dhcp_v6))
      return false;
    if (__isset.mac_address != rhs.__isset.mac_address)
      return false;
    else if (__isset.mac_address && !(mac_address == rhs.mac_address))
      return false;
    if (__isset.subnet_masks != rhs.__isset.subnet_masks)
      return false;
    else if (__isset.subnet_masks && !(subnet_masks == rhs.subnet_masks))
      return false;
    return true;
  }
  bool operator != (const network_info &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const network_info & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const network_info& obj);
};

void swap(network_info &a, network_info &b);

typedef struct _storage_info__isset {
  _storage_info__isset() : connection_type(true), protocol(true), storage_id(true), storage_name(true), network_infos(false), sanclient_names(false) {}
  bool connection_type :1;
  bool protocol :1;
  bool storage_id :1;
  bool storage_name :1;
  bool network_infos :1;
  bool sanclient_names :1;
} _storage_info__isset;

class storage_info {
 public:

  static const char* ascii_fingerprint; // = "E62053777EB83E74C5E383E2F603E879";
  static const uint8_t binary_fingerprint[16]; // = {0xE6,0x20,0x53,0x77,0x7E,0xB8,0x3E,0x74,0xC5,0xE3,0x83,0xE2,0xF6,0x03,0xE8,0x79};

  storage_info(const storage_info&);
  storage_info& operator=(const storage_info&);
  storage_info() : connection_type(-1), protocol(-1), storage_id(""), storage_name("") {
  }

  virtual ~storage_info() throw();
  int32_t connection_type;
  int32_t protocol;
  std::string storage_id;
  std::string storage_name;
  std::set<network_info>  network_infos;
  std::set<std::string>  sanclient_names;

  _storage_info__isset __isset;

  void __set_connection_type(const int32_t val);

  void __set_protocol(const int32_t val);

  void __set_storage_id(const std::string& val);

  void __set_storage_name(const std::string& val);

  void __set_network_infos(const std::set<network_info> & val);

  void __set_sanclient_names(const std::set<std::string> & val);

  bool operator == (const storage_info & rhs) const
  {
    if (__isset.connection_type != rhs.__isset.connection_type)
      return false;
    else if (__isset.connection_type && !(connection_type == rhs.connection_type))
      return false;
    if (__isset.protocol != rhs.__isset.protocol)
      return false;
    else if (__isset.protocol && !(protocol == rhs.protocol))
      return false;
    if (__isset.storage_id != rhs.__isset.storage_id)
      return false;
    else if (__isset.storage_id && !(storage_id == rhs.storage_id))
      return false;
    if (__isset.storage_name != rhs.__isset.storage_name)
      return false;
    else if (__isset.storage_name && !(storage_name == rhs.storage_name))
      return false;
    if (__isset.network_infos != rhs.__isset.network_infos)
      return false;
    else if (__isset.network_infos && !(network_infos == rhs.network_infos))
      return false;
    if (__isset.sanclient_names != rhs.__isset.sanclient_names)
      return false;
    else if (__isset.sanclient_names && !(sanclient_names == rhs.sanclient_names))
      return false;
    return true;
  }
  bool operator != (const storage_info &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const storage_info & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const storage_info& obj);
};

void swap(storage_info &a, storage_info &b);

typedef struct _server_info__isset {
  _server_info__isset() : initiator_name(true), server_id(true), server_name(true), network_infos(false) {}
  bool initiator_name :1;
  bool server_id :1;
  bool server_name :1;
  bool network_infos :1;
} _server_info__isset;

class server_info {
 public:

  static const char* ascii_fingerprint; // = "C0684AB42E8CC6DEAF815897FDB9122E";
  static const uint8_t binary_fingerprint[16]; // = {0xC0,0x68,0x4A,0xB4,0x2E,0x8C,0xC6,0xDE,0xAF,0x81,0x58,0x97,0xFD,0xB9,0x12,0x2E};

  server_info(const server_info&);
  server_info& operator=(const server_info&);
  server_info() : initiator_name(""), server_id(""), server_name("") {
  }

  virtual ~server_info() throw();
  std::string initiator_name;
  std::string server_id;
  std::string server_name;
  std::set<network_info>  network_infos;

  _server_info__isset __isset;

  void __set_initiator_name(const std::string& val);

  void __set_server_id(const std::string& val);

  void __set_server_name(const std::string& val);

  void __set_network_infos(const std::set<network_info> & val);

  bool operator == (const server_info & rhs) const
  {
    if (__isset.initiator_name != rhs.__isset.initiator_name)
      return false;
    else if (__isset.initiator_name && !(initiator_name == rhs.initiator_name))
      return false;
    if (__isset.server_id != rhs.__isset.server_id)
      return false;
    else if (__isset.server_id && !(server_id == rhs.server_id))
      return false;
    if (__isset.server_name != rhs.__isset.server_name)
      return false;
    else if (__isset.server_name && !(server_name == rhs.server_name))
      return false;
    if (__isset.network_infos != rhs.__isset.network_infos)
      return false;
    else if (__isset.network_infos && !(network_infos == rhs.network_infos))
      return false;
    return true;
  }
  bool operator != (const server_info &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const server_info & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const server_info& obj);
};

void swap(server_info &a, server_info &b);

typedef struct _cluster_network__isset {
  _cluster_network__isset() : cluster_network_name(true), cluster_network_id(true), cluster_network_address(true), cluster_network_address_mask(true), network_infos(false) {}
  bool cluster_network_name :1;
  bool cluster_network_id :1;
  bool cluster_network_address :1;
  bool cluster_network_address_mask :1;
  bool network_infos :1;
} _cluster_network__isset;

class cluster_network {
 public:

  static const char* ascii_fingerprint; // = "AF43E4841CC6FC09852238B8ACF26430";
  static const uint8_t binary_fingerprint[16]; // = {0xAF,0x43,0xE4,0x84,0x1C,0xC6,0xFC,0x09,0x85,0x22,0x38,0xB8,0xAC,0xF2,0x64,0x30};

  cluster_network(const cluster_network&);
  cluster_network& operator=(const cluster_network&);
  cluster_network() : cluster_network_name(""), cluster_network_id(""), cluster_network_address(""), cluster_network_address_mask("") {
  }

  virtual ~cluster_network() throw();
  std::string cluster_network_name;
  std::string cluster_network_id;
  std::string cluster_network_address;
  std::string cluster_network_address_mask;
  std::set<network_info>  network_infos;

  _cluster_network__isset __isset;

  void __set_cluster_network_name(const std::string& val);

  void __set_cluster_network_id(const std::string& val);

  void __set_cluster_network_address(const std::string& val);

  void __set_cluster_network_address_mask(const std::string& val);

  void __set_network_infos(const std::set<network_info> & val);

  bool operator == (const cluster_network & rhs) const
  {
    if (__isset.cluster_network_name != rhs.__isset.cluster_network_name)
      return false;
    else if (__isset.cluster_network_name && !(cluster_network_name == rhs.cluster_network_name))
      return false;
    if (__isset.cluster_network_id != rhs.__isset.cluster_network_id)
      return false;
    else if (__isset.cluster_network_id && !(cluster_network_id == rhs.cluster_network_id))
      return false;
    if (__isset.cluster_network_address != rhs.__isset.cluster_network_address)
      return false;
    else if (__isset.cluster_network_address && !(cluster_network_address == rhs.cluster_network_address))
      return false;
    if (__isset.cluster_network_address_mask != rhs.__isset.cluster_network_address_mask)
      return false;
    else if (__isset.cluster_network_address_mask && !(cluster_network_address_mask == rhs.cluster_network_address_mask))
      return false;
    if (__isset.network_infos != rhs.__isset.network_infos)
      return false;
    else if (__isset.network_infos && !(network_infos == rhs.network_infos))
      return false;
    return true;
  }
  bool operator != (const cluster_network &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const cluster_network & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const cluster_network& obj);
};

void swap(cluster_network &a, cluster_network &b);

typedef struct _cluster_group__isset {
  _cluster_group__isset() : group_id(true), group_name(true), group_owner(true), cluster_disks(false), cluster_partitions(false), cluster_network_infos(false) {}
  bool group_id :1;
  bool group_name :1;
  bool group_owner :1;
  bool cluster_disks :1;
  bool cluster_partitions :1;
  bool cluster_network_infos :1;
} _cluster_group__isset;

class cluster_group {
 public:

  static const char* ascii_fingerprint; // = "5C7E5267DAAC84834D6BA4237633DB5D";
  static const uint8_t binary_fingerprint[16]; // = {0x5C,0x7E,0x52,0x67,0xDA,0xAC,0x84,0x83,0x4D,0x6B,0xA4,0x23,0x76,0x33,0xDB,0x5D};

  cluster_group(const cluster_group&);
  cluster_group& operator=(const cluster_group&);
  cluster_group() : group_id(""), group_name(""), group_owner("") {
  }

  virtual ~cluster_group() throw();
  std::string group_id;
  std::string group_name;
  std::string group_owner;
  std::set<disk_info>  cluster_disks;
  std::set<volume_info>  cluster_partitions;
  std::set<cluster_network>  cluster_network_infos;

  _cluster_group__isset __isset;

  void __set_group_id(const std::string& val);

  void __set_group_name(const std::string& val);

  void __set_group_owner(const std::string& val);

  void __set_cluster_disks(const std::set<disk_info> & val);

  void __set_cluster_partitions(const std::set<volume_info> & val);

  void __set_cluster_network_infos(const std::set<cluster_network> & val);

  bool operator == (const cluster_group & rhs) const
  {
    if (__isset.group_id != rhs.__isset.group_id)
      return false;
    else if (__isset.group_id && !(group_id == rhs.group_id))
      return false;
    if (__isset.group_name != rhs.__isset.group_name)
      return false;
    else if (__isset.group_name && !(group_name == rhs.group_name))
      return false;
    if (__isset.group_owner != rhs.__isset.group_owner)
      return false;
    else if (__isset.group_owner && !(group_owner == rhs.group_owner))
      return false;
    if (__isset.cluster_disks != rhs.__isset.cluster_disks)
      return false;
    else if (__isset.cluster_disks && !(cluster_disks == rhs.cluster_disks))
      return false;
    if (__isset.cluster_partitions != rhs.__isset.cluster_partitions)
      return false;
    else if (__isset.cluster_partitions && !(cluster_partitions == rhs.cluster_partitions))
      return false;
    if (__isset.cluster_network_infos != rhs.__isset.cluster_network_infos)
      return false;
    else if (__isset.cluster_network_infos && !(cluster_network_infos == rhs.cluster_network_infos))
      return false;
    return true;
  }
  bool operator != (const cluster_group &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const cluster_group & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const cluster_group& obj);
};

void swap(cluster_group &a, cluster_group &b);

typedef struct _cluster_info__isset {
  _cluster_info__isset() : cluster_name(true), quorum_disk(false), cluster_nodes(false), client_ids(false), machine_ids(false), cluster_network_infos(false), cluster_groups(false) {}
  bool cluster_name :1;
  bool quorum_disk :1;
  bool cluster_nodes :1;
  bool client_ids :1;
  bool machine_ids :1;
  bool cluster_network_infos :1;
  bool cluster_groups :1;
} _cluster_info__isset;

class cluster_info {
 public:

  static const char* ascii_fingerprint; // = "C8BAB221FCDC9B72897C67B01F9BAE71";
  static const uint8_t binary_fingerprint[16]; // = {0xC8,0xBA,0xB2,0x21,0xFC,0xDC,0x9B,0x72,0x89,0x7C,0x67,0xB0,0x1F,0x9B,0xAE,0x71};

  cluster_info(const cluster_info&);
  cluster_info& operator=(const cluster_info&);
  cluster_info() : cluster_name("") {
  }

  virtual ~cluster_info() throw();
  std::string cluster_name;
  disk_info quorum_disk;
  std::set<std::string>  cluster_nodes;
  std::set<std::string>  client_ids;
  std::set<std::string>  machine_ids;
  std::set<cluster_network>  cluster_network_infos;
  std::set<cluster_group>  cluster_groups;

  _cluster_info__isset __isset;

  void __set_cluster_name(const std::string& val);

  void __set_quorum_disk(const disk_info& val);

  void __set_cluster_nodes(const std::set<std::string> & val);

  void __set_client_ids(const std::set<std::string> & val);

  void __set_machine_ids(const std::set<std::string> & val);

  void __set_cluster_network_infos(const std::set<cluster_network> & val);

  void __set_cluster_groups(const std::set<cluster_group> & val);

  bool operator == (const cluster_info & rhs) const
  {
    if (__isset.cluster_name != rhs.__isset.cluster_name)
      return false;
    else if (__isset.cluster_name && !(cluster_name == rhs.cluster_name))
      return false;
    if (__isset.quorum_disk != rhs.__isset.quorum_disk)
      return false;
    else if (__isset.quorum_disk && !(quorum_disk == rhs.quorum_disk))
      return false;
    if (__isset.cluster_nodes != rhs.__isset.cluster_nodes)
      return false;
    else if (__isset.cluster_nodes && !(cluster_nodes == rhs.cluster_nodes))
      return false;
    if (__isset.client_ids != rhs.__isset.client_ids)
      return false;
    else if (__isset.client_ids && !(client_ids == rhs.client_ids))
      return false;
    if (__isset.machine_ids != rhs.__isset.machine_ids)
      return false;
    else if (__isset.machine_ids && !(machine_ids == rhs.machine_ids))
      return false;
    if (__isset.cluster_network_infos != rhs.__isset.cluster_network_infos)
      return false;
    else if (__isset.cluster_network_infos && !(cluster_network_infos == rhs.cluster_network_infos))
      return false;
    if (__isset.cluster_groups != rhs.__isset.cluster_groups)
      return false;
    else if (__isset.cluster_groups && !(cluster_groups == rhs.cluster_groups))
      return false;
    return true;
  }
  bool operator != (const cluster_info &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const cluster_info & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const cluster_info& obj);
};

void swap(cluster_info &a, cluster_info &b);

typedef struct _agent_info__isset {
  _agent_info__isset() : agent_id(true), agent_name(true), agent_version(true), status(true) {}
  bool agent_id :1;
  bool agent_name :1;
  bool agent_version :1;
  bool status :1;
} _agent_info__isset;

class agent_info {
 public:

  static const char* ascii_fingerprint; // = "EA56942314ECD5D27DC4278DCD614C8D";
  static const uint8_t binary_fingerprint[16]; // = {0xEA,0x56,0x94,0x23,0x14,0xEC,0xD5,0xD2,0x7D,0xC4,0x27,0x8D,0xCD,0x61,0x4C,0x8D};

  agent_info(const agent_info&);
  agent_info& operator=(const agent_info&);
  agent_info() : agent_id(""), agent_name(""), agent_version(""), status(-1LL) {
  }

  virtual ~agent_info() throw();
  std::string agent_id;
  std::string agent_name;
  std::string agent_version;
  int64_t status;

  _agent_info__isset __isset;

  void __set_agent_id(const std::string& val);

  void __set_agent_name(const std::string& val);

  void __set_agent_version(const std::string& val);

  void __set_status(const int64_t val);

  bool operator == (const agent_info & rhs) const
  {
    if (__isset.agent_id != rhs.__isset.agent_id)
      return false;
    else if (__isset.agent_id && !(agent_id == rhs.agent_id))
      return false;
    if (__isset.agent_name != rhs.__isset.agent_name)
      return false;
    else if (__isset.agent_name && !(agent_name == rhs.agent_name))
      return false;
    if (__isset.agent_version != rhs.__isset.agent_version)
      return false;
    else if (__isset.agent_version && !(agent_version == rhs.agent_version))
      return false;
    if (__isset.status != rhs.__isset.status)
      return false;
    else if (__isset.status && !(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const agent_info &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const agent_info & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const agent_info& obj);
};

void swap(agent_info &a, agent_info &b);

typedef struct _os_version_info__isset {
  _os_version_info__isset() : csd_version(true), build_number(true), major_version(true), minor_version(true), platform_id(true), product_type(true), servicepack_major(true), servicepack_minor(true), suite_mask(true) {}
  bool csd_version :1;
  bool build_number :1;
  bool major_version :1;
  bool minor_version :1;
  bool platform_id :1;
  bool product_type :1;
  bool servicepack_major :1;
  bool servicepack_minor :1;
  bool suite_mask :1;
} _os_version_info__isset;

class os_version_info {
 public:

  static const char* ascii_fingerprint; // = "255B0BEA48975067F628CED39DEE9D25";
  static const uint8_t binary_fingerprint[16]; // = {0x25,0x5B,0x0B,0xEA,0x48,0x97,0x50,0x67,0xF6,0x28,0xCE,0xD3,0x9D,0xEE,0x9D,0x25};

  os_version_info(const os_version_info&);
  os_version_info& operator=(const os_version_info&);
  os_version_info() : csd_version(""), build_number(-1), major_version(-1), minor_version(-1), platform_id(-1), product_type(-1), servicepack_major(-1), servicepack_minor(-1), suite_mask(-1) {
  }

  virtual ~os_version_info() throw();
  std::string csd_version;
  int32_t build_number;
  int32_t major_version;
  int32_t minor_version;
  int32_t platform_id;
  int16_t product_type;
  int32_t servicepack_major;
  int32_t servicepack_minor;
  int32_t suite_mask;

  _os_version_info__isset __isset;

  void __set_csd_version(const std::string& val);

  void __set_build_number(const int32_t val);

  void __set_major_version(const int32_t val);

  void __set_minor_version(const int32_t val);

  void __set_platform_id(const int32_t val);

  void __set_product_type(const int16_t val);

  void __set_servicepack_major(const int32_t val);

  void __set_servicepack_minor(const int32_t val);

  void __set_suite_mask(const int32_t val);

  bool operator == (const os_version_info & rhs) const
  {
    if (__isset.csd_version != rhs.__isset.csd_version)
      return false;
    else if (__isset.csd_version && !(csd_version == rhs.csd_version))
      return false;
    if (__isset.build_number != rhs.__isset.build_number)
      return false;
    else if (__isset.build_number && !(build_number == rhs.build_number))
      return false;
    if (__isset.major_version != rhs.__isset.major_version)
      return false;
    else if (__isset.major_version && !(major_version == rhs.major_version))
      return false;
    if (__isset.minor_version != rhs.__isset.minor_version)
      return false;
    else if (__isset.minor_version && !(minor_version == rhs.minor_version))
      return false;
    if (__isset.platform_id != rhs.__isset.platform_id)
      return false;
    else if (__isset.platform_id && !(platform_id == rhs.platform_id))
      return false;
    if (__isset.product_type != rhs.__isset.product_type)
      return false;
    else if (__isset.product_type && !(product_type == rhs.product_type))
      return false;
    if (__isset.servicepack_major != rhs.__isset.servicepack_major)
      return false;
    else if (__isset.servicepack_major && !(servicepack_major == rhs.servicepack_major))
      return false;
    if (__isset.servicepack_minor != rhs.__isset.servicepack_minor)
      return false;
    else if (__isset.servicepack_minor && !(servicepack_minor == rhs.servicepack_minor))
      return false;
    if (__isset.suite_mask != rhs.__isset.suite_mask)
      return false;
    else if (__isset.suite_mask && !(suite_mask == rhs.suite_mask))
      return false;
    return true;
  }
  bool operator != (const os_version_info &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const os_version_info & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const os_version_info& obj);
};

void swap(os_version_info &a, os_version_info &b);

typedef struct _client_info__isset {
  _client_info__isset() : architecture(true), client_id(true), client_name(true), domain(true), hal(true), initiator_name(true), is_oem(true), logical_processors(true), machine_id(true), manufacturer(true), os_name(true), os_type(true), os_system_info(false), physical_memory(true), processors(true), role(true), system_model(true), system_root(true), workgroup(true), os_version(false), agent_infos(false), cluster_infos(false), disk_infos(false), network_infos(false), partition_infos(false), protection_relationships(false), protection_sets(false), storage_infos(false), volume_infos(false) {}
  bool architecture :1;
  bool client_id :1;
  bool client_name :1;
  bool domain :1;
  bool hal :1;
  bool initiator_name :1;
  bool is_oem :1;
  bool logical_processors :1;
  bool machine_id :1;
  bool manufacturer :1;
  bool os_name :1;
  bool os_type :1;
  bool os_system_info :1;
  bool physical_memory :1;
  bool processors :1;
  bool role :1;
  bool system_model :1;
  bool system_root :1;
  bool workgroup :1;
  bool os_version :1;
  bool agent_infos :1;
  bool cluster_infos :1;
  bool disk_infos :1;
  bool network_infos :1;
  bool partition_infos :1;
  bool protection_relationships :1;
  bool protection_sets :1;
  bool storage_infos :1;
  bool volume_infos :1;
} _client_info__isset;

class client_info {
 public:

  static const char* ascii_fingerprint; // = "86268AF2F5D2F1EF9E8A15E93D6927E0";
  static const uint8_t binary_fingerprint[16]; // = {0x86,0x26,0x8A,0xF2,0xF5,0xD2,0xF1,0xEF,0x9E,0x8A,0x15,0xE9,0x3D,0x69,0x27,0xE0};

  client_info(const client_info&);
  client_info& operator=(const client_info&);
  client_info() : architecture(""), client_id(""), client_name(""), domain(""), hal(""), initiator_name(""), is_oem(false), logical_processors(0), machine_id(""), manufacturer(""), os_name(""), os_type(0), os_system_info(), physical_memory(0LL), processors(0), role(0), system_model(""), system_root(""), workgroup("") {
  }

  virtual ~client_info() throw();
  std::string architecture;
  std::string client_id;
  std::string client_name;
  std::string domain;
  std::string hal;
  std::string initiator_name;
  bool is_oem;
  int16_t logical_processors;
  std::string machine_id;
  std::string manufacturer;
  std::string os_name;
  int32_t os_type;
  std::string os_system_info;
  int64_t physical_memory;
  int16_t processors;
  int32_t role;
  std::string system_model;
  std::string system_root;
  std::string workgroup;
  os_version_info os_version;
  std::set<agent_info>  agent_infos;
  std::set<cluster_info>  cluster_infos;
  std::set<disk_info>  disk_infos;
  std::set<network_info>  network_infos;
  std::set<partition_info>  partition_infos;
  std::map<std::string, protection_relationship>  protection_relationships;
  std::set<protection_set>  protection_sets;
  std::set<storage_info>  storage_infos;
  std::set<volume_info>  volume_infos;

  _client_info__isset __isset;

  void __set_architecture(const std::string& val);

  void __set_client_id(const std::string& val);

  void __set_client_name(const std::string& val);

  void __set_domain(const std::string& val);

  void __set_hal(const std::string& val);

  void __set_initiator_name(const std::string& val);

  void __set_is_oem(const bool val);

  void __set_logical_processors(const int16_t val);

  void __set_machine_id(const std::string& val);

  void __set_manufacturer(const std::string& val);

  void __set_os_name(const std::string& val);

  void __set_os_type(const int32_t val);

  void __set_os_system_info(const std::string& val);

  void __set_physical_memory(const int64_t val);

  void __set_processors(const int16_t val);

  void __set_role(const int32_t val);

  void __set_system_model(const std::string& val);

  void __set_system_root(const std::string& val);

  void __set_workgroup(const std::string& val);

  void __set_os_version(const os_version_info& val);

  void __set_agent_infos(const std::set<agent_info> & val);

  void __set_cluster_infos(const std::set<cluster_info> & val);

  void __set_disk_infos(const std::set<disk_info> & val);

  void __set_network_infos(const std::set<network_info> & val);

  void __set_partition_infos(const std::set<partition_info> & val);

  void __set_protection_relationships(const std::map<std::string, protection_relationship> & val);

  void __set_protection_sets(const std::set<protection_set> & val);

  void __set_storage_infos(const std::set<storage_info> & val);

  void __set_volume_infos(const std::set<volume_info> & val);

  bool operator == (const client_info & rhs) const
  {
    if (__isset.architecture != rhs.__isset.architecture)
      return false;
    else if (__isset.architecture && !(architecture == rhs.architecture))
      return false;
    if (__isset.client_id != rhs.__isset.client_id)
      return false;
    else if (__isset.client_id && !(client_id == rhs.client_id))
      return false;
    if (__isset.client_name != rhs.__isset.client_name)
      return false;
    else if (__isset.client_name && !(client_name == rhs.client_name))
      return false;
    if (__isset.domain != rhs.__isset.domain)
      return false;
    else if (__isset.domain && !(domain == rhs.domain))
      return false;
    if (__isset.hal != rhs.__isset.hal)
      return false;
    else if (__isset.hal && !(hal == rhs.hal))
      return false;
    if (__isset.initiator_name != rhs.__isset.initiator_name)
      return false;
    else if (__isset.initiator_name && !(initiator_name == rhs.initiator_name))
      return false;
    if (__isset.is_oem != rhs.__isset.is_oem)
      return false;
    else if (__isset.is_oem && !(is_oem == rhs.is_oem))
      return false;
    if (__isset.logical_processors != rhs.__isset.logical_processors)
      return false;
    else if (__isset.logical_processors && !(logical_processors == rhs.logical_processors))
      return false;
    if (__isset.machine_id != rhs.__isset.machine_id)
      return false;
    else if (__isset.machine_id && !(machine_id == rhs.machine_id))
      return false;
    if (__isset.manufacturer != rhs.__isset.manufacturer)
      return false;
    else if (__isset.manufacturer && !(manufacturer == rhs.manufacturer))
      return false;
    if (__isset.os_name != rhs.__isset.os_name)
      return false;
    else if (__isset.os_name && !(os_name == rhs.os_name))
      return false;
    if (__isset.os_type != rhs.__isset.os_type)
      return false;
    else if (__isset.os_type && !(os_type == rhs.os_type))
      return false;
    if (__isset.os_system_info != rhs.__isset.os_system_info)
      return false;
    else if (__isset.os_system_info && !(os_system_info == rhs.os_system_info))
      return false;
    if (__isset.physical_memory != rhs.__isset.physical_memory)
      return false;
    else if (__isset.physical_memory && !(physical_memory == rhs.physical_memory))
      return false;
    if (__isset.processors != rhs.__isset.processors)
      return false;
    else if (__isset.processors && !(processors == rhs.processors))
      return false;
    if (__isset.role != rhs.__isset.role)
      return false;
    else if (__isset.role && !(role == rhs.role))
      return false;
    if (__isset.system_model != rhs.__isset.system_model)
      return false;
    else if (__isset.system_model && !(system_model == rhs.system_model))
      return false;
    if (__isset.system_root != rhs.__isset.system_root)
      return false;
    else if (__isset.system_root && !(system_root == rhs.system_root))
      return false;
    if (__isset.workgroup != rhs.__isset.workgroup)
      return false;
    else if (__isset.workgroup && !(workgroup == rhs.workgroup))
      return false;
    if (__isset.os_version != rhs.__isset.os_version)
      return false;
    else if (__isset.os_version && !(os_version == rhs.os_version))
      return false;
    if (__isset.agent_infos != rhs.__isset.agent_infos)
      return false;
    else if (__isset.agent_infos && !(agent_infos == rhs.agent_infos))
      return false;
    if (__isset.cluster_infos != rhs.__isset.cluster_infos)
      return false;
    else if (__isset.cluster_infos && !(cluster_infos == rhs.cluster_infos))
      return false;
    if (__isset.disk_infos != rhs.__isset.disk_infos)
      return false;
    else if (__isset.disk_infos && !(disk_infos == rhs.disk_infos))
      return false;
    if (__isset.network_infos != rhs.__isset.network_infos)
      return false;
    else if (__isset.network_infos && !(network_infos == rhs.network_infos))
      return false;
    if (__isset.partition_infos != rhs.__isset.partition_infos)
      return false;
    else if (__isset.partition_infos && !(partition_infos == rhs.partition_infos))
      return false;
    if (__isset.protection_relationships != rhs.__isset.protection_relationships)
      return false;
    else if (__isset.protection_relationships && !(protection_relationships == rhs.protection_relationships))
      return false;
    if (__isset.protection_sets != rhs.__isset.protection_sets)
      return false;
    else if (__isset.protection_sets && !(protection_sets == rhs.protection_sets))
      return false;
    if (__isset.storage_infos != rhs.__isset.storage_infos)
      return false;
    else if (__isset.storage_infos && !(storage_infos == rhs.storage_infos))
      return false;
    if (__isset.volume_infos != rhs.__isset.volume_infos)
      return false;
    else if (__isset.volume_infos && !(volume_infos == rhs.volume_infos))
      return false;
    return true;
  }
  bool operator != (const client_info &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const client_info & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const client_info& obj);
};

void swap(client_info &a, client_info &b);

typedef struct _command_request__isset {
  _command_request__isset() : command(true), event_id(true), pre_command(true), post_command(true), set_ids(true), protection_relationships(false), protection_sets(false) {}
  bool command :1;
  bool event_id :1;
  bool pre_command :1;
  bool post_command :1;
  bool set_ids :1;
  bool protection_relationships :1;
  bool protection_sets :1;
} _command_request__isset;

class command_request {
 public:

  static const char* ascii_fingerprint; // = "DEBEE7CA4E3650EBAC0ED438704A51CF";
  static const uint8_t binary_fingerprint[16]; // = {0xDE,0xBE,0xE7,0xCA,0x4E,0x36,0x50,0xEB,0xAC,0x0E,0xD4,0x38,0x70,0x4A,0x51,0xCF};

  command_request(const command_request&);
  command_request& operator=(const command_request&);
  command_request() : command(""), event_id(""), pre_command(""), post_command("") {

  }

  virtual ~command_request() throw();
  std::string command;
  std::string event_id;
  std::string pre_command;
  std::string post_command;
  std::set<std::string>  set_ids;
  std::map<std::string, protection_relationship>  protection_relationships;
  std::set<protection_set>  protection_sets;

  _command_request__isset __isset;

  void __set_command(const std::string& val);

  void __set_event_id(const std::string& val);

  void __set_pre_command(const std::string& val);

  void __set_post_command(const std::string& val);

  void __set_set_ids(const std::set<std::string> & val);

  void __set_protection_relationships(const std::map<std::string, protection_relationship> & val);

  void __set_protection_sets(const std::set<protection_set> & val);

  bool operator == (const command_request & rhs) const
  {
    if (__isset.command != rhs.__isset.command)
      return false;
    else if (__isset.command && !(command == rhs.command))
      return false;
    if (__isset.event_id != rhs.__isset.event_id)
      return false;
    else if (__isset.event_id && !(event_id == rhs.event_id))
      return false;
    if (__isset.pre_command != rhs.__isset.pre_command)
      return false;
    else if (__isset.pre_command && !(pre_command == rhs.pre_command))
      return false;
    if (__isset.post_command != rhs.__isset.post_command)
      return false;
    else if (__isset.post_command && !(post_command == rhs.post_command))
      return false;
    if (__isset.set_ids != rhs.__isset.set_ids)
      return false;
    else if (__isset.set_ids && !(set_ids == rhs.set_ids))
      return false;
    if (__isset.protection_relationships != rhs.__isset.protection_relationships)
      return false;
    else if (__isset.protection_relationships && !(protection_relationships == rhs.protection_relationships))
      return false;
    if (__isset.protection_sets != rhs.__isset.protection_sets)
      return false;
    else if (__isset.protection_sets && !(protection_sets == rhs.protection_sets))
      return false;
    return true;
  }
  bool operator != (const command_request &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const command_request & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const command_request& obj);
};

void swap(command_request &a, command_request &b);

typedef struct _command_result__isset {
  _command_result__isset() : client_id(true), machine_id(true), code(true), command(true), message(true), event_id(true), pre_command_message(true), post_command_message(true), set_ids(true) {}
  bool client_id :1;
  bool machine_id :1;
  bool code :1;
  bool command :1;
  bool message :1;
  bool event_id :1;
  bool pre_command_message :1;
  bool post_command_message :1;
  bool set_ids :1;
} _command_result__isset;

class command_result {
 public:

  static const char* ascii_fingerprint; // = "ACA1F6744558CEAD04C48E10EAC67655";
  static const uint8_t binary_fingerprint[16]; // = {0xAC,0xA1,0xF6,0x74,0x45,0x58,0xCE,0xAD,0x04,0xC4,0x8E,0x10,0xEA,0xC6,0x76,0x55};

  command_result(const command_result&);
  command_result& operator=(const command_result&);
  command_result() : client_id(""), machine_id(""), code(-1LL), command(""), message(""), event_id(""), pre_command_message(""), post_command_message("") {

  }

  virtual ~command_result() throw();
  std::string client_id;
  std::string machine_id;
  int64_t code;
  std::string command;
  std::string message;
  std::string event_id;
  std::string pre_command_message;
  std::string post_command_message;
  std::set<std::string>  set_ids;

  _command_result__isset __isset;

  void __set_client_id(const std::string& val);

  void __set_machine_id(const std::string& val);

  void __set_code(const int64_t val);

  void __set_command(const std::string& val);

  void __set_message(const std::string& val);

  void __set_event_id(const std::string& val);

  void __set_pre_command_message(const std::string& val);

  void __set_post_command_message(const std::string& val);

  void __set_set_ids(const std::set<std::string> & val);

  bool operator == (const command_result & rhs) const
  {
    if (__isset.client_id != rhs.__isset.client_id)
      return false;
    else if (__isset.client_id && !(client_id == rhs.client_id))
      return false;
    if (__isset.machine_id != rhs.__isset.machine_id)
      return false;
    else if (__isset.machine_id && !(machine_id == rhs.machine_id))
      return false;
    if (__isset.code != rhs.__isset.code)
      return false;
    else if (__isset.code && !(code == rhs.code))
      return false;
    if (__isset.command != rhs.__isset.command)
      return false;
    else if (__isset.command && !(command == rhs.command))
      return false;
    if (__isset.message != rhs.__isset.message)
      return false;
    else if (__isset.message && !(message == rhs.message))
      return false;
    if (__isset.event_id != rhs.__isset.event_id)
      return false;
    else if (__isset.event_id && !(event_id == rhs.event_id))
      return false;
    if (__isset.pre_command_message != rhs.__isset.pre_command_message)
      return false;
    else if (__isset.pre_command_message && !(pre_command_message == rhs.pre_command_message))
      return false;
    if (__isset.post_command_message != rhs.__isset.post_command_message)
      return false;
    else if (__isset.post_command_message && !(post_command_message == rhs.post_command_message))
      return false;
    if (__isset.set_ids != rhs.__isset.set_ids)
      return false;
    else if (__isset.set_ids && !(set_ids == rhs.set_ids))
      return false;
    return true;
  }
  bool operator != (const command_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const command_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const command_result& obj);
};

void swap(command_result &a, command_result &b);

}}}} // namespace

#endif
