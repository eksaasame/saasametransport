/**
 * Autogenerated by Thrift Compiler (0.12.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "saasame_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace saasame { namespace transport {

int _kenumerate_disk_filter_styleValues[] = {
  enumerate_disk_filter_style::ALL_DISK,
  enumerate_disk_filter_style::UNINITIALIZED_DISK
};
const char* _kenumerate_disk_filter_styleNames[] = {
  "ALL_DISK",
  "UNINITIALIZED_DISK"
};
const std::map<int, const char*> _enumerate_disk_filter_style_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kenumerate_disk_filter_styleValues, _kenumerate_disk_filter_styleNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const enumerate_disk_filter_style::type& val) {
  std::map<int, const char*>::const_iterator it = _enumerate_disk_filter_style_VALUES_TO_NAMES.find(val);
  if (it != _enumerate_disk_filter_style_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kmachine_detail_filterValues[] = {
  machine_detail_filter::FULL,
  machine_detail_filter::SIMPLE
};
const char* _kmachine_detail_filterNames[] = {
  "FULL",
  "SIMPLE"
};
const std::map<int, const char*> _machine_detail_filter_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kmachine_detail_filterValues, _kmachine_detail_filterNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const machine_detail_filter::type& val) {
  std::map<int, const char*>::const_iterator it = _machine_detail_filter_VALUES_TO_NAMES.find(val);
  if (it != _machine_detail_filter_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kpartition_styleValues[] = {
  partition_style::PARTITION_UNKNOWN,
  partition_style::PARTITION_MBR,
  partition_style::PARTITION_GPT
};
const char* _kpartition_styleNames[] = {
  "PARTITION_UNKNOWN",
  "PARTITION_MBR",
  "PARTITION_GPT"
};
const std::map<int, const char*> _partition_style_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kpartition_styleValues, _kpartition_styleNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const partition_style::type& val) {
  std::map<int, const char*>::const_iterator it = _partition_style_VALUES_TO_NAMES.find(val);
  if (it != _partition_style_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kdrive_typeValues[] = {
  drive_type::DT_UNKNOWN,
  drive_type::DT_NO_ROOT_PATH,
  drive_type::DT_REMOVABLE,
  drive_type::DT_FIXED,
  drive_type::DT_REMOTE,
  drive_type::DT_CDROM,
  drive_type::DT_RAMDISK
};
const char* _kdrive_typeNames[] = {
  "DT_UNKNOWN",
  "DT_NO_ROOT_PATH",
  "DT_REMOVABLE",
  "DT_FIXED",
  "DT_REMOTE",
  "DT_CDROM",
  "DT_RAMDISK"
};
const std::map<int, const char*> _drive_type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kdrive_typeValues, _kdrive_typeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const drive_type::type& val) {
  std::map<int, const char*>::const_iterator it = _drive_type_VALUES_TO_NAMES.find(val);
  if (it != _drive_type_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kbus_typeValues[] = {
  bus_type::Unknown,
  bus_type::SCSI,
  bus_type::ATAPI,
  bus_type::ATA,
  bus_type::IEEE_1394,
  bus_type::SSA,
  bus_type::Fibre_Channel,
  bus_type::USB,
  bus_type::RAID,
  bus_type::iSCSI,
  bus_type::SAS,
  bus_type::SATA,
  bus_type::SD,
  bus_type::MMC,
  bus_type::Virtual,
  bus_type::File_Backed_Virtual,
  bus_type::Storage_Spaces,
  bus_type::NVMe
};
const char* _kbus_typeNames[] = {
  "Unknown",
  "SCSI",
  "ATAPI",
  "ATA",
  "IEEE_1394",
  "SSA",
  "Fibre_Channel",
  "USB",
  "RAID",
  "iSCSI",
  "SAS",
  "SATA",
  "SD",
  "MMC",
  "Virtual",
  "File_Backed_Virtual",
  "Storage_Spaces",
  "NVMe"
};
const std::map<int, const char*> _bus_type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(18, _kbus_typeValues, _kbus_typeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const bus_type::type& val) {
  std::map<int, const char*>::const_iterator it = _bus_type_VALUES_TO_NAMES.find(val);
  if (it != _bus_type_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _khv_vm_tools_statusValues[] = {
  hv_vm_tools_status::HV_VMTOOLS_UNKNOWN,
  hv_vm_tools_status::HV_VMTOOLS_OK,
  hv_vm_tools_status::HV_VMTOOLS_NOTINSTALLED,
  hv_vm_tools_status::HV_VMTOOLS_OLD,
  hv_vm_tools_status::HV_VMTOOLS_NOTRUNNING,
  hv_vm_tools_status::HV_VMTOOLS_NEEDUPGRADE,
  hv_vm_tools_status::HV_VMTOOLS_UNMANAGED,
  hv_vm_tools_status::HV_VMTOOLS_NEW,
  hv_vm_tools_status::HV_VMTOOLS_BLACKLISTED
};
const char* _khv_vm_tools_statusNames[] = {
  "HV_VMTOOLS_UNKNOWN",
  "HV_VMTOOLS_OK",
  "HV_VMTOOLS_NOTINSTALLED",
  "HV_VMTOOLS_OLD",
  "HV_VMTOOLS_NOTRUNNING",
  "HV_VMTOOLS_NEEDUPGRADE",
  "HV_VMTOOLS_UNMANAGED",
  "HV_VMTOOLS_NEW",
  "HV_VMTOOLS_BLACKLISTED"
};
const std::map<int, const char*> _hv_vm_tools_status_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(9, _khv_vm_tools_statusValues, _khv_vm_tools_statusNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const hv_vm_tools_status::type& val) {
  std::map<int, const char*>::const_iterator it = _hv_vm_tools_status_VALUES_TO_NAMES.find(val);
  if (it != _hv_vm_tools_status_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _khv_vm_power_stateValues[] = {
  hv_vm_power_state::HV_VMPOWER_UNKNOWN,
  hv_vm_power_state::HV_VMPOWER_ON,
  hv_vm_power_state::HV_VMPOWER_OFF,
  hv_vm_power_state::HV_VMPOWER_SUSPENDED
};
const char* _khv_vm_power_stateNames[] = {
  "HV_VMPOWER_UNKNOWN",
  "HV_VMPOWER_ON",
  "HV_VMPOWER_OFF",
  "HV_VMPOWER_SUSPENDED"
};
const std::map<int, const char*> _hv_vm_power_state_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _khv_vm_power_stateValues, _khv_vm_power_stateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const hv_vm_power_state::type& val) {
  std::map<int, const char*>::const_iterator it = _hv_vm_power_state_VALUES_TO_NAMES.find(val);
  if (it != _hv_vm_power_state_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _khv_vm_connection_stateValues[] = {
  hv_vm_connection_state::HV_VMCONNECT_UNKNOWN,
  hv_vm_connection_state::HV_VMCONNECT_CONNECTED,
  hv_vm_connection_state::HV_VMCONNECT_DISCONNECTED,
  hv_vm_connection_state::HV_VMCONNECT_INACCESSIBLE,
  hv_vm_connection_state::HV_VMCONNECT_INVALID,
  hv_vm_connection_state::HV_VMCONNECT_ORPHANED
};
const char* _khv_vm_connection_stateNames[] = {
  "HV_VMCONNECT_UNKNOWN",
  "HV_VMCONNECT_CONNECTED",
  "HV_VMCONNECT_DISCONNECTED",
  "HV_VMCONNECT_INACCESSIBLE",
  "HV_VMCONNECT_INVALID",
  "HV_VMCONNECT_ORPHANED"
};
const std::map<int, const char*> _hv_vm_connection_state_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _khv_vm_connection_stateValues, _khv_vm_connection_stateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const hv_vm_connection_state::type& val) {
  std::map<int, const char*>::const_iterator it = _hv_vm_connection_state_VALUES_TO_NAMES.find(val);
  if (it != _hv_vm_connection_state_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _khv_host_power_stateValues[] = {
  hv_host_power_state::HV_HOSTPOWER_UNKNOWN,
  hv_host_power_state::HV_HOSTPOWER_ON,
  hv_host_power_state::HV_HOSTPOWER_OFF,
  hv_host_power_state::HV_HOSTPOWER_STANDBY
};
const char* _khv_host_power_stateNames[] = {
  "HV_HOSTPOWER_UNKNOWN",
  "HV_HOSTPOWER_ON",
  "HV_HOSTPOWER_OFF",
  "HV_HOSTPOWER_STANDBY"
};
const std::map<int, const char*> _hv_host_power_state_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _khv_host_power_stateValues, _khv_host_power_stateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const hv_host_power_state::type& val) {
  std::map<int, const char*>::const_iterator it = _hv_host_power_state_VALUES_TO_NAMES.find(val);
  if (it != _hv_host_power_state_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _khv_connection_typeValues[] = {
  hv_connection_type::HV_CONNECTION_TYPE_UNKNOWN,
  hv_connection_type::HV_CONNECTION_TYPE_VCENTER,
  hv_connection_type::HV_CONNECTION_TYPE_HOST
};
const char* _khv_connection_typeNames[] = {
  "HV_CONNECTION_TYPE_UNKNOWN",
  "HV_CONNECTION_TYPE_VCENTER",
  "HV_CONNECTION_TYPE_HOST"
};
const std::map<int, const char*> _hv_connection_type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _khv_connection_typeValues, _khv_connection_typeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const hv_connection_type::type& val) {
  std::map<int, const char*>::const_iterator it = _hv_connection_type_VALUES_TO_NAMES.find(val);
  if (it != _hv_connection_type_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _khv_guest_os_typeValues[] = {
  hv_guest_os_type::HV_OS_UNKNOWN,
  hv_guest_os_type::HV_OS_WINDOWS,
  hv_guest_os_type::HV_OS_LINUX
};
const char* _khv_guest_os_typeNames[] = {
  "HV_OS_UNKNOWN",
  "HV_OS_WINDOWS",
  "HV_OS_LINUX"
};
const std::map<int, const char*> _hv_guest_os_type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _khv_guest_os_typeValues, _khv_guest_os_typeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const hv_guest_os_type::type& val) {
  std::map<int, const char*>::const_iterator it = _hv_guest_os_type_VALUES_TO_NAMES.find(val);
  if (it != _hv_guest_os_type_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _khv_controller_typeValues[] = {
  hv_controller_type::HV_CTRL_ANY,
  hv_controller_type::HV_CTRL_IDE,
  hv_controller_type::HV_CTRL_PARA_VIRT_SCSI,
  hv_controller_type::HV_CTRL_BUS_LOGIC,
  hv_controller_type::HV_CTRL_LSI_LOGIC,
  hv_controller_type::HV_CTRL_LSI_LOGIC_SAS
};
const char* _khv_controller_typeNames[] = {
  "HV_CTRL_ANY",
  "HV_CTRL_IDE",
  "HV_CTRL_PARA_VIRT_SCSI",
  "HV_CTRL_BUS_LOGIC",
  "HV_CTRL_LSI_LOGIC",
  "HV_CTRL_LSI_LOGIC_SAS"
};
const std::map<int, const char*> _hv_controller_type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _khv_controller_typeValues, _khv_controller_typeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const hv_controller_type::type& val) {
  std::map<int, const char*>::const_iterator it = _hv_controller_type_VALUES_TO_NAMES.find(val);
  if (it != _hv_controller_type_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _khv_vm_firmwareValues[] = {
  hv_vm_firmware::HV_VM_FIRMWARE_BIOS,
  hv_vm_firmware::HV_VM_FIRMWARE_EFI
};
const char* _khv_vm_firmwareNames[] = {
  "HV_VM_FIRMWARE_BIOS",
  "HV_VM_FIRMWARE_EFI"
};
const std::map<int, const char*> _hv_vm_firmware_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _khv_vm_firmwareValues, _khv_vm_firmwareNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const hv_vm_firmware::type& val) {
  std::map<int, const char*>::const_iterator it = _hv_vm_firmware_VALUES_TO_NAMES.find(val);
  if (it != _hv_vm_firmware_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kjob_typeValues[] = {
  job_type::physical_packer_job_type,
  job_type::virtual_packer_job_type,
  job_type::physical_transport_type,
  job_type::virtual_transport_type,
  job_type::loader_job_type,
  job_type::launcher_job_type,
  job_type::winpe_packer_job_type,
  job_type::winpe_transport_job_type
};
const char* _kjob_typeNames[] = {
  "physical_packer_job_type",
  "virtual_packer_job_type",
  "physical_transport_type",
  "virtual_transport_type",
  "loader_job_type",
  "launcher_job_type",
  "winpe_packer_job_type",
  "winpe_transport_job_type"
};
const std::map<int, const char*> _job_type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(8, _kjob_typeValues, _kjob_typeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const job_type::type& val) {
  std::map<int, const char*>::const_iterator it = _job_type_VALUES_TO_NAMES.find(val);
  if (it != _job_type_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kjob_trigger_typeValues[] = {
  job_trigger_type::runonce_trigger,
  job_trigger_type::interval_trigger
};
const char* _kjob_trigger_typeNames[] = {
  "runonce_trigger",
  "interval_trigger"
};
const std::map<int, const char*> _job_trigger_type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kjob_trigger_typeValues, _kjob_trigger_typeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const job_trigger_type::type& val) {
  std::map<int, const char*>::const_iterator it = _job_trigger_type_VALUES_TO_NAMES.find(val);
  if (it != _job_trigger_type_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kjob_stateValues[] = {
  job_state::job_state_none,
  job_state::job_state_initialed,
  job_state::job_state_replicating,
  job_state::job_state_replicated,
  job_state::job_state_converting,
  job_state::job_state_finished,
  job_state::job_state_sche_completed,
  job_state::job_state_recover,
  job_state::job_state_resizing,
  job_state::job_state_uploading,
  job_state::job_state_upload_completed,
  job_state::job_state_discard
};
const char* _kjob_stateNames[] = {
  "job_state_none",
  "job_state_initialed",
  "job_state_replicating",
  "job_state_replicated",
  "job_state_converting",
  "job_state_finished",
  "job_state_sche_completed",
  "job_state_recover",
  "job_state_resizing",
  "job_state_uploading",
  "job_state_upload_completed",
  "job_state_discard"
};
const std::map<int, const char*> _job_state_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(12, _kjob_stateValues, _kjob_stateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const job_state::type& val) {
  std::map<int, const char*>::const_iterator it = _job_state_VALUES_TO_NAMES.find(val);
  if (it != _job_state_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kerror_codesValues[] = {
  error_codes::SAASAME_S_OK,
  error_codes::SAASAME_NOERROR,
  error_codes::SAASAME_E_FAIL,
  error_codes::SAASAME_E_INITIAL_FAIL,
  error_codes::SAASAME_E_DISK_FULL,
  error_codes::SAASAME_E_INVALID_ARG,
  error_codes::SAASAME_E_INVALID_AUTHENTICATION,
  error_codes::SAASAME_E_INTERNAL_FAIL,
  error_codes::SAASAME_E_CANNOT_CONNECT_TO_HOST,
  error_codes::SAASAME_E_QUEUE_FULL,
  error_codes::SAASAME_E_INVALID_LICENSE_KEY,
  error_codes::SAASAME_E_INVALID_LICENSE,
  error_codes::SAASAME_E_JOB_CREATE_FAIL,
  error_codes::SAASAME_E_JOB_REMOVE_FAIL,
  error_codes::SAASAME_E_JOB_NOTFOUND,
  error_codes::SAASAME_E_JOB_CONFIG_NOTFOUND,
  error_codes::SAASAME_E_JOB_STATUS_NOTFOUND,
  error_codes::SAASAME_E_JOB_CANCELLED,
  error_codes::SAASAME_E_JOB_CONVERT_FAIL,
  error_codes::SAASAME_E_JOB_REPLICATE_FAIL,
  error_codes::SAASAME_E_JOB_ID_DUPLICATED,
  error_codes::SAASAME_E_JOB_INTERRUPTED,
  error_codes::SAASAME_E_JOB_RUNNING,
  error_codes::SAASAME_E_JOB_RESPONSE,
  error_codes::SAASAME_E_PHYSICAL_CONFIG_FAILED,
  error_codes::SAASAME_E_VIRTUAL_VM_NOTFOUND,
  error_codes::SAASAME_E_IMAGE_NOTFOUND,
  error_codes::SAASAME_E_IMAGE_CREATE_FAIL,
  error_codes::SAASAME_E_IMAGE_OPEN_FAIL,
  error_codes::SAASAME_E_IMAGE_READ,
  error_codes::SAASAME_E_IMAGE_WRITE,
  error_codes::SAASAME_E_IMAGE_OUTOFRANGE,
  error_codes::SAASAME_E_IMAGE_ATTACH_FAIL,
  error_codes::SAASAME_E_IMAGE_DETACH_FAIL,
  error_codes::SAASAME_E_IMAGE_PROPERTY_FAIL,
  error_codes::SAASAME_E_SNAPSHOT_CREATE_FAIL,
  error_codes::SAASAME_E_SNAPSHOT_REMOVE_FAIL,
  error_codes::SAASAME_E_SNAPSHOT_NOTFOUND,
  error_codes::SAASAME_E_SNAPSHOT_INVALID
};
const char* _kerror_codesNames[] = {
  "SAASAME_S_OK",
  "SAASAME_NOERROR",
  "SAASAME_E_FAIL",
  "SAASAME_E_INITIAL_FAIL",
  "SAASAME_E_DISK_FULL",
  "SAASAME_E_INVALID_ARG",
  "SAASAME_E_INVALID_AUTHENTICATION",
  "SAASAME_E_INTERNAL_FAIL",
  "SAASAME_E_CANNOT_CONNECT_TO_HOST",
  "SAASAME_E_QUEUE_FULL",
  "SAASAME_E_INVALID_LICENSE_KEY",
  "SAASAME_E_INVALID_LICENSE",
  "SAASAME_E_JOB_CREATE_FAIL",
  "SAASAME_E_JOB_REMOVE_FAIL",
  "SAASAME_E_JOB_NOTFOUND",
  "SAASAME_E_JOB_CONFIG_NOTFOUND",
  "SAASAME_E_JOB_STATUS_NOTFOUND",
  "SAASAME_E_JOB_CANCELLED",
  "SAASAME_E_JOB_CONVERT_FAIL",
  "SAASAME_E_JOB_REPLICATE_FAIL",
  "SAASAME_E_JOB_ID_DUPLICATED",
  "SAASAME_E_JOB_INTERRUPTED",
  "SAASAME_E_JOB_RUNNING",
  "SAASAME_E_JOB_RESPONSE",
  "SAASAME_E_PHYSICAL_CONFIG_FAILED",
  "SAASAME_E_VIRTUAL_VM_NOTFOUND",
  "SAASAME_E_IMAGE_NOTFOUND",
  "SAASAME_E_IMAGE_CREATE_FAIL",
  "SAASAME_E_IMAGE_OPEN_FAIL",
  "SAASAME_E_IMAGE_READ",
  "SAASAME_E_IMAGE_WRITE",
  "SAASAME_E_IMAGE_OUTOFRANGE",
  "SAASAME_E_IMAGE_ATTACH_FAIL",
  "SAASAME_E_IMAGE_DETACH_FAIL",
  "SAASAME_E_IMAGE_PROPERTY_FAIL",
  "SAASAME_E_SNAPSHOT_CREATE_FAIL",
  "SAASAME_E_SNAPSHOT_REMOVE_FAIL",
  "SAASAME_E_SNAPSHOT_NOTFOUND",
  "SAASAME_E_SNAPSHOT_INVALID"
};
const std::map<int, const char*> _error_codes_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(39, _kerror_codesValues, _kerror_codesNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const error_codes::type& val) {
  std::map<int, const char*>::const_iterator it = _error_codes_VALUES_TO_NAMES.find(val);
  if (it != _error_codes_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kconnection_typeValues[] = {
  connection_type::LOCAL_FOLDER,
  connection_type::NFS_FOLDER,
  connection_type::CIFS_FOLDER,
  connection_type::WEBDAV,
  connection_type::S3_BUCKET,
  connection_type::WEBDAV_WITH_SSL,
  connection_type::WEBDAV_EX,
  connection_type::S3_BUCKET_EX,
  connection_type::LOCAL_FOLDER_EX
};
const char* _kconnection_typeNames[] = {
  "LOCAL_FOLDER",
  "NFS_FOLDER",
  "CIFS_FOLDER",
  "WEBDAV",
  "S3_BUCKET",
  "WEBDAV_WITH_SSL",
  "WEBDAV_EX",
  "S3_BUCKET_EX",
  "LOCAL_FOLDER_EX"
};
const std::map<int, const char*> _connection_type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(9, _kconnection_typeValues, _kconnection_typeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const connection_type::type& val) {
  std::map<int, const char*>::const_iterator it = _connection_type_VALUES_TO_NAMES.find(val);
  if (it != _connection_type_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kaws_regionValues[] = {
  aws_region::US_EAST_1,
  aws_region::US_WEST_1,
  aws_region::US_WEST_2,
  aws_region::EU_WEST_1,
  aws_region::EU_CENTRAL_1,
  aws_region::AP_SOUTHEAST_1,
  aws_region::AP_SOUTHEAST_2,
  aws_region::AP_NORTHEAST_1,
  aws_region::AP_NORTHEAST_2,
  aws_region::SA_EAST_1
};
const char* _kaws_regionNames[] = {
  "US_EAST_1",
  "US_WEST_1",
  "US_WEST_2",
  "EU_WEST_1",
  "EU_CENTRAL_1",
  "AP_SOUTHEAST_1",
  "AP_SOUTHEAST_2",
  "AP_NORTHEAST_1",
  "AP_NORTHEAST_2",
  "SA_EAST_1"
};
const std::map<int, const char*> _aws_region_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(10, _kaws_regionValues, _kaws_regionNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const aws_region::type& val) {
  std::map<int, const char*>::const_iterator it = _aws_region_VALUES_TO_NAMES.find(val);
  if (it != _aws_region_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kcreate_image_optionValues[] = {
  create_image_option::VERSION_1,
  create_image_option::VERSION_2
};
const char* _kcreate_image_optionNames[] = {
  "VERSION_1",
  "VERSION_2"
};
const std::map<int, const char*> _create_image_option_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kcreate_image_optionValues, _kcreate_image_optionNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const create_image_option::type& val) {
  std::map<int, const char*>::const_iterator it = _create_image_option_VALUES_TO_NAMES.find(val);
  if (it != _create_image_option_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kdisk_detect_typeValues[] = {
  disk_detect_type::SCSI_ADDRESS,
  disk_detect_type::LINUX_DEVICE_PATH,
  disk_detect_type::SERIAL_NUMBER,
  disk_detect_type::EXPORT_IMAGE,
  disk_detect_type::UNIQUE_ID,
  disk_detect_type::CUSTOMIZED_ID,
  disk_detect_type::AZURE_BLOB,
  disk_detect_type::VMWARE_VADP
};
const char* _kdisk_detect_typeNames[] = {
  "SCSI_ADDRESS",
  "LINUX_DEVICE_PATH",
  "SERIAL_NUMBER",
  "EXPORT_IMAGE",
  "UNIQUE_ID",
  "CUSTOMIZED_ID",
  "AZURE_BLOB",
  "VMWARE_VADP"
};
const std::map<int, const char*> _disk_detect_type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(8, _kdisk_detect_typeValues, _kdisk_detect_typeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const disk_detect_type::type& val) {
  std::map<int, const char*>::const_iterator it = _disk_detect_type_VALUES_TO_NAMES.find(val);
  if (it != _disk_detect_type_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kvirtual_disk_typeValues[] = {
  virtual_disk_type::VHD,
  virtual_disk_type::VHDX
};
const char* _kvirtual_disk_typeNames[] = {
  "VHD",
  "VHDX"
};
const std::map<int, const char*> _virtual_disk_type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kvirtual_disk_typeValues, _kvirtual_disk_typeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const virtual_disk_type::type& val) {
  std::map<int, const char*>::const_iterator it = _virtual_disk_type_VALUES_TO_NAMES.find(val);
  if (it != _virtual_disk_type_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kconversion_typeValues[] = {
  conversion_type::ANY_TO_ANY,
  conversion_type::OPENSTACK,
  conversion_type::XEN,
  conversion_type::VMWARE,
  conversion_type::HYPERV,
  conversion_type::AUTO
};
const char* _kconversion_typeNames[] = {
  "ANY_TO_ANY",
  "OPENSTACK",
  "XEN",
  "VMWARE",
  "HYPERV",
  "AUTO"
};
const std::map<int, const char*> _conversion_type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kconversion_typeValues, _kconversion_typeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const conversion_type::type& val) {
  std::map<int, const char*>::const_iterator it = _conversion_type_VALUES_TO_NAMES.find(val);
  if (it != _conversion_type_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _krecovery_typeValues[] = {
  recovery_type::TEST_RECOVERY,
  recovery_type::DISASTER_RECOVERY,
  recovery_type::MIGRATION_RECOVERY
};
const char* _krecovery_typeNames[] = {
  "TEST_RECOVERY",
  "DISASTER_RECOVERY",
  "MIGRATION_RECOVERY"
};
const std::map<int, const char*> _recovery_type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _krecovery_typeValues, _krecovery_typeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const recovery_type::type& val) {
  std::map<int, const char*>::const_iterator it = _recovery_type_VALUES_TO_NAMES.find(val);
  if (it != _recovery_type_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kextra_options_typeValues[] = {
  extra_options_type::UNKNOWN,
  extra_options_type::ALIYUN,
  extra_options_type::TENCENT
};
const char* _kextra_options_typeNames[] = {
  "UNKNOWN",
  "ALIYUN",
  "TENCENT"
};
const std::map<int, const char*> _extra_options_type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kextra_options_typeValues, _kextra_options_typeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const extra_options_type::type& val) {
  std::map<int, const char*>::const_iterator it = _extra_options_type_VALUES_TO_NAMES.find(val);
  if (it != _extra_options_type_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}


disk_info::~disk_info() throw() {
}


void disk_info::__set_boot_from_disk(const bool val) {
  this->boot_from_disk = val;
__isset.boot_from_disk = true;
}

void disk_info::__set_bus_type(const bus_type::type val) {
  this->bus_type = val;
__isset.bus_type = true;
}

void disk_info::__set_cluster_owner(const std::string& val) {
  this->cluster_owner = val;
__isset.cluster_owner = true;
}

void disk_info::__set_cylinders(const int64_t val) {
  this->cylinders = val;
__isset.cylinders = true;
}

void disk_info::__set_friendly_name(const std::string& val) {
  this->friendly_name = val;
__isset.friendly_name = true;
}

void disk_info::__set_guid(const std::string& val) {
  this->guid = val;
__isset.guid = true;
}

void disk_info::__set_tracks_per_cylinder(const int32_t val) {
  this->tracks_per_cylinder = val;
__isset.tracks_per_cylinder = true;
}

void disk_info::__set_is_boot(const bool val) {
  this->is_boot = val;
__isset.is_boot = true;
}

void disk_info::__set_is_clustered(const bool val) {
  this->is_clustered = val;
__isset.is_clustered = true;
}

void disk_info::__set_is_offline(const bool val) {
  this->is_offline = val;
__isset.is_offline = true;
}

void disk_info::__set_is_readonly(const bool val) {
  this->is_readonly = val;
__isset.is_readonly = true;
}

void disk_info::__set_is_snapshot(const bool val) {
  this->is_snapshot = val;
__isset.is_snapshot = true;
}

void disk_info::__set_is_system(const bool val) {
  this->is_system = val;
__isset.is_system = true;
}

void disk_info::__set_location(const std::string& val) {
  this->location = val;
__isset.location = true;
}

void disk_info::__set_logical_sector_size(const int32_t val) {
  this->logical_sector_size = val;
__isset.logical_sector_size = true;
}

void disk_info::__set_manufacturer(const std::string& val) {
  this->manufacturer = val;
__isset.manufacturer = true;
}

void disk_info::__set_model(const std::string& val) {
  this->model = val;
__isset.model = true;
}

void disk_info::__set_number(const int32_t val) {
  this->number = val;
__isset.number = true;
}

void disk_info::__set_number_of_partitions(const int32_t val) {
  this->number_of_partitions = val;
__isset.number_of_partitions = true;
}

void disk_info::__set_offline_reason(const int16_t val) {
  this->offline_reason = val;
__isset.offline_reason = true;
}

void disk_info::__set_partition_style(const partition_style::type val) {
  this->partition_style = val;
__isset.partition_style = true;
}

void disk_info::__set_path(const std::string& val) {
  this->path = val;
__isset.path = true;
}

void disk_info::__set_physical_sector_size(const int32_t val) {
  this->physical_sector_size = val;
__isset.physical_sector_size = true;
}

void disk_info::__set_sectors_per_track(const int32_t val) {
  this->sectors_per_track = val;
__isset.sectors_per_track = true;
}

void disk_info::__set_serial_number(const std::string& val) {
  this->serial_number = val;
__isset.serial_number = true;
}

void disk_info::__set_signature(const int32_t val) {
  this->signature = val;
__isset.signature = true;
}

void disk_info::__set_size(const int64_t val) {
  this->size = val;
__isset.size = true;
}

void disk_info::__set_uri(const std::string& val) {
  this->uri = val;
__isset.uri = true;
}

void disk_info::__set_scsi_bus(const int32_t val) {
  this->scsi_bus = val;
__isset.scsi_bus = true;
}

void disk_info::__set_scsi_logical_unit(const int16_t val) {
  this->scsi_logical_unit = val;
__isset.scsi_logical_unit = true;
}

void disk_info::__set_scsi_port(const int16_t val) {
  this->scsi_port = val;
__isset.scsi_port = true;
}

void disk_info::__set_scsi_target_id(const int16_t val) {
  this->scsi_target_id = val;
__isset.scsi_target_id = true;
}

void disk_info::__set_unique_id(const std::string& val) {
  this->unique_id = val;
__isset.unique_id = true;
}

void disk_info::__set_unique_id_format(const int16_t val) {
  this->unique_id_format = val;
__isset.unique_id_format = true;
}

void disk_info::__set_customized_id(const std::string& val) {
  this->customized_id = val;
__isset.customized_id = true;
}
std::ostream& operator<<(std::ostream& out, const disk_info& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t disk_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->boot_from_disk);
          this->__isset.boot_from_disk = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->bus_type = (bus_type::type)ecast0;
          this->__isset.bus_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cluster_owner);
          this->__isset.cluster_owner = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cylinders);
          this->__isset.cylinders = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->friendly_name);
          this->__isset.friendly_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guid);
          this->__isset.guid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->tracks_per_cylinder);
          this->__isset.tracks_per_cylinder = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_boot);
          this->__isset.is_boot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_clustered);
          this->__isset.is_clustered = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_offline);
          this->__isset.is_offline = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_readonly);
          this->__isset.is_readonly = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_snapshot);
          this->__isset.is_snapshot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_system);
          this->__isset.is_system = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->location);
          this->__isset.location = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->logical_sector_size);
          this->__isset.logical_sector_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->manufacturer);
          this->__isset.manufacturer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->model);
          this->__isset.model = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->number);
          this->__isset.number = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->number_of_partitions);
          this->__isset.number_of_partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->offline_reason);
          this->__isset.offline_reason = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1;
          xfer += iprot->readI32(ecast1);
          this->partition_style = (partition_style::type)ecast1;
          this->__isset.partition_style = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->path);
          this->__isset.path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->physical_sector_size);
          this->__isset.physical_sector_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sectors_per_track);
          this->__isset.sectors_per_track = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->serial_number);
          this->__isset.serial_number = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 26:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->signature);
          this->__isset.signature = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 27:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->size);
          this->__isset.size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 28:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->uri);
          this->__isset.uri = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 29:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->scsi_bus);
          this->__isset.scsi_bus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->scsi_logical_unit);
          this->__isset.scsi_logical_unit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 31:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->scsi_port);
          this->__isset.scsi_port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 32:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->scsi_target_id);
          this->__isset.scsi_target_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 33:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->unique_id);
          this->__isset.unique_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 34:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->unique_id_format);
          this->__isset.unique_id_format = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 35:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->customized_id);
          this->__isset.customized_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t disk_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("disk_info");

  if (this->__isset.boot_from_disk) {
    xfer += oprot->writeFieldBegin("boot_from_disk", ::apache::thrift::protocol::T_BOOL, 1);
    xfer += oprot->writeBool(this->boot_from_disk);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.bus_type) {
    xfer += oprot->writeFieldBegin("bus_type", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32((int32_t)this->bus_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_owner) {
    xfer += oprot->writeFieldBegin("cluster_owner", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->cluster_owner);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cylinders) {
    xfer += oprot->writeFieldBegin("cylinders", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->cylinders);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.friendly_name) {
    xfer += oprot->writeFieldBegin("friendly_name", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->friendly_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.guid) {
    xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->guid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tracks_per_cylinder) {
    xfer += oprot->writeFieldBegin("tracks_per_cylinder", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32(this->tracks_per_cylinder);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_boot) {
    xfer += oprot->writeFieldBegin("is_boot", ::apache::thrift::protocol::T_BOOL, 8);
    xfer += oprot->writeBool(this->is_boot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_clustered) {
    xfer += oprot->writeFieldBegin("is_clustered", ::apache::thrift::protocol::T_BOOL, 9);
    xfer += oprot->writeBool(this->is_clustered);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_offline) {
    xfer += oprot->writeFieldBegin("is_offline", ::apache::thrift::protocol::T_BOOL, 10);
    xfer += oprot->writeBool(this->is_offline);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_readonly) {
    xfer += oprot->writeFieldBegin("is_readonly", ::apache::thrift::protocol::T_BOOL, 11);
    xfer += oprot->writeBool(this->is_readonly);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_snapshot) {
    xfer += oprot->writeFieldBegin("is_snapshot", ::apache::thrift::protocol::T_BOOL, 12);
    xfer += oprot->writeBool(this->is_snapshot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_system) {
    xfer += oprot->writeFieldBegin("is_system", ::apache::thrift::protocol::T_BOOL, 13);
    xfer += oprot->writeBool(this->is_system);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.location) {
    xfer += oprot->writeFieldBegin("location", ::apache::thrift::protocol::T_STRING, 14);
    xfer += oprot->writeString(this->location);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.logical_sector_size) {
    xfer += oprot->writeFieldBegin("logical_sector_size", ::apache::thrift::protocol::T_I32, 15);
    xfer += oprot->writeI32(this->logical_sector_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.manufacturer) {
    xfer += oprot->writeFieldBegin("manufacturer", ::apache::thrift::protocol::T_STRING, 16);
    xfer += oprot->writeString(this->manufacturer);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.model) {
    xfer += oprot->writeFieldBegin("model", ::apache::thrift::protocol::T_STRING, 17);
    xfer += oprot->writeString(this->model);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.number) {
    xfer += oprot->writeFieldBegin("number", ::apache::thrift::protocol::T_I32, 18);
    xfer += oprot->writeI32(this->number);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.number_of_partitions) {
    xfer += oprot->writeFieldBegin("number_of_partitions", ::apache::thrift::protocol::T_I32, 19);
    xfer += oprot->writeI32(this->number_of_partitions);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.offline_reason) {
    xfer += oprot->writeFieldBegin("offline_reason", ::apache::thrift::protocol::T_I16, 20);
    xfer += oprot->writeI16(this->offline_reason);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partition_style) {
    xfer += oprot->writeFieldBegin("partition_style", ::apache::thrift::protocol::T_I32, 21);
    xfer += oprot->writeI32((int32_t)this->partition_style);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.path) {
    xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_STRING, 22);
    xfer += oprot->writeString(this->path);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.physical_sector_size) {
    xfer += oprot->writeFieldBegin("physical_sector_size", ::apache::thrift::protocol::T_I32, 23);
    xfer += oprot->writeI32(this->physical_sector_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sectors_per_track) {
    xfer += oprot->writeFieldBegin("sectors_per_track", ::apache::thrift::protocol::T_I32, 24);
    xfer += oprot->writeI32(this->sectors_per_track);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.serial_number) {
    xfer += oprot->writeFieldBegin("serial_number", ::apache::thrift::protocol::T_STRING, 25);
    xfer += oprot->writeString(this->serial_number);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.signature) {
    xfer += oprot->writeFieldBegin("signature", ::apache::thrift::protocol::T_I32, 26);
    xfer += oprot->writeI32(this->signature);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.size) {
    xfer += oprot->writeFieldBegin("size", ::apache::thrift::protocol::T_I64, 27);
    xfer += oprot->writeI64(this->size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.uri) {
    xfer += oprot->writeFieldBegin("uri", ::apache::thrift::protocol::T_STRING, 28);
    xfer += oprot->writeString(this->uri);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.scsi_bus) {
    xfer += oprot->writeFieldBegin("scsi_bus", ::apache::thrift::protocol::T_I32, 29);
    xfer += oprot->writeI32(this->scsi_bus);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.scsi_logical_unit) {
    xfer += oprot->writeFieldBegin("scsi_logical_unit", ::apache::thrift::protocol::T_I16, 30);
    xfer += oprot->writeI16(this->scsi_logical_unit);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.scsi_port) {
    xfer += oprot->writeFieldBegin("scsi_port", ::apache::thrift::protocol::T_I16, 31);
    xfer += oprot->writeI16(this->scsi_port);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.scsi_target_id) {
    xfer += oprot->writeFieldBegin("scsi_target_id", ::apache::thrift::protocol::T_I16, 32);
    xfer += oprot->writeI16(this->scsi_target_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.unique_id) {
    xfer += oprot->writeFieldBegin("unique_id", ::apache::thrift::protocol::T_STRING, 33);
    xfer += oprot->writeString(this->unique_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.unique_id_format) {
    xfer += oprot->writeFieldBegin("unique_id_format", ::apache::thrift::protocol::T_I16, 34);
    xfer += oprot->writeI16(this->unique_id_format);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.customized_id) {
    xfer += oprot->writeFieldBegin("customized_id", ::apache::thrift::protocol::T_STRING, 35);
    xfer += oprot->writeString(this->customized_id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(disk_info &a, disk_info &b) {
  using ::std::swap;
  swap(a.boot_from_disk, b.boot_from_disk);
  swap(a.bus_type, b.bus_type);
  swap(a.cluster_owner, b.cluster_owner);
  swap(a.cylinders, b.cylinders);
  swap(a.friendly_name, b.friendly_name);
  swap(a.guid, b.guid);
  swap(a.tracks_per_cylinder, b.tracks_per_cylinder);
  swap(a.is_boot, b.is_boot);
  swap(a.is_clustered, b.is_clustered);
  swap(a.is_offline, b.is_offline);
  swap(a.is_readonly, b.is_readonly);
  swap(a.is_snapshot, b.is_snapshot);
  swap(a.is_system, b.is_system);
  swap(a.location, b.location);
  swap(a.logical_sector_size, b.logical_sector_size);
  swap(a.manufacturer, b.manufacturer);
  swap(a.model, b.model);
  swap(a.number, b.number);
  swap(a.number_of_partitions, b.number_of_partitions);
  swap(a.offline_reason, b.offline_reason);
  swap(a.partition_style, b.partition_style);
  swap(a.path, b.path);
  swap(a.physical_sector_size, b.physical_sector_size);
  swap(a.sectors_per_track, b.sectors_per_track);
  swap(a.serial_number, b.serial_number);
  swap(a.signature, b.signature);
  swap(a.size, b.size);
  swap(a.uri, b.uri);
  swap(a.scsi_bus, b.scsi_bus);
  swap(a.scsi_logical_unit, b.scsi_logical_unit);
  swap(a.scsi_port, b.scsi_port);
  swap(a.scsi_target_id, b.scsi_target_id);
  swap(a.unique_id, b.unique_id);
  swap(a.unique_id_format, b.unique_id_format);
  swap(a.customized_id, b.customized_id);
  swap(a.__isset, b.__isset);
}

disk_info::disk_info(const disk_info& other2) {
  boot_from_disk = other2.boot_from_disk;
  bus_type = other2.bus_type;
  cluster_owner = other2.cluster_owner;
  cylinders = other2.cylinders;
  friendly_name = other2.friendly_name;
  guid = other2.guid;
  tracks_per_cylinder = other2.tracks_per_cylinder;
  is_boot = other2.is_boot;
  is_clustered = other2.is_clustered;
  is_offline = other2.is_offline;
  is_readonly = other2.is_readonly;
  is_snapshot = other2.is_snapshot;
  is_system = other2.is_system;
  location = other2.location;
  logical_sector_size = other2.logical_sector_size;
  manufacturer = other2.manufacturer;
  model = other2.model;
  number = other2.number;
  number_of_partitions = other2.number_of_partitions;
  offline_reason = other2.offline_reason;
  partition_style = other2.partition_style;
  path = other2.path;
  physical_sector_size = other2.physical_sector_size;
  sectors_per_track = other2.sectors_per_track;
  serial_number = other2.serial_number;
  signature = other2.signature;
  size = other2.size;
  uri = other2.uri;
  scsi_bus = other2.scsi_bus;
  scsi_logical_unit = other2.scsi_logical_unit;
  scsi_port = other2.scsi_port;
  scsi_target_id = other2.scsi_target_id;
  unique_id = other2.unique_id;
  unique_id_format = other2.unique_id_format;
  customized_id = other2.customized_id;
  __isset = other2.__isset;
}
disk_info& disk_info::operator=(const disk_info& other3) {
  boot_from_disk = other3.boot_from_disk;
  bus_type = other3.bus_type;
  cluster_owner = other3.cluster_owner;
  cylinders = other3.cylinders;
  friendly_name = other3.friendly_name;
  guid = other3.guid;
  tracks_per_cylinder = other3.tracks_per_cylinder;
  is_boot = other3.is_boot;
  is_clustered = other3.is_clustered;
  is_offline = other3.is_offline;
  is_readonly = other3.is_readonly;
  is_snapshot = other3.is_snapshot;
  is_system = other3.is_system;
  location = other3.location;
  logical_sector_size = other3.logical_sector_size;
  manufacturer = other3.manufacturer;
  model = other3.model;
  number = other3.number;
  number_of_partitions = other3.number_of_partitions;
  offline_reason = other3.offline_reason;
  partition_style = other3.partition_style;
  path = other3.path;
  physical_sector_size = other3.physical_sector_size;
  sectors_per_track = other3.sectors_per_track;
  serial_number = other3.serial_number;
  signature = other3.signature;
  size = other3.size;
  uri = other3.uri;
  scsi_bus = other3.scsi_bus;
  scsi_logical_unit = other3.scsi_logical_unit;
  scsi_port = other3.scsi_port;
  scsi_target_id = other3.scsi_target_id;
  unique_id = other3.unique_id;
  unique_id_format = other3.unique_id_format;
  customized_id = other3.customized_id;
  __isset = other3.__isset;
  return *this;
}
void disk_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "disk_info(";
  out << "boot_from_disk="; (__isset.boot_from_disk ? (out << to_string(boot_from_disk)) : (out << "<null>"));
  out << ", " << "bus_type="; (__isset.bus_type ? (out << to_string(bus_type)) : (out << "<null>"));
  out << ", " << "cluster_owner="; (__isset.cluster_owner ? (out << to_string(cluster_owner)) : (out << "<null>"));
  out << ", " << "cylinders="; (__isset.cylinders ? (out << to_string(cylinders)) : (out << "<null>"));
  out << ", " << "friendly_name="; (__isset.friendly_name ? (out << to_string(friendly_name)) : (out << "<null>"));
  out << ", " << "guid="; (__isset.guid ? (out << to_string(guid)) : (out << "<null>"));
  out << ", " << "tracks_per_cylinder="; (__isset.tracks_per_cylinder ? (out << to_string(tracks_per_cylinder)) : (out << "<null>"));
  out << ", " << "is_boot="; (__isset.is_boot ? (out << to_string(is_boot)) : (out << "<null>"));
  out << ", " << "is_clustered="; (__isset.is_clustered ? (out << to_string(is_clustered)) : (out << "<null>"));
  out << ", " << "is_offline="; (__isset.is_offline ? (out << to_string(is_offline)) : (out << "<null>"));
  out << ", " << "is_readonly="; (__isset.is_readonly ? (out << to_string(is_readonly)) : (out << "<null>"));
  out << ", " << "is_snapshot="; (__isset.is_snapshot ? (out << to_string(is_snapshot)) : (out << "<null>"));
  out << ", " << "is_system="; (__isset.is_system ? (out << to_string(is_system)) : (out << "<null>"));
  out << ", " << "location="; (__isset.location ? (out << to_string(location)) : (out << "<null>"));
  out << ", " << "logical_sector_size="; (__isset.logical_sector_size ? (out << to_string(logical_sector_size)) : (out << "<null>"));
  out << ", " << "manufacturer="; (__isset.manufacturer ? (out << to_string(manufacturer)) : (out << "<null>"));
  out << ", " << "model="; (__isset.model ? (out << to_string(model)) : (out << "<null>"));
  out << ", " << "number="; (__isset.number ? (out << to_string(number)) : (out << "<null>"));
  out << ", " << "number_of_partitions="; (__isset.number_of_partitions ? (out << to_string(number_of_partitions)) : (out << "<null>"));
  out << ", " << "offline_reason="; (__isset.offline_reason ? (out << to_string(offline_reason)) : (out << "<null>"));
  out << ", " << "partition_style="; (__isset.partition_style ? (out << to_string(partition_style)) : (out << "<null>"));
  out << ", " << "path="; (__isset.path ? (out << to_string(path)) : (out << "<null>"));
  out << ", " << "physical_sector_size="; (__isset.physical_sector_size ? (out << to_string(physical_sector_size)) : (out << "<null>"));
  out << ", " << "sectors_per_track="; (__isset.sectors_per_track ? (out << to_string(sectors_per_track)) : (out << "<null>"));
  out << ", " << "serial_number="; (__isset.serial_number ? (out << to_string(serial_number)) : (out << "<null>"));
  out << ", " << "signature="; (__isset.signature ? (out << to_string(signature)) : (out << "<null>"));
  out << ", " << "size="; (__isset.size ? (out << to_string(size)) : (out << "<null>"));
  out << ", " << "uri="; (__isset.uri ? (out << to_string(uri)) : (out << "<null>"));
  out << ", " << "scsi_bus="; (__isset.scsi_bus ? (out << to_string(scsi_bus)) : (out << "<null>"));
  out << ", " << "scsi_logical_unit="; (__isset.scsi_logical_unit ? (out << to_string(scsi_logical_unit)) : (out << "<null>"));
  out << ", " << "scsi_port="; (__isset.scsi_port ? (out << to_string(scsi_port)) : (out << "<null>"));
  out << ", " << "scsi_target_id="; (__isset.scsi_target_id ? (out << to_string(scsi_target_id)) : (out << "<null>"));
  out << ", " << "unique_id="; (__isset.unique_id ? (out << to_string(unique_id)) : (out << "<null>"));
  out << ", " << "unique_id_format="; (__isset.unique_id_format ? (out << to_string(unique_id_format)) : (out << "<null>"));
  out << ", " << "customized_id="; (__isset.customized_id ? (out << to_string(customized_id)) : (out << "<null>"));
  out << ")";
}


partition_info::~partition_info() throw() {
}


void partition_info::__set_access_paths(const std::set<std::string> & val) {
  this->access_paths = val;
__isset.access_paths = true;
}

void partition_info::__set_disk_number(const int32_t val) {
  this->disk_number = val;
__isset.disk_number = true;
}

void partition_info::__set_drive_letter(const std::string& val) {
  this->drive_letter = val;
__isset.drive_letter = true;
}

void partition_info::__set_gpt_type(const std::string& val) {
  this->gpt_type = val;
__isset.gpt_type = true;
}

void partition_info::__set_guid(const std::string& val) {
  this->guid = val;
__isset.guid = true;
}

void partition_info::__set_is_active(const bool val) {
  this->is_active = val;
__isset.is_active = true;
}

void partition_info::__set_is_boot(const bool val) {
  this->is_boot = val;
__isset.is_boot = true;
}

void partition_info::__set_is_hidden(const bool val) {
  this->is_hidden = val;
__isset.is_hidden = true;
}

void partition_info::__set_is_offline(const bool val) {
  this->is_offline = val;
__isset.is_offline = true;
}

void partition_info::__set_is_readonly(const bool val) {
  this->is_readonly = val;
__isset.is_readonly = true;
}

void partition_info::__set_is_shadowcopy(const bool val) {
  this->is_shadowcopy = val;
__isset.is_shadowcopy = true;
}

void partition_info::__set_is_system(const bool val) {
  this->is_system = val;
__isset.is_system = true;
}

void partition_info::__set_mbr_type(const int16_t val) {
  this->mbr_type = val;
__isset.mbr_type = true;
}

void partition_info::__set_offset(const int64_t val) {
  this->offset = val;
__isset.offset = true;
}

void partition_info::__set_partition_number(const int32_t val) {
  this->partition_number = val;
__isset.partition_number = true;
}

void partition_info::__set_size(const int64_t val) {
  this->size = val;
__isset.size = true;
}
std::ostream& operator<<(std::ostream& out, const partition_info& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t partition_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->access_paths.clear();
            uint32_t _size4;
            ::apache::thrift::protocol::TType _etype7;
            xfer += iprot->readSetBegin(_etype7, _size4);
            uint32_t _i8;
            for (_i8 = 0; _i8 < _size4; ++_i8)
            {
              std::string _elem9;
              xfer += iprot->readString(_elem9);
              this->access_paths.insert(_elem9);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.access_paths = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->disk_number);
          this->__isset.disk_number = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->drive_letter);
          this->__isset.drive_letter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->gpt_type);
          this->__isset.gpt_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guid);
          this->__isset.guid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_active);
          this->__isset.is_active = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_boot);
          this->__isset.is_boot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_hidden);
          this->__isset.is_hidden = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_offline);
          this->__isset.is_offline = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_readonly);
          this->__isset.is_readonly = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_shadowcopy);
          this->__isset.is_shadowcopy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_system);
          this->__isset.is_system = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->mbr_type);
          this->__isset.mbr_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->offset);
          this->__isset.offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->partition_number);
          this->__isset.partition_number = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->size);
          this->__isset.size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t partition_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("partition_info");

  if (this->__isset.access_paths) {
    xfer += oprot->writeFieldBegin("access_paths", ::apache::thrift::protocol::T_SET, 1);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->access_paths.size()));
      std::set<std::string> ::const_iterator _iter10;
      for (_iter10 = this->access_paths.begin(); _iter10 != this->access_paths.end(); ++_iter10)
      {
        xfer += oprot->writeString((*_iter10));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.disk_number) {
    xfer += oprot->writeFieldBegin("disk_number", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->disk_number);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.drive_letter) {
    xfer += oprot->writeFieldBegin("drive_letter", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->drive_letter);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.gpt_type) {
    xfer += oprot->writeFieldBegin("gpt_type", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->gpt_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.guid) {
    xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->guid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_active) {
    xfer += oprot->writeFieldBegin("is_active", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->is_active);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_boot) {
    xfer += oprot->writeFieldBegin("is_boot", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->is_boot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_hidden) {
    xfer += oprot->writeFieldBegin("is_hidden", ::apache::thrift::protocol::T_BOOL, 8);
    xfer += oprot->writeBool(this->is_hidden);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_offline) {
    xfer += oprot->writeFieldBegin("is_offline", ::apache::thrift::protocol::T_BOOL, 9);
    xfer += oprot->writeBool(this->is_offline);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_readonly) {
    xfer += oprot->writeFieldBegin("is_readonly", ::apache::thrift::protocol::T_BOOL, 10);
    xfer += oprot->writeBool(this->is_readonly);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_shadowcopy) {
    xfer += oprot->writeFieldBegin("is_shadowcopy", ::apache::thrift::protocol::T_BOOL, 11);
    xfer += oprot->writeBool(this->is_shadowcopy);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_system) {
    xfer += oprot->writeFieldBegin("is_system", ::apache::thrift::protocol::T_BOOL, 12);
    xfer += oprot->writeBool(this->is_system);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mbr_type) {
    xfer += oprot->writeFieldBegin("mbr_type", ::apache::thrift::protocol::T_I16, 13);
    xfer += oprot->writeI16(this->mbr_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.offset) {
    xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I64, 14);
    xfer += oprot->writeI64(this->offset);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partition_number) {
    xfer += oprot->writeFieldBegin("partition_number", ::apache::thrift::protocol::T_I32, 15);
    xfer += oprot->writeI32(this->partition_number);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.size) {
    xfer += oprot->writeFieldBegin("size", ::apache::thrift::protocol::T_I64, 16);
    xfer += oprot->writeI64(this->size);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(partition_info &a, partition_info &b) {
  using ::std::swap;
  swap(a.access_paths, b.access_paths);
  swap(a.disk_number, b.disk_number);
  swap(a.drive_letter, b.drive_letter);
  swap(a.gpt_type, b.gpt_type);
  swap(a.guid, b.guid);
  swap(a.is_active, b.is_active);
  swap(a.is_boot, b.is_boot);
  swap(a.is_hidden, b.is_hidden);
  swap(a.is_offline, b.is_offline);
  swap(a.is_readonly, b.is_readonly);
  swap(a.is_shadowcopy, b.is_shadowcopy);
  swap(a.is_system, b.is_system);
  swap(a.mbr_type, b.mbr_type);
  swap(a.offset, b.offset);
  swap(a.partition_number, b.partition_number);
  swap(a.size, b.size);
  swap(a.__isset, b.__isset);
}

partition_info::partition_info(const partition_info& other11) {
  access_paths = other11.access_paths;
  disk_number = other11.disk_number;
  drive_letter = other11.drive_letter;
  gpt_type = other11.gpt_type;
  guid = other11.guid;
  is_active = other11.is_active;
  is_boot = other11.is_boot;
  is_hidden = other11.is_hidden;
  is_offline = other11.is_offline;
  is_readonly = other11.is_readonly;
  is_shadowcopy = other11.is_shadowcopy;
  is_system = other11.is_system;
  mbr_type = other11.mbr_type;
  offset = other11.offset;
  partition_number = other11.partition_number;
  size = other11.size;
  __isset = other11.__isset;
}
partition_info& partition_info::operator=(const partition_info& other12) {
  access_paths = other12.access_paths;
  disk_number = other12.disk_number;
  drive_letter = other12.drive_letter;
  gpt_type = other12.gpt_type;
  guid = other12.guid;
  is_active = other12.is_active;
  is_boot = other12.is_boot;
  is_hidden = other12.is_hidden;
  is_offline = other12.is_offline;
  is_readonly = other12.is_readonly;
  is_shadowcopy = other12.is_shadowcopy;
  is_system = other12.is_system;
  mbr_type = other12.mbr_type;
  offset = other12.offset;
  partition_number = other12.partition_number;
  size = other12.size;
  __isset = other12.__isset;
  return *this;
}
void partition_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "partition_info(";
  out << "access_paths="; (__isset.access_paths ? (out << to_string(access_paths)) : (out << "<null>"));
  out << ", " << "disk_number="; (__isset.disk_number ? (out << to_string(disk_number)) : (out << "<null>"));
  out << ", " << "drive_letter="; (__isset.drive_letter ? (out << to_string(drive_letter)) : (out << "<null>"));
  out << ", " << "gpt_type="; (__isset.gpt_type ? (out << to_string(gpt_type)) : (out << "<null>"));
  out << ", " << "guid="; (__isset.guid ? (out << to_string(guid)) : (out << "<null>"));
  out << ", " << "is_active="; (__isset.is_active ? (out << to_string(is_active)) : (out << "<null>"));
  out << ", " << "is_boot="; (__isset.is_boot ? (out << to_string(is_boot)) : (out << "<null>"));
  out << ", " << "is_hidden="; (__isset.is_hidden ? (out << to_string(is_hidden)) : (out << "<null>"));
  out << ", " << "is_offline="; (__isset.is_offline ? (out << to_string(is_offline)) : (out << "<null>"));
  out << ", " << "is_readonly="; (__isset.is_readonly ? (out << to_string(is_readonly)) : (out << "<null>"));
  out << ", " << "is_shadowcopy="; (__isset.is_shadowcopy ? (out << to_string(is_shadowcopy)) : (out << "<null>"));
  out << ", " << "is_system="; (__isset.is_system ? (out << to_string(is_system)) : (out << "<null>"));
  out << ", " << "mbr_type="; (__isset.mbr_type ? (out << to_string(mbr_type)) : (out << "<null>"));
  out << ", " << "offset="; (__isset.offset ? (out << to_string(offset)) : (out << "<null>"));
  out << ", " << "partition_number="; (__isset.partition_number ? (out << to_string(partition_number)) : (out << "<null>"));
  out << ", " << "size="; (__isset.size ? (out << to_string(size)) : (out << "<null>"));
  out << ")";
}


volume_info::~volume_info() throw() {
}


void volume_info::__set_access_paths(const std::set<std::string> & val) {
  this->access_paths = val;
__isset.access_paths = true;
}

void volume_info::__set_cluster_access_path(const std::string& val) {
  this->cluster_access_path = val;
__isset.cluster_access_path = true;
}

void volume_info::__set_drive_letter(const std::string& val) {
  this->drive_letter = val;
__isset.drive_letter = true;
}

void volume_info::__set_drive_type(const drive_type::type val) {
  this->drive_type = val;
__isset.drive_type = true;
}

void volume_info::__set_file_system(const std::string& val) {
  this->file_system = val;
__isset.file_system = true;
}

void volume_info::__set_file_system_catalogid(const std::string& val) {
  this->file_system_catalogid = val;
__isset.file_system_catalogid = true;
}

void volume_info::__set_file_system_label(const std::string& val) {
  this->file_system_label = val;
__isset.file_system_label = true;
}

void volume_info::__set_object_id(const std::string& val) {
  this->object_id = val;
__isset.object_id = true;
}

void volume_info::__set_path(const std::string& val) {
  this->path = val;
__isset.path = true;
}

void volume_info::__set_size(const int64_t val) {
  this->size = val;
__isset.size = true;
}

void volume_info::__set_size_remaining(const int64_t val) {
  this->size_remaining = val;
__isset.size_remaining = true;
}
std::ostream& operator<<(std::ostream& out, const volume_info& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t volume_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->access_paths.clear();
            uint32_t _size13;
            ::apache::thrift::protocol::TType _etype16;
            xfer += iprot->readSetBegin(_etype16, _size13);
            uint32_t _i17;
            for (_i17 = 0; _i17 < _size13; ++_i17)
            {
              std::string _elem18;
              xfer += iprot->readString(_elem18);
              this->access_paths.insert(_elem18);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.access_paths = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cluster_access_path);
          this->__isset.cluster_access_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->drive_letter);
          this->__isset.drive_letter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast19;
          xfer += iprot->readI32(ecast19);
          this->drive_type = (drive_type::type)ecast19;
          this->__isset.drive_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->file_system);
          this->__isset.file_system = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->file_system_catalogid);
          this->__isset.file_system_catalogid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->file_system_label);
          this->__isset.file_system_label = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->object_id);
          this->__isset.object_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->path);
          this->__isset.path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->size);
          this->__isset.size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->size_remaining);
          this->__isset.size_remaining = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t volume_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("volume_info");

  if (this->__isset.access_paths) {
    xfer += oprot->writeFieldBegin("access_paths", ::apache::thrift::protocol::T_SET, 1);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->access_paths.size()));
      std::set<std::string> ::const_iterator _iter20;
      for (_iter20 = this->access_paths.begin(); _iter20 != this->access_paths.end(); ++_iter20)
      {
        xfer += oprot->writeString((*_iter20));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_access_path) {
    xfer += oprot->writeFieldBegin("cluster_access_path", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->cluster_access_path);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.drive_letter) {
    xfer += oprot->writeFieldBegin("drive_letter", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->drive_letter);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.drive_type) {
    xfer += oprot->writeFieldBegin("drive_type", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32((int32_t)this->drive_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.file_system) {
    xfer += oprot->writeFieldBegin("file_system", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->file_system);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.file_system_catalogid) {
    xfer += oprot->writeFieldBegin("file_system_catalogid", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->file_system_catalogid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.file_system_label) {
    xfer += oprot->writeFieldBegin("file_system_label", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->file_system_label);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.object_id) {
    xfer += oprot->writeFieldBegin("object_id", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->object_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.path) {
    xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->path);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.size) {
    xfer += oprot->writeFieldBegin("size", ::apache::thrift::protocol::T_I64, 10);
    xfer += oprot->writeI64(this->size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.size_remaining) {
    xfer += oprot->writeFieldBegin("size_remaining", ::apache::thrift::protocol::T_I64, 11);
    xfer += oprot->writeI64(this->size_remaining);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(volume_info &a, volume_info &b) {
  using ::std::swap;
  swap(a.access_paths, b.access_paths);
  swap(a.cluster_access_path, b.cluster_access_path);
  swap(a.drive_letter, b.drive_letter);
  swap(a.drive_type, b.drive_type);
  swap(a.file_system, b.file_system);
  swap(a.file_system_catalogid, b.file_system_catalogid);
  swap(a.file_system_label, b.file_system_label);
  swap(a.object_id, b.object_id);
  swap(a.path, b.path);
  swap(a.size, b.size);
  swap(a.size_remaining, b.size_remaining);
  swap(a.__isset, b.__isset);
}

volume_info::volume_info(const volume_info& other21) {
  access_paths = other21.access_paths;
  cluster_access_path = other21.cluster_access_path;
  drive_letter = other21.drive_letter;
  drive_type = other21.drive_type;
  file_system = other21.file_system;
  file_system_catalogid = other21.file_system_catalogid;
  file_system_label = other21.file_system_label;
  object_id = other21.object_id;
  path = other21.path;
  size = other21.size;
  size_remaining = other21.size_remaining;
  __isset = other21.__isset;
}
volume_info& volume_info::operator=(const volume_info& other22) {
  access_paths = other22.access_paths;
  cluster_access_path = other22.cluster_access_path;
  drive_letter = other22.drive_letter;
  drive_type = other22.drive_type;
  file_system = other22.file_system;
  file_system_catalogid = other22.file_system_catalogid;
  file_system_label = other22.file_system_label;
  object_id = other22.object_id;
  path = other22.path;
  size = other22.size;
  size_remaining = other22.size_remaining;
  __isset = other22.__isset;
  return *this;
}
void volume_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "volume_info(";
  out << "access_paths="; (__isset.access_paths ? (out << to_string(access_paths)) : (out << "<null>"));
  out << ", " << "cluster_access_path="; (__isset.cluster_access_path ? (out << to_string(cluster_access_path)) : (out << "<null>"));
  out << ", " << "drive_letter="; (__isset.drive_letter ? (out << to_string(drive_letter)) : (out << "<null>"));
  out << ", " << "drive_type="; (__isset.drive_type ? (out << to_string(drive_type)) : (out << "<null>"));
  out << ", " << "file_system="; (__isset.file_system ? (out << to_string(file_system)) : (out << "<null>"));
  out << ", " << "file_system_catalogid="; (__isset.file_system_catalogid ? (out << to_string(file_system_catalogid)) : (out << "<null>"));
  out << ", " << "file_system_label="; (__isset.file_system_label ? (out << to_string(file_system_label)) : (out << "<null>"));
  out << ", " << "object_id="; (__isset.object_id ? (out << to_string(object_id)) : (out << "<null>"));
  out << ", " << "path="; (__isset.path ? (out << to_string(path)) : (out << "<null>"));
  out << ", " << "size="; (__isset.size ? (out << to_string(size)) : (out << "<null>"));
  out << ", " << "size_remaining="; (__isset.size_remaining ? (out << to_string(size_remaining)) : (out << "<null>"));
  out << ")";
}


network_info::~network_info() throw() {
}


void network_info::__set_adapter_name(const std::string& val) {
  this->adapter_name = val;
__isset.adapter_name = true;
}

void network_info::__set_description(const std::string& val) {
  this->description = val;
__isset.description = true;
}

void network_info::__set_dnss(const std::vector<std::string> & val) {
  this->dnss = val;
__isset.dnss = true;
}

void network_info::__set_gateways(const std::vector<std::string> & val) {
  this->gateways = val;
__isset.gateways = true;
}

void network_info::__set_ip_addresses(const std::vector<std::string> & val) {
  this->ip_addresses = val;
__isset.ip_addresses = true;
}

void network_info::__set_is_dhcp_v4(const bool val) {
  this->is_dhcp_v4 = val;
__isset.is_dhcp_v4 = true;
}

void network_info::__set_is_dhcp_v6(const bool val) {
  this->is_dhcp_v6 = val;
__isset.is_dhcp_v6 = true;
}

void network_info::__set_mac_address(const std::string& val) {
  this->mac_address = val;
__isset.mac_address = true;
}

void network_info::__set_subnet_masks(const std::vector<std::string> & val) {
  this->subnet_masks = val;
__isset.subnet_masks = true;
}
std::ostream& operator<<(std::ostream& out, const network_info& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t network_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->adapter_name);
          this->__isset.adapter_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->description);
          this->__isset.description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->dnss.clear();
            uint32_t _size23;
            ::apache::thrift::protocol::TType _etype26;
            xfer += iprot->readListBegin(_etype26, _size23);
            this->dnss.resize(_size23);
            uint32_t _i27;
            for (_i27 = 0; _i27 < _size23; ++_i27)
            {
              xfer += iprot->readString(this->dnss[_i27]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.dnss = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->gateways.clear();
            uint32_t _size28;
            ::apache::thrift::protocol::TType _etype31;
            xfer += iprot->readListBegin(_etype31, _size28);
            this->gateways.resize(_size28);
            uint32_t _i32;
            for (_i32 = 0; _i32 < _size28; ++_i32)
            {
              xfer += iprot->readString(this->gateways[_i32]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.gateways = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->ip_addresses.clear();
            uint32_t _size33;
            ::apache::thrift::protocol::TType _etype36;
            xfer += iprot->readListBegin(_etype36, _size33);
            this->ip_addresses.resize(_size33);
            uint32_t _i37;
            for (_i37 = 0; _i37 < _size33; ++_i37)
            {
              xfer += iprot->readString(this->ip_addresses[_i37]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.ip_addresses = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_dhcp_v4);
          this->__isset.is_dhcp_v4 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_dhcp_v6);
          this->__isset.is_dhcp_v6 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->mac_address);
          this->__isset.mac_address = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->subnet_masks.clear();
            uint32_t _size38;
            ::apache::thrift::protocol::TType _etype41;
            xfer += iprot->readListBegin(_etype41, _size38);
            this->subnet_masks.resize(_size38);
            uint32_t _i42;
            for (_i42 = 0; _i42 < _size38; ++_i42)
            {
              xfer += iprot->readString(this->subnet_masks[_i42]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.subnet_masks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t network_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("network_info");

  if (this->__isset.adapter_name) {
    xfer += oprot->writeFieldBegin("adapter_name", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->adapter_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.description) {
    xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->description);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dnss) {
    xfer += oprot->writeFieldBegin("dnss", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->dnss.size()));
      std::vector<std::string> ::const_iterator _iter43;
      for (_iter43 = this->dnss.begin(); _iter43 != this->dnss.end(); ++_iter43)
      {
        xfer += oprot->writeString((*_iter43));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.gateways) {
    xfer += oprot->writeFieldBegin("gateways", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->gateways.size()));
      std::vector<std::string> ::const_iterator _iter44;
      for (_iter44 = this->gateways.begin(); _iter44 != this->gateways.end(); ++_iter44)
      {
        xfer += oprot->writeString((*_iter44));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ip_addresses) {
    xfer += oprot->writeFieldBegin("ip_addresses", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->ip_addresses.size()));
      std::vector<std::string> ::const_iterator _iter45;
      for (_iter45 = this->ip_addresses.begin(); _iter45 != this->ip_addresses.end(); ++_iter45)
      {
        xfer += oprot->writeString((*_iter45));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_dhcp_v4) {
    xfer += oprot->writeFieldBegin("is_dhcp_v4", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->is_dhcp_v4);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_dhcp_v6) {
    xfer += oprot->writeFieldBegin("is_dhcp_v6", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->is_dhcp_v6);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mac_address) {
    xfer += oprot->writeFieldBegin("mac_address", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->mac_address);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.subnet_masks) {
    xfer += oprot->writeFieldBegin("subnet_masks", ::apache::thrift::protocol::T_LIST, 9);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->subnet_masks.size()));
      std::vector<std::string> ::const_iterator _iter46;
      for (_iter46 = this->subnet_masks.begin(); _iter46 != this->subnet_masks.end(); ++_iter46)
      {
        xfer += oprot->writeString((*_iter46));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(network_info &a, network_info &b) {
  using ::std::swap;
  swap(a.adapter_name, b.adapter_name);
  swap(a.description, b.description);
  swap(a.dnss, b.dnss);
  swap(a.gateways, b.gateways);
  swap(a.ip_addresses, b.ip_addresses);
  swap(a.is_dhcp_v4, b.is_dhcp_v4);
  swap(a.is_dhcp_v6, b.is_dhcp_v6);
  swap(a.mac_address, b.mac_address);
  swap(a.subnet_masks, b.subnet_masks);
  swap(a.__isset, b.__isset);
}

network_info::network_info(const network_info& other47) {
  adapter_name = other47.adapter_name;
  description = other47.description;
  dnss = other47.dnss;
  gateways = other47.gateways;
  ip_addresses = other47.ip_addresses;
  is_dhcp_v4 = other47.is_dhcp_v4;
  is_dhcp_v6 = other47.is_dhcp_v6;
  mac_address = other47.mac_address;
  subnet_masks = other47.subnet_masks;
  __isset = other47.__isset;
}
network_info& network_info::operator=(const network_info& other48) {
  adapter_name = other48.adapter_name;
  description = other48.description;
  dnss = other48.dnss;
  gateways = other48.gateways;
  ip_addresses = other48.ip_addresses;
  is_dhcp_v4 = other48.is_dhcp_v4;
  is_dhcp_v6 = other48.is_dhcp_v6;
  mac_address = other48.mac_address;
  subnet_masks = other48.subnet_masks;
  __isset = other48.__isset;
  return *this;
}
void network_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "network_info(";
  out << "adapter_name="; (__isset.adapter_name ? (out << to_string(adapter_name)) : (out << "<null>"));
  out << ", " << "description="; (__isset.description ? (out << to_string(description)) : (out << "<null>"));
  out << ", " << "dnss="; (__isset.dnss ? (out << to_string(dnss)) : (out << "<null>"));
  out << ", " << "gateways="; (__isset.gateways ? (out << to_string(gateways)) : (out << "<null>"));
  out << ", " << "ip_addresses="; (__isset.ip_addresses ? (out << to_string(ip_addresses)) : (out << "<null>"));
  out << ", " << "is_dhcp_v4="; (__isset.is_dhcp_v4 ? (out << to_string(is_dhcp_v4)) : (out << "<null>"));
  out << ", " << "is_dhcp_v6="; (__isset.is_dhcp_v6 ? (out << to_string(is_dhcp_v6)) : (out << "<null>"));
  out << ", " << "mac_address="; (__isset.mac_address ? (out << to_string(mac_address)) : (out << "<null>"));
  out << ", " << "subnet_masks="; (__isset.subnet_masks ? (out << to_string(subnet_masks)) : (out << "<null>"));
  out << ")";
}


cluster_network::~cluster_network() throw() {
}


void cluster_network::__set_cluster_network_name(const std::string& val) {
  this->cluster_network_name = val;
__isset.cluster_network_name = true;
}

void cluster_network::__set_cluster_network_id(const std::string& val) {
  this->cluster_network_id = val;
__isset.cluster_network_id = true;
}

void cluster_network::__set_cluster_network_address(const std::string& val) {
  this->cluster_network_address = val;
__isset.cluster_network_address = true;
}

void cluster_network::__set_cluster_network_address_mask(const std::string& val) {
  this->cluster_network_address_mask = val;
__isset.cluster_network_address_mask = true;
}

void cluster_network::__set_network_infos(const std::set<network_info> & val) {
  this->network_infos = val;
__isset.network_infos = true;
}
std::ostream& operator<<(std::ostream& out, const cluster_network& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t cluster_network::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cluster_network_name);
          this->__isset.cluster_network_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cluster_network_id);
          this->__isset.cluster_network_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cluster_network_address);
          this->__isset.cluster_network_address = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cluster_network_address_mask);
          this->__isset.cluster_network_address_mask = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->network_infos.clear();
            uint32_t _size49;
            ::apache::thrift::protocol::TType _etype52;
            xfer += iprot->readSetBegin(_etype52, _size49);
            uint32_t _i53;
            for (_i53 = 0; _i53 < _size49; ++_i53)
            {
              network_info _elem54;
              xfer += _elem54.read(iprot);
              this->network_infos.insert(_elem54);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.network_infos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t cluster_network::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("cluster_network");

  if (this->__isset.cluster_network_name) {
    xfer += oprot->writeFieldBegin("cluster_network_name", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->cluster_network_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_network_id) {
    xfer += oprot->writeFieldBegin("cluster_network_id", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->cluster_network_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_network_address) {
    xfer += oprot->writeFieldBegin("cluster_network_address", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->cluster_network_address);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_network_address_mask) {
    xfer += oprot->writeFieldBegin("cluster_network_address_mask", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->cluster_network_address_mask);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.network_infos) {
    xfer += oprot->writeFieldBegin("network_infos", ::apache::thrift::protocol::T_SET, 5);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->network_infos.size()));
      std::set<network_info> ::const_iterator _iter55;
      for (_iter55 = this->network_infos.begin(); _iter55 != this->network_infos.end(); ++_iter55)
      {
        xfer += (*_iter55).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(cluster_network &a, cluster_network &b) {
  using ::std::swap;
  swap(a.cluster_network_name, b.cluster_network_name);
  swap(a.cluster_network_id, b.cluster_network_id);
  swap(a.cluster_network_address, b.cluster_network_address);
  swap(a.cluster_network_address_mask, b.cluster_network_address_mask);
  swap(a.network_infos, b.network_infos);
  swap(a.__isset, b.__isset);
}

cluster_network::cluster_network(const cluster_network& other56) {
  cluster_network_name = other56.cluster_network_name;
  cluster_network_id = other56.cluster_network_id;
  cluster_network_address = other56.cluster_network_address;
  cluster_network_address_mask = other56.cluster_network_address_mask;
  network_infos = other56.network_infos;
  __isset = other56.__isset;
}
cluster_network& cluster_network::operator=(const cluster_network& other57) {
  cluster_network_name = other57.cluster_network_name;
  cluster_network_id = other57.cluster_network_id;
  cluster_network_address = other57.cluster_network_address;
  cluster_network_address_mask = other57.cluster_network_address_mask;
  network_infos = other57.network_infos;
  __isset = other57.__isset;
  return *this;
}
void cluster_network::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "cluster_network(";
  out << "cluster_network_name="; (__isset.cluster_network_name ? (out << to_string(cluster_network_name)) : (out << "<null>"));
  out << ", " << "cluster_network_id="; (__isset.cluster_network_id ? (out << to_string(cluster_network_id)) : (out << "<null>"));
  out << ", " << "cluster_network_address="; (__isset.cluster_network_address ? (out << to_string(cluster_network_address)) : (out << "<null>"));
  out << ", " << "cluster_network_address_mask="; (__isset.cluster_network_address_mask ? (out << to_string(cluster_network_address_mask)) : (out << "<null>"));
  out << ", " << "network_infos="; (__isset.network_infos ? (out << to_string(network_infos)) : (out << "<null>"));
  out << ")";
}


cluster_group::~cluster_group() throw() {
}


void cluster_group::__set_group_id(const std::string& val) {
  this->group_id = val;
__isset.group_id = true;
}

void cluster_group::__set_group_name(const std::string& val) {
  this->group_name = val;
__isset.group_name = true;
}

void cluster_group::__set_group_owner(const std::string& val) {
  this->group_owner = val;
__isset.group_owner = true;
}

void cluster_group::__set_cluster_disks(const std::set<disk_info> & val) {
  this->cluster_disks = val;
__isset.cluster_disks = true;
}

void cluster_group::__set_cluster_partitions(const std::set<volume_info> & val) {
  this->cluster_partitions = val;
__isset.cluster_partitions = true;
}

void cluster_group::__set_cluster_network_infos(const std::set<cluster_network> & val) {
  this->cluster_network_infos = val;
__isset.cluster_network_infos = true;
}
std::ostream& operator<<(std::ostream& out, const cluster_group& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t cluster_group::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->group_id);
          this->__isset.group_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->group_name);
          this->__isset.group_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->group_owner);
          this->__isset.group_owner = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->cluster_disks.clear();
            uint32_t _size58;
            ::apache::thrift::protocol::TType _etype61;
            xfer += iprot->readSetBegin(_etype61, _size58);
            uint32_t _i62;
            for (_i62 = 0; _i62 < _size58; ++_i62)
            {
              disk_info _elem63;
              xfer += _elem63.read(iprot);
              this->cluster_disks.insert(_elem63);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.cluster_disks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->cluster_partitions.clear();
            uint32_t _size64;
            ::apache::thrift::protocol::TType _etype67;
            xfer += iprot->readSetBegin(_etype67, _size64);
            uint32_t _i68;
            for (_i68 = 0; _i68 < _size64; ++_i68)
            {
              volume_info _elem69;
              xfer += _elem69.read(iprot);
              this->cluster_partitions.insert(_elem69);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.cluster_partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->cluster_network_infos.clear();
            uint32_t _size70;
            ::apache::thrift::protocol::TType _etype73;
            xfer += iprot->readSetBegin(_etype73, _size70);
            uint32_t _i74;
            for (_i74 = 0; _i74 < _size70; ++_i74)
            {
              cluster_network _elem75;
              xfer += _elem75.read(iprot);
              this->cluster_network_infos.insert(_elem75);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.cluster_network_infos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t cluster_group::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("cluster_group");

  if (this->__isset.group_id) {
    xfer += oprot->writeFieldBegin("group_id", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->group_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.group_name) {
    xfer += oprot->writeFieldBegin("group_name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->group_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.group_owner) {
    xfer += oprot->writeFieldBegin("group_owner", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->group_owner);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_disks) {
    xfer += oprot->writeFieldBegin("cluster_disks", ::apache::thrift::protocol::T_SET, 4);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cluster_disks.size()));
      std::set<disk_info> ::const_iterator _iter76;
      for (_iter76 = this->cluster_disks.begin(); _iter76 != this->cluster_disks.end(); ++_iter76)
      {
        xfer += (*_iter76).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_partitions) {
    xfer += oprot->writeFieldBegin("cluster_partitions", ::apache::thrift::protocol::T_SET, 5);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cluster_partitions.size()));
      std::set<volume_info> ::const_iterator _iter77;
      for (_iter77 = this->cluster_partitions.begin(); _iter77 != this->cluster_partitions.end(); ++_iter77)
      {
        xfer += (*_iter77).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_network_infos) {
    xfer += oprot->writeFieldBegin("cluster_network_infos", ::apache::thrift::protocol::T_SET, 6);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cluster_network_infos.size()));
      std::set<cluster_network> ::const_iterator _iter78;
      for (_iter78 = this->cluster_network_infos.begin(); _iter78 != this->cluster_network_infos.end(); ++_iter78)
      {
        xfer += (*_iter78).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(cluster_group &a, cluster_group &b) {
  using ::std::swap;
  swap(a.group_id, b.group_id);
  swap(a.group_name, b.group_name);
  swap(a.group_owner, b.group_owner);
  swap(a.cluster_disks, b.cluster_disks);
  swap(a.cluster_partitions, b.cluster_partitions);
  swap(a.cluster_network_infos, b.cluster_network_infos);
  swap(a.__isset, b.__isset);
}

cluster_group::cluster_group(const cluster_group& other79) {
  group_id = other79.group_id;
  group_name = other79.group_name;
  group_owner = other79.group_owner;
  cluster_disks = other79.cluster_disks;
  cluster_partitions = other79.cluster_partitions;
  cluster_network_infos = other79.cluster_network_infos;
  __isset = other79.__isset;
}
cluster_group& cluster_group::operator=(const cluster_group& other80) {
  group_id = other80.group_id;
  group_name = other80.group_name;
  group_owner = other80.group_owner;
  cluster_disks = other80.cluster_disks;
  cluster_partitions = other80.cluster_partitions;
  cluster_network_infos = other80.cluster_network_infos;
  __isset = other80.__isset;
  return *this;
}
void cluster_group::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "cluster_group(";
  out << "group_id="; (__isset.group_id ? (out << to_string(group_id)) : (out << "<null>"));
  out << ", " << "group_name="; (__isset.group_name ? (out << to_string(group_name)) : (out << "<null>"));
  out << ", " << "group_owner="; (__isset.group_owner ? (out << to_string(group_owner)) : (out << "<null>"));
  out << ", " << "cluster_disks="; (__isset.cluster_disks ? (out << to_string(cluster_disks)) : (out << "<null>"));
  out << ", " << "cluster_partitions="; (__isset.cluster_partitions ? (out << to_string(cluster_partitions)) : (out << "<null>"));
  out << ", " << "cluster_network_infos="; (__isset.cluster_network_infos ? (out << to_string(cluster_network_infos)) : (out << "<null>"));
  out << ")";
}


cluster_info::~cluster_info() throw() {
}


void cluster_info::__set_cluster_name(const std::string& val) {
  this->cluster_name = val;
__isset.cluster_name = true;
}

void cluster_info::__set_quorum_disk(const disk_info& val) {
  this->quorum_disk = val;
__isset.quorum_disk = true;
}

void cluster_info::__set_cluster_nodes(const std::set<std::string> & val) {
  this->cluster_nodes = val;
__isset.cluster_nodes = true;
}

void cluster_info::__set_client_ids(const std::set<std::string> & val) {
  this->client_ids = val;
__isset.client_ids = true;
}

void cluster_info::__set_machine_ids(const std::set<std::string> & val) {
  this->machine_ids = val;
__isset.machine_ids = true;
}

void cluster_info::__set_cluster_network_infos(const std::set<cluster_network> & val) {
  this->cluster_network_infos = val;
__isset.cluster_network_infos = true;
}

void cluster_info::__set_cluster_groups(const std::set<cluster_group> & val) {
  this->cluster_groups = val;
__isset.cluster_groups = true;
}
std::ostream& operator<<(std::ostream& out, const cluster_info& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t cluster_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cluster_name);
          this->__isset.cluster_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->quorum_disk.read(iprot);
          this->__isset.quorum_disk = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->cluster_nodes.clear();
            uint32_t _size81;
            ::apache::thrift::protocol::TType _etype84;
            xfer += iprot->readSetBegin(_etype84, _size81);
            uint32_t _i85;
            for (_i85 = 0; _i85 < _size81; ++_i85)
            {
              std::string _elem86;
              xfer += iprot->readString(_elem86);
              this->cluster_nodes.insert(_elem86);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.cluster_nodes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->client_ids.clear();
            uint32_t _size87;
            ::apache::thrift::protocol::TType _etype90;
            xfer += iprot->readSetBegin(_etype90, _size87);
            uint32_t _i91;
            for (_i91 = 0; _i91 < _size87; ++_i91)
            {
              std::string _elem92;
              xfer += iprot->readString(_elem92);
              this->client_ids.insert(_elem92);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.client_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->machine_ids.clear();
            uint32_t _size93;
            ::apache::thrift::protocol::TType _etype96;
            xfer += iprot->readSetBegin(_etype96, _size93);
            uint32_t _i97;
            for (_i97 = 0; _i97 < _size93; ++_i97)
            {
              std::string _elem98;
              xfer += iprot->readString(_elem98);
              this->machine_ids.insert(_elem98);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.machine_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->cluster_network_infos.clear();
            uint32_t _size99;
            ::apache::thrift::protocol::TType _etype102;
            xfer += iprot->readSetBegin(_etype102, _size99);
            uint32_t _i103;
            for (_i103 = 0; _i103 < _size99; ++_i103)
            {
              cluster_network _elem104;
              xfer += _elem104.read(iprot);
              this->cluster_network_infos.insert(_elem104);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.cluster_network_infos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->cluster_groups.clear();
            uint32_t _size105;
            ::apache::thrift::protocol::TType _etype108;
            xfer += iprot->readSetBegin(_etype108, _size105);
            uint32_t _i109;
            for (_i109 = 0; _i109 < _size105; ++_i109)
            {
              cluster_group _elem110;
              xfer += _elem110.read(iprot);
              this->cluster_groups.insert(_elem110);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.cluster_groups = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t cluster_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("cluster_info");

  if (this->__isset.cluster_name) {
    xfer += oprot->writeFieldBegin("cluster_name", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->cluster_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.quorum_disk) {
    xfer += oprot->writeFieldBegin("quorum_disk", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->quorum_disk.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_nodes) {
    xfer += oprot->writeFieldBegin("cluster_nodes", ::apache::thrift::protocol::T_SET, 3);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->cluster_nodes.size()));
      std::set<std::string> ::const_iterator _iter111;
      for (_iter111 = this->cluster_nodes.begin(); _iter111 != this->cluster_nodes.end(); ++_iter111)
      {
        xfer += oprot->writeString((*_iter111));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.client_ids) {
    xfer += oprot->writeFieldBegin("client_ids", ::apache::thrift::protocol::T_SET, 4);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->client_ids.size()));
      std::set<std::string> ::const_iterator _iter112;
      for (_iter112 = this->client_ids.begin(); _iter112 != this->client_ids.end(); ++_iter112)
      {
        xfer += oprot->writeString((*_iter112));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.machine_ids) {
    xfer += oprot->writeFieldBegin("machine_ids", ::apache::thrift::protocol::T_SET, 5);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->machine_ids.size()));
      std::set<std::string> ::const_iterator _iter113;
      for (_iter113 = this->machine_ids.begin(); _iter113 != this->machine_ids.end(); ++_iter113)
      {
        xfer += oprot->writeString((*_iter113));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_network_infos) {
    xfer += oprot->writeFieldBegin("cluster_network_infos", ::apache::thrift::protocol::T_SET, 6);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cluster_network_infos.size()));
      std::set<cluster_network> ::const_iterator _iter114;
      for (_iter114 = this->cluster_network_infos.begin(); _iter114 != this->cluster_network_infos.end(); ++_iter114)
      {
        xfer += (*_iter114).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_groups) {
    xfer += oprot->writeFieldBegin("cluster_groups", ::apache::thrift::protocol::T_SET, 7);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cluster_groups.size()));
      std::set<cluster_group> ::const_iterator _iter115;
      for (_iter115 = this->cluster_groups.begin(); _iter115 != this->cluster_groups.end(); ++_iter115)
      {
        xfer += (*_iter115).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(cluster_info &a, cluster_info &b) {
  using ::std::swap;
  swap(a.cluster_name, b.cluster_name);
  swap(a.quorum_disk, b.quorum_disk);
  swap(a.cluster_nodes, b.cluster_nodes);
  swap(a.client_ids, b.client_ids);
  swap(a.machine_ids, b.machine_ids);
  swap(a.cluster_network_infos, b.cluster_network_infos);
  swap(a.cluster_groups, b.cluster_groups);
  swap(a.__isset, b.__isset);
}

cluster_info::cluster_info(const cluster_info& other116) {
  cluster_name = other116.cluster_name;
  quorum_disk = other116.quorum_disk;
  cluster_nodes = other116.cluster_nodes;
  client_ids = other116.client_ids;
  machine_ids = other116.machine_ids;
  cluster_network_infos = other116.cluster_network_infos;
  cluster_groups = other116.cluster_groups;
  __isset = other116.__isset;
}
cluster_info& cluster_info::operator=(const cluster_info& other117) {
  cluster_name = other117.cluster_name;
  quorum_disk = other117.quorum_disk;
  cluster_nodes = other117.cluster_nodes;
  client_ids = other117.client_ids;
  machine_ids = other117.machine_ids;
  cluster_network_infos = other117.cluster_network_infos;
  cluster_groups = other117.cluster_groups;
  __isset = other117.__isset;
  return *this;
}
void cluster_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "cluster_info(";
  out << "cluster_name="; (__isset.cluster_name ? (out << to_string(cluster_name)) : (out << "<null>"));
  out << ", " << "quorum_disk="; (__isset.quorum_disk ? (out << to_string(quorum_disk)) : (out << "<null>"));
  out << ", " << "cluster_nodes="; (__isset.cluster_nodes ? (out << to_string(cluster_nodes)) : (out << "<null>"));
  out << ", " << "client_ids="; (__isset.client_ids ? (out << to_string(client_ids)) : (out << "<null>"));
  out << ", " << "machine_ids="; (__isset.machine_ids ? (out << to_string(machine_ids)) : (out << "<null>"));
  out << ", " << "cluster_network_infos="; (__isset.cluster_network_infos ? (out << to_string(cluster_network_infos)) : (out << "<null>"));
  out << ", " << "cluster_groups="; (__isset.cluster_groups ? (out << to_string(cluster_groups)) : (out << "<null>"));
  out << ")";
}


os_version_info::~os_version_info() throw() {
}


void os_version_info::__set_csd_version(const std::string& val) {
  this->csd_version = val;
__isset.csd_version = true;
}

void os_version_info::__set_build_number(const int32_t val) {
  this->build_number = val;
__isset.build_number = true;
}

void os_version_info::__set_major_version(const int32_t val) {
  this->major_version = val;
__isset.major_version = true;
}

void os_version_info::__set_minor_version(const int32_t val) {
  this->minor_version = val;
__isset.minor_version = true;
}

void os_version_info::__set_platform_id(const int32_t val) {
  this->platform_id = val;
__isset.platform_id = true;
}

void os_version_info::__set_product_type(const int16_t val) {
  this->product_type = val;
__isset.product_type = true;
}

void os_version_info::__set_servicepack_major(const int32_t val) {
  this->servicepack_major = val;
__isset.servicepack_major = true;
}

void os_version_info::__set_servicepack_minor(const int32_t val) {
  this->servicepack_minor = val;
__isset.servicepack_minor = true;
}

void os_version_info::__set_suite_mask(const int32_t val) {
  this->suite_mask = val;
__isset.suite_mask = true;
}
std::ostream& operator<<(std::ostream& out, const os_version_info& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t os_version_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->csd_version);
          this->__isset.csd_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->build_number);
          this->__isset.build_number = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->major_version);
          this->__isset.major_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->minor_version);
          this->__isset.minor_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->platform_id);
          this->__isset.platform_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->product_type);
          this->__isset.product_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->servicepack_major);
          this->__isset.servicepack_major = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->servicepack_minor);
          this->__isset.servicepack_minor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->suite_mask);
          this->__isset.suite_mask = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t os_version_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("os_version_info");

  if (this->__isset.csd_version) {
    xfer += oprot->writeFieldBegin("csd_version", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->csd_version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.build_number) {
    xfer += oprot->writeFieldBegin("build_number", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->build_number);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.major_version) {
    xfer += oprot->writeFieldBegin("major_version", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->major_version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.minor_version) {
    xfer += oprot->writeFieldBegin("minor_version", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->minor_version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.platform_id) {
    xfer += oprot->writeFieldBegin("platform_id", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->platform_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.product_type) {
    xfer += oprot->writeFieldBegin("product_type", ::apache::thrift::protocol::T_I16, 6);
    xfer += oprot->writeI16(this->product_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.servicepack_major) {
    xfer += oprot->writeFieldBegin("servicepack_major", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32(this->servicepack_major);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.servicepack_minor) {
    xfer += oprot->writeFieldBegin("servicepack_minor", ::apache::thrift::protocol::T_I32, 8);
    xfer += oprot->writeI32(this->servicepack_minor);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.suite_mask) {
    xfer += oprot->writeFieldBegin("suite_mask", ::apache::thrift::protocol::T_I32, 9);
    xfer += oprot->writeI32(this->suite_mask);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(os_version_info &a, os_version_info &b) {
  using ::std::swap;
  swap(a.csd_version, b.csd_version);
  swap(a.build_number, b.build_number);
  swap(a.major_version, b.major_version);
  swap(a.minor_version, b.minor_version);
  swap(a.platform_id, b.platform_id);
  swap(a.product_type, b.product_type);
  swap(a.servicepack_major, b.servicepack_major);
  swap(a.servicepack_minor, b.servicepack_minor);
  swap(a.suite_mask, b.suite_mask);
  swap(a.__isset, b.__isset);
}

os_version_info::os_version_info(const os_version_info& other118) {
  csd_version = other118.csd_version;
  build_number = other118.build_number;
  major_version = other118.major_version;
  minor_version = other118.minor_version;
  platform_id = other118.platform_id;
  product_type = other118.product_type;
  servicepack_major = other118.servicepack_major;
  servicepack_minor = other118.servicepack_minor;
  suite_mask = other118.suite_mask;
  __isset = other118.__isset;
}
os_version_info& os_version_info::operator=(const os_version_info& other119) {
  csd_version = other119.csd_version;
  build_number = other119.build_number;
  major_version = other119.major_version;
  minor_version = other119.minor_version;
  platform_id = other119.platform_id;
  product_type = other119.product_type;
  servicepack_major = other119.servicepack_major;
  servicepack_minor = other119.servicepack_minor;
  suite_mask = other119.suite_mask;
  __isset = other119.__isset;
  return *this;
}
void os_version_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "os_version_info(";
  out << "csd_version="; (__isset.csd_version ? (out << to_string(csd_version)) : (out << "<null>"));
  out << ", " << "build_number="; (__isset.build_number ? (out << to_string(build_number)) : (out << "<null>"));
  out << ", " << "major_version="; (__isset.major_version ? (out << to_string(major_version)) : (out << "<null>"));
  out << ", " << "minor_version="; (__isset.minor_version ? (out << to_string(minor_version)) : (out << "<null>"));
  out << ", " << "platform_id="; (__isset.platform_id ? (out << to_string(platform_id)) : (out << "<null>"));
  out << ", " << "product_type="; (__isset.product_type ? (out << to_string(product_type)) : (out << "<null>"));
  out << ", " << "servicepack_major="; (__isset.servicepack_major ? (out << to_string(servicepack_major)) : (out << "<null>"));
  out << ", " << "servicepack_minor="; (__isset.servicepack_minor ? (out << to_string(servicepack_minor)) : (out << "<null>"));
  out << ", " << "suite_mask="; (__isset.suite_mask ? (out << to_string(suite_mask)) : (out << "<null>"));
  out << ")";
}


snapshot::~snapshot() throw() {
}


void snapshot::__set_snapshot_set_id(const std::string& val) {
  this->snapshot_set_id = val;
__isset.snapshot_set_id = true;
}

void snapshot::__set_snapshot_id(const std::string& val) {
  this->snapshot_id = val;
__isset.snapshot_id = true;
}

void snapshot::__set_original_volume_name(const std::string& val) {
  this->original_volume_name = val;
__isset.original_volume_name = true;
}

void snapshot::__set_snapshot_device_object(const std::string& val) {
  this->snapshot_device_object = val;
__isset.snapshot_device_object = true;
}

void snapshot::__set_creation_time_stamp(const std::string& val) {
  this->creation_time_stamp = val;
__isset.creation_time_stamp = true;
}

void snapshot::__set_snapshots_count(const int32_t val) {
  this->snapshots_count = val;
__isset.snapshots_count = true;
}
std::ostream& operator<<(std::ostream& out, const snapshot& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t snapshot::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->snapshot_set_id);
          this->__isset.snapshot_set_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->snapshot_id);
          this->__isset.snapshot_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->original_volume_name);
          this->__isset.original_volume_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->snapshot_device_object);
          this->__isset.snapshot_device_object = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->creation_time_stamp);
          this->__isset.creation_time_stamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->snapshots_count);
          this->__isset.snapshots_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t snapshot::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("snapshot");

  if (this->__isset.snapshot_set_id) {
    xfer += oprot->writeFieldBegin("snapshot_set_id", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->snapshot_set_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.snapshot_id) {
    xfer += oprot->writeFieldBegin("snapshot_id", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->snapshot_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.original_volume_name) {
    xfer += oprot->writeFieldBegin("original_volume_name", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->original_volume_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.snapshot_device_object) {
    xfer += oprot->writeFieldBegin("snapshot_device_object", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->snapshot_device_object);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.creation_time_stamp) {
    xfer += oprot->writeFieldBegin("creation_time_stamp", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->creation_time_stamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.snapshots_count) {
    xfer += oprot->writeFieldBegin("snapshots_count", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(this->snapshots_count);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(snapshot &a, snapshot &b) {
  using ::std::swap;
  swap(a.snapshot_set_id, b.snapshot_set_id);
  swap(a.snapshot_id, b.snapshot_id);
  swap(a.original_volume_name, b.original_volume_name);
  swap(a.snapshot_device_object, b.snapshot_device_object);
  swap(a.creation_time_stamp, b.creation_time_stamp);
  swap(a.snapshots_count, b.snapshots_count);
  swap(a.__isset, b.__isset);
}

snapshot::snapshot(const snapshot& other120) {
  snapshot_set_id = other120.snapshot_set_id;
  snapshot_id = other120.snapshot_id;
  original_volume_name = other120.original_volume_name;
  snapshot_device_object = other120.snapshot_device_object;
  creation_time_stamp = other120.creation_time_stamp;
  snapshots_count = other120.snapshots_count;
  __isset = other120.__isset;
}
snapshot& snapshot::operator=(const snapshot& other121) {
  snapshot_set_id = other121.snapshot_set_id;
  snapshot_id = other121.snapshot_id;
  original_volume_name = other121.original_volume_name;
  snapshot_device_object = other121.snapshot_device_object;
  creation_time_stamp = other121.creation_time_stamp;
  snapshots_count = other121.snapshots_count;
  __isset = other121.__isset;
  return *this;
}
void snapshot::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "snapshot(";
  out << "snapshot_set_id="; (__isset.snapshot_set_id ? (out << to_string(snapshot_set_id)) : (out << "<null>"));
  out << ", " << "snapshot_id="; (__isset.snapshot_id ? (out << to_string(snapshot_id)) : (out << "<null>"));
  out << ", " << "original_volume_name="; (__isset.original_volume_name ? (out << to_string(original_volume_name)) : (out << "<null>"));
  out << ", " << "snapshot_device_object="; (__isset.snapshot_device_object ? (out << to_string(snapshot_device_object)) : (out << "<null>"));
  out << ", " << "creation_time_stamp="; (__isset.creation_time_stamp ? (out << to_string(creation_time_stamp)) : (out << "<null>"));
  out << ", " << "snapshots_count="; (__isset.snapshots_count ? (out << to_string(snapshots_count)) : (out << "<null>"));
  out << ")";
}


snapshot_result::~snapshot_result() throw() {
}


void snapshot_result::__set_snapshots(const std::vector<snapshot> & val) {
  this->snapshots = val;
}
std::ostream& operator<<(std::ostream& out, const snapshot_result& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t snapshot_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->snapshots.clear();
            uint32_t _size122;
            ::apache::thrift::protocol::TType _etype125;
            xfer += iprot->readListBegin(_etype125, _size122);
            this->snapshots.resize(_size122);
            uint32_t _i126;
            for (_i126 = 0; _i126 < _size122; ++_i126)
            {
              xfer += this->snapshots[_i126].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.snapshots = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t snapshot_result::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("snapshot_result");

  xfer += oprot->writeFieldBegin("snapshots", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->snapshots.size()));
    std::vector<snapshot> ::const_iterator _iter127;
    for (_iter127 = this->snapshots.begin(); _iter127 != this->snapshots.end(); ++_iter127)
    {
      xfer += (*_iter127).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(snapshot_result &a, snapshot_result &b) {
  using ::std::swap;
  swap(a.snapshots, b.snapshots);
  swap(a.__isset, b.__isset);
}

snapshot_result::snapshot_result(const snapshot_result& other128) {
  snapshots = other128.snapshots;
  __isset = other128.__isset;
}
snapshot_result& snapshot_result::operator=(const snapshot_result& other129) {
  snapshots = other129.snapshots;
  __isset = other129.__isset;
  return *this;
}
void snapshot_result::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "snapshot_result(";
  out << "snapshots=" << to_string(snapshots);
  out << ")";
}


volume_bit_map::~volume_bit_map() throw() {
}


void volume_bit_map::__set_cluster_size(const int32_t val) {
  this->cluster_size = val;
__isset.cluster_size = true;
}

void volume_bit_map::__set_starting_lcn(const int64_t val) {
  this->starting_lcn = val;
__isset.starting_lcn = true;
}

void volume_bit_map::__set_total_number_of_clusters(const int64_t val) {
  this->total_number_of_clusters = val;
__isset.total_number_of_clusters = true;
}

void volume_bit_map::__set_bit_map(const std::string& val) {
  this->bit_map = val;
__isset.bit_map = true;
}

void volume_bit_map::__set_compressed(const bool val) {
  this->compressed = val;
__isset.compressed = true;
}
std::ostream& operator<<(std::ostream& out, const volume_bit_map& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t volume_bit_map::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cluster_size);
          this->__isset.cluster_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->starting_lcn);
          this->__isset.starting_lcn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->total_number_of_clusters);
          this->__isset.total_number_of_clusters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->bit_map);
          this->__isset.bit_map = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->compressed);
          this->__isset.compressed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t volume_bit_map::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("volume_bit_map");

  if (this->__isset.cluster_size) {
    xfer += oprot->writeFieldBegin("cluster_size", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->cluster_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.starting_lcn) {
    xfer += oprot->writeFieldBegin("starting_lcn", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->starting_lcn);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.total_number_of_clusters) {
    xfer += oprot->writeFieldBegin("total_number_of_clusters", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->total_number_of_clusters);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.bit_map) {
    xfer += oprot->writeFieldBegin("bit_map", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeBinary(this->bit_map);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.compressed) {
    xfer += oprot->writeFieldBegin("compressed", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->compressed);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(volume_bit_map &a, volume_bit_map &b) {
  using ::std::swap;
  swap(a.cluster_size, b.cluster_size);
  swap(a.starting_lcn, b.starting_lcn);
  swap(a.total_number_of_clusters, b.total_number_of_clusters);
  swap(a.bit_map, b.bit_map);
  swap(a.compressed, b.compressed);
  swap(a.__isset, b.__isset);
}

volume_bit_map::volume_bit_map(const volume_bit_map& other130) {
  cluster_size = other130.cluster_size;
  starting_lcn = other130.starting_lcn;
  total_number_of_clusters = other130.total_number_of_clusters;
  bit_map = other130.bit_map;
  compressed = other130.compressed;
  __isset = other130.__isset;
}
volume_bit_map& volume_bit_map::operator=(const volume_bit_map& other131) {
  cluster_size = other131.cluster_size;
  starting_lcn = other131.starting_lcn;
  total_number_of_clusters = other131.total_number_of_clusters;
  bit_map = other131.bit_map;
  compressed = other131.compressed;
  __isset = other131.__isset;
  return *this;
}
void volume_bit_map::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "volume_bit_map(";
  out << "cluster_size="; (__isset.cluster_size ? (out << to_string(cluster_size)) : (out << "<null>"));
  out << ", " << "starting_lcn="; (__isset.starting_lcn ? (out << to_string(starting_lcn)) : (out << "<null>"));
  out << ", " << "total_number_of_clusters="; (__isset.total_number_of_clusters ? (out << to_string(total_number_of_clusters)) : (out << "<null>"));
  out << ", " << "bit_map="; (__isset.bit_map ? (out << to_string(bit_map)) : (out << "<null>"));
  out << ", " << "compressed="; (__isset.compressed ? (out << to_string(compressed)) : (out << "<null>"));
  out << ")";
}


replication_result::~replication_result() throw() {
}


void replication_result::__set_result(const std::string& val) {
  this->result = val;
__isset.result = true;
}

void replication_result::__set_compressed(const bool val) {
  this->compressed = val;
__isset.compressed = true;
}
std::ostream& operator<<(std::ostream& out, const replication_result& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t replication_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->compressed);
          this->__isset.compressed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t replication_result::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("replication_result");

  if (this->__isset.result) {
    xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeBinary(this->result);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.compressed) {
    xfer += oprot->writeFieldBegin("compressed", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->compressed);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(replication_result &a, replication_result &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.compressed, b.compressed);
  swap(a.__isset, b.__isset);
}

replication_result::replication_result(const replication_result& other132) {
  result = other132.result;
  compressed = other132.compressed;
  __isset = other132.__isset;
}
replication_result& replication_result::operator=(const replication_result& other133) {
  result = other133.result;
  compressed = other133.compressed;
  __isset = other133.__isset;
  return *this;
}
void replication_result::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "replication_result(";
  out << "result="; (__isset.result ? (out << to_string(result)) : (out << "<null>"));
  out << ", " << "compressed="; (__isset.compressed ? (out << to_string(compressed)) : (out << "<null>"));
  out << ")";
}


delete_snapshot_result::~delete_snapshot_result() throw() {
}


void delete_snapshot_result::__set_code(const int32_t val) {
  this->code = val;
__isset.code = true;
}

void delete_snapshot_result::__set_deleted_snapshots(const int32_t val) {
  this->deleted_snapshots = val;
__isset.deleted_snapshots = true;
}

void delete_snapshot_result::__set_non_deleted_snapshot_id(const std::string& val) {
  this->non_deleted_snapshot_id = val;
__isset.non_deleted_snapshot_id = true;
}
std::ostream& operator<<(std::ostream& out, const delete_snapshot_result& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t delete_snapshot_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->code);
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->deleted_snapshots);
          this->__isset.deleted_snapshots = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->non_deleted_snapshot_id);
          this->__isset.non_deleted_snapshot_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t delete_snapshot_result::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("delete_snapshot_result");

  if (this->__isset.code) {
    xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->code);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.deleted_snapshots) {
    xfer += oprot->writeFieldBegin("deleted_snapshots", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->deleted_snapshots);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.non_deleted_snapshot_id) {
    xfer += oprot->writeFieldBegin("non_deleted_snapshot_id", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->non_deleted_snapshot_id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(delete_snapshot_result &a, delete_snapshot_result &b) {
  using ::std::swap;
  swap(a.code, b.code);
  swap(a.deleted_snapshots, b.deleted_snapshots);
  swap(a.non_deleted_snapshot_id, b.non_deleted_snapshot_id);
  swap(a.__isset, b.__isset);
}

delete_snapshot_result::delete_snapshot_result(const delete_snapshot_result& other134) {
  code = other134.code;
  deleted_snapshots = other134.deleted_snapshots;
  non_deleted_snapshot_id = other134.non_deleted_snapshot_id;
  __isset = other134.__isset;
}
delete_snapshot_result& delete_snapshot_result::operator=(const delete_snapshot_result& other135) {
  code = other135.code;
  deleted_snapshots = other135.deleted_snapshots;
  non_deleted_snapshot_id = other135.non_deleted_snapshot_id;
  __isset = other135.__isset;
  return *this;
}
void delete_snapshot_result::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "delete_snapshot_result(";
  out << "code="; (__isset.code ? (out << to_string(code)) : (out << "<null>"));
  out << ", " << "deleted_snapshots="; (__isset.deleted_snapshots ? (out << to_string(deleted_snapshots)) : (out << "<null>"));
  out << ", " << "non_deleted_snapshot_id="; (__isset.non_deleted_snapshot_id ? (out << to_string(non_deleted_snapshot_id)) : (out << "<null>"));
  out << ")";
}


physical_machine_info::~physical_machine_info() throw() {
}


void physical_machine_info::__set_architecture(const std::string& val) {
  this->architecture = val;
__isset.architecture = true;
}

void physical_machine_info::__set_client_id(const std::string& val) {
  this->client_id = val;
__isset.client_id = true;
}

void physical_machine_info::__set_client_name(const std::string& val) {
  this->client_name = val;
__isset.client_name = true;
}

void physical_machine_info::__set_domain(const std::string& val) {
  this->domain = val;
__isset.domain = true;
}

void physical_machine_info::__set_hal(const std::string& val) {
  this->hal = val;
__isset.hal = true;
}

void physical_machine_info::__set_initiator_name(const std::string& val) {
  this->initiator_name = val;
__isset.initiator_name = true;
}

void physical_machine_info::__set_is_oem(const bool val) {
  this->is_oem = val;
__isset.is_oem = true;
}

void physical_machine_info::__set_logical_processors(const int16_t val) {
  this->logical_processors = val;
__isset.logical_processors = true;
}

void physical_machine_info::__set_machine_id(const std::string& val) {
  this->machine_id = val;
__isset.machine_id = true;
}

void physical_machine_info::__set_manufacturer(const std::string& val) {
  this->manufacturer = val;
__isset.manufacturer = true;
}

void physical_machine_info::__set_os_name(const std::string& val) {
  this->os_name = val;
__isset.os_name = true;
}

void physical_machine_info::__set_os_type(const int32_t val) {
  this->os_type = val;
__isset.os_type = true;
}

void physical_machine_info::__set_os_system_info(const std::string& val) {
  this->os_system_info = val;
__isset.os_system_info = true;
}

void physical_machine_info::__set_physical_memory(const int64_t val) {
  this->physical_memory = val;
__isset.physical_memory = true;
}

void physical_machine_info::__set_processors(const int16_t val) {
  this->processors = val;
__isset.processors = true;
}

void physical_machine_info::__set_role(const int32_t val) {
  this->role = val;
__isset.role = true;
}

void physical_machine_info::__set_system_model(const std::string& val) {
  this->system_model = val;
__isset.system_model = true;
}

void physical_machine_info::__set_system_root(const std::string& val) {
  this->system_root = val;
__isset.system_root = true;
}

void physical_machine_info::__set_workgroup(const std::string& val) {
  this->workgroup = val;
__isset.workgroup = true;
}

void physical_machine_info::__set_os_version(const os_version_info& val) {
  this->os_version = val;
__isset.os_version = true;
}

void physical_machine_info::__set_cluster_infos(const std::set<cluster_info> & val) {
  this->cluster_infos = val;
__isset.cluster_infos = true;
}

void physical_machine_info::__set_disk_infos(const std::set<disk_info> & val) {
  this->disk_infos = val;
__isset.disk_infos = true;
}

void physical_machine_info::__set_network_infos(const std::set<network_info> & val) {
  this->network_infos = val;
__isset.network_infos = true;
}

void physical_machine_info::__set_partition_infos(const std::set<partition_info> & val) {
  this->partition_infos = val;
__isset.partition_infos = true;
}

void physical_machine_info::__set_volume_infos(const std::set<volume_info> & val) {
  this->volume_infos = val;
__isset.volume_infos = true;
}

void physical_machine_info::__set_is_vcbt_driver_installed(const bool val) {
  this->is_vcbt_driver_installed = val;
__isset.is_vcbt_driver_installed = true;
}

void physical_machine_info::__set_is_vcbt_enabled(const bool val) {
  this->is_vcbt_enabled = val;
__isset.is_vcbt_enabled = true;
}

void physical_machine_info::__set_current_vcbt_version(const std::string& val) {
  this->current_vcbt_version = val;
__isset.current_vcbt_version = true;
}

void physical_machine_info::__set_installed_vcbt_version(const std::string& val) {
  this->installed_vcbt_version = val;
__isset.installed_vcbt_version = true;
}

void physical_machine_info::__set_is_winpe(const bool val) {
  this->is_winpe = val;
__isset.is_winpe = true;
}

void physical_machine_info::__set_system_default_ui_language(const int16_t val) {
  this->system_default_ui_language = val;
__isset.system_default_ui_language = true;
}
std::ostream& operator<<(std::ostream& out, const physical_machine_info& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t physical_machine_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->architecture);
          this->__isset.architecture = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->client_id);
          this->__isset.client_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->client_name);
          this->__isset.client_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->domain);
          this->__isset.domain = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hal);
          this->__isset.hal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->initiator_name);
          this->__isset.initiator_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_oem);
          this->__isset.is_oem = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->logical_processors);
          this->__isset.logical_processors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->machine_id);
          this->__isset.machine_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->manufacturer);
          this->__isset.manufacturer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->os_name);
          this->__isset.os_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->os_type);
          this->__isset.os_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->os_system_info);
          this->__isset.os_system_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->physical_memory);
          this->__isset.physical_memory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->processors);
          this->__isset.processors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->role);
          this->__isset.role = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->system_model);
          this->__isset.system_model = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->system_root);
          this->__isset.system_root = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->workgroup);
          this->__isset.workgroup = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->os_version.read(iprot);
          this->__isset.os_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->cluster_infos.clear();
            uint32_t _size136;
            ::apache::thrift::protocol::TType _etype139;
            xfer += iprot->readSetBegin(_etype139, _size136);
            uint32_t _i140;
            for (_i140 = 0; _i140 < _size136; ++_i140)
            {
              cluster_info _elem141;
              xfer += _elem141.read(iprot);
              this->cluster_infos.insert(_elem141);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.cluster_infos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->disk_infos.clear();
            uint32_t _size142;
            ::apache::thrift::protocol::TType _etype145;
            xfer += iprot->readSetBegin(_etype145, _size142);
            uint32_t _i146;
            for (_i146 = 0; _i146 < _size142; ++_i146)
            {
              disk_info _elem147;
              xfer += _elem147.read(iprot);
              this->disk_infos.insert(_elem147);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.disk_infos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->network_infos.clear();
            uint32_t _size148;
            ::apache::thrift::protocol::TType _etype151;
            xfer += iprot->readSetBegin(_etype151, _size148);
            uint32_t _i152;
            for (_i152 = 0; _i152 < _size148; ++_i152)
            {
              network_info _elem153;
              xfer += _elem153.read(iprot);
              this->network_infos.insert(_elem153);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.network_infos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->partition_infos.clear();
            uint32_t _size154;
            ::apache::thrift::protocol::TType _etype157;
            xfer += iprot->readSetBegin(_etype157, _size154);
            uint32_t _i158;
            for (_i158 = 0; _i158 < _size154; ++_i158)
            {
              partition_info _elem159;
              xfer += _elem159.read(iprot);
              this->partition_infos.insert(_elem159);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.partition_infos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->volume_infos.clear();
            uint32_t _size160;
            ::apache::thrift::protocol::TType _etype163;
            xfer += iprot->readSetBegin(_etype163, _size160);
            uint32_t _i164;
            for (_i164 = 0; _i164 < _size160; ++_i164)
            {
              volume_info _elem165;
              xfer += _elem165.read(iprot);
              this->volume_infos.insert(_elem165);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.volume_infos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 26:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_vcbt_driver_installed);
          this->__isset.is_vcbt_driver_installed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 27:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_vcbt_enabled);
          this->__isset.is_vcbt_enabled = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 28:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->current_vcbt_version);
          this->__isset.current_vcbt_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 29:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->installed_vcbt_version);
          this->__isset.installed_vcbt_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_winpe);
          this->__isset.is_winpe = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 31:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->system_default_ui_language);
          this->__isset.system_default_ui_language = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_machine_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_machine_info");

  if (this->__isset.architecture) {
    xfer += oprot->writeFieldBegin("architecture", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->architecture);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.client_id) {
    xfer += oprot->writeFieldBegin("client_id", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->client_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.client_name) {
    xfer += oprot->writeFieldBegin("client_name", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->client_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.domain) {
    xfer += oprot->writeFieldBegin("domain", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->domain);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.hal) {
    xfer += oprot->writeFieldBegin("hal", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->hal);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.initiator_name) {
    xfer += oprot->writeFieldBegin("initiator_name", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->initiator_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_oem) {
    xfer += oprot->writeFieldBegin("is_oem", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->is_oem);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.logical_processors) {
    xfer += oprot->writeFieldBegin("logical_processors", ::apache::thrift::protocol::T_I16, 8);
    xfer += oprot->writeI16(this->logical_processors);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.machine_id) {
    xfer += oprot->writeFieldBegin("machine_id", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->machine_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.manufacturer) {
    xfer += oprot->writeFieldBegin("manufacturer", ::apache::thrift::protocol::T_STRING, 10);
    xfer += oprot->writeString(this->manufacturer);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.os_name) {
    xfer += oprot->writeFieldBegin("os_name", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeString(this->os_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.os_type) {
    xfer += oprot->writeFieldBegin("os_type", ::apache::thrift::protocol::T_I32, 12);
    xfer += oprot->writeI32(this->os_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.os_system_info) {
    xfer += oprot->writeFieldBegin("os_system_info", ::apache::thrift::protocol::T_STRING, 13);
    xfer += oprot->writeString(this->os_system_info);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.physical_memory) {
    xfer += oprot->writeFieldBegin("physical_memory", ::apache::thrift::protocol::T_I64, 14);
    xfer += oprot->writeI64(this->physical_memory);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.processors) {
    xfer += oprot->writeFieldBegin("processors", ::apache::thrift::protocol::T_I16, 15);
    xfer += oprot->writeI16(this->processors);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.role) {
    xfer += oprot->writeFieldBegin("role", ::apache::thrift::protocol::T_I32, 16);
    xfer += oprot->writeI32(this->role);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.system_model) {
    xfer += oprot->writeFieldBegin("system_model", ::apache::thrift::protocol::T_STRING, 17);
    xfer += oprot->writeString(this->system_model);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.system_root) {
    xfer += oprot->writeFieldBegin("system_root", ::apache::thrift::protocol::T_STRING, 18);
    xfer += oprot->writeString(this->system_root);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.workgroup) {
    xfer += oprot->writeFieldBegin("workgroup", ::apache::thrift::protocol::T_STRING, 19);
    xfer += oprot->writeString(this->workgroup);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.os_version) {
    xfer += oprot->writeFieldBegin("os_version", ::apache::thrift::protocol::T_STRUCT, 20);
    xfer += this->os_version.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_infos) {
    xfer += oprot->writeFieldBegin("cluster_infos", ::apache::thrift::protocol::T_SET, 21);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cluster_infos.size()));
      std::set<cluster_info> ::const_iterator _iter166;
      for (_iter166 = this->cluster_infos.begin(); _iter166 != this->cluster_infos.end(); ++_iter166)
      {
        xfer += (*_iter166).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.disk_infos) {
    xfer += oprot->writeFieldBegin("disk_infos", ::apache::thrift::protocol::T_SET, 22);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->disk_infos.size()));
      std::set<disk_info> ::const_iterator _iter167;
      for (_iter167 = this->disk_infos.begin(); _iter167 != this->disk_infos.end(); ++_iter167)
      {
        xfer += (*_iter167).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.network_infos) {
    xfer += oprot->writeFieldBegin("network_infos", ::apache::thrift::protocol::T_SET, 23);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->network_infos.size()));
      std::set<network_info> ::const_iterator _iter168;
      for (_iter168 = this->network_infos.begin(); _iter168 != this->network_infos.end(); ++_iter168)
      {
        xfer += (*_iter168).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partition_infos) {
    xfer += oprot->writeFieldBegin("partition_infos", ::apache::thrift::protocol::T_SET, 24);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partition_infos.size()));
      std::set<partition_info> ::const_iterator _iter169;
      for (_iter169 = this->partition_infos.begin(); _iter169 != this->partition_infos.end(); ++_iter169)
      {
        xfer += (*_iter169).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.volume_infos) {
    xfer += oprot->writeFieldBegin("volume_infos", ::apache::thrift::protocol::T_SET, 25);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->volume_infos.size()));
      std::set<volume_info> ::const_iterator _iter170;
      for (_iter170 = this->volume_infos.begin(); _iter170 != this->volume_infos.end(); ++_iter170)
      {
        xfer += (*_iter170).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_vcbt_driver_installed) {
    xfer += oprot->writeFieldBegin("is_vcbt_driver_installed", ::apache::thrift::protocol::T_BOOL, 26);
    xfer += oprot->writeBool(this->is_vcbt_driver_installed);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_vcbt_enabled) {
    xfer += oprot->writeFieldBegin("is_vcbt_enabled", ::apache::thrift::protocol::T_BOOL, 27);
    xfer += oprot->writeBool(this->is_vcbt_enabled);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.current_vcbt_version) {
    xfer += oprot->writeFieldBegin("current_vcbt_version", ::apache::thrift::protocol::T_STRING, 28);
    xfer += oprot->writeString(this->current_vcbt_version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.installed_vcbt_version) {
    xfer += oprot->writeFieldBegin("installed_vcbt_version", ::apache::thrift::protocol::T_STRING, 29);
    xfer += oprot->writeString(this->installed_vcbt_version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_winpe) {
    xfer += oprot->writeFieldBegin("is_winpe", ::apache::thrift::protocol::T_BOOL, 30);
    xfer += oprot->writeBool(this->is_winpe);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.system_default_ui_language) {
    xfer += oprot->writeFieldBegin("system_default_ui_language", ::apache::thrift::protocol::T_I16, 31);
    xfer += oprot->writeI16(this->system_default_ui_language);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(physical_machine_info &a, physical_machine_info &b) {
  using ::std::swap;
  swap(a.architecture, b.architecture);
  swap(a.client_id, b.client_id);
  swap(a.client_name, b.client_name);
  swap(a.domain, b.domain);
  swap(a.hal, b.hal);
  swap(a.initiator_name, b.initiator_name);
  swap(a.is_oem, b.is_oem);
  swap(a.logical_processors, b.logical_processors);
  swap(a.machine_id, b.machine_id);
  swap(a.manufacturer, b.manufacturer);
  swap(a.os_name, b.os_name);
  swap(a.os_type, b.os_type);
  swap(a.os_system_info, b.os_system_info);
  swap(a.physical_memory, b.physical_memory);
  swap(a.processors, b.processors);
  swap(a.role, b.role);
  swap(a.system_model, b.system_model);
  swap(a.system_root, b.system_root);
  swap(a.workgroup, b.workgroup);
  swap(a.os_version, b.os_version);
  swap(a.cluster_infos, b.cluster_infos);
  swap(a.disk_infos, b.disk_infos);
  swap(a.network_infos, b.network_infos);
  swap(a.partition_infos, b.partition_infos);
  swap(a.volume_infos, b.volume_infos);
  swap(a.is_vcbt_driver_installed, b.is_vcbt_driver_installed);
  swap(a.is_vcbt_enabled, b.is_vcbt_enabled);
  swap(a.current_vcbt_version, b.current_vcbt_version);
  swap(a.installed_vcbt_version, b.installed_vcbt_version);
  swap(a.is_winpe, b.is_winpe);
  swap(a.system_default_ui_language, b.system_default_ui_language);
  swap(a.__isset, b.__isset);
}

physical_machine_info::physical_machine_info(const physical_machine_info& other171) {
  architecture = other171.architecture;
  client_id = other171.client_id;
  client_name = other171.client_name;
  domain = other171.domain;
  hal = other171.hal;
  initiator_name = other171.initiator_name;
  is_oem = other171.is_oem;
  logical_processors = other171.logical_processors;
  machine_id = other171.machine_id;
  manufacturer = other171.manufacturer;
  os_name = other171.os_name;
  os_type = other171.os_type;
  os_system_info = other171.os_system_info;
  physical_memory = other171.physical_memory;
  processors = other171.processors;
  role = other171.role;
  system_model = other171.system_model;
  system_root = other171.system_root;
  workgroup = other171.workgroup;
  os_version = other171.os_version;
  cluster_infos = other171.cluster_infos;
  disk_infos = other171.disk_infos;
  network_infos = other171.network_infos;
  partition_infos = other171.partition_infos;
  volume_infos = other171.volume_infos;
  is_vcbt_driver_installed = other171.is_vcbt_driver_installed;
  is_vcbt_enabled = other171.is_vcbt_enabled;
  current_vcbt_version = other171.current_vcbt_version;
  installed_vcbt_version = other171.installed_vcbt_version;
  is_winpe = other171.is_winpe;
  system_default_ui_language = other171.system_default_ui_language;
  __isset = other171.__isset;
}
physical_machine_info& physical_machine_info::operator=(const physical_machine_info& other172) {
  architecture = other172.architecture;
  client_id = other172.client_id;
  client_name = other172.client_name;
  domain = other172.domain;
  hal = other172.hal;
  initiator_name = other172.initiator_name;
  is_oem = other172.is_oem;
  logical_processors = other172.logical_processors;
  machine_id = other172.machine_id;
  manufacturer = other172.manufacturer;
  os_name = other172.os_name;
  os_type = other172.os_type;
  os_system_info = other172.os_system_info;
  physical_memory = other172.physical_memory;
  processors = other172.processors;
  role = other172.role;
  system_model = other172.system_model;
  system_root = other172.system_root;
  workgroup = other172.workgroup;
  os_version = other172.os_version;
  cluster_infos = other172.cluster_infos;
  disk_infos = other172.disk_infos;
  network_infos = other172.network_infos;
  partition_infos = other172.partition_infos;
  volume_infos = other172.volume_infos;
  is_vcbt_driver_installed = other172.is_vcbt_driver_installed;
  is_vcbt_enabled = other172.is_vcbt_enabled;
  current_vcbt_version = other172.current_vcbt_version;
  installed_vcbt_version = other172.installed_vcbt_version;
  is_winpe = other172.is_winpe;
  system_default_ui_language = other172.system_default_ui_language;
  __isset = other172.__isset;
  return *this;
}
void physical_machine_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "physical_machine_info(";
  out << "architecture="; (__isset.architecture ? (out << to_string(architecture)) : (out << "<null>"));
  out << ", " << "client_id="; (__isset.client_id ? (out << to_string(client_id)) : (out << "<null>"));
  out << ", " << "client_name="; (__isset.client_name ? (out << to_string(client_name)) : (out << "<null>"));
  out << ", " << "domain="; (__isset.domain ? (out << to_string(domain)) : (out << "<null>"));
  out << ", " << "hal="; (__isset.hal ? (out << to_string(hal)) : (out << "<null>"));
  out << ", " << "initiator_name="; (__isset.initiator_name ? (out << to_string(initiator_name)) : (out << "<null>"));
  out << ", " << "is_oem="; (__isset.is_oem ? (out << to_string(is_oem)) : (out << "<null>"));
  out << ", " << "logical_processors="; (__isset.logical_processors ? (out << to_string(logical_processors)) : (out << "<null>"));
  out << ", " << "machine_id="; (__isset.machine_id ? (out << to_string(machine_id)) : (out << "<null>"));
  out << ", " << "manufacturer="; (__isset.manufacturer ? (out << to_string(manufacturer)) : (out << "<null>"));
  out << ", " << "os_name="; (__isset.os_name ? (out << to_string(os_name)) : (out << "<null>"));
  out << ", " << "os_type="; (__isset.os_type ? (out << to_string(os_type)) : (out << "<null>"));
  out << ", " << "os_system_info="; (__isset.os_system_info ? (out << to_string(os_system_info)) : (out << "<null>"));
  out << ", " << "physical_memory="; (__isset.physical_memory ? (out << to_string(physical_memory)) : (out << "<null>"));
  out << ", " << "processors="; (__isset.processors ? (out << to_string(processors)) : (out << "<null>"));
  out << ", " << "role="; (__isset.role ? (out << to_string(role)) : (out << "<null>"));
  out << ", " << "system_model="; (__isset.system_model ? (out << to_string(system_model)) : (out << "<null>"));
  out << ", " << "system_root="; (__isset.system_root ? (out << to_string(system_root)) : (out << "<null>"));
  out << ", " << "workgroup="; (__isset.workgroup ? (out << to_string(workgroup)) : (out << "<null>"));
  out << ", " << "os_version="; (__isset.os_version ? (out << to_string(os_version)) : (out << "<null>"));
  out << ", " << "cluster_infos="; (__isset.cluster_infos ? (out << to_string(cluster_infos)) : (out << "<null>"));
  out << ", " << "disk_infos="; (__isset.disk_infos ? (out << to_string(disk_infos)) : (out << "<null>"));
  out << ", " << "network_infos="; (__isset.network_infos ? (out << to_string(network_infos)) : (out << "<null>"));
  out << ", " << "partition_infos="; (__isset.partition_infos ? (out << to_string(partition_infos)) : (out << "<null>"));
  out << ", " << "volume_infos="; (__isset.volume_infos ? (out << to_string(volume_infos)) : (out << "<null>"));
  out << ", " << "is_vcbt_driver_installed="; (__isset.is_vcbt_driver_installed ? (out << to_string(is_vcbt_driver_installed)) : (out << "<null>"));
  out << ", " << "is_vcbt_enabled="; (__isset.is_vcbt_enabled ? (out << to_string(is_vcbt_enabled)) : (out << "<null>"));
  out << ", " << "current_vcbt_version="; (__isset.current_vcbt_version ? (out << to_string(current_vcbt_version)) : (out << "<null>"));
  out << ", " << "installed_vcbt_version="; (__isset.installed_vcbt_version ? (out << to_string(installed_vcbt_version)) : (out << "<null>"));
  out << ", " << "is_winpe="; (__isset.is_winpe ? (out << to_string(is_winpe)) : (out << "<null>"));
  out << ", " << "system_default_ui_language="; (__isset.system_default_ui_language ? (out << to_string(system_default_ui_language)) : (out << "<null>"));
  out << ")";
}


virtual_host::~virtual_host() throw() {
}


void virtual_host::__set_name_ref(const std::string& val) {
  this->name_ref = val;
__isset.name_ref = true;
}

void virtual_host::__set_name(const std::string& val) {
  this->name = val;
__isset.name = true;
}

void virtual_host::__set_ip_addresses(const std::vector<std::string> & val) {
  this->ip_addresses = val;
__isset.ip_addresses = true;
}

void virtual_host::__set_ip_address(const std::string& val) {
  this->ip_address = val;
__isset.ip_address = true;
}

void virtual_host::__set_product_name(const std::string& val) {
  this->product_name = val;
__isset.product_name = true;
}

void virtual_host::__set_version(const std::string& val) {
  this->version = val;
__isset.version = true;
}

void virtual_host::__set_power_state(const hv_host_power_state::type val) {
  this->power_state = val;
__isset.power_state = true;
}

void virtual_host::__set_state(const std::string& val) {
  this->state = val;
__isset.state = true;
}

void virtual_host::__set_in_maintenance_mode(const bool val) {
  this->in_maintenance_mode = val;
__isset.in_maintenance_mode = true;
}

void virtual_host::__set_vms(const std::map<std::string, std::string> & val) {
  this->vms = val;
__isset.vms = true;
}

void virtual_host::__set_datastores(const std::map<std::string, std::string> & val) {
  this->datastores = val;
__isset.datastores = true;
}

void virtual_host::__set_networks(const std::map<std::string, std::string> & val) {
  this->networks = val;
__isset.networks = true;
}

void virtual_host::__set_datacenter_name(const std::string& val) {
  this->datacenter_name = val;
__isset.datacenter_name = true;
}

void virtual_host::__set_domain_name(const std::string& val) {
  this->domain_name = val;
__isset.domain_name = true;
}

void virtual_host::__set_cluster_key(const std::string& val) {
  this->cluster_key = val;
__isset.cluster_key = true;
}

void virtual_host::__set_full_name(const std::string& val) {
  this->full_name = val;
__isset.full_name = true;
}

void virtual_host::__set_lic_features(const std::map<std::string, std::vector<std::string> > & val) {
  this->lic_features = val;
__isset.lic_features = true;
}

void virtual_host::__set_name_list(const std::vector<std::string> & val) {
  this->name_list = val;
__isset.name_list = true;
}

void virtual_host::__set_domain_name_list(const std::vector<std::string> & val) {
  this->domain_name_list = val;
__isset.domain_name_list = true;
}

void virtual_host::__set_connection_type(const hv_connection_type::type val) {
  this->connection_type = val;
__isset.connection_type = true;
}

void virtual_host::__set_virtual_center_name(const std::string& val) {
  this->virtual_center_name = val;
__isset.virtual_center_name = true;
}

void virtual_host::__set_virtual_center_version(const std::string& val) {
  this->virtual_center_version = val;
__isset.virtual_center_version = true;
}

void virtual_host::__set_uuid(const std::string& val) {
  this->uuid = val;
__isset.uuid = true;
}

void virtual_host::__set_number_of_cpu_cores(const int16_t val) {
  this->number_of_cpu_cores = val;
__isset.number_of_cpu_cores = true;
}

void virtual_host::__set_number_of_cpu_packages(const int16_t val) {
  this->number_of_cpu_packages = val;
__isset.number_of_cpu_packages = true;
}

void virtual_host::__set_size_of_memory(const int64_t val) {
  this->size_of_memory = val;
__isset.size_of_memory = true;
}

void virtual_host::__set_number_of_cpu_threads(const int16_t val) {
  this->number_of_cpu_threads = val;
__isset.number_of_cpu_threads = true;
}
std::ostream& operator<<(std::ostream& out, const virtual_host& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t virtual_host::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name_ref);
          this->__isset.name_ref = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->ip_addresses.clear();
            uint32_t _size173;
            ::apache::thrift::protocol::TType _etype176;
            xfer += iprot->readListBegin(_etype176, _size173);
            this->ip_addresses.resize(_size173);
            uint32_t _i177;
            for (_i177 = 0; _i177 < _size173; ++_i177)
            {
              xfer += iprot->readString(this->ip_addresses[_i177]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.ip_addresses = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ip_address);
          this->__isset.ip_address = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->product_name);
          this->__isset.product_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast178;
          xfer += iprot->readI32(ecast178);
          this->power_state = (hv_host_power_state::type)ecast178;
          this->__isset.power_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->state);
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->in_maintenance_mode);
          this->__isset.in_maintenance_mode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->vms.clear();
            uint32_t _size179;
            ::apache::thrift::protocol::TType _ktype180;
            ::apache::thrift::protocol::TType _vtype181;
            xfer += iprot->readMapBegin(_ktype180, _vtype181, _size179);
            uint32_t _i183;
            for (_i183 = 0; _i183 < _size179; ++_i183)
            {
              std::string _key184;
              xfer += iprot->readString(_key184);
              std::string& _val185 = this->vms[_key184];
              xfer += iprot->readString(_val185);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.vms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->datastores.clear();
            uint32_t _size186;
            ::apache::thrift::protocol::TType _ktype187;
            ::apache::thrift::protocol::TType _vtype188;
            xfer += iprot->readMapBegin(_ktype187, _vtype188, _size186);
            uint32_t _i190;
            for (_i190 = 0; _i190 < _size186; ++_i190)
            {
              std::string _key191;
              xfer += iprot->readString(_key191);
              std::string& _val192 = this->datastores[_key191];
              xfer += iprot->readString(_val192);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.datastores = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->networks.clear();
            uint32_t _size193;
            ::apache::thrift::protocol::TType _ktype194;
            ::apache::thrift::protocol::TType _vtype195;
            xfer += iprot->readMapBegin(_ktype194, _vtype195, _size193);
            uint32_t _i197;
            for (_i197 = 0; _i197 < _size193; ++_i197)
            {
              std::string _key198;
              xfer += iprot->readString(_key198);
              std::string& _val199 = this->networks[_key198];
              xfer += iprot->readString(_val199);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.networks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->datacenter_name);
          this->__isset.datacenter_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->domain_name);
          this->__isset.domain_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cluster_key);
          this->__isset.cluster_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->full_name);
          this->__isset.full_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->lic_features.clear();
            uint32_t _size200;
            ::apache::thrift::protocol::TType _ktype201;
            ::apache::thrift::protocol::TType _vtype202;
            xfer += iprot->readMapBegin(_ktype201, _vtype202, _size200);
            uint32_t _i204;
            for (_i204 = 0; _i204 < _size200; ++_i204)
            {
              std::string _key205;
              xfer += iprot->readString(_key205);
              std::vector<std::string> & _val206 = this->lic_features[_key205];
              {
                _val206.clear();
                uint32_t _size207;
                ::apache::thrift::protocol::TType _etype210;
                xfer += iprot->readListBegin(_etype210, _size207);
                _val206.resize(_size207);
                uint32_t _i211;
                for (_i211 = 0; _i211 < _size207; ++_i211)
                {
                  xfer += iprot->readString(_val206[_i211]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.lic_features = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->name_list.clear();
            uint32_t _size212;
            ::apache::thrift::protocol::TType _etype215;
            xfer += iprot->readListBegin(_etype215, _size212);
            this->name_list.resize(_size212);
            uint32_t _i216;
            for (_i216 = 0; _i216 < _size212; ++_i216)
            {
              xfer += iprot->readString(this->name_list[_i216]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.name_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->domain_name_list.clear();
            uint32_t _size217;
            ::apache::thrift::protocol::TType _etype220;
            xfer += iprot->readListBegin(_etype220, _size217);
            this->domain_name_list.resize(_size217);
            uint32_t _i221;
            for (_i221 = 0; _i221 < _size217; ++_i221)
            {
              xfer += iprot->readString(this->domain_name_list[_i221]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.domain_name_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast222;
          xfer += iprot->readI32(ecast222);
          this->connection_type = (hv_connection_type::type)ecast222;
          this->__isset.connection_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->virtual_center_name);
          this->__isset.virtual_center_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->virtual_center_version);
          this->__isset.virtual_center_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->uuid);
          this->__isset.uuid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->number_of_cpu_cores);
          this->__isset.number_of_cpu_cores = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->number_of_cpu_packages);
          this->__isset.number_of_cpu_packages = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 26:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->size_of_memory);
          this->__isset.size_of_memory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 27:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->number_of_cpu_threads);
          this->__isset.number_of_cpu_threads = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t virtual_host::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("virtual_host");

  if (this->__isset.name_ref) {
    xfer += oprot->writeFieldBegin("name_ref", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->name_ref);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ip_addresses) {
    xfer += oprot->writeFieldBegin("ip_addresses", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->ip_addresses.size()));
      std::vector<std::string> ::const_iterator _iter223;
      for (_iter223 = this->ip_addresses.begin(); _iter223 != this->ip_addresses.end(); ++_iter223)
      {
        xfer += oprot->writeString((*_iter223));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ip_address) {
    xfer += oprot->writeFieldBegin("ip_address", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->ip_address);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.product_name) {
    xfer += oprot->writeFieldBegin("product_name", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->product_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.version) {
    xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.power_state) {
    xfer += oprot->writeFieldBegin("power_state", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32((int32_t)this->power_state);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.state) {
    xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->state);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.in_maintenance_mode) {
    xfer += oprot->writeFieldBegin("in_maintenance_mode", ::apache::thrift::protocol::T_BOOL, 9);
    xfer += oprot->writeBool(this->in_maintenance_mode);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vms) {
    xfer += oprot->writeFieldBegin("vms", ::apache::thrift::protocol::T_MAP, 10);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->vms.size()));
      std::map<std::string, std::string> ::const_iterator _iter224;
      for (_iter224 = this->vms.begin(); _iter224 != this->vms.end(); ++_iter224)
      {
        xfer += oprot->writeString(_iter224->first);
        xfer += oprot->writeString(_iter224->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.datastores) {
    xfer += oprot->writeFieldBegin("datastores", ::apache::thrift::protocol::T_MAP, 11);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->datastores.size()));
      std::map<std::string, std::string> ::const_iterator _iter225;
      for (_iter225 = this->datastores.begin(); _iter225 != this->datastores.end(); ++_iter225)
      {
        xfer += oprot->writeString(_iter225->first);
        xfer += oprot->writeString(_iter225->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.networks) {
    xfer += oprot->writeFieldBegin("networks", ::apache::thrift::protocol::T_MAP, 12);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->networks.size()));
      std::map<std::string, std::string> ::const_iterator _iter226;
      for (_iter226 = this->networks.begin(); _iter226 != this->networks.end(); ++_iter226)
      {
        xfer += oprot->writeString(_iter226->first);
        xfer += oprot->writeString(_iter226->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.datacenter_name) {
    xfer += oprot->writeFieldBegin("datacenter_name", ::apache::thrift::protocol::T_STRING, 13);
    xfer += oprot->writeString(this->datacenter_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.domain_name) {
    xfer += oprot->writeFieldBegin("domain_name", ::apache::thrift::protocol::T_STRING, 14);
    xfer += oprot->writeString(this->domain_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_key) {
    xfer += oprot->writeFieldBegin("cluster_key", ::apache::thrift::protocol::T_STRING, 15);
    xfer += oprot->writeString(this->cluster_key);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.full_name) {
    xfer += oprot->writeFieldBegin("full_name", ::apache::thrift::protocol::T_STRING, 16);
    xfer += oprot->writeString(this->full_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lic_features) {
    xfer += oprot->writeFieldBegin("lic_features", ::apache::thrift::protocol::T_MAP, 17);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->lic_features.size()));
      std::map<std::string, std::vector<std::string> > ::const_iterator _iter227;
      for (_iter227 = this->lic_features.begin(); _iter227 != this->lic_features.end(); ++_iter227)
      {
        xfer += oprot->writeString(_iter227->first);
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter227->second.size()));
          std::vector<std::string> ::const_iterator _iter228;
          for (_iter228 = _iter227->second.begin(); _iter228 != _iter227->second.end(); ++_iter228)
          {
            xfer += oprot->writeString((*_iter228));
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.name_list) {
    xfer += oprot->writeFieldBegin("name_list", ::apache::thrift::protocol::T_LIST, 18);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->name_list.size()));
      std::vector<std::string> ::const_iterator _iter229;
      for (_iter229 = this->name_list.begin(); _iter229 != this->name_list.end(); ++_iter229)
      {
        xfer += oprot->writeString((*_iter229));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.domain_name_list) {
    xfer += oprot->writeFieldBegin("domain_name_list", ::apache::thrift::protocol::T_LIST, 19);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->domain_name_list.size()));
      std::vector<std::string> ::const_iterator _iter230;
      for (_iter230 = this->domain_name_list.begin(); _iter230 != this->domain_name_list.end(); ++_iter230)
      {
        xfer += oprot->writeString((*_iter230));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.connection_type) {
    xfer += oprot->writeFieldBegin("connection_type", ::apache::thrift::protocol::T_I32, 20);
    xfer += oprot->writeI32((int32_t)this->connection_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.virtual_center_name) {
    xfer += oprot->writeFieldBegin("virtual_center_name", ::apache::thrift::protocol::T_STRING, 21);
    xfer += oprot->writeString(this->virtual_center_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.virtual_center_version) {
    xfer += oprot->writeFieldBegin("virtual_center_version", ::apache::thrift::protocol::T_STRING, 22);
    xfer += oprot->writeString(this->virtual_center_version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.uuid) {
    xfer += oprot->writeFieldBegin("uuid", ::apache::thrift::protocol::T_STRING, 23);
    xfer += oprot->writeString(this->uuid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.number_of_cpu_cores) {
    xfer += oprot->writeFieldBegin("number_of_cpu_cores", ::apache::thrift::protocol::T_I16, 24);
    xfer += oprot->writeI16(this->number_of_cpu_cores);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.number_of_cpu_packages) {
    xfer += oprot->writeFieldBegin("number_of_cpu_packages", ::apache::thrift::protocol::T_I16, 25);
    xfer += oprot->writeI16(this->number_of_cpu_packages);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.size_of_memory) {
    xfer += oprot->writeFieldBegin("size_of_memory", ::apache::thrift::protocol::T_I64, 26);
    xfer += oprot->writeI64(this->size_of_memory);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.number_of_cpu_threads) {
    xfer += oprot->writeFieldBegin("number_of_cpu_threads", ::apache::thrift::protocol::T_I16, 27);
    xfer += oprot->writeI16(this->number_of_cpu_threads);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(virtual_host &a, virtual_host &b) {
  using ::std::swap;
  swap(a.name_ref, b.name_ref);
  swap(a.name, b.name);
  swap(a.ip_addresses, b.ip_addresses);
  swap(a.ip_address, b.ip_address);
  swap(a.product_name, b.product_name);
  swap(a.version, b.version);
  swap(a.power_state, b.power_state);
  swap(a.state, b.state);
  swap(a.in_maintenance_mode, b.in_maintenance_mode);
  swap(a.vms, b.vms);
  swap(a.datastores, b.datastores);
  swap(a.networks, b.networks);
  swap(a.datacenter_name, b.datacenter_name);
  swap(a.domain_name, b.domain_name);
  swap(a.cluster_key, b.cluster_key);
  swap(a.full_name, b.full_name);
  swap(a.lic_features, b.lic_features);
  swap(a.name_list, b.name_list);
  swap(a.domain_name_list, b.domain_name_list);
  swap(a.connection_type, b.connection_type);
  swap(a.virtual_center_name, b.virtual_center_name);
  swap(a.virtual_center_version, b.virtual_center_version);
  swap(a.uuid, b.uuid);
  swap(a.number_of_cpu_cores, b.number_of_cpu_cores);
  swap(a.number_of_cpu_packages, b.number_of_cpu_packages);
  swap(a.size_of_memory, b.size_of_memory);
  swap(a.number_of_cpu_threads, b.number_of_cpu_threads);
  swap(a.__isset, b.__isset);
}

virtual_host::virtual_host(const virtual_host& other231) {
  name_ref = other231.name_ref;
  name = other231.name;
  ip_addresses = other231.ip_addresses;
  ip_address = other231.ip_address;
  product_name = other231.product_name;
  version = other231.version;
  power_state = other231.power_state;
  state = other231.state;
  in_maintenance_mode = other231.in_maintenance_mode;
  vms = other231.vms;
  datastores = other231.datastores;
  networks = other231.networks;
  datacenter_name = other231.datacenter_name;
  domain_name = other231.domain_name;
  cluster_key = other231.cluster_key;
  full_name = other231.full_name;
  lic_features = other231.lic_features;
  name_list = other231.name_list;
  domain_name_list = other231.domain_name_list;
  connection_type = other231.connection_type;
  virtual_center_name = other231.virtual_center_name;
  virtual_center_version = other231.virtual_center_version;
  uuid = other231.uuid;
  number_of_cpu_cores = other231.number_of_cpu_cores;
  number_of_cpu_packages = other231.number_of_cpu_packages;
  size_of_memory = other231.size_of_memory;
  number_of_cpu_threads = other231.number_of_cpu_threads;
  __isset = other231.__isset;
}
virtual_host& virtual_host::operator=(const virtual_host& other232) {
  name_ref = other232.name_ref;
  name = other232.name;
  ip_addresses = other232.ip_addresses;
  ip_address = other232.ip_address;
  product_name = other232.product_name;
  version = other232.version;
  power_state = other232.power_state;
  state = other232.state;
  in_maintenance_mode = other232.in_maintenance_mode;
  vms = other232.vms;
  datastores = other232.datastores;
  networks = other232.networks;
  datacenter_name = other232.datacenter_name;
  domain_name = other232.domain_name;
  cluster_key = other232.cluster_key;
  full_name = other232.full_name;
  lic_features = other232.lic_features;
  name_list = other232.name_list;
  domain_name_list = other232.domain_name_list;
  connection_type = other232.connection_type;
  virtual_center_name = other232.virtual_center_name;
  virtual_center_version = other232.virtual_center_version;
  uuid = other232.uuid;
  number_of_cpu_cores = other232.number_of_cpu_cores;
  number_of_cpu_packages = other232.number_of_cpu_packages;
  size_of_memory = other232.size_of_memory;
  number_of_cpu_threads = other232.number_of_cpu_threads;
  __isset = other232.__isset;
  return *this;
}
void virtual_host::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "virtual_host(";
  out << "name_ref="; (__isset.name_ref ? (out << to_string(name_ref)) : (out << "<null>"));
  out << ", " << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
  out << ", " << "ip_addresses="; (__isset.ip_addresses ? (out << to_string(ip_addresses)) : (out << "<null>"));
  out << ", " << "ip_address="; (__isset.ip_address ? (out << to_string(ip_address)) : (out << "<null>"));
  out << ", " << "product_name="; (__isset.product_name ? (out << to_string(product_name)) : (out << "<null>"));
  out << ", " << "version="; (__isset.version ? (out << to_string(version)) : (out << "<null>"));
  out << ", " << "power_state="; (__isset.power_state ? (out << to_string(power_state)) : (out << "<null>"));
  out << ", " << "state="; (__isset.state ? (out << to_string(state)) : (out << "<null>"));
  out << ", " << "in_maintenance_mode="; (__isset.in_maintenance_mode ? (out << to_string(in_maintenance_mode)) : (out << "<null>"));
  out << ", " << "vms="; (__isset.vms ? (out << to_string(vms)) : (out << "<null>"));
  out << ", " << "datastores="; (__isset.datastores ? (out << to_string(datastores)) : (out << "<null>"));
  out << ", " << "networks="; (__isset.networks ? (out << to_string(networks)) : (out << "<null>"));
  out << ", " << "datacenter_name="; (__isset.datacenter_name ? (out << to_string(datacenter_name)) : (out << "<null>"));
  out << ", " << "domain_name="; (__isset.domain_name ? (out << to_string(domain_name)) : (out << "<null>"));
  out << ", " << "cluster_key="; (__isset.cluster_key ? (out << to_string(cluster_key)) : (out << "<null>"));
  out << ", " << "full_name="; (__isset.full_name ? (out << to_string(full_name)) : (out << "<null>"));
  out << ", " << "lic_features="; (__isset.lic_features ? (out << to_string(lic_features)) : (out << "<null>"));
  out << ", " << "name_list="; (__isset.name_list ? (out << to_string(name_list)) : (out << "<null>"));
  out << ", " << "domain_name_list="; (__isset.domain_name_list ? (out << to_string(domain_name_list)) : (out << "<null>"));
  out << ", " << "connection_type="; (__isset.connection_type ? (out << to_string(connection_type)) : (out << "<null>"));
  out << ", " << "virtual_center_name="; (__isset.virtual_center_name ? (out << to_string(virtual_center_name)) : (out << "<null>"));
  out << ", " << "virtual_center_version="; (__isset.virtual_center_version ? (out << to_string(virtual_center_version)) : (out << "<null>"));
  out << ", " << "uuid="; (__isset.uuid ? (out << to_string(uuid)) : (out << "<null>"));
  out << ", " << "number_of_cpu_cores="; (__isset.number_of_cpu_cores ? (out << to_string(number_of_cpu_cores)) : (out << "<null>"));
  out << ", " << "number_of_cpu_packages="; (__isset.number_of_cpu_packages ? (out << to_string(number_of_cpu_packages)) : (out << "<null>"));
  out << ", " << "size_of_memory="; (__isset.size_of_memory ? (out << to_string(size_of_memory)) : (out << "<null>"));
  out << ", " << "number_of_cpu_threads="; (__isset.number_of_cpu_threads ? (out << to_string(number_of_cpu_threads)) : (out << "<null>"));
  out << ")";
}


virtual_network_adapter::~virtual_network_adapter() throw() {
}


void virtual_network_adapter::__set_key(const int32_t val) {
  this->key = val;
__isset.key = true;
}

void virtual_network_adapter::__set_name(const std::string& val) {
  this->name = val;
__isset.name = true;
}

void virtual_network_adapter::__set_mac_address(const std::string& val) {
  this->mac_address = val;
__isset.mac_address = true;
}

void virtual_network_adapter::__set_network(const std::string& val) {
  this->network = val;
__isset.network = true;
}

void virtual_network_adapter::__set_port_group(const std::string& val) {
  this->port_group = val;
__isset.port_group = true;
}

void virtual_network_adapter::__set_type(const std::string& val) {
  this->type = val;
__isset.type = true;
}

void virtual_network_adapter::__set_is_connected(const bool val) {
  this->is_connected = val;
__isset.is_connected = true;
}

void virtual_network_adapter::__set_is_start_connected(const bool val) {
  this->is_start_connected = val;
__isset.is_start_connected = true;
}

void virtual_network_adapter::__set_is_allow_guest_control(const bool val) {
  this->is_allow_guest_control = val;
__isset.is_allow_guest_control = true;
}

void virtual_network_adapter::__set_address_type(const std::string& val) {
  this->address_type = val;
__isset.address_type = true;
}

void virtual_network_adapter::__set_ip_addresses(const std::vector<std::string> & val) {
  this->ip_addresses = val;
__isset.ip_addresses = true;
}
std::ostream& operator<<(std::ostream& out, const virtual_network_adapter& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t virtual_network_adapter::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->mac_address);
          this->__isset.mac_address = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->network);
          this->__isset.network = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->port_group);
          this->__isset.port_group = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_connected);
          this->__isset.is_connected = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_start_connected);
          this->__isset.is_start_connected = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_allow_guest_control);
          this->__isset.is_allow_guest_control = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->address_type);
          this->__isset.address_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->ip_addresses.clear();
            uint32_t _size233;
            ::apache::thrift::protocol::TType _etype236;
            xfer += iprot->readListBegin(_etype236, _size233);
            this->ip_addresses.resize(_size233);
            uint32_t _i237;
            for (_i237 = 0; _i237 < _size233; ++_i237)
            {
              xfer += iprot->readString(this->ip_addresses[_i237]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.ip_addresses = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t virtual_network_adapter::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("virtual_network_adapter");

  if (this->__isset.key) {
    xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->key);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mac_address) {
    xfer += oprot->writeFieldBegin("mac_address", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->mac_address);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.network) {
    xfer += oprot->writeFieldBegin("network", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->network);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.port_group) {
    xfer += oprot->writeFieldBegin("port_group", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->port_group);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.type) {
    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_connected) {
    xfer += oprot->writeFieldBegin("is_connected", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->is_connected);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_start_connected) {
    xfer += oprot->writeFieldBegin("is_start_connected", ::apache::thrift::protocol::T_BOOL, 8);
    xfer += oprot->writeBool(this->is_start_connected);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_allow_guest_control) {
    xfer += oprot->writeFieldBegin("is_allow_guest_control", ::apache::thrift::protocol::T_BOOL, 9);
    xfer += oprot->writeBool(this->is_allow_guest_control);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.address_type) {
    xfer += oprot->writeFieldBegin("address_type", ::apache::thrift::protocol::T_STRING, 10);
    xfer += oprot->writeString(this->address_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ip_addresses) {
    xfer += oprot->writeFieldBegin("ip_addresses", ::apache::thrift::protocol::T_LIST, 11);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->ip_addresses.size()));
      std::vector<std::string> ::const_iterator _iter238;
      for (_iter238 = this->ip_addresses.begin(); _iter238 != this->ip_addresses.end(); ++_iter238)
      {
        xfer += oprot->writeString((*_iter238));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(virtual_network_adapter &a, virtual_network_adapter &b) {
  using ::std::swap;
  swap(a.key, b.key);
  swap(a.name, b.name);
  swap(a.mac_address, b.mac_address);
  swap(a.network, b.network);
  swap(a.port_group, b.port_group);
  swap(a.type, b.type);
  swap(a.is_connected, b.is_connected);
  swap(a.is_start_connected, b.is_start_connected);
  swap(a.is_allow_guest_control, b.is_allow_guest_control);
  swap(a.address_type, b.address_type);
  swap(a.ip_addresses, b.ip_addresses);
  swap(a.__isset, b.__isset);
}

virtual_network_adapter::virtual_network_adapter(const virtual_network_adapter& other239) {
  key = other239.key;
  name = other239.name;
  mac_address = other239.mac_address;
  network = other239.network;
  port_group = other239.port_group;
  type = other239.type;
  is_connected = other239.is_connected;
  is_start_connected = other239.is_start_connected;
  is_allow_guest_control = other239.is_allow_guest_control;
  address_type = other239.address_type;
  ip_addresses = other239.ip_addresses;
  __isset = other239.__isset;
}
virtual_network_adapter& virtual_network_adapter::operator=(const virtual_network_adapter& other240) {
  key = other240.key;
  name = other240.name;
  mac_address = other240.mac_address;
  network = other240.network;
  port_group = other240.port_group;
  type = other240.type;
  is_connected = other240.is_connected;
  is_start_connected = other240.is_start_connected;
  is_allow_guest_control = other240.is_allow_guest_control;
  address_type = other240.address_type;
  ip_addresses = other240.ip_addresses;
  __isset = other240.__isset;
  return *this;
}
void virtual_network_adapter::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "virtual_network_adapter(";
  out << "key="; (__isset.key ? (out << to_string(key)) : (out << "<null>"));
  out << ", " << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
  out << ", " << "mac_address="; (__isset.mac_address ? (out << to_string(mac_address)) : (out << "<null>"));
  out << ", " << "network="; (__isset.network ? (out << to_string(network)) : (out << "<null>"));
  out << ", " << "port_group="; (__isset.port_group ? (out << to_string(port_group)) : (out << "<null>"));
  out << ", " << "type="; (__isset.type ? (out << to_string(type)) : (out << "<null>"));
  out << ", " << "is_connected="; (__isset.is_connected ? (out << to_string(is_connected)) : (out << "<null>"));
  out << ", " << "is_start_connected="; (__isset.is_start_connected ? (out << to_string(is_start_connected)) : (out << "<null>"));
  out << ", " << "is_allow_guest_control="; (__isset.is_allow_guest_control ? (out << to_string(is_allow_guest_control)) : (out << "<null>"));
  out << ", " << "address_type="; (__isset.address_type ? (out << to_string(address_type)) : (out << "<null>"));
  out << ", " << "ip_addresses="; (__isset.ip_addresses ? (out << to_string(ip_addresses)) : (out << "<null>"));
  out << ")";
}


virtual_machine_snapshots::~virtual_machine_snapshots() throw() {
}


void virtual_machine_snapshots::__set_name(const std::string& val) {
  this->name = val;
__isset.name = true;
}

void virtual_machine_snapshots::__set_description(const std::string& val) {
  this->description = val;
__isset.description = true;
}

void virtual_machine_snapshots::__set_create_time(const std::string& val) {
  this->create_time = val;
__isset.create_time = true;
}

void virtual_machine_snapshots::__set_quiesced(const bool val) {
  this->quiesced = val;
__isset.quiesced = true;
}

void virtual_machine_snapshots::__set_id(const int32_t val) {
  this->id = val;
__isset.id = true;
}

void virtual_machine_snapshots::__set_backup_manifest(const std::string& val) {
  this->backup_manifest = val;
__isset.backup_manifest = true;
}

void virtual_machine_snapshots::__set_replay_supported(const bool val) {
  this->replay_supported = val;
__isset.replay_supported = true;
}

void virtual_machine_snapshots::__set_child_snapshot_list(const std::vector<virtual_machine_snapshots> & val) {
  this->child_snapshot_list = val;
__isset.child_snapshot_list = true;
}
std::ostream& operator<<(std::ostream& out, const virtual_machine_snapshots& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t virtual_machine_snapshots::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->description);
          this->__isset.description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->create_time);
          this->__isset.create_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->quiesced);
          this->__isset.quiesced = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->backup_manifest);
          this->__isset.backup_manifest = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->replay_supported);
          this->__isset.replay_supported = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->child_snapshot_list.clear();
            uint32_t _size241;
            ::apache::thrift::protocol::TType _etype244;
            xfer += iprot->readListBegin(_etype244, _size241);
            this->child_snapshot_list.resize(_size241);
            uint32_t _i245;
            for (_i245 = 0; _i245 < _size241; ++_i245)
            {
              xfer += this->child_snapshot_list[_i245].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.child_snapshot_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t virtual_machine_snapshots::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("virtual_machine_snapshots");

  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.description) {
    xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->description);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.create_time) {
    xfer += oprot->writeFieldBegin("create_time", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->create_time);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.quiesced) {
    xfer += oprot->writeFieldBegin("quiesced", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->quiesced);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.backup_manifest) {
    xfer += oprot->writeFieldBegin("backup_manifest", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->backup_manifest);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.replay_supported) {
    xfer += oprot->writeFieldBegin("replay_supported", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->replay_supported);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.child_snapshot_list) {
    xfer += oprot->writeFieldBegin("child_snapshot_list", ::apache::thrift::protocol::T_LIST, 8);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->child_snapshot_list.size()));
      std::vector<virtual_machine_snapshots> ::const_iterator _iter246;
      for (_iter246 = this->child_snapshot_list.begin(); _iter246 != this->child_snapshot_list.end(); ++_iter246)
      {
        xfer += (*_iter246).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(virtual_machine_snapshots &a, virtual_machine_snapshots &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.description, b.description);
  swap(a.create_time, b.create_time);
  swap(a.quiesced, b.quiesced);
  swap(a.id, b.id);
  swap(a.backup_manifest, b.backup_manifest);
  swap(a.replay_supported, b.replay_supported);
  swap(a.child_snapshot_list, b.child_snapshot_list);
  swap(a.__isset, b.__isset);
}

virtual_machine_snapshots::virtual_machine_snapshots(const virtual_machine_snapshots& other247) {
  name = other247.name;
  description = other247.description;
  create_time = other247.create_time;
  quiesced = other247.quiesced;
  id = other247.id;
  backup_manifest = other247.backup_manifest;
  replay_supported = other247.replay_supported;
  child_snapshot_list = other247.child_snapshot_list;
  __isset = other247.__isset;
}
virtual_machine_snapshots& virtual_machine_snapshots::operator=(const virtual_machine_snapshots& other248) {
  name = other248.name;
  description = other248.description;
  create_time = other248.create_time;
  quiesced = other248.quiesced;
  id = other248.id;
  backup_manifest = other248.backup_manifest;
  replay_supported = other248.replay_supported;
  child_snapshot_list = other248.child_snapshot_list;
  __isset = other248.__isset;
  return *this;
}
void virtual_machine_snapshots::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "virtual_machine_snapshots(";
  out << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
  out << ", " << "description="; (__isset.description ? (out << to_string(description)) : (out << "<null>"));
  out << ", " << "create_time="; (__isset.create_time ? (out << to_string(create_time)) : (out << "<null>"));
  out << ", " << "quiesced="; (__isset.quiesced ? (out << to_string(quiesced)) : (out << "<null>"));
  out << ", " << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "backup_manifest="; (__isset.backup_manifest ? (out << to_string(backup_manifest)) : (out << "<null>"));
  out << ", " << "replay_supported="; (__isset.replay_supported ? (out << to_string(replay_supported)) : (out << "<null>"));
  out << ", " << "child_snapshot_list="; (__isset.child_snapshot_list ? (out << to_string(child_snapshot_list)) : (out << "<null>"));
  out << ")";
}


virtual_disk_info::~virtual_disk_info() throw() {
}


void virtual_disk_info::__set_key(const std::string& val) {
  this->key = val;
__isset.key = true;
}

void virtual_disk_info::__set_name(const std::string& val) {
  this->name = val;
__isset.name = true;
}

void virtual_disk_info::__set_id(const std::string& val) {
  this->id = val;
__isset.id = true;
}

void virtual_disk_info::__set_size_kb(const int64_t val) {
  this->size_kb = val;
__isset.size_kb = true;
}

void virtual_disk_info::__set_size(const int64_t val) {
  this->size = val;
__isset.size = true;
}

void virtual_disk_info::__set_controller_type(const hv_controller_type::type val) {
  this->controller_type = val;
__isset.controller_type = true;
}

void virtual_disk_info::__set_thin_provisioned(const bool val) {
  this->thin_provisioned = val;
__isset.thin_provisioned = true;
}
std::ostream& operator<<(std::ostream& out, const virtual_disk_info& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t virtual_disk_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->size_kb);
          this->__isset.size_kb = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->size);
          this->__isset.size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast249;
          xfer += iprot->readI32(ecast249);
          this->controller_type = (hv_controller_type::type)ecast249;
          this->__isset.controller_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->thin_provisioned);
          this->__isset.thin_provisioned = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t virtual_disk_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("virtual_disk_info");

  if (this->__isset.key) {
    xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->key);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.size_kb) {
    xfer += oprot->writeFieldBegin("size_kb", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->size_kb);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.size) {
    xfer += oprot->writeFieldBegin("size", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.controller_type) {
    xfer += oprot->writeFieldBegin("controller_type", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32((int32_t)this->controller_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.thin_provisioned) {
    xfer += oprot->writeFieldBegin("thin_provisioned", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->thin_provisioned);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(virtual_disk_info &a, virtual_disk_info &b) {
  using ::std::swap;
  swap(a.key, b.key);
  swap(a.name, b.name);
  swap(a.id, b.id);
  swap(a.size_kb, b.size_kb);
  swap(a.size, b.size);
  swap(a.controller_type, b.controller_type);
  swap(a.thin_provisioned, b.thin_provisioned);
  swap(a.__isset, b.__isset);
}

virtual_disk_info::virtual_disk_info(const virtual_disk_info& other250) {
  key = other250.key;
  name = other250.name;
  id = other250.id;
  size_kb = other250.size_kb;
  size = other250.size;
  controller_type = other250.controller_type;
  thin_provisioned = other250.thin_provisioned;
  __isset = other250.__isset;
}
virtual_disk_info& virtual_disk_info::operator=(const virtual_disk_info& other251) {
  key = other251.key;
  name = other251.name;
  id = other251.id;
  size_kb = other251.size_kb;
  size = other251.size;
  controller_type = other251.controller_type;
  thin_provisioned = other251.thin_provisioned;
  __isset = other251.__isset;
  return *this;
}
void virtual_disk_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "virtual_disk_info(";
  out << "key="; (__isset.key ? (out << to_string(key)) : (out << "<null>"));
  out << ", " << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
  out << ", " << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "size_kb="; (__isset.size_kb ? (out << to_string(size_kb)) : (out << "<null>"));
  out << ", " << "size="; (__isset.size ? (out << to_string(size)) : (out << "<null>"));
  out << ", " << "controller_type="; (__isset.controller_type ? (out << to_string(controller_type)) : (out << "<null>"));
  out << ", " << "thin_provisioned="; (__isset.thin_provisioned ? (out << to_string(thin_provisioned)) : (out << "<null>"));
  out << ")";
}


virtual_machine::~virtual_machine() throw() {
}


void virtual_machine::__set_uuid(const std::string& val) {
  this->uuid = val;
__isset.uuid = true;
}

void virtual_machine::__set_name(const std::string& val) {
  this->name = val;
__isset.name = true;
}

void virtual_machine::__set_host_key(const std::string& val) {
  this->host_key = val;
__isset.host_key = true;
}

void virtual_machine::__set_host_ip(const std::string& val) {
  this->host_ip = val;
__isset.host_ip = true;
}

void virtual_machine::__set_host_name(const std::string& val) {
  this->host_name = val;
__isset.host_name = true;
}

void virtual_machine::__set_cluster_key(const std::string& val) {
  this->cluster_key = val;
__isset.cluster_key = true;
}

void virtual_machine::__set_cluster_name(const std::string& val) {
  this->cluster_name = val;
__isset.cluster_name = true;
}

void virtual_machine::__set_annotation(const std::string& val) {
  this->annotation = val;
__isset.annotation = true;
}

void virtual_machine::__set_is_cpu_hot_add(const bool val) {
  this->is_cpu_hot_add = val;
__isset.is_cpu_hot_add = true;
}

void virtual_machine::__set_is_cpu_hot_remove(const bool val) {
  this->is_cpu_hot_remove = val;
__isset.is_cpu_hot_remove = true;
}

void virtual_machine::__set_memory_mb(const int32_t val) {
  this->memory_mb = val;
__isset.memory_mb = true;
}

void virtual_machine::__set_number_of_cpu(const int32_t val) {
  this->number_of_cpu = val;
__isset.number_of_cpu = true;
}

void virtual_machine::__set_is_template(const bool val) {
  this->is_template = val;
__isset.is_template = true;
}

void virtual_machine::__set_config_path(const std::string& val) {
  this->config_path = val;
__isset.config_path = true;
}

void virtual_machine::__set_config_path_file(const std::string& val) {
  this->config_path_file = val;
__isset.config_path_file = true;
}

void virtual_machine::__set_version(const int32_t val) {
  this->version = val;
__isset.version = true;
}

void virtual_machine::__set_power_state(const hv_vm_power_state::type val) {
  this->power_state = val;
__isset.power_state = true;
}

void virtual_machine::__set_connection_state(const hv_vm_connection_state::type val) {
  this->connection_state = val;
__isset.connection_state = true;
}

void virtual_machine::__set_tools_status(const hv_vm_tools_status::type val) {
  this->tools_status = val;
__isset.tools_status = true;
}

void virtual_machine::__set_firmware(const hv_vm_firmware::type val) {
  this->firmware = val;
__isset.firmware = true;
}

void virtual_machine::__set_guest_os_type(const hv_guest_os_type::type val) {
  this->guest_os_type = val;
__isset.guest_os_type = true;
}

void virtual_machine::__set_guest_id(const std::string& val) {
  this->guest_id = val;
__isset.guest_id = true;
}

void virtual_machine::__set_guest_os_name(const std::string& val) {
  this->guest_os_name = val;
__isset.guest_os_name = true;
}

void virtual_machine::__set_is_disk_uuid_enabled(const bool val) {
  this->is_disk_uuid_enabled = val;
__isset.is_disk_uuid_enabled = true;
}

void virtual_machine::__set_folder_path(const std::string& val) {
  this->folder_path = val;
__isset.folder_path = true;
}

void virtual_machine::__set_resource_pool_path(const std::string& val) {
  this->resource_pool_path = val;
__isset.resource_pool_path = true;
}

void virtual_machine::__set_disks(const std::vector<virtual_disk_info> & val) {
  this->disks = val;
__isset.disks = true;
}

void virtual_machine::__set_networks(const std::map<std::string, std::string> & val) {
  this->networks = val;
__isset.networks = true;
}

void virtual_machine::__set_datacenter_name(const std::string& val) {
  this->datacenter_name = val;
__isset.datacenter_name = true;
}

void virtual_machine::__set_network_adapters(const std::vector<virtual_network_adapter> & val) {
  this->network_adapters = val;
__isset.network_adapters = true;
}

void virtual_machine::__set_root_snapshot_list(const std::vector<virtual_machine_snapshots> & val) {
  this->root_snapshot_list = val;
__isset.root_snapshot_list = true;
}

void virtual_machine::__set_guest_host_name(const std::string& val) {
  this->guest_host_name = val;
__isset.guest_host_name = true;
}

void virtual_machine::__set_guest_ip(const std::string& val) {
  this->guest_ip = val;
__isset.guest_ip = true;
}

void virtual_machine::__set_has_cdrom(const bool val) {
  this->has_cdrom = val;
__isset.has_cdrom = true;
}
std::ostream& operator<<(std::ostream& out, const virtual_machine& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t virtual_machine::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->uuid);
          this->__isset.uuid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host_key);
          this->__isset.host_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host_ip);
          this->__isset.host_ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host_name);
          this->__isset.host_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cluster_key);
          this->__isset.cluster_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cluster_name);
          this->__isset.cluster_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->annotation);
          this->__isset.annotation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_cpu_hot_add);
          this->__isset.is_cpu_hot_add = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_cpu_hot_remove);
          this->__isset.is_cpu_hot_remove = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->memory_mb);
          this->__isset.memory_mb = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->number_of_cpu);
          this->__isset.number_of_cpu = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_template);
          this->__isset.is_template = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->config_path);
          this->__isset.config_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->config_path_file);
          this->__isset.config_path_file = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast252;
          xfer += iprot->readI32(ecast252);
          this->power_state = (hv_vm_power_state::type)ecast252;
          this->__isset.power_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast253;
          xfer += iprot->readI32(ecast253);
          this->connection_state = (hv_vm_connection_state::type)ecast253;
          this->__isset.connection_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast254;
          xfer += iprot->readI32(ecast254);
          this->tools_status = (hv_vm_tools_status::type)ecast254;
          this->__isset.tools_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast255;
          xfer += iprot->readI32(ecast255);
          this->firmware = (hv_vm_firmware::type)ecast255;
          this->__isset.firmware = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast256;
          xfer += iprot->readI32(ecast256);
          this->guest_os_type = (hv_guest_os_type::type)ecast256;
          this->__isset.guest_os_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guest_id);
          this->__isset.guest_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guest_os_name);
          this->__isset.guest_os_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_disk_uuid_enabled);
          this->__isset.is_disk_uuid_enabled = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->folder_path);
          this->__isset.folder_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 26:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resource_pool_path);
          this->__isset.resource_pool_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 27:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->disks.clear();
            uint32_t _size257;
            ::apache::thrift::protocol::TType _etype260;
            xfer += iprot->readListBegin(_etype260, _size257);
            this->disks.resize(_size257);
            uint32_t _i261;
            for (_i261 = 0; _i261 < _size257; ++_i261)
            {
              xfer += this->disks[_i261].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.disks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 28:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->networks.clear();
            uint32_t _size262;
            ::apache::thrift::protocol::TType _ktype263;
            ::apache::thrift::protocol::TType _vtype264;
            xfer += iprot->readMapBegin(_ktype263, _vtype264, _size262);
            uint32_t _i266;
            for (_i266 = 0; _i266 < _size262; ++_i266)
            {
              std::string _key267;
              xfer += iprot->readString(_key267);
              std::string& _val268 = this->networks[_key267];
              xfer += iprot->readString(_val268);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.networks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 29:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->datacenter_name);
          this->__isset.datacenter_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->network_adapters.clear();
            uint32_t _size269;
            ::apache::thrift::protocol::TType _etype272;
            xfer += iprot->readListBegin(_etype272, _size269);
            this->network_adapters.resize(_size269);
            uint32_t _i273;
            for (_i273 = 0; _i273 < _size269; ++_i273)
            {
              xfer += this->network_adapters[_i273].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.network_adapters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 31:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->root_snapshot_list.clear();
            uint32_t _size274;
            ::apache::thrift::protocol::TType _etype277;
            xfer += iprot->readListBegin(_etype277, _size274);
            this->root_snapshot_list.resize(_size274);
            uint32_t _i278;
            for (_i278 = 0; _i278 < _size274; ++_i278)
            {
              xfer += this->root_snapshot_list[_i278].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.root_snapshot_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 32:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guest_host_name);
          this->__isset.guest_host_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 33:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guest_ip);
          this->__isset.guest_ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 34:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->has_cdrom);
          this->__isset.has_cdrom = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t virtual_machine::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("virtual_machine");

  if (this->__isset.uuid) {
    xfer += oprot->writeFieldBegin("uuid", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->uuid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.host_key) {
    xfer += oprot->writeFieldBegin("host_key", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->host_key);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.host_ip) {
    xfer += oprot->writeFieldBegin("host_ip", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->host_ip);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.host_name) {
    xfer += oprot->writeFieldBegin("host_name", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->host_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_key) {
    xfer += oprot->writeFieldBegin("cluster_key", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->cluster_key);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_name) {
    xfer += oprot->writeFieldBegin("cluster_name", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->cluster_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.annotation) {
    xfer += oprot->writeFieldBegin("annotation", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->annotation);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_cpu_hot_add) {
    xfer += oprot->writeFieldBegin("is_cpu_hot_add", ::apache::thrift::protocol::T_BOOL, 9);
    xfer += oprot->writeBool(this->is_cpu_hot_add);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_cpu_hot_remove) {
    xfer += oprot->writeFieldBegin("is_cpu_hot_remove", ::apache::thrift::protocol::T_BOOL, 10);
    xfer += oprot->writeBool(this->is_cpu_hot_remove);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.memory_mb) {
    xfer += oprot->writeFieldBegin("memory_mb", ::apache::thrift::protocol::T_I32, 11);
    xfer += oprot->writeI32(this->memory_mb);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.number_of_cpu) {
    xfer += oprot->writeFieldBegin("number_of_cpu", ::apache::thrift::protocol::T_I32, 12);
    xfer += oprot->writeI32(this->number_of_cpu);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_template) {
    xfer += oprot->writeFieldBegin("is_template", ::apache::thrift::protocol::T_BOOL, 13);
    xfer += oprot->writeBool(this->is_template);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.config_path) {
    xfer += oprot->writeFieldBegin("config_path", ::apache::thrift::protocol::T_STRING, 14);
    xfer += oprot->writeString(this->config_path);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.config_path_file) {
    xfer += oprot->writeFieldBegin("config_path_file", ::apache::thrift::protocol::T_STRING, 15);
    xfer += oprot->writeString(this->config_path_file);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.version) {
    xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_I32, 16);
    xfer += oprot->writeI32(this->version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.power_state) {
    xfer += oprot->writeFieldBegin("power_state", ::apache::thrift::protocol::T_I32, 17);
    xfer += oprot->writeI32((int32_t)this->power_state);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.connection_state) {
    xfer += oprot->writeFieldBegin("connection_state", ::apache::thrift::protocol::T_I32, 18);
    xfer += oprot->writeI32((int32_t)this->connection_state);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tools_status) {
    xfer += oprot->writeFieldBegin("tools_status", ::apache::thrift::protocol::T_I32, 19);
    xfer += oprot->writeI32((int32_t)this->tools_status);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.firmware) {
    xfer += oprot->writeFieldBegin("firmware", ::apache::thrift::protocol::T_I32, 20);
    xfer += oprot->writeI32((int32_t)this->firmware);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.guest_os_type) {
    xfer += oprot->writeFieldBegin("guest_os_type", ::apache::thrift::protocol::T_I32, 21);
    xfer += oprot->writeI32((int32_t)this->guest_os_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.guest_id) {
    xfer += oprot->writeFieldBegin("guest_id", ::apache::thrift::protocol::T_STRING, 22);
    xfer += oprot->writeString(this->guest_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.guest_os_name) {
    xfer += oprot->writeFieldBegin("guest_os_name", ::apache::thrift::protocol::T_STRING, 23);
    xfer += oprot->writeString(this->guest_os_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_disk_uuid_enabled) {
    xfer += oprot->writeFieldBegin("is_disk_uuid_enabled", ::apache::thrift::protocol::T_BOOL, 24);
    xfer += oprot->writeBool(this->is_disk_uuid_enabled);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.folder_path) {
    xfer += oprot->writeFieldBegin("folder_path", ::apache::thrift::protocol::T_STRING, 25);
    xfer += oprot->writeString(this->folder_path);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.resource_pool_path) {
    xfer += oprot->writeFieldBegin("resource_pool_path", ::apache::thrift::protocol::T_STRING, 26);
    xfer += oprot->writeString(this->resource_pool_path);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.disks) {
    xfer += oprot->writeFieldBegin("disks", ::apache::thrift::protocol::T_LIST, 27);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->disks.size()));
      std::vector<virtual_disk_info> ::const_iterator _iter279;
      for (_iter279 = this->disks.begin(); _iter279 != this->disks.end(); ++_iter279)
      {
        xfer += (*_iter279).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.networks) {
    xfer += oprot->writeFieldBegin("networks", ::apache::thrift::protocol::T_MAP, 28);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->networks.size()));
      std::map<std::string, std::string> ::const_iterator _iter280;
      for (_iter280 = this->networks.begin(); _iter280 != this->networks.end(); ++_iter280)
      {
        xfer += oprot->writeString(_iter280->first);
        xfer += oprot->writeString(_iter280->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.datacenter_name) {
    xfer += oprot->writeFieldBegin("datacenter_name", ::apache::thrift::protocol::T_STRING, 29);
    xfer += oprot->writeString(this->datacenter_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.network_adapters) {
    xfer += oprot->writeFieldBegin("network_adapters", ::apache::thrift::protocol::T_LIST, 30);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->network_adapters.size()));
      std::vector<virtual_network_adapter> ::const_iterator _iter281;
      for (_iter281 = this->network_adapters.begin(); _iter281 != this->network_adapters.end(); ++_iter281)
      {
        xfer += (*_iter281).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.root_snapshot_list) {
    xfer += oprot->writeFieldBegin("root_snapshot_list", ::apache::thrift::protocol::T_LIST, 31);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->root_snapshot_list.size()));
      std::vector<virtual_machine_snapshots> ::const_iterator _iter282;
      for (_iter282 = this->root_snapshot_list.begin(); _iter282 != this->root_snapshot_list.end(); ++_iter282)
      {
        xfer += (*_iter282).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.guest_host_name) {
    xfer += oprot->writeFieldBegin("guest_host_name", ::apache::thrift::protocol::T_STRING, 32);
    xfer += oprot->writeString(this->guest_host_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.guest_ip) {
    xfer += oprot->writeFieldBegin("guest_ip", ::apache::thrift::protocol::T_STRING, 33);
    xfer += oprot->writeString(this->guest_ip);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.has_cdrom) {
    xfer += oprot->writeFieldBegin("has_cdrom", ::apache::thrift::protocol::T_BOOL, 34);
    xfer += oprot->writeBool(this->has_cdrom);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(virtual_machine &a, virtual_machine &b) {
  using ::std::swap;
  swap(a.uuid, b.uuid);
  swap(a.name, b.name);
  swap(a.host_key, b.host_key);
  swap(a.host_ip, b.host_ip);
  swap(a.host_name, b.host_name);
  swap(a.cluster_key, b.cluster_key);
  swap(a.cluster_name, b.cluster_name);
  swap(a.annotation, b.annotation);
  swap(a.is_cpu_hot_add, b.is_cpu_hot_add);
  swap(a.is_cpu_hot_remove, b.is_cpu_hot_remove);
  swap(a.memory_mb, b.memory_mb);
  swap(a.number_of_cpu, b.number_of_cpu);
  swap(a.is_template, b.is_template);
  swap(a.config_path, b.config_path);
  swap(a.config_path_file, b.config_path_file);
  swap(a.version, b.version);
  swap(a.power_state, b.power_state);
  swap(a.connection_state, b.connection_state);
  swap(a.tools_status, b.tools_status);
  swap(a.firmware, b.firmware);
  swap(a.guest_os_type, b.guest_os_type);
  swap(a.guest_id, b.guest_id);
  swap(a.guest_os_name, b.guest_os_name);
  swap(a.is_disk_uuid_enabled, b.is_disk_uuid_enabled);
  swap(a.folder_path, b.folder_path);
  swap(a.resource_pool_path, b.resource_pool_path);
  swap(a.disks, b.disks);
  swap(a.networks, b.networks);
  swap(a.datacenter_name, b.datacenter_name);
  swap(a.network_adapters, b.network_adapters);
  swap(a.root_snapshot_list, b.root_snapshot_list);
  swap(a.guest_host_name, b.guest_host_name);
  swap(a.guest_ip, b.guest_ip);
  swap(a.has_cdrom, b.has_cdrom);
  swap(a.__isset, b.__isset);
}

virtual_machine::virtual_machine(const virtual_machine& other283) {
  uuid = other283.uuid;
  name = other283.name;
  host_key = other283.host_key;
  host_ip = other283.host_ip;
  host_name = other283.host_name;
  cluster_key = other283.cluster_key;
  cluster_name = other283.cluster_name;
  annotation = other283.annotation;
  is_cpu_hot_add = other283.is_cpu_hot_add;
  is_cpu_hot_remove = other283.is_cpu_hot_remove;
  memory_mb = other283.memory_mb;
  number_of_cpu = other283.number_of_cpu;
  is_template = other283.is_template;
  config_path = other283.config_path;
  config_path_file = other283.config_path_file;
  version = other283.version;
  power_state = other283.power_state;
  connection_state = other283.connection_state;
  tools_status = other283.tools_status;
  firmware = other283.firmware;
  guest_os_type = other283.guest_os_type;
  guest_id = other283.guest_id;
  guest_os_name = other283.guest_os_name;
  is_disk_uuid_enabled = other283.is_disk_uuid_enabled;
  folder_path = other283.folder_path;
  resource_pool_path = other283.resource_pool_path;
  disks = other283.disks;
  networks = other283.networks;
  datacenter_name = other283.datacenter_name;
  network_adapters = other283.network_adapters;
  root_snapshot_list = other283.root_snapshot_list;
  guest_host_name = other283.guest_host_name;
  guest_ip = other283.guest_ip;
  has_cdrom = other283.has_cdrom;
  __isset = other283.__isset;
}
virtual_machine& virtual_machine::operator=(const virtual_machine& other284) {
  uuid = other284.uuid;
  name = other284.name;
  host_key = other284.host_key;
  host_ip = other284.host_ip;
  host_name = other284.host_name;
  cluster_key = other284.cluster_key;
  cluster_name = other284.cluster_name;
  annotation = other284.annotation;
  is_cpu_hot_add = other284.is_cpu_hot_add;
  is_cpu_hot_remove = other284.is_cpu_hot_remove;
  memory_mb = other284.memory_mb;
  number_of_cpu = other284.number_of_cpu;
  is_template = other284.is_template;
  config_path = other284.config_path;
  config_path_file = other284.config_path_file;
  version = other284.version;
  power_state = other284.power_state;
  connection_state = other284.connection_state;
  tools_status = other284.tools_status;
  firmware = other284.firmware;
  guest_os_type = other284.guest_os_type;
  guest_id = other284.guest_id;
  guest_os_name = other284.guest_os_name;
  is_disk_uuid_enabled = other284.is_disk_uuid_enabled;
  folder_path = other284.folder_path;
  resource_pool_path = other284.resource_pool_path;
  disks = other284.disks;
  networks = other284.networks;
  datacenter_name = other284.datacenter_name;
  network_adapters = other284.network_adapters;
  root_snapshot_list = other284.root_snapshot_list;
  guest_host_name = other284.guest_host_name;
  guest_ip = other284.guest_ip;
  has_cdrom = other284.has_cdrom;
  __isset = other284.__isset;
  return *this;
}
void virtual_machine::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "virtual_machine(";
  out << "uuid="; (__isset.uuid ? (out << to_string(uuid)) : (out << "<null>"));
  out << ", " << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
  out << ", " << "host_key="; (__isset.host_key ? (out << to_string(host_key)) : (out << "<null>"));
  out << ", " << "host_ip="; (__isset.host_ip ? (out << to_string(host_ip)) : (out << "<null>"));
  out << ", " << "host_name="; (__isset.host_name ? (out << to_string(host_name)) : (out << "<null>"));
  out << ", " << "cluster_key="; (__isset.cluster_key ? (out << to_string(cluster_key)) : (out << "<null>"));
  out << ", " << "cluster_name="; (__isset.cluster_name ? (out << to_string(cluster_name)) : (out << "<null>"));
  out << ", " << "annotation="; (__isset.annotation ? (out << to_string(annotation)) : (out << "<null>"));
  out << ", " << "is_cpu_hot_add="; (__isset.is_cpu_hot_add ? (out << to_string(is_cpu_hot_add)) : (out << "<null>"));
  out << ", " << "is_cpu_hot_remove="; (__isset.is_cpu_hot_remove ? (out << to_string(is_cpu_hot_remove)) : (out << "<null>"));
  out << ", " << "memory_mb="; (__isset.memory_mb ? (out << to_string(memory_mb)) : (out << "<null>"));
  out << ", " << "number_of_cpu="; (__isset.number_of_cpu ? (out << to_string(number_of_cpu)) : (out << "<null>"));
  out << ", " << "is_template="; (__isset.is_template ? (out << to_string(is_template)) : (out << "<null>"));
  out << ", " << "config_path="; (__isset.config_path ? (out << to_string(config_path)) : (out << "<null>"));
  out << ", " << "config_path_file="; (__isset.config_path_file ? (out << to_string(config_path_file)) : (out << "<null>"));
  out << ", " << "version="; (__isset.version ? (out << to_string(version)) : (out << "<null>"));
  out << ", " << "power_state="; (__isset.power_state ? (out << to_string(power_state)) : (out << "<null>"));
  out << ", " << "connection_state="; (__isset.connection_state ? (out << to_string(connection_state)) : (out << "<null>"));
  out << ", " << "tools_status="; (__isset.tools_status ? (out << to_string(tools_status)) : (out << "<null>"));
  out << ", " << "firmware="; (__isset.firmware ? (out << to_string(firmware)) : (out << "<null>"));
  out << ", " << "guest_os_type="; (__isset.guest_os_type ? (out << to_string(guest_os_type)) : (out << "<null>"));
  out << ", " << "guest_id="; (__isset.guest_id ? (out << to_string(guest_id)) : (out << "<null>"));
  out << ", " << "guest_os_name="; (__isset.guest_os_name ? (out << to_string(guest_os_name)) : (out << "<null>"));
  out << ", " << "is_disk_uuid_enabled="; (__isset.is_disk_uuid_enabled ? (out << to_string(is_disk_uuid_enabled)) : (out << "<null>"));
  out << ", " << "folder_path="; (__isset.folder_path ? (out << to_string(folder_path)) : (out << "<null>"));
  out << ", " << "resource_pool_path="; (__isset.resource_pool_path ? (out << to_string(resource_pool_path)) : (out << "<null>"));
  out << ", " << "disks="; (__isset.disks ? (out << to_string(disks)) : (out << "<null>"));
  out << ", " << "networks="; (__isset.networks ? (out << to_string(networks)) : (out << "<null>"));
  out << ", " << "datacenter_name="; (__isset.datacenter_name ? (out << to_string(datacenter_name)) : (out << "<null>"));
  out << ", " << "network_adapters="; (__isset.network_adapters ? (out << to_string(network_adapters)) : (out << "<null>"));
  out << ", " << "root_snapshot_list="; (__isset.root_snapshot_list ? (out << to_string(root_snapshot_list)) : (out << "<null>"));
  out << ", " << "guest_host_name="; (__isset.guest_host_name ? (out << to_string(guest_host_name)) : (out << "<null>"));
  out << ", " << "guest_ip="; (__isset.guest_ip ? (out << to_string(guest_ip)) : (out << "<null>"));
  out << ", " << "has_cdrom="; (__isset.has_cdrom ? (out << to_string(has_cdrom)) : (out << "<null>"));
  out << ")";
}


invalid_operation::~invalid_operation() throw() {
}


void invalid_operation::__set_what_op(const int32_t val) {
  this->what_op = val;
}

void invalid_operation::__set_why(const std::string& val) {
  this->why = val;
}

void invalid_operation::__set_format(const std::string& val) {
  this->format = val;
__isset.format = true;
}

void invalid_operation::__set_arguments(const std::vector<std::string> & val) {
  this->arguments = val;
__isset.arguments = true;
}
std::ostream& operator<<(std::ostream& out, const invalid_operation& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t invalid_operation::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->what_op);
          this->__isset.what_op = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->why);
          this->__isset.why = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->format);
          this->__isset.format = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->arguments.clear();
            uint32_t _size285;
            ::apache::thrift::protocol::TType _etype288;
            xfer += iprot->readListBegin(_etype288, _size285);
            this->arguments.resize(_size285);
            uint32_t _i289;
            for (_i289 = 0; _i289 < _size285; ++_i289)
            {
              xfer += iprot->readString(this->arguments[_i289]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.arguments = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t invalid_operation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("invalid_operation");

  xfer += oprot->writeFieldBegin("what_op", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->what_op);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("why", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->why);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.format) {
    xfer += oprot->writeFieldBegin("format", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->format);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.arguments) {
    xfer += oprot->writeFieldBegin("arguments", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->arguments.size()));
      std::vector<std::string> ::const_iterator _iter290;
      for (_iter290 = this->arguments.begin(); _iter290 != this->arguments.end(); ++_iter290)
      {
        xfer += oprot->writeString((*_iter290));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(invalid_operation &a, invalid_operation &b) {
  using ::std::swap;
  swap(a.what_op, b.what_op);
  swap(a.why, b.why);
  swap(a.format, b.format);
  swap(a.arguments, b.arguments);
  swap(a.__isset, b.__isset);
}

invalid_operation::invalid_operation(const invalid_operation& other291) : TException() {
  what_op = other291.what_op;
  why = other291.why;
  format = other291.format;
  arguments = other291.arguments;
  __isset = other291.__isset;
}
invalid_operation& invalid_operation::operator=(const invalid_operation& other292) {
  what_op = other292.what_op;
  why = other292.why;
  format = other292.format;
  arguments = other292.arguments;
  __isset = other292.__isset;
  return *this;
}
void invalid_operation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "invalid_operation(";
  out << "what_op=" << to_string(what_op);
  out << ", " << "why=" << to_string(why);
  out << ", " << "format="; (__isset.format ? (out << to_string(format)) : (out << "<null>"));
  out << ", " << "arguments="; (__isset.arguments ? (out << to_string(arguments)) : (out << "<null>"));
  out << ")";
}

const char* invalid_operation::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: invalid_operation";
  }
}


job_trigger::~job_trigger() throw() {
}


void job_trigger::__set_type(const job_trigger_type::type val) {
  this->type = val;
__isset.type = true;
}

void job_trigger::__set_start(const std::string& val) {
  this->start = val;
__isset.start = true;
}

void job_trigger::__set_finish(const std::string& val) {
  this->finish = val;
__isset.finish = true;
}

void job_trigger::__set_interval(const int32_t val) {
  this->interval = val;
__isset.interval = true;
}

void job_trigger::__set_id(const std::string& val) {
  this->id = val;
__isset.id = true;
}

void job_trigger::__set_duration(const int32_t val) {
  this->duration = val;
__isset.duration = true;
}
std::ostream& operator<<(std::ostream& out, const job_trigger& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t job_trigger::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast293;
          xfer += iprot->readI32(ecast293);
          this->type = (job_trigger_type::type)ecast293;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->start);
          this->__isset.start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->finish);
          this->__isset.finish = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->interval);
          this->__isset.interval = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->duration);
          this->__isset.duration = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t job_trigger::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("job_trigger");

  if (this->__isset.type) {
    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32((int32_t)this->type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.start) {
    xfer += oprot->writeFieldBegin("start", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->start);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.finish) {
    xfer += oprot->writeFieldBegin("finish", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->finish);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.interval) {
    xfer += oprot->writeFieldBegin("interval", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->interval);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.duration) {
    xfer += oprot->writeFieldBegin("duration", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(this->duration);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(job_trigger &a, job_trigger &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.start, b.start);
  swap(a.finish, b.finish);
  swap(a.interval, b.interval);
  swap(a.id, b.id);
  swap(a.duration, b.duration);
  swap(a.__isset, b.__isset);
}

job_trigger::job_trigger(const job_trigger& other294) {
  type = other294.type;
  start = other294.start;
  finish = other294.finish;
  interval = other294.interval;
  id = other294.id;
  duration = other294.duration;
  __isset = other294.__isset;
}
job_trigger& job_trigger::operator=(const job_trigger& other295) {
  type = other295.type;
  start = other295.start;
  finish = other295.finish;
  interval = other295.interval;
  id = other295.id;
  duration = other295.duration;
  __isset = other295.__isset;
  return *this;
}
void job_trigger::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "job_trigger(";
  out << "type="; (__isset.type ? (out << to_string(type)) : (out << "<null>"));
  out << ", " << "start="; (__isset.start ? (out << to_string(start)) : (out << "<null>"));
  out << ", " << "finish="; (__isset.finish ? (out << to_string(finish)) : (out << "<null>"));
  out << ", " << "interval="; (__isset.interval ? (out << to_string(interval)) : (out << "<null>"));
  out << ", " << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "duration="; (__isset.duration ? (out << to_string(duration)) : (out << "<null>"));
  out << ")";
}


job_history::~job_history() throw() {
}


void job_history::__set_time(const std::string& val) {
  this->time = val;
__isset.time = true;
}

void job_history::__set_state(const job_state::type val) {
  this->state = val;
__isset.state = true;
}

void job_history::__set_error(const int32_t val) {
  this->error = val;
__isset.error = true;
}

void job_history::__set_description(const std::string& val) {
  this->description = val;
__isset.description = true;
}

void job_history::__set_format(const std::string& val) {
  this->format = val;
__isset.format = true;
}

void job_history::__set_arguments(const std::vector<std::string> & val) {
  this->arguments = val;
__isset.arguments = true;
}

void job_history::__set_is_display(const bool val) {
  this->is_display = val;
__isset.is_display = true;
}
std::ostream& operator<<(std::ostream& out, const job_history& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t job_history::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->time);
          this->__isset.time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast296;
          xfer += iprot->readI32(ecast296);
          this->state = (job_state::type)ecast296;
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->error);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->description);
          this->__isset.description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->format);
          this->__isset.format = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->arguments.clear();
            uint32_t _size297;
            ::apache::thrift::protocol::TType _etype300;
            xfer += iprot->readListBegin(_etype300, _size297);
            this->arguments.resize(_size297);
            uint32_t _i301;
            for (_i301 = 0; _i301 < _size297; ++_i301)
            {
              xfer += iprot->readString(this->arguments[_i301]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.arguments = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_display);
          this->__isset.is_display = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t job_history::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("job_history");

  if (this->__isset.time) {
    xfer += oprot->writeFieldBegin("time", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->time);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.state) {
    xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32((int32_t)this->state);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->error);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.description) {
    xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->description);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.format) {
    xfer += oprot->writeFieldBegin("format", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->format);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.arguments) {
    xfer += oprot->writeFieldBegin("arguments", ::apache::thrift::protocol::T_LIST, 8);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->arguments.size()));
      std::vector<std::string> ::const_iterator _iter302;
      for (_iter302 = this->arguments.begin(); _iter302 != this->arguments.end(); ++_iter302)
      {
        xfer += oprot->writeString((*_iter302));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_display) {
    xfer += oprot->writeFieldBegin("is_display", ::apache::thrift::protocol::T_BOOL, 9);
    xfer += oprot->writeBool(this->is_display);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(job_history &a, job_history &b) {
  using ::std::swap;
  swap(a.time, b.time);
  swap(a.state, b.state);
  swap(a.error, b.error);
  swap(a.description, b.description);
  swap(a.format, b.format);
  swap(a.arguments, b.arguments);
  swap(a.is_display, b.is_display);
  swap(a.__isset, b.__isset);
}

job_history::job_history(const job_history& other303) {
  time = other303.time;
  state = other303.state;
  error = other303.error;
  description = other303.description;
  format = other303.format;
  arguments = other303.arguments;
  is_display = other303.is_display;
  __isset = other303.__isset;
}
job_history& job_history::operator=(const job_history& other304) {
  time = other304.time;
  state = other304.state;
  error = other304.error;
  description = other304.description;
  format = other304.format;
  arguments = other304.arguments;
  is_display = other304.is_display;
  __isset = other304.__isset;
  return *this;
}
void job_history::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "job_history(";
  out << "time="; (__isset.time ? (out << to_string(time)) : (out << "<null>"));
  out << ", " << "state="; (__isset.state ? (out << to_string(state)) : (out << "<null>"));
  out << ", " << "error="; (__isset.error ? (out << to_string(error)) : (out << "<null>"));
  out << ", " << "description="; (__isset.description ? (out << to_string(description)) : (out << "<null>"));
  out << ", " << "format="; (__isset.format ? (out << to_string(format)) : (out << "<null>"));
  out << ", " << "arguments="; (__isset.arguments ? (out << to_string(arguments)) : (out << "<null>"));
  out << ", " << "is_display="; (__isset.is_display ? (out << to_string(is_display)) : (out << "<null>"));
  out << ")";
}


create_job_detail::~create_job_detail() throw() {
}


void create_job_detail::__set_type(const job_type::type val) {
  this->type = val;
__isset.type = true;
}

void create_job_detail::__set_triggers(const std::vector<job_trigger> & val) {
  this->triggers = val;
__isset.triggers = true;
}

void create_job_detail::__set_management_id(const std::string& val) {
  this->management_id = val;
__isset.management_id = true;
}

void create_job_detail::__set_mgmt_addr(const std::set<std::string> & val) {
  this->mgmt_addr = val;
__isset.mgmt_addr = true;
}

void create_job_detail::__set_mgmt_port(const int32_t val) {
  this->mgmt_port = val;
__isset.mgmt_port = true;
}

void create_job_detail::__set_is_ssl(const bool val) {
  this->is_ssl = val;
__isset.is_ssl = true;
}
std::ostream& operator<<(std::ostream& out, const create_job_detail& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t create_job_detail::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast305;
          xfer += iprot->readI32(ecast305);
          this->type = (job_type::type)ecast305;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->triggers.clear();
            uint32_t _size306;
            ::apache::thrift::protocol::TType _etype309;
            xfer += iprot->readListBegin(_etype309, _size306);
            this->triggers.resize(_size306);
            uint32_t _i310;
            for (_i310 = 0; _i310 < _size306; ++_i310)
            {
              xfer += this->triggers[_i310].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.triggers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->management_id);
          this->__isset.management_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->mgmt_addr.clear();
            uint32_t _size311;
            ::apache::thrift::protocol::TType _etype314;
            xfer += iprot->readSetBegin(_etype314, _size311);
            uint32_t _i315;
            for (_i315 = 0; _i315 < _size311; ++_i315)
            {
              std::string _elem316;
              xfer += iprot->readString(_elem316);
              this->mgmt_addr.insert(_elem316);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.mgmt_addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->mgmt_port);
          this->__isset.mgmt_port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_ssl);
          this->__isset.is_ssl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t create_job_detail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("create_job_detail");

  if (this->__isset.type) {
    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32((int32_t)this->type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.triggers) {
    xfer += oprot->writeFieldBegin("triggers", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->triggers.size()));
      std::vector<job_trigger> ::const_iterator _iter317;
      for (_iter317 = this->triggers.begin(); _iter317 != this->triggers.end(); ++_iter317)
      {
        xfer += (*_iter317).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.management_id) {
    xfer += oprot->writeFieldBegin("management_id", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->management_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mgmt_addr) {
    xfer += oprot->writeFieldBegin("mgmt_addr", ::apache::thrift::protocol::T_SET, 4);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->mgmt_addr.size()));
      std::set<std::string> ::const_iterator _iter318;
      for (_iter318 = this->mgmt_addr.begin(); _iter318 != this->mgmt_addr.end(); ++_iter318)
      {
        xfer += oprot->writeString((*_iter318));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mgmt_port) {
    xfer += oprot->writeFieldBegin("mgmt_port", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->mgmt_port);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_ssl) {
    xfer += oprot->writeFieldBegin("is_ssl", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->is_ssl);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(create_job_detail &a, create_job_detail &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.triggers, b.triggers);
  swap(a.management_id, b.management_id);
  swap(a.mgmt_addr, b.mgmt_addr);
  swap(a.mgmt_port, b.mgmt_port);
  swap(a.is_ssl, b.is_ssl);
  swap(a.__isset, b.__isset);
}

create_job_detail::create_job_detail(const create_job_detail& other319) {
  type = other319.type;
  triggers = other319.triggers;
  management_id = other319.management_id;
  mgmt_addr = other319.mgmt_addr;
  mgmt_port = other319.mgmt_port;
  is_ssl = other319.is_ssl;
  __isset = other319.__isset;
}
create_job_detail& create_job_detail::operator=(const create_job_detail& other320) {
  type = other320.type;
  triggers = other320.triggers;
  management_id = other320.management_id;
  mgmt_addr = other320.mgmt_addr;
  mgmt_port = other320.mgmt_port;
  is_ssl = other320.is_ssl;
  __isset = other320.__isset;
  return *this;
}
void create_job_detail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "create_job_detail(";
  out << "type="; (__isset.type ? (out << to_string(type)) : (out << "<null>"));
  out << ", " << "triggers="; (__isset.triggers ? (out << to_string(triggers)) : (out << "<null>"));
  out << ", " << "management_id="; (__isset.management_id ? (out << to_string(management_id)) : (out << "<null>"));
  out << ", " << "mgmt_addr="; (__isset.mgmt_addr ? (out << to_string(mgmt_addr)) : (out << "<null>"));
  out << ", " << "mgmt_port="; (__isset.mgmt_port ? (out << to_string(mgmt_port)) : (out << "<null>"));
  out << ", " << "is_ssl="; (__isset.is_ssl ? (out << to_string(is_ssl)) : (out << "<null>"));
  out << ")";
}


packer_disk_image::~packer_disk_image() throw() {
}


void packer_disk_image::__set_name(const std::string& val) {
  this->name = val;
__isset.name = true;
}

void packer_disk_image::__set_parent(const std::string& val) {
  this->parent = val;
__isset.parent = true;
}

void packer_disk_image::__set_base(const std::string& val) {
  this->base = val;
__isset.base = true;
}
std::ostream& operator<<(std::ostream& out, const packer_disk_image& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t packer_disk_image::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->parent);
          this->__isset.parent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->base);
          this->__isset.base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t packer_disk_image::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("packer_disk_image");

  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.parent) {
    xfer += oprot->writeFieldBegin("parent", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->parent);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.base) {
    xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->base);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(packer_disk_image &a, packer_disk_image &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.parent, b.parent);
  swap(a.base, b.base);
  swap(a.__isset, b.__isset);
}

packer_disk_image::packer_disk_image(const packer_disk_image& other321) {
  name = other321.name;
  parent = other321.parent;
  base = other321.base;
  __isset = other321.__isset;
}
packer_disk_image& packer_disk_image::operator=(const packer_disk_image& other322) {
  name = other322.name;
  parent = other322.parent;
  base = other322.base;
  __isset = other322.__isset;
  return *this;
}
void packer_disk_image::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "packer_disk_image(";
  out << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
  out << ", " << "parent="; (__isset.parent ? (out << to_string(parent)) : (out << "<null>"));
  out << ", " << "base="; (__isset.base ? (out << to_string(base)) : (out << "<null>"));
  out << ")";
}


virtual_partition_info::~virtual_partition_info() throw() {
}


void virtual_partition_info::__set_partition_number(const int32_t val) {
  this->partition_number = val;
__isset.partition_number = true;
}

void virtual_partition_info::__set_offset(const int64_t val) {
  this->offset = val;
__isset.offset = true;
}

void virtual_partition_info::__set_size(const int64_t val) {
  this->size = val;
__isset.size = true;
}
std::ostream& operator<<(std::ostream& out, const virtual_partition_info& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t virtual_partition_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->partition_number);
          this->__isset.partition_number = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->offset);
          this->__isset.offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->size);
          this->__isset.size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t virtual_partition_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("virtual_partition_info");

  if (this->__isset.partition_number) {
    xfer += oprot->writeFieldBegin("partition_number", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->partition_number);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.offset) {
    xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->offset);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.size) {
    xfer += oprot->writeFieldBegin("size", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->size);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(virtual_partition_info &a, virtual_partition_info &b) {
  using ::std::swap;
  swap(a.partition_number, b.partition_number);
  swap(a.offset, b.offset);
  swap(a.size, b.size);
  swap(a.__isset, b.__isset);
}

virtual_partition_info::virtual_partition_info(const virtual_partition_info& other323) {
  partition_number = other323.partition_number;
  offset = other323.offset;
  size = other323.size;
  __isset = other323.__isset;
}
virtual_partition_info& virtual_partition_info::operator=(const virtual_partition_info& other324) {
  partition_number = other324.partition_number;
  offset = other324.offset;
  size = other324.size;
  __isset = other324.__isset;
  return *this;
}
void virtual_partition_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "virtual_partition_info(";
  out << "partition_number="; (__isset.partition_number ? (out << to_string(partition_number)) : (out << "<null>"));
  out << ", " << "offset="; (__isset.offset ? (out << to_string(offset)) : (out << "<null>"));
  out << ", " << "size="; (__isset.size ? (out << to_string(size)) : (out << "<null>"));
  out << ")";
}


virtual_disk_info_ex::~virtual_disk_info_ex() throw() {
}


void virtual_disk_info_ex::__set_id(const std::string& val) {
  this->id = val;
__isset.id = true;
}

void virtual_disk_info_ex::__set_size(const int64_t val) {
  this->size = val;
__isset.size = true;
}

void virtual_disk_info_ex::__set_partition_style(const partition_style::type val) {
  this->partition_style = val;
__isset.partition_style = true;
}

void virtual_disk_info_ex::__set_guid(const std::string& val) {
  this->guid = val;
__isset.guid = true;
}

void virtual_disk_info_ex::__set_signature(const int32_t val) {
  this->signature = val;
__isset.signature = true;
}

void virtual_disk_info_ex::__set_is_system(const bool val) {
  this->is_system = val;
__isset.is_system = true;
}

void virtual_disk_info_ex::__set_partitions(const std::set<virtual_partition_info> & val) {
  this->partitions = val;
__isset.partitions = true;
}
std::ostream& operator<<(std::ostream& out, const virtual_disk_info_ex& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t virtual_disk_info_ex::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->size);
          this->__isset.size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast325;
          xfer += iprot->readI32(ecast325);
          this->partition_style = (partition_style::type)ecast325;
          this->__isset.partition_style = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guid);
          this->__isset.guid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->signature);
          this->__isset.signature = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_system);
          this->__isset.is_system = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->partitions.clear();
            uint32_t _size326;
            ::apache::thrift::protocol::TType _etype329;
            xfer += iprot->readSetBegin(_etype329, _size326);
            uint32_t _i330;
            for (_i330 = 0; _i330 < _size326; ++_i330)
            {
              virtual_partition_info _elem331;
              xfer += _elem331.read(iprot);
              this->partitions.insert(_elem331);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t virtual_disk_info_ex::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("virtual_disk_info_ex");

  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.size) {
    xfer += oprot->writeFieldBegin("size", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partition_style) {
    xfer += oprot->writeFieldBegin("partition_style", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32((int32_t)this->partition_style);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.guid) {
    xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->guid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.signature) {
    xfer += oprot->writeFieldBegin("signature", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->signature);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_system) {
    xfer += oprot->writeFieldBegin("is_system", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->is_system);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partitions) {
    xfer += oprot->writeFieldBegin("partitions", ::apache::thrift::protocol::T_SET, 7);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitions.size()));
      std::set<virtual_partition_info> ::const_iterator _iter332;
      for (_iter332 = this->partitions.begin(); _iter332 != this->partitions.end(); ++_iter332)
      {
        xfer += (*_iter332).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(virtual_disk_info_ex &a, virtual_disk_info_ex &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.size, b.size);
  swap(a.partition_style, b.partition_style);
  swap(a.guid, b.guid);
  swap(a.signature, b.signature);
  swap(a.is_system, b.is_system);
  swap(a.partitions, b.partitions);
  swap(a.__isset, b.__isset);
}

virtual_disk_info_ex::virtual_disk_info_ex(const virtual_disk_info_ex& other333) {
  id = other333.id;
  size = other333.size;
  partition_style = other333.partition_style;
  guid = other333.guid;
  signature = other333.signature;
  is_system = other333.is_system;
  partitions = other333.partitions;
  __isset = other333.__isset;
}
virtual_disk_info_ex& virtual_disk_info_ex::operator=(const virtual_disk_info_ex& other334) {
  id = other334.id;
  size = other334.size;
  partition_style = other334.partition_style;
  guid = other334.guid;
  signature = other334.signature;
  is_system = other334.is_system;
  partitions = other334.partitions;
  __isset = other334.__isset;
  return *this;
}
void virtual_disk_info_ex::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "virtual_disk_info_ex(";
  out << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "size="; (__isset.size ? (out << to_string(size)) : (out << "<null>"));
  out << ", " << "partition_style="; (__isset.partition_style ? (out << to_string(partition_style)) : (out << "<null>"));
  out << ", " << "guid="; (__isset.guid ? (out << to_string(guid)) : (out << "<null>"));
  out << ", " << "signature="; (__isset.signature ? (out << to_string(signature)) : (out << "<null>"));
  out << ", " << "is_system="; (__isset.is_system ? (out << to_string(is_system)) : (out << "<null>"));
  out << ", " << "partitions="; (__isset.partitions ? (out << to_string(partitions)) : (out << "<null>"));
  out << ")";
}


virtual_create_packer_job_detail::~virtual_create_packer_job_detail() throw() {
}


void virtual_create_packer_job_detail::__set_disks(const std::set<std::string> & val) {
  this->disks = val;
__isset.disks = true;
}

void virtual_create_packer_job_detail::__set_host(const std::string& val) {
  this->host = val;
__isset.host = true;
}

void virtual_create_packer_job_detail::__set_addr(const std::set<std::string> & val) {
  this->addr = val;
__isset.addr = true;
}

void virtual_create_packer_job_detail::__set_username(const std::string& val) {
  this->username = val;
__isset.username = true;
}

void virtual_create_packer_job_detail::__set_password(const std::string& val) {
  this->password = val;
__isset.password = true;
}

void virtual_create_packer_job_detail::__set_virtual_machine_id(const std::string& val) {
  this->virtual_machine_id = val;
__isset.virtual_machine_id = true;
}

void virtual_create_packer_job_detail::__set_snapshot(const std::string& val) {
  this->snapshot = val;
__isset.snapshot = true;
}

void virtual_create_packer_job_detail::__set_images(const std::map<std::string, packer_disk_image> & val) {
  this->images = val;
__isset.images = true;
}

void virtual_create_packer_job_detail::__set_backup_size(const std::map<std::string, int64_t> & val) {
  this->backup_size = val;
__isset.backup_size = true;
}

void virtual_create_packer_job_detail::__set_backup_progress(const std::map<std::string, int64_t> & val) {
  this->backup_progress = val;
__isset.backup_progress = true;
}

void virtual_create_packer_job_detail::__set_backup_image_offset(const std::map<std::string, int64_t> & val) {
  this->backup_image_offset = val;
__isset.backup_image_offset = true;
}

void virtual_create_packer_job_detail::__set_previous_change_ids(const std::map<std::string, std::string> & val) {
  this->previous_change_ids = val;
__isset.previous_change_ids = true;
}

void virtual_create_packer_job_detail::__set_completed_blocks(const std::map<std::string, std::vector<io_changed_range> > & val) {
  this->completed_blocks = val;
__isset.completed_blocks = true;
}
std::ostream& operator<<(std::ostream& out, const virtual_create_packer_job_detail& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t virtual_create_packer_job_detail::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->disks.clear();
            uint32_t _size335;
            ::apache::thrift::protocol::TType _etype338;
            xfer += iprot->readSetBegin(_etype338, _size335);
            uint32_t _i339;
            for (_i339 = 0; _i339 < _size335; ++_i339)
            {
              std::string _elem340;
              xfer += iprot->readString(_elem340);
              this->disks.insert(_elem340);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.disks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host);
          this->__isset.host = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->addr.clear();
            uint32_t _size341;
            ::apache::thrift::protocol::TType _etype344;
            xfer += iprot->readSetBegin(_etype344, _size341);
            uint32_t _i345;
            for (_i345 = 0; _i345 < _size341; ++_i345)
            {
              std::string _elem346;
              xfer += iprot->readString(_elem346);
              this->addr.insert(_elem346);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->username);
          this->__isset.username = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->password);
          this->__isset.password = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->virtual_machine_id);
          this->__isset.virtual_machine_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->snapshot);
          this->__isset.snapshot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->images.clear();
            uint32_t _size347;
            ::apache::thrift::protocol::TType _ktype348;
            ::apache::thrift::protocol::TType _vtype349;
            xfer += iprot->readMapBegin(_ktype348, _vtype349, _size347);
            uint32_t _i351;
            for (_i351 = 0; _i351 < _size347; ++_i351)
            {
              std::string _key352;
              xfer += iprot->readString(_key352);
              packer_disk_image& _val353 = this->images[_key352];
              xfer += _val353.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.images = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->backup_size.clear();
            uint32_t _size354;
            ::apache::thrift::protocol::TType _ktype355;
            ::apache::thrift::protocol::TType _vtype356;
            xfer += iprot->readMapBegin(_ktype355, _vtype356, _size354);
            uint32_t _i358;
            for (_i358 = 0; _i358 < _size354; ++_i358)
            {
              std::string _key359;
              xfer += iprot->readString(_key359);
              int64_t& _val360 = this->backup_size[_key359];
              xfer += iprot->readI64(_val360);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.backup_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->backup_progress.clear();
            uint32_t _size361;
            ::apache::thrift::protocol::TType _ktype362;
            ::apache::thrift::protocol::TType _vtype363;
            xfer += iprot->readMapBegin(_ktype362, _vtype363, _size361);
            uint32_t _i365;
            for (_i365 = 0; _i365 < _size361; ++_i365)
            {
              std::string _key366;
              xfer += iprot->readString(_key366);
              int64_t& _val367 = this->backup_progress[_key366];
              xfer += iprot->readI64(_val367);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.backup_progress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->backup_image_offset.clear();
            uint32_t _size368;
            ::apache::thrift::protocol::TType _ktype369;
            ::apache::thrift::protocol::TType _vtype370;
            xfer += iprot->readMapBegin(_ktype369, _vtype370, _size368);
            uint32_t _i372;
            for (_i372 = 0; _i372 < _size368; ++_i372)
            {
              std::string _key373;
              xfer += iprot->readString(_key373);
              int64_t& _val374 = this->backup_image_offset[_key373];
              xfer += iprot->readI64(_val374);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.backup_image_offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->previous_change_ids.clear();
            uint32_t _size375;
            ::apache::thrift::protocol::TType _ktype376;
            ::apache::thrift::protocol::TType _vtype377;
            xfer += iprot->readMapBegin(_ktype376, _vtype377, _size375);
            uint32_t _i379;
            for (_i379 = 0; _i379 < _size375; ++_i379)
            {
              std::string _key380;
              xfer += iprot->readString(_key380);
              std::string& _val381 = this->previous_change_ids[_key380];
              xfer += iprot->readString(_val381);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.previous_change_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->completed_blocks.clear();
            uint32_t _size382;
            ::apache::thrift::protocol::TType _ktype383;
            ::apache::thrift::protocol::TType _vtype384;
            xfer += iprot->readMapBegin(_ktype383, _vtype384, _size382);
            uint32_t _i386;
            for (_i386 = 0; _i386 < _size382; ++_i386)
            {
              std::string _key387;
              xfer += iprot->readString(_key387);
              std::vector<io_changed_range> & _val388 = this->completed_blocks[_key387];
              {
                _val388.clear();
                uint32_t _size389;
                ::apache::thrift::protocol::TType _etype392;
                xfer += iprot->readListBegin(_etype392, _size389);
                _val388.resize(_size389);
                uint32_t _i393;
                for (_i393 = 0; _i393 < _size389; ++_i393)
                {
                  xfer += _val388[_i393].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.completed_blocks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t virtual_create_packer_job_detail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("virtual_create_packer_job_detail");

  if (this->__isset.disks) {
    xfer += oprot->writeFieldBegin("disks", ::apache::thrift::protocol::T_SET, 1);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->disks.size()));
      std::set<std::string> ::const_iterator _iter394;
      for (_iter394 = this->disks.begin(); _iter394 != this->disks.end(); ++_iter394)
      {
        xfer += oprot->writeString((*_iter394));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.host) {
    xfer += oprot->writeFieldBegin("host", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->host);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.addr) {
    xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_SET, 3);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->addr.size()));
      std::set<std::string> ::const_iterator _iter395;
      for (_iter395 = this->addr.begin(); _iter395 != this->addr.end(); ++_iter395)
      {
        xfer += oprot->writeString((*_iter395));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.username) {
    xfer += oprot->writeFieldBegin("username", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->username);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.password) {
    xfer += oprot->writeFieldBegin("password", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->password);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.virtual_machine_id) {
    xfer += oprot->writeFieldBegin("virtual_machine_id", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->virtual_machine_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.snapshot) {
    xfer += oprot->writeFieldBegin("snapshot", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->snapshot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.images) {
    xfer += oprot->writeFieldBegin("images", ::apache::thrift::protocol::T_MAP, 10);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->images.size()));
      std::map<std::string, packer_disk_image> ::const_iterator _iter396;
      for (_iter396 = this->images.begin(); _iter396 != this->images.end(); ++_iter396)
      {
        xfer += oprot->writeString(_iter396->first);
        xfer += _iter396->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.backup_size) {
    xfer += oprot->writeFieldBegin("backup_size", ::apache::thrift::protocol::T_MAP, 14);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->backup_size.size()));
      std::map<std::string, int64_t> ::const_iterator _iter397;
      for (_iter397 = this->backup_size.begin(); _iter397 != this->backup_size.end(); ++_iter397)
      {
        xfer += oprot->writeString(_iter397->first);
        xfer += oprot->writeI64(_iter397->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.backup_progress) {
    xfer += oprot->writeFieldBegin("backup_progress", ::apache::thrift::protocol::T_MAP, 15);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->backup_progress.size()));
      std::map<std::string, int64_t> ::const_iterator _iter398;
      for (_iter398 = this->backup_progress.begin(); _iter398 != this->backup_progress.end(); ++_iter398)
      {
        xfer += oprot->writeString(_iter398->first);
        xfer += oprot->writeI64(_iter398->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.backup_image_offset) {
    xfer += oprot->writeFieldBegin("backup_image_offset", ::apache::thrift::protocol::T_MAP, 16);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->backup_image_offset.size()));
      std::map<std::string, int64_t> ::const_iterator _iter399;
      for (_iter399 = this->backup_image_offset.begin(); _iter399 != this->backup_image_offset.end(); ++_iter399)
      {
        xfer += oprot->writeString(_iter399->first);
        xfer += oprot->writeI64(_iter399->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.previous_change_ids) {
    xfer += oprot->writeFieldBegin("previous_change_ids", ::apache::thrift::protocol::T_MAP, 17);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->previous_change_ids.size()));
      std::map<std::string, std::string> ::const_iterator _iter400;
      for (_iter400 = this->previous_change_ids.begin(); _iter400 != this->previous_change_ids.end(); ++_iter400)
      {
        xfer += oprot->writeString(_iter400->first);
        xfer += oprot->writeString(_iter400->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.completed_blocks) {
    xfer += oprot->writeFieldBegin("completed_blocks", ::apache::thrift::protocol::T_MAP, 18);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->completed_blocks.size()));
      std::map<std::string, std::vector<io_changed_range> > ::const_iterator _iter401;
      for (_iter401 = this->completed_blocks.begin(); _iter401 != this->completed_blocks.end(); ++_iter401)
      {
        xfer += oprot->writeString(_iter401->first);
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter401->second.size()));
          std::vector<io_changed_range> ::const_iterator _iter402;
          for (_iter402 = _iter401->second.begin(); _iter402 != _iter401->second.end(); ++_iter402)
          {
            xfer += (*_iter402).write(oprot);
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(virtual_create_packer_job_detail &a, virtual_create_packer_job_detail &b) {
  using ::std::swap;
  swap(a.disks, b.disks);
  swap(a.host, b.host);
  swap(a.addr, b.addr);
  swap(a.username, b.username);
  swap(a.password, b.password);
  swap(a.virtual_machine_id, b.virtual_machine_id);
  swap(a.snapshot, b.snapshot);
  swap(a.images, b.images);
  swap(a.backup_size, b.backup_size);
  swap(a.backup_progress, b.backup_progress);
  swap(a.backup_image_offset, b.backup_image_offset);
  swap(a.previous_change_ids, b.previous_change_ids);
  swap(a.completed_blocks, b.completed_blocks);
  swap(a.__isset, b.__isset);
}

virtual_create_packer_job_detail::virtual_create_packer_job_detail(const virtual_create_packer_job_detail& other403) {
  disks = other403.disks;
  host = other403.host;
  addr = other403.addr;
  username = other403.username;
  password = other403.password;
  virtual_machine_id = other403.virtual_machine_id;
  snapshot = other403.snapshot;
  images = other403.images;
  backup_size = other403.backup_size;
  backup_progress = other403.backup_progress;
  backup_image_offset = other403.backup_image_offset;
  previous_change_ids = other403.previous_change_ids;
  completed_blocks = other403.completed_blocks;
  __isset = other403.__isset;
}
virtual_create_packer_job_detail& virtual_create_packer_job_detail::operator=(const virtual_create_packer_job_detail& other404) {
  disks = other404.disks;
  host = other404.host;
  addr = other404.addr;
  username = other404.username;
  password = other404.password;
  virtual_machine_id = other404.virtual_machine_id;
  snapshot = other404.snapshot;
  images = other404.images;
  backup_size = other404.backup_size;
  backup_progress = other404.backup_progress;
  backup_image_offset = other404.backup_image_offset;
  previous_change_ids = other404.previous_change_ids;
  completed_blocks = other404.completed_blocks;
  __isset = other404.__isset;
  return *this;
}
void virtual_create_packer_job_detail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "virtual_create_packer_job_detail(";
  out << "disks="; (__isset.disks ? (out << to_string(disks)) : (out << "<null>"));
  out << ", " << "host="; (__isset.host ? (out << to_string(host)) : (out << "<null>"));
  out << ", " << "addr="; (__isset.addr ? (out << to_string(addr)) : (out << "<null>"));
  out << ", " << "username="; (__isset.username ? (out << to_string(username)) : (out << "<null>"));
  out << ", " << "password="; (__isset.password ? (out << to_string(password)) : (out << "<null>"));
  out << ", " << "virtual_machine_id="; (__isset.virtual_machine_id ? (out << to_string(virtual_machine_id)) : (out << "<null>"));
  out << ", " << "snapshot="; (__isset.snapshot ? (out << to_string(snapshot)) : (out << "<null>"));
  out << ", " << "images="; (__isset.images ? (out << to_string(images)) : (out << "<null>"));
  out << ", " << "backup_size="; (__isset.backup_size ? (out << to_string(backup_size)) : (out << "<null>"));
  out << ", " << "backup_progress="; (__isset.backup_progress ? (out << to_string(backup_progress)) : (out << "<null>"));
  out << ", " << "backup_image_offset="; (__isset.backup_image_offset ? (out << to_string(backup_image_offset)) : (out << "<null>"));
  out << ", " << "previous_change_ids="; (__isset.previous_change_ids ? (out << to_string(previous_change_ids)) : (out << "<null>"));
  out << ", " << "completed_blocks="; (__isset.completed_blocks ? (out << to_string(completed_blocks)) : (out << "<null>"));
  out << ")";
}


physical_vcbt_journal::~physical_vcbt_journal() throw() {
}


void physical_vcbt_journal::__set_id(const int64_t val) {
  this->id = val;
__isset.id = true;
}

void physical_vcbt_journal::__set_first_key(const int64_t val) {
  this->first_key = val;
__isset.first_key = true;
}

void physical_vcbt_journal::__set_latest_key(const int64_t val) {
  this->latest_key = val;
__isset.latest_key = true;
}

void physical_vcbt_journal::__set_lowest_valid_key(const int64_t val) {
  this->lowest_valid_key = val;
__isset.lowest_valid_key = true;
}
std::ostream& operator<<(std::ostream& out, const physical_vcbt_journal& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t physical_vcbt_journal::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->first_key);
          this->__isset.first_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->latest_key);
          this->__isset.latest_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lowest_valid_key);
          this->__isset.lowest_valid_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_vcbt_journal::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_vcbt_journal");

  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.first_key) {
    xfer += oprot->writeFieldBegin("first_key", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->first_key);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.latest_key) {
    xfer += oprot->writeFieldBegin("latest_key", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->latest_key);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lowest_valid_key) {
    xfer += oprot->writeFieldBegin("lowest_valid_key", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->lowest_valid_key);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(physical_vcbt_journal &a, physical_vcbt_journal &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.first_key, b.first_key);
  swap(a.latest_key, b.latest_key);
  swap(a.lowest_valid_key, b.lowest_valid_key);
  swap(a.__isset, b.__isset);
}

physical_vcbt_journal::physical_vcbt_journal(const physical_vcbt_journal& other405) {
  id = other405.id;
  first_key = other405.first_key;
  latest_key = other405.latest_key;
  lowest_valid_key = other405.lowest_valid_key;
  __isset = other405.__isset;
}
physical_vcbt_journal& physical_vcbt_journal::operator=(const physical_vcbt_journal& other406) {
  id = other406.id;
  first_key = other406.first_key;
  latest_key = other406.latest_key;
  lowest_valid_key = other406.lowest_valid_key;
  __isset = other406.__isset;
  return *this;
}
void physical_vcbt_journal::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "physical_vcbt_journal(";
  out << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "first_key="; (__isset.first_key ? (out << to_string(first_key)) : (out << "<null>"));
  out << ", " << "latest_key="; (__isset.latest_key ? (out << to_string(latest_key)) : (out << "<null>"));
  out << ", " << "lowest_valid_key="; (__isset.lowest_valid_key ? (out << to_string(lowest_valid_key)) : (out << "<null>"));
  out << ")";
}


io_changed_range::~io_changed_range() throw() {
}


void io_changed_range::__set_offset(const int64_t val) {
  this->offset = val;
}

void io_changed_range::__set_start(const int64_t val) {
  this->start = val;
}

void io_changed_range::__set_length(const int64_t val) {
  this->length = val;
}
std::ostream& operator<<(std::ostream& out, const io_changed_range& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t io_changed_range::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->offset);
          this->__isset.offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->start);
          this->__isset.start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->length);
          this->__isset.length = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t io_changed_range::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("io_changed_range");

  xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->offset);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->start);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("length", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->length);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(io_changed_range &a, io_changed_range &b) {
  using ::std::swap;
  swap(a.offset, b.offset);
  swap(a.start, b.start);
  swap(a.length, b.length);
  swap(a.__isset, b.__isset);
}

io_changed_range::io_changed_range(const io_changed_range& other407) {
  offset = other407.offset;
  start = other407.start;
  length = other407.length;
  __isset = other407.__isset;
}
io_changed_range& io_changed_range::operator=(const io_changed_range& other408) {
  offset = other408.offset;
  start = other408.start;
  length = other408.length;
  __isset = other408.__isset;
  return *this;
}
void io_changed_range::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "io_changed_range(";
  out << "offset=" << to_string(offset);
  out << ", " << "start=" << to_string(start);
  out << ", " << "length=" << to_string(length);
  out << ")";
}


physical_create_packer_job_detail::~physical_create_packer_job_detail() throw() {
}


void physical_create_packer_job_detail::__set_disks(const std::set<std::string> & val) {
  this->disks = val;
__isset.disks = true;
}

void physical_create_packer_job_detail::__set_snapshots(const std::vector<snapshot> & val) {
  this->snapshots = val;
__isset.snapshots = true;
}

void physical_create_packer_job_detail::__set_previous_journals(const std::map<int64_t, physical_vcbt_journal> & val) {
  this->previous_journals = val;
__isset.previous_journals = true;
}

void physical_create_packer_job_detail::__set_images(const std::map<std::string, packer_disk_image> & val) {
  this->images = val;
__isset.images = true;
}

void physical_create_packer_job_detail::__set_backup_size(const std::map<std::string, int64_t> & val) {
  this->backup_size = val;
__isset.backup_size = true;
}

void physical_create_packer_job_detail::__set_backup_progress(const std::map<std::string, int64_t> & val) {
  this->backup_progress = val;
__isset.backup_progress = true;
}

void physical_create_packer_job_detail::__set_backup_image_offset(const std::map<std::string, int64_t> & val) {
  this->backup_image_offset = val;
__isset.backup_image_offset = true;
}

void physical_create_packer_job_detail::__set_cdr_journals(const std::map<int64_t, physical_vcbt_journal> & val) {
  this->cdr_journals = val;
__isset.cdr_journals = true;
}

void physical_create_packer_job_detail::__set_cdr_changed_ranges(const std::map<std::string, std::vector<io_changed_range> > & val) {
  this->cdr_changed_ranges = val;
__isset.cdr_changed_ranges = true;
}

void physical_create_packer_job_detail::__set_completed_blocks(const std::map<std::string, std::vector<io_changed_range> > & val) {
  this->completed_blocks = val;
__isset.completed_blocks = true;
}

void physical_create_packer_job_detail::__set_excluded_paths(const std::set<std::string> & val) {
  this->excluded_paths = val;
__isset.excluded_paths = true;
}

void physical_create_packer_job_detail::__set_resync_paths(const std::set<std::string> & val) {
  this->resync_paths = val;
__isset.resync_paths = true;
}
std::ostream& operator<<(std::ostream& out, const physical_create_packer_job_detail& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t physical_create_packer_job_detail::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->disks.clear();
            uint32_t _size409;
            ::apache::thrift::protocol::TType _etype412;
            xfer += iprot->readSetBegin(_etype412, _size409);
            uint32_t _i413;
            for (_i413 = 0; _i413 < _size409; ++_i413)
            {
              std::string _elem414;
              xfer += iprot->readString(_elem414);
              this->disks.insert(_elem414);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.disks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->snapshots.clear();
            uint32_t _size415;
            ::apache::thrift::protocol::TType _etype418;
            xfer += iprot->readListBegin(_etype418, _size415);
            this->snapshots.resize(_size415);
            uint32_t _i419;
            for (_i419 = 0; _i419 < _size415; ++_i419)
            {
              xfer += this->snapshots[_i419].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.snapshots = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->previous_journals.clear();
            uint32_t _size420;
            ::apache::thrift::protocol::TType _ktype421;
            ::apache::thrift::protocol::TType _vtype422;
            xfer += iprot->readMapBegin(_ktype421, _vtype422, _size420);
            uint32_t _i424;
            for (_i424 = 0; _i424 < _size420; ++_i424)
            {
              int64_t _key425;
              xfer += iprot->readI64(_key425);
              physical_vcbt_journal& _val426 = this->previous_journals[_key425];
              xfer += _val426.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.previous_journals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->images.clear();
            uint32_t _size427;
            ::apache::thrift::protocol::TType _ktype428;
            ::apache::thrift::protocol::TType _vtype429;
            xfer += iprot->readMapBegin(_ktype428, _vtype429, _size427);
            uint32_t _i431;
            for (_i431 = 0; _i431 < _size427; ++_i431)
            {
              std::string _key432;
              xfer += iprot->readString(_key432);
              packer_disk_image& _val433 = this->images[_key432];
              xfer += _val433.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.images = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->backup_size.clear();
            uint32_t _size434;
            ::apache::thrift::protocol::TType _ktype435;
            ::apache::thrift::protocol::TType _vtype436;
            xfer += iprot->readMapBegin(_ktype435, _vtype436, _size434);
            uint32_t _i438;
            for (_i438 = 0; _i438 < _size434; ++_i438)
            {
              std::string _key439;
              xfer += iprot->readString(_key439);
              int64_t& _val440 = this->backup_size[_key439];
              xfer += iprot->readI64(_val440);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.backup_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->backup_progress.clear();
            uint32_t _size441;
            ::apache::thrift::protocol::TType _ktype442;
            ::apache::thrift::protocol::TType _vtype443;
            xfer += iprot->readMapBegin(_ktype442, _vtype443, _size441);
            uint32_t _i445;
            for (_i445 = 0; _i445 < _size441; ++_i445)
            {
              std::string _key446;
              xfer += iprot->readString(_key446);
              int64_t& _val447 = this->backup_progress[_key446];
              xfer += iprot->readI64(_val447);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.backup_progress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->backup_image_offset.clear();
            uint32_t _size448;
            ::apache::thrift::protocol::TType _ktype449;
            ::apache::thrift::protocol::TType _vtype450;
            xfer += iprot->readMapBegin(_ktype449, _vtype450, _size448);
            uint32_t _i452;
            for (_i452 = 0; _i452 < _size448; ++_i452)
            {
              std::string _key453;
              xfer += iprot->readString(_key453);
              int64_t& _val454 = this->backup_image_offset[_key453];
              xfer += iprot->readI64(_val454);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.backup_image_offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->cdr_journals.clear();
            uint32_t _size455;
            ::apache::thrift::protocol::TType _ktype456;
            ::apache::thrift::protocol::TType _vtype457;
            xfer += iprot->readMapBegin(_ktype456, _vtype457, _size455);
            uint32_t _i459;
            for (_i459 = 0; _i459 < _size455; ++_i459)
            {
              int64_t _key460;
              xfer += iprot->readI64(_key460);
              physical_vcbt_journal& _val461 = this->cdr_journals[_key460];
              xfer += _val461.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.cdr_journals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->cdr_changed_ranges.clear();
            uint32_t _size462;
            ::apache::thrift::protocol::TType _ktype463;
            ::apache::thrift::protocol::TType _vtype464;
            xfer += iprot->readMapBegin(_ktype463, _vtype464, _size462);
            uint32_t _i466;
            for (_i466 = 0; _i466 < _size462; ++_i466)
            {
              std::string _key467;
              xfer += iprot->readString(_key467);
              std::vector<io_changed_range> & _val468 = this->cdr_changed_ranges[_key467];
              {
                _val468.clear();
                uint32_t _size469;
                ::apache::thrift::protocol::TType _etype472;
                xfer += iprot->readListBegin(_etype472, _size469);
                _val468.resize(_size469);
                uint32_t _i473;
                for (_i473 = 0; _i473 < _size469; ++_i473)
                {
                  xfer += _val468[_i473].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.cdr_changed_ranges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->completed_blocks.clear();
            uint32_t _size474;
            ::apache::thrift::protocol::TType _ktype475;
            ::apache::thrift::protocol::TType _vtype476;
            xfer += iprot->readMapBegin(_ktype475, _vtype476, _size474);
            uint32_t _i478;
            for (_i478 = 0; _i478 < _size474; ++_i478)
            {
              std::string _key479;
              xfer += iprot->readString(_key479);
              std::vector<io_changed_range> & _val480 = this->completed_blocks[_key479];
              {
                _val480.clear();
                uint32_t _size481;
                ::apache::thrift::protocol::TType _etype484;
                xfer += iprot->readListBegin(_etype484, _size481);
                _val480.resize(_size481);
                uint32_t _i485;
                for (_i485 = 0; _i485 < _size481; ++_i485)
                {
                  xfer += _val480[_i485].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.completed_blocks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->excluded_paths.clear();
            uint32_t _size486;
            ::apache::thrift::protocol::TType _etype489;
            xfer += iprot->readSetBegin(_etype489, _size486);
            uint32_t _i490;
            for (_i490 = 0; _i490 < _size486; ++_i490)
            {
              std::string _elem491;
              xfer += iprot->readString(_elem491);
              this->excluded_paths.insert(_elem491);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.excluded_paths = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->resync_paths.clear();
            uint32_t _size492;
            ::apache::thrift::protocol::TType _etype495;
            xfer += iprot->readSetBegin(_etype495, _size492);
            uint32_t _i496;
            for (_i496 = 0; _i496 < _size492; ++_i496)
            {
              std::string _elem497;
              xfer += iprot->readString(_elem497);
              this->resync_paths.insert(_elem497);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.resync_paths = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_create_packer_job_detail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_create_packer_job_detail");

  if (this->__isset.disks) {
    xfer += oprot->writeFieldBegin("disks", ::apache::thrift::protocol::T_SET, 1);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->disks.size()));
      std::set<std::string> ::const_iterator _iter498;
      for (_iter498 = this->disks.begin(); _iter498 != this->disks.end(); ++_iter498)
      {
        xfer += oprot->writeString((*_iter498));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.snapshots) {
    xfer += oprot->writeFieldBegin("snapshots", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->snapshots.size()));
      std::vector<snapshot> ::const_iterator _iter499;
      for (_iter499 = this->snapshots.begin(); _iter499 != this->snapshots.end(); ++_iter499)
      {
        xfer += (*_iter499).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.previous_journals) {
    xfer += oprot->writeFieldBegin("previous_journals", ::apache::thrift::protocol::T_MAP, 3);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I64, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->previous_journals.size()));
      std::map<int64_t, physical_vcbt_journal> ::const_iterator _iter500;
      for (_iter500 = this->previous_journals.begin(); _iter500 != this->previous_journals.end(); ++_iter500)
      {
        xfer += oprot->writeI64(_iter500->first);
        xfer += _iter500->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.images) {
    xfer += oprot->writeFieldBegin("images", ::apache::thrift::protocol::T_MAP, 4);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->images.size()));
      std::map<std::string, packer_disk_image> ::const_iterator _iter501;
      for (_iter501 = this->images.begin(); _iter501 != this->images.end(); ++_iter501)
      {
        xfer += oprot->writeString(_iter501->first);
        xfer += _iter501->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.backup_size) {
    xfer += oprot->writeFieldBegin("backup_size", ::apache::thrift::protocol::T_MAP, 5);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->backup_size.size()));
      std::map<std::string, int64_t> ::const_iterator _iter502;
      for (_iter502 = this->backup_size.begin(); _iter502 != this->backup_size.end(); ++_iter502)
      {
        xfer += oprot->writeString(_iter502->first);
        xfer += oprot->writeI64(_iter502->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.backup_progress) {
    xfer += oprot->writeFieldBegin("backup_progress", ::apache::thrift::protocol::T_MAP, 6);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->backup_progress.size()));
      std::map<std::string, int64_t> ::const_iterator _iter503;
      for (_iter503 = this->backup_progress.begin(); _iter503 != this->backup_progress.end(); ++_iter503)
      {
        xfer += oprot->writeString(_iter503->first);
        xfer += oprot->writeI64(_iter503->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.backup_image_offset) {
    xfer += oprot->writeFieldBegin("backup_image_offset", ::apache::thrift::protocol::T_MAP, 7);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->backup_image_offset.size()));
      std::map<std::string, int64_t> ::const_iterator _iter504;
      for (_iter504 = this->backup_image_offset.begin(); _iter504 != this->backup_image_offset.end(); ++_iter504)
      {
        xfer += oprot->writeString(_iter504->first);
        xfer += oprot->writeI64(_iter504->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cdr_journals) {
    xfer += oprot->writeFieldBegin("cdr_journals", ::apache::thrift::protocol::T_MAP, 8);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I64, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cdr_journals.size()));
      std::map<int64_t, physical_vcbt_journal> ::const_iterator _iter505;
      for (_iter505 = this->cdr_journals.begin(); _iter505 != this->cdr_journals.end(); ++_iter505)
      {
        xfer += oprot->writeI64(_iter505->first);
        xfer += _iter505->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cdr_changed_ranges) {
    xfer += oprot->writeFieldBegin("cdr_changed_ranges", ::apache::thrift::protocol::T_MAP, 9);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->cdr_changed_ranges.size()));
      std::map<std::string, std::vector<io_changed_range> > ::const_iterator _iter506;
      for (_iter506 = this->cdr_changed_ranges.begin(); _iter506 != this->cdr_changed_ranges.end(); ++_iter506)
      {
        xfer += oprot->writeString(_iter506->first);
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter506->second.size()));
          std::vector<io_changed_range> ::const_iterator _iter507;
          for (_iter507 = _iter506->second.begin(); _iter507 != _iter506->second.end(); ++_iter507)
          {
            xfer += (*_iter507).write(oprot);
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.completed_blocks) {
    xfer += oprot->writeFieldBegin("completed_blocks", ::apache::thrift::protocol::T_MAP, 10);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->completed_blocks.size()));
      std::map<std::string, std::vector<io_changed_range> > ::const_iterator _iter508;
      for (_iter508 = this->completed_blocks.begin(); _iter508 != this->completed_blocks.end(); ++_iter508)
      {
        xfer += oprot->writeString(_iter508->first);
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter508->second.size()));
          std::vector<io_changed_range> ::const_iterator _iter509;
          for (_iter509 = _iter508->second.begin(); _iter509 != _iter508->second.end(); ++_iter509)
          {
            xfer += (*_iter509).write(oprot);
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.excluded_paths) {
    xfer += oprot->writeFieldBegin("excluded_paths", ::apache::thrift::protocol::T_SET, 11);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->excluded_paths.size()));
      std::set<std::string> ::const_iterator _iter510;
      for (_iter510 = this->excluded_paths.begin(); _iter510 != this->excluded_paths.end(); ++_iter510)
      {
        xfer += oprot->writeString((*_iter510));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.resync_paths) {
    xfer += oprot->writeFieldBegin("resync_paths", ::apache::thrift::protocol::T_SET, 12);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->resync_paths.size()));
      std::set<std::string> ::const_iterator _iter511;
      for (_iter511 = this->resync_paths.begin(); _iter511 != this->resync_paths.end(); ++_iter511)
      {
        xfer += oprot->writeString((*_iter511));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(physical_create_packer_job_detail &a, physical_create_packer_job_detail &b) {
  using ::std::swap;
  swap(a.disks, b.disks);
  swap(a.snapshots, b.snapshots);
  swap(a.previous_journals, b.previous_journals);
  swap(a.images, b.images);
  swap(a.backup_size, b.backup_size);
  swap(a.backup_progress, b.backup_progress);
  swap(a.backup_image_offset, b.backup_image_offset);
  swap(a.cdr_journals, b.cdr_journals);
  swap(a.cdr_changed_ranges, b.cdr_changed_ranges);
  swap(a.completed_blocks, b.completed_blocks);
  swap(a.excluded_paths, b.excluded_paths);
  swap(a.resync_paths, b.resync_paths);
  swap(a.__isset, b.__isset);
}

physical_create_packer_job_detail::physical_create_packer_job_detail(const physical_create_packer_job_detail& other512) {
  disks = other512.disks;
  snapshots = other512.snapshots;
  previous_journals = other512.previous_journals;
  images = other512.images;
  backup_size = other512.backup_size;
  backup_progress = other512.backup_progress;
  backup_image_offset = other512.backup_image_offset;
  cdr_journals = other512.cdr_journals;
  cdr_changed_ranges = other512.cdr_changed_ranges;
  completed_blocks = other512.completed_blocks;
  excluded_paths = other512.excluded_paths;
  resync_paths = other512.resync_paths;
  __isset = other512.__isset;
}
physical_create_packer_job_detail& physical_create_packer_job_detail::operator=(const physical_create_packer_job_detail& other513) {
  disks = other513.disks;
  snapshots = other513.snapshots;
  previous_journals = other513.previous_journals;
  images = other513.images;
  backup_size = other513.backup_size;
  backup_progress = other513.backup_progress;
  backup_image_offset = other513.backup_image_offset;
  cdr_journals = other513.cdr_journals;
  cdr_changed_ranges = other513.cdr_changed_ranges;
  completed_blocks = other513.completed_blocks;
  excluded_paths = other513.excluded_paths;
  resync_paths = other513.resync_paths;
  __isset = other513.__isset;
  return *this;
}
void physical_create_packer_job_detail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "physical_create_packer_job_detail(";
  out << "disks="; (__isset.disks ? (out << to_string(disks)) : (out << "<null>"));
  out << ", " << "snapshots="; (__isset.snapshots ? (out << to_string(snapshots)) : (out << "<null>"));
  out << ", " << "previous_journals="; (__isset.previous_journals ? (out << to_string(previous_journals)) : (out << "<null>"));
  out << ", " << "images="; (__isset.images ? (out << to_string(images)) : (out << "<null>"));
  out << ", " << "backup_size="; (__isset.backup_size ? (out << to_string(backup_size)) : (out << "<null>"));
  out << ", " << "backup_progress="; (__isset.backup_progress ? (out << to_string(backup_progress)) : (out << "<null>"));
  out << ", " << "backup_image_offset="; (__isset.backup_image_offset ? (out << to_string(backup_image_offset)) : (out << "<null>"));
  out << ", " << "cdr_journals="; (__isset.cdr_journals ? (out << to_string(cdr_journals)) : (out << "<null>"));
  out << ", " << "cdr_changed_ranges="; (__isset.cdr_changed_ranges ? (out << to_string(cdr_changed_ranges)) : (out << "<null>"));
  out << ", " << "completed_blocks="; (__isset.completed_blocks ? (out << to_string(completed_blocks)) : (out << "<null>"));
  out << ", " << "excluded_paths="; (__isset.excluded_paths ? (out << to_string(excluded_paths)) : (out << "<null>"));
  out << ", " << "resync_paths="; (__isset.resync_paths ? (out << to_string(resync_paths)) : (out << "<null>"));
  out << ")";
}


_create_packer_job_detail::~_create_packer_job_detail() throw() {
}


void _create_packer_job_detail::__set_p(const physical_create_packer_job_detail& val) {
  this->p = val;
__isset.p = true;
}

void _create_packer_job_detail::__set_v(const virtual_create_packer_job_detail& val) {
  this->v = val;
__isset.v = true;
}
std::ostream& operator<<(std::ostream& out, const _create_packer_job_detail& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t _create_packer_job_detail::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->p.read(iprot);
          this->__isset.p = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->v.read(iprot);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t _create_packer_job_detail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("_create_packer_job_detail");

  if (this->__isset.p) {
    xfer += oprot->writeFieldBegin("p", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->p.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.v) {
    xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->v.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(_create_packer_job_detail &a, _create_packer_job_detail &b) {
  using ::std::swap;
  swap(a.p, b.p);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

_create_packer_job_detail::_create_packer_job_detail(const _create_packer_job_detail& other514) {
  p = other514.p;
  v = other514.v;
  __isset = other514.__isset;
}
_create_packer_job_detail& _create_packer_job_detail::operator=(const _create_packer_job_detail& other515) {
  p = other515.p;
  v = other515.v;
  __isset = other515.__isset;
  return *this;
}
void _create_packer_job_detail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "_create_packer_job_detail(";
  out << "p="; (__isset.p ? (out << to_string(p)) : (out << "<null>"));
  out << ", " << "v="; (__isset.v ? (out << to_string(v)) : (out << "<null>"));
  out << ")";
}


create_packer_job_detail::~create_packer_job_detail() throw() {
}


void create_packer_job_detail::__set_type(const job_type::type val) {
  this->type = val;
}

void create_packer_job_detail::__set_connection_ids(const std::set<std::string> & val) {
  this->connection_ids = val;
}

void create_packer_job_detail::__set_carriers(const std::map<std::string, std::set<std::string> > & val) {
  this->carriers = val;
}

void create_packer_job_detail::__set_detail(const _create_packer_job_detail& val) {
  this->detail = val;
}

void create_packer_job_detail::__set_checksum_verify(const bool val) {
  this->checksum_verify = val;
__isset.checksum_verify = true;
}

void create_packer_job_detail::__set_timeout(const int32_t val) {
  this->timeout = val;
__isset.timeout = true;
}

void create_packer_job_detail::__set_is_encrypted(const bool val) {
  this->is_encrypted = val;
__isset.is_encrypted = true;
}

void create_packer_job_detail::__set_worker_thread_number(const int32_t val) {
  this->worker_thread_number = val;
__isset.worker_thread_number = true;
}

void create_packer_job_detail::__set_file_system_filter_enable(const bool val) {
  this->file_system_filter_enable = val;
__isset.file_system_filter_enable = true;
}

void create_packer_job_detail::__set_min_transport_size(const int32_t val) {
  this->min_transport_size = val;
__isset.min_transport_size = true;
}

void create_packer_job_detail::__set_full_min_transport_size(const int32_t val) {
  this->full_min_transport_size = val;
__isset.full_min_transport_size = true;
}

void create_packer_job_detail::__set_is_compressed(const bool val) {
  this->is_compressed = val;
__isset.is_compressed = true;
}

void create_packer_job_detail::__set_is_checksum(const bool val) {
  this->is_checksum = val;
__isset.is_checksum = true;
}

void create_packer_job_detail::__set_priority_carrier(const std::map<std::string, std::string> & val) {
  this->priority_carrier = val;
__isset.priority_carrier = true;
}

void create_packer_job_detail::__set_is_only_single_system_disk(const bool val) {
  this->is_only_single_system_disk = val;
__isset.is_only_single_system_disk = true;
}

void create_packer_job_detail::__set_is_compressed_by_packer(const bool val) {
  this->is_compressed_by_packer = val;
__isset.is_compressed_by_packer = true;
}

void create_packer_job_detail::__set_checksum_target(const std::map<std::string, std::string> & val) {
  this->checksum_target = val;
__isset.checksum_target = true;
}
std::ostream& operator<<(std::ostream& out, const create_packer_job_detail& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t create_packer_job_detail::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast516;
          xfer += iprot->readI32(ecast516);
          this->type = (job_type::type)ecast516;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->connection_ids.clear();
            uint32_t _size517;
            ::apache::thrift::protocol::TType _etype520;
            xfer += iprot->readSetBegin(_etype520, _size517);
            uint32_t _i521;
            for (_i521 = 0; _i521 < _size517; ++_i521)
            {
              std::string _elem522;
              xfer += iprot->readString(_elem522);
              this->connection_ids.insert(_elem522);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.connection_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->carriers.clear();
            uint32_t _size523;
            ::apache::thrift::protocol::TType _ktype524;
            ::apache::thrift::protocol::TType _vtype525;
            xfer += iprot->readMapBegin(_ktype524, _vtype525, _size523);
            uint32_t _i527;
            for (_i527 = 0; _i527 < _size523; ++_i527)
            {
              std::string _key528;
              xfer += iprot->readString(_key528);
              std::set<std::string> & _val529 = this->carriers[_key528];
              {
                _val529.clear();
                uint32_t _size530;
                ::apache::thrift::protocol::TType _etype533;
                xfer += iprot->readSetBegin(_etype533, _size530);
                uint32_t _i534;
                for (_i534 = 0; _i534 < _size530; ++_i534)
                {
                  std::string _elem535;
                  xfer += iprot->readString(_elem535);
                  _val529.insert(_elem535);
                }
                xfer += iprot->readSetEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.carriers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->detail.read(iprot);
          this->__isset.detail = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->checksum_verify);
          this->__isset.checksum_verify = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->timeout);
          this->__isset.timeout = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_encrypted);
          this->__isset.is_encrypted = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->worker_thread_number);
          this->__isset.worker_thread_number = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->file_system_filter_enable);
          this->__isset.file_system_filter_enable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->min_transport_size);
          this->__isset.min_transport_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->full_min_transport_size);
          this->__isset.full_min_transport_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_compressed);
          this->__isset.is_compressed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_checksum);
          this->__isset.is_checksum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->priority_carrier.clear();
            uint32_t _size536;
            ::apache::thrift::protocol::TType _ktype537;
            ::apache::thrift::protocol::TType _vtype538;
            xfer += iprot->readMapBegin(_ktype537, _vtype538, _size536);
            uint32_t _i540;
            for (_i540 = 0; _i540 < _size536; ++_i540)
            {
              std::string _key541;
              xfer += iprot->readString(_key541);
              std::string& _val542 = this->priority_carrier[_key541];
              xfer += iprot->readString(_val542);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.priority_carrier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_only_single_system_disk);
          this->__isset.is_only_single_system_disk = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_compressed_by_packer);
          this->__isset.is_compressed_by_packer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->checksum_target.clear();
            uint32_t _size543;
            ::apache::thrift::protocol::TType _ktype544;
            ::apache::thrift::protocol::TType _vtype545;
            xfer += iprot->readMapBegin(_ktype544, _vtype545, _size543);
            uint32_t _i547;
            for (_i547 = 0; _i547 < _size543; ++_i547)
            {
              std::string _key548;
              xfer += iprot->readString(_key548);
              std::string& _val549 = this->checksum_target[_key548];
              xfer += iprot->readString(_val549);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.checksum_target = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t create_packer_job_detail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("create_packer_job_detail");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("connection_ids", ::apache::thrift::protocol::T_SET, 2);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->connection_ids.size()));
    std::set<std::string> ::const_iterator _iter550;
    for (_iter550 = this->connection_ids.begin(); _iter550 != this->connection_ids.end(); ++_iter550)
    {
      xfer += oprot->writeString((*_iter550));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("carriers", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_SET, static_cast<uint32_t>(this->carriers.size()));
    std::map<std::string, std::set<std::string> > ::const_iterator _iter551;
    for (_iter551 = this->carriers.begin(); _iter551 != this->carriers.end(); ++_iter551)
    {
      xfer += oprot->writeString(_iter551->first);
      {
        xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter551->second.size()));
        std::set<std::string> ::const_iterator _iter552;
        for (_iter552 = _iter551->second.begin(); _iter552 != _iter551->second.end(); ++_iter552)
        {
          xfer += oprot->writeString((*_iter552));
        }
        xfer += oprot->writeSetEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("detail", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->detail.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.checksum_verify) {
    xfer += oprot->writeFieldBegin("checksum_verify", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->checksum_verify);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timeout) {
    xfer += oprot->writeFieldBegin("timeout", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(this->timeout);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_encrypted) {
    xfer += oprot->writeFieldBegin("is_encrypted", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->is_encrypted);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.worker_thread_number) {
    xfer += oprot->writeFieldBegin("worker_thread_number", ::apache::thrift::protocol::T_I32, 8);
    xfer += oprot->writeI32(this->worker_thread_number);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.file_system_filter_enable) {
    xfer += oprot->writeFieldBegin("file_system_filter_enable", ::apache::thrift::protocol::T_BOOL, 9);
    xfer += oprot->writeBool(this->file_system_filter_enable);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.min_transport_size) {
    xfer += oprot->writeFieldBegin("min_transport_size", ::apache::thrift::protocol::T_I32, 10);
    xfer += oprot->writeI32(this->min_transport_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.full_min_transport_size) {
    xfer += oprot->writeFieldBegin("full_min_transport_size", ::apache::thrift::protocol::T_I32, 11);
    xfer += oprot->writeI32(this->full_min_transport_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_compressed) {
    xfer += oprot->writeFieldBegin("is_compressed", ::apache::thrift::protocol::T_BOOL, 12);
    xfer += oprot->writeBool(this->is_compressed);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_checksum) {
    xfer += oprot->writeFieldBegin("is_checksum", ::apache::thrift::protocol::T_BOOL, 13);
    xfer += oprot->writeBool(this->is_checksum);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.priority_carrier) {
    xfer += oprot->writeFieldBegin("priority_carrier", ::apache::thrift::protocol::T_MAP, 14);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->priority_carrier.size()));
      std::map<std::string, std::string> ::const_iterator _iter553;
      for (_iter553 = this->priority_carrier.begin(); _iter553 != this->priority_carrier.end(); ++_iter553)
      {
        xfer += oprot->writeString(_iter553->first);
        xfer += oprot->writeString(_iter553->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_only_single_system_disk) {
    xfer += oprot->writeFieldBegin("is_only_single_system_disk", ::apache::thrift::protocol::T_BOOL, 15);
    xfer += oprot->writeBool(this->is_only_single_system_disk);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_compressed_by_packer) {
    xfer += oprot->writeFieldBegin("is_compressed_by_packer", ::apache::thrift::protocol::T_BOOL, 16);
    xfer += oprot->writeBool(this->is_compressed_by_packer);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.checksum_target) {
    xfer += oprot->writeFieldBegin("checksum_target", ::apache::thrift::protocol::T_MAP, 17);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->checksum_target.size()));
      std::map<std::string, std::string> ::const_iterator _iter554;
      for (_iter554 = this->checksum_target.begin(); _iter554 != this->checksum_target.end(); ++_iter554)
      {
        xfer += oprot->writeString(_iter554->first);
        xfer += oprot->writeString(_iter554->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(create_packer_job_detail &a, create_packer_job_detail &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.connection_ids, b.connection_ids);
  swap(a.carriers, b.carriers);
  swap(a.detail, b.detail);
  swap(a.checksum_verify, b.checksum_verify);
  swap(a.timeout, b.timeout);
  swap(a.is_encrypted, b.is_encrypted);
  swap(a.worker_thread_number, b.worker_thread_number);
  swap(a.file_system_filter_enable, b.file_system_filter_enable);
  swap(a.min_transport_size, b.min_transport_size);
  swap(a.full_min_transport_size, b.full_min_transport_size);
  swap(a.is_compressed, b.is_compressed);
  swap(a.is_checksum, b.is_checksum);
  swap(a.priority_carrier, b.priority_carrier);
  swap(a.is_only_single_system_disk, b.is_only_single_system_disk);
  swap(a.is_compressed_by_packer, b.is_compressed_by_packer);
  swap(a.checksum_target, b.checksum_target);
  swap(a.__isset, b.__isset);
}

create_packer_job_detail::create_packer_job_detail(const create_packer_job_detail& other555) {
  type = other555.type;
  connection_ids = other555.connection_ids;
  carriers = other555.carriers;
  detail = other555.detail;
  checksum_verify = other555.checksum_verify;
  timeout = other555.timeout;
  is_encrypted = other555.is_encrypted;
  worker_thread_number = other555.worker_thread_number;
  file_system_filter_enable = other555.file_system_filter_enable;
  min_transport_size = other555.min_transport_size;
  full_min_transport_size = other555.full_min_transport_size;
  is_compressed = other555.is_compressed;
  is_checksum = other555.is_checksum;
  priority_carrier = other555.priority_carrier;
  is_only_single_system_disk = other555.is_only_single_system_disk;
  is_compressed_by_packer = other555.is_compressed_by_packer;
  checksum_target = other555.checksum_target;
  __isset = other555.__isset;
}
create_packer_job_detail& create_packer_job_detail::operator=(const create_packer_job_detail& other556) {
  type = other556.type;
  connection_ids = other556.connection_ids;
  carriers = other556.carriers;
  detail = other556.detail;
  checksum_verify = other556.checksum_verify;
  timeout = other556.timeout;
  is_encrypted = other556.is_encrypted;
  worker_thread_number = other556.worker_thread_number;
  file_system_filter_enable = other556.file_system_filter_enable;
  min_transport_size = other556.min_transport_size;
  full_min_transport_size = other556.full_min_transport_size;
  is_compressed = other556.is_compressed;
  is_checksum = other556.is_checksum;
  priority_carrier = other556.priority_carrier;
  is_only_single_system_disk = other556.is_only_single_system_disk;
  is_compressed_by_packer = other556.is_compressed_by_packer;
  checksum_target = other556.checksum_target;
  __isset = other556.__isset;
  return *this;
}
void create_packer_job_detail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "create_packer_job_detail(";
  out << "type=" << to_string(type);
  out << ", " << "connection_ids=" << to_string(connection_ids);
  out << ", " << "carriers=" << to_string(carriers);
  out << ", " << "detail=" << to_string(detail);
  out << ", " << "checksum_verify="; (__isset.checksum_verify ? (out << to_string(checksum_verify)) : (out << "<null>"));
  out << ", " << "timeout="; (__isset.timeout ? (out << to_string(timeout)) : (out << "<null>"));
  out << ", " << "is_encrypted="; (__isset.is_encrypted ? (out << to_string(is_encrypted)) : (out << "<null>"));
  out << ", " << "worker_thread_number="; (__isset.worker_thread_number ? (out << to_string(worker_thread_number)) : (out << "<null>"));
  out << ", " << "file_system_filter_enable="; (__isset.file_system_filter_enable ? (out << to_string(file_system_filter_enable)) : (out << "<null>"));
  out << ", " << "min_transport_size="; (__isset.min_transport_size ? (out << to_string(min_transport_size)) : (out << "<null>"));
  out << ", " << "full_min_transport_size="; (__isset.full_min_transport_size ? (out << to_string(full_min_transport_size)) : (out << "<null>"));
  out << ", " << "is_compressed="; (__isset.is_compressed ? (out << to_string(is_compressed)) : (out << "<null>"));
  out << ", " << "is_checksum="; (__isset.is_checksum ? (out << to_string(is_checksum)) : (out << "<null>"));
  out << ", " << "priority_carrier="; (__isset.priority_carrier ? (out << to_string(priority_carrier)) : (out << "<null>"));
  out << ", " << "is_only_single_system_disk="; (__isset.is_only_single_system_disk ? (out << to_string(is_only_single_system_disk)) : (out << "<null>"));
  out << ", " << "is_compressed_by_packer="; (__isset.is_compressed_by_packer ? (out << to_string(is_compressed_by_packer)) : (out << "<null>"));
  out << ", " << "checksum_target="; (__isset.checksum_target ? (out << to_string(checksum_target)) : (out << "<null>"));
  out << ")";
}


virtual_packer_job_detail::~virtual_packer_job_detail() throw() {
}


void virtual_packer_job_detail::__set_original_size(const std::map<std::string, int64_t> & val) {
  this->original_size = val;
__isset.original_size = true;
}

void virtual_packer_job_detail::__set_backup_size(const std::map<std::string, int64_t> & val) {
  this->backup_size = val;
__isset.backup_size = true;
}

void virtual_packer_job_detail::__set_backup_progress(const std::map<std::string, int64_t> & val) {
  this->backup_progress = val;
__isset.backup_progress = true;
}

void virtual_packer_job_detail::__set_backup_image_offset(const std::map<std::string, int64_t> & val) {
  this->backup_image_offset = val;
__isset.backup_image_offset = true;
}

void virtual_packer_job_detail::__set_change_ids(const std::map<std::string, std::string> & val) {
  this->change_ids = val;
__isset.change_ids = true;
}

void virtual_packer_job_detail::__set_guest_os_type(const hv_guest_os_type::type val) {
  this->guest_os_type = val;
__isset.guest_os_type = true;
}

void virtual_packer_job_detail::__set_completed_blocks(const std::map<std::string, std::vector<io_changed_range> > & val) {
  this->completed_blocks = val;
__isset.completed_blocks = true;
}

void virtual_packer_job_detail::__set_disk_infos(const std::vector<virtual_disk_info_ex> & val) {
  this->disk_infos = val;
__isset.disk_infos = true;
}
std::ostream& operator<<(std::ostream& out, const virtual_packer_job_detail& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t virtual_packer_job_detail::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->original_size.clear();
            uint32_t _size557;
            ::apache::thrift::protocol::TType _ktype558;
            ::apache::thrift::protocol::TType _vtype559;
            xfer += iprot->readMapBegin(_ktype558, _vtype559, _size557);
            uint32_t _i561;
            for (_i561 = 0; _i561 < _size557; ++_i561)
            {
              std::string _key562;
              xfer += iprot->readString(_key562);
              int64_t& _val563 = this->original_size[_key562];
              xfer += iprot->readI64(_val563);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.original_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->backup_size.clear();
            uint32_t _size564;
            ::apache::thrift::protocol::TType _ktype565;
            ::apache::thrift::protocol::TType _vtype566;
            xfer += iprot->readMapBegin(_ktype565, _vtype566, _size564);
            uint32_t _i568;
            for (_i568 = 0; _i568 < _size564; ++_i568)
            {
              std::string _key569;
              xfer += iprot->readString(_key569);
              int64_t& _val570 = this->backup_size[_key569];
              xfer += iprot->readI64(_val570);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.backup_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->backup_progress.clear();
            uint32_t _size571;
            ::apache::thrift::protocol::TType _ktype572;
            ::apache::thrift::protocol::TType _vtype573;
            xfer += iprot->readMapBegin(_ktype572, _vtype573, _size571);
            uint32_t _i575;
            for (_i575 = 0; _i575 < _size571; ++_i575)
            {
              std::string _key576;
              xfer += iprot->readString(_key576);
              int64_t& _val577 = this->backup_progress[_key576];
              xfer += iprot->readI64(_val577);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.backup_progress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->backup_image_offset.clear();
            uint32_t _size578;
            ::apache::thrift::protocol::TType _ktype579;
            ::apache::thrift::protocol::TType _vtype580;
            xfer += iprot->readMapBegin(_ktype579, _vtype580, _size578);
            uint32_t _i582;
            for (_i582 = 0; _i582 < _size578; ++_i582)
            {
              std::string _key583;
              xfer += iprot->readString(_key583);
              int64_t& _val584 = this->backup_image_offset[_key583];
              xfer += iprot->readI64(_val584);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.backup_image_offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->change_ids.clear();
            uint32_t _size585;
            ::apache::thrift::protocol::TType _ktype586;
            ::apache::thrift::protocol::TType _vtype587;
            xfer += iprot->readMapBegin(_ktype586, _vtype587, _size585);
            uint32_t _i589;
            for (_i589 = 0; _i589 < _size585; ++_i589)
            {
              std::string _key590;
              xfer += iprot->readString(_key590);
              std::string& _val591 = this->change_ids[_key590];
              xfer += iprot->readString(_val591);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.change_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast592;
          xfer += iprot->readI32(ecast592);
          this->guest_os_type = (hv_guest_os_type::type)ecast592;
          this->__isset.guest_os_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->completed_blocks.clear();
            uint32_t _size593;
            ::apache::thrift::protocol::TType _ktype594;
            ::apache::thrift::protocol::TType _vtype595;
            xfer += iprot->readMapBegin(_ktype594, _vtype595, _size593);
            uint32_t _i597;
            for (_i597 = 0; _i597 < _size593; ++_i597)
            {
              std::string _key598;
              xfer += iprot->readString(_key598);
              std::vector<io_changed_range> & _val599 = this->completed_blocks[_key598];
              {
                _val599.clear();
                uint32_t _size600;
                ::apache::thrift::protocol::TType _etype603;
                xfer += iprot->readListBegin(_etype603, _size600);
                _val599.resize(_size600);
                uint32_t _i604;
                for (_i604 = 0; _i604 < _size600; ++_i604)
                {
                  xfer += _val599[_i604].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.completed_blocks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->disk_infos.clear();
            uint32_t _size605;
            ::apache::thrift::protocol::TType _etype608;
            xfer += iprot->readListBegin(_etype608, _size605);
            this->disk_infos.resize(_size605);
            uint32_t _i609;
            for (_i609 = 0; _i609 < _size605; ++_i609)
            {
              xfer += this->disk_infos[_i609].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.disk_infos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t virtual_packer_job_detail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("virtual_packer_job_detail");

  if (this->__isset.original_size) {
    xfer += oprot->writeFieldBegin("original_size", ::apache::thrift::protocol::T_MAP, 1);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->original_size.size()));
      std::map<std::string, int64_t> ::const_iterator _iter610;
      for (_iter610 = this->original_size.begin(); _iter610 != this->original_size.end(); ++_iter610)
      {
        xfer += oprot->writeString(_iter610->first);
        xfer += oprot->writeI64(_iter610->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.backup_size) {
    xfer += oprot->writeFieldBegin("backup_size", ::apache::thrift::protocol::T_MAP, 2);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->backup_size.size()));
      std::map<std::string, int64_t> ::const_iterator _iter611;
      for (_iter611 = this->backup_size.begin(); _iter611 != this->backup_size.end(); ++_iter611)
      {
        xfer += oprot->writeString(_iter611->first);
        xfer += oprot->writeI64(_iter611->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.backup_progress) {
    xfer += oprot->writeFieldBegin("backup_progress", ::apache::thrift::protocol::T_MAP, 3);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->backup_progress.size()));
      std::map<std::string, int64_t> ::const_iterator _iter612;
      for (_iter612 = this->backup_progress.begin(); _iter612 != this->backup_progress.end(); ++_iter612)
      {
        xfer += oprot->writeString(_iter612->first);
        xfer += oprot->writeI64(_iter612->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.backup_image_offset) {
    xfer += oprot->writeFieldBegin("backup_image_offset", ::apache::thrift::protocol::T_MAP, 4);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->backup_image_offset.size()));
      std::map<std::string, int64_t> ::const_iterator _iter613;
      for (_iter613 = this->backup_image_offset.begin(); _iter613 != this->backup_image_offset.end(); ++_iter613)
      {
        xfer += oprot->writeString(_iter613->first);
        xfer += oprot->writeI64(_iter613->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.change_ids) {
    xfer += oprot->writeFieldBegin("change_ids", ::apache::thrift::protocol::T_MAP, 5);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->change_ids.size()));
      std::map<std::string, std::string> ::const_iterator _iter614;
      for (_iter614 = this->change_ids.begin(); _iter614 != this->change_ids.end(); ++_iter614)
      {
        xfer += oprot->writeString(_iter614->first);
        xfer += oprot->writeString(_iter614->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.guest_os_type) {
    xfer += oprot->writeFieldBegin("guest_os_type", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32((int32_t)this->guest_os_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.completed_blocks) {
    xfer += oprot->writeFieldBegin("completed_blocks", ::apache::thrift::protocol::T_MAP, 7);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->completed_blocks.size()));
      std::map<std::string, std::vector<io_changed_range> > ::const_iterator _iter615;
      for (_iter615 = this->completed_blocks.begin(); _iter615 != this->completed_blocks.end(); ++_iter615)
      {
        xfer += oprot->writeString(_iter615->first);
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter615->second.size()));
          std::vector<io_changed_range> ::const_iterator _iter616;
          for (_iter616 = _iter615->second.begin(); _iter616 != _iter615->second.end(); ++_iter616)
          {
            xfer += (*_iter616).write(oprot);
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.disk_infos) {
    xfer += oprot->writeFieldBegin("disk_infos", ::apache::thrift::protocol::T_LIST, 8);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->disk_infos.size()));
      std::vector<virtual_disk_info_ex> ::const_iterator _iter617;
      for (_iter617 = this->disk_infos.begin(); _iter617 != this->disk_infos.end(); ++_iter617)
      {
        xfer += (*_iter617).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(virtual_packer_job_detail &a, virtual_packer_job_detail &b) {
  using ::std::swap;
  swap(a.original_size, b.original_size);
  swap(a.backup_size, b.backup_size);
  swap(a.backup_progress, b.backup_progress);
  swap(a.backup_image_offset, b.backup_image_offset);
  swap(a.change_ids, b.change_ids);
  swap(a.guest_os_type, b.guest_os_type);
  swap(a.completed_blocks, b.completed_blocks);
  swap(a.disk_infos, b.disk_infos);
  swap(a.__isset, b.__isset);
}

virtual_packer_job_detail::virtual_packer_job_detail(const virtual_packer_job_detail& other618) {
  original_size = other618.original_size;
  backup_size = other618.backup_size;
  backup_progress = other618.backup_progress;
  backup_image_offset = other618.backup_image_offset;
  change_ids = other618.change_ids;
  guest_os_type = other618.guest_os_type;
  completed_blocks = other618.completed_blocks;
  disk_infos = other618.disk_infos;
  __isset = other618.__isset;
}
virtual_packer_job_detail& virtual_packer_job_detail::operator=(const virtual_packer_job_detail& other619) {
  original_size = other619.original_size;
  backup_size = other619.backup_size;
  backup_progress = other619.backup_progress;
  backup_image_offset = other619.backup_image_offset;
  change_ids = other619.change_ids;
  guest_os_type = other619.guest_os_type;
  completed_blocks = other619.completed_blocks;
  disk_infos = other619.disk_infos;
  __isset = other619.__isset;
  return *this;
}
void virtual_packer_job_detail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "virtual_packer_job_detail(";
  out << "original_size="; (__isset.original_size ? (out << to_string(original_size)) : (out << "<null>"));
  out << ", " << "backup_size="; (__isset.backup_size ? (out << to_string(backup_size)) : (out << "<null>"));
  out << ", " << "backup_progress="; (__isset.backup_progress ? (out << to_string(backup_progress)) : (out << "<null>"));
  out << ", " << "backup_image_offset="; (__isset.backup_image_offset ? (out << to_string(backup_image_offset)) : (out << "<null>"));
  out << ", " << "change_ids="; (__isset.change_ids ? (out << to_string(change_ids)) : (out << "<null>"));
  out << ", " << "guest_os_type="; (__isset.guest_os_type ? (out << to_string(guest_os_type)) : (out << "<null>"));
  out << ", " << "completed_blocks="; (__isset.completed_blocks ? (out << to_string(completed_blocks)) : (out << "<null>"));
  out << ", " << "disk_infos="; (__isset.disk_infos ? (out << to_string(disk_infos)) : (out << "<null>"));
  out << ")";
}


physical_packer_job_detail::~physical_packer_job_detail() throw() {
}


void physical_packer_job_detail::__set_original_size(const std::map<std::string, int64_t> & val) {
  this->original_size = val;
__isset.original_size = true;
}

void physical_packer_job_detail::__set_backup_size(const std::map<std::string, int64_t> & val) {
  this->backup_size = val;
__isset.backup_size = true;
}

void physical_packer_job_detail::__set_backup_progress(const std::map<std::string, int64_t> & val) {
  this->backup_progress = val;
__isset.backup_progress = true;
}

void physical_packer_job_detail::__set_backup_image_offset(const std::map<std::string, int64_t> & val) {
  this->backup_image_offset = val;
__isset.backup_image_offset = true;
}

void physical_packer_job_detail::__set_vcbt_journals(const std::map<int64_t, physical_vcbt_journal> & val) {
  this->vcbt_journals = val;
__isset.vcbt_journals = true;
}

void physical_packer_job_detail::__set_guest_os_type(const hv_guest_os_type::type val) {
  this->guest_os_type = val;
__isset.guest_os_type = true;
}

void physical_packer_job_detail::__set_cdr_changed_ranges(const std::map<std::string, std::vector<io_changed_range> > & val) {
  this->cdr_changed_ranges = val;
__isset.cdr_changed_ranges = true;
}

void physical_packer_job_detail::__set_completed_blocks(const std::map<std::string, std::vector<io_changed_range> > & val) {
  this->completed_blocks = val;
__isset.completed_blocks = true;
}
std::ostream& operator<<(std::ostream& out, const physical_packer_job_detail& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t physical_packer_job_detail::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->original_size.clear();
            uint32_t _size620;
            ::apache::thrift::protocol::TType _ktype621;
            ::apache::thrift::protocol::TType _vtype622;
            xfer += iprot->readMapBegin(_ktype621, _vtype622, _size620);
            uint32_t _i624;
            for (_i624 = 0; _i624 < _size620; ++_i624)
            {
              std::string _key625;
              xfer += iprot->readString(_key625);
              int64_t& _val626 = this->original_size[_key625];
              xfer += iprot->readI64(_val626);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.original_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->backup_size.clear();
            uint32_t _size627;
            ::apache::thrift::protocol::TType _ktype628;
            ::apache::thrift::protocol::TType _vtype629;
            xfer += iprot->readMapBegin(_ktype628, _vtype629, _size627);
            uint32_t _i631;
            for (_i631 = 0; _i631 < _size627; ++_i631)
            {
              std::string _key632;
              xfer += iprot->readString(_key632);
              int64_t& _val633 = this->backup_size[_key632];
              xfer += iprot->readI64(_val633);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.backup_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->backup_progress.clear();
            uint32_t _size634;
            ::apache::thrift::protocol::TType _ktype635;
            ::apache::thrift::protocol::TType _vtype636;
            xfer += iprot->readMapBegin(_ktype635, _vtype636, _size634);
            uint32_t _i638;
            for (_i638 = 0; _i638 < _size634; ++_i638)
            {
              std::string _key639;
              xfer += iprot->readString(_key639);
              int64_t& _val640 = this->backup_progress[_key639];
              xfer += iprot->readI64(_val640);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.backup_progress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->backup_image_offset.clear();
            uint32_t _size641;
            ::apache::thrift::protocol::TType _ktype642;
            ::apache::thrift::protocol::TType _vtype643;
            xfer += iprot->readMapBegin(_ktype642, _vtype643, _size641);
            uint32_t _i645;
            for (_i645 = 0; _i645 < _size641; ++_i645)
            {
              std::string _key646;
              xfer += iprot->readString(_key646);
              int64_t& _val647 = this->backup_image_offset[_key646];
              xfer += iprot->readI64(_val647);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.backup_image_offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->vcbt_journals.clear();
            uint32_t _size648;
            ::apache::thrift::protocol::TType _ktype649;
            ::apache::thrift::protocol::TType _vtype650;
            xfer += iprot->readMapBegin(_ktype649, _vtype650, _size648);
            uint32_t _i652;
            for (_i652 = 0; _i652 < _size648; ++_i652)
            {
              int64_t _key653;
              xfer += iprot->readI64(_key653);
              physical_vcbt_journal& _val654 = this->vcbt_journals[_key653];
              xfer += _val654.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.vcbt_journals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast655;
          xfer += iprot->readI32(ecast655);
          this->guest_os_type = (hv_guest_os_type::type)ecast655;
          this->__isset.guest_os_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->cdr_changed_ranges.clear();
            uint32_t _size656;
            ::apache::thrift::protocol::TType _ktype657;
            ::apache::thrift::protocol::TType _vtype658;
            xfer += iprot->readMapBegin(_ktype657, _vtype658, _size656);
            uint32_t _i660;
            for (_i660 = 0; _i660 < _size656; ++_i660)
            {
              std::string _key661;
              xfer += iprot->readString(_key661);
              std::vector<io_changed_range> & _val662 = this->cdr_changed_ranges[_key661];
              {
                _val662.clear();
                uint32_t _size663;
                ::apache::thrift::protocol::TType _etype666;
                xfer += iprot->readListBegin(_etype666, _size663);
                _val662.resize(_size663);
                uint32_t _i667;
                for (_i667 = 0; _i667 < _size663; ++_i667)
                {
                  xfer += _val662[_i667].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.cdr_changed_ranges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->completed_blocks.clear();
            uint32_t _size668;
            ::apache::thrift::protocol::TType _ktype669;
            ::apache::thrift::protocol::TType _vtype670;
            xfer += iprot->readMapBegin(_ktype669, _vtype670, _size668);
            uint32_t _i672;
            for (_i672 = 0; _i672 < _size668; ++_i672)
            {
              std::string _key673;
              xfer += iprot->readString(_key673);
              std::vector<io_changed_range> & _val674 = this->completed_blocks[_key673];
              {
                _val674.clear();
                uint32_t _size675;
                ::apache::thrift::protocol::TType _etype678;
                xfer += iprot->readListBegin(_etype678, _size675);
                _val674.resize(_size675);
                uint32_t _i679;
                for (_i679 = 0; _i679 < _size675; ++_i679)
                {
                  xfer += _val674[_i679].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.completed_blocks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_job_detail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_job_detail");

  if (this->__isset.original_size) {
    xfer += oprot->writeFieldBegin("original_size", ::apache::thrift::protocol::T_MAP, 1);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->original_size.size()));
      std::map<std::string, int64_t> ::const_iterator _iter680;
      for (_iter680 = this->original_size.begin(); _iter680 != this->original_size.end(); ++_iter680)
      {
        xfer += oprot->writeString(_iter680->first);
        xfer += oprot->writeI64(_iter680->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.backup_size) {
    xfer += oprot->writeFieldBegin("backup_size", ::apache::thrift::protocol::T_MAP, 2);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->backup_size.size()));
      std::map<std::string, int64_t> ::const_iterator _iter681;
      for (_iter681 = this->backup_size.begin(); _iter681 != this->backup_size.end(); ++_iter681)
      {
        xfer += oprot->writeString(_iter681->first);
        xfer += oprot->writeI64(_iter681->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.backup_progress) {
    xfer += oprot->writeFieldBegin("backup_progress", ::apache::thrift::protocol::T_MAP, 3);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->backup_progress.size()));
      std::map<std::string, int64_t> ::const_iterator _iter682;
      for (_iter682 = this->backup_progress.begin(); _iter682 != this->backup_progress.end(); ++_iter682)
      {
        xfer += oprot->writeString(_iter682->first);
        xfer += oprot->writeI64(_iter682->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.backup_image_offset) {
    xfer += oprot->writeFieldBegin("backup_image_offset", ::apache::thrift::protocol::T_MAP, 4);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->backup_image_offset.size()));
      std::map<std::string, int64_t> ::const_iterator _iter683;
      for (_iter683 = this->backup_image_offset.begin(); _iter683 != this->backup_image_offset.end(); ++_iter683)
      {
        xfer += oprot->writeString(_iter683->first);
        xfer += oprot->writeI64(_iter683->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vcbt_journals) {
    xfer += oprot->writeFieldBegin("vcbt_journals", ::apache::thrift::protocol::T_MAP, 5);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I64, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->vcbt_journals.size()));
      std::map<int64_t, physical_vcbt_journal> ::const_iterator _iter684;
      for (_iter684 = this->vcbt_journals.begin(); _iter684 != this->vcbt_journals.end(); ++_iter684)
      {
        xfer += oprot->writeI64(_iter684->first);
        xfer += _iter684->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.guest_os_type) {
    xfer += oprot->writeFieldBegin("guest_os_type", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32((int32_t)this->guest_os_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cdr_changed_ranges) {
    xfer += oprot->writeFieldBegin("cdr_changed_ranges", ::apache::thrift::protocol::T_MAP, 7);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->cdr_changed_ranges.size()));
      std::map<std::string, std::vector<io_changed_range> > ::const_iterator _iter685;
      for (_iter685 = this->cdr_changed_ranges.begin(); _iter685 != this->cdr_changed_ranges.end(); ++_iter685)
      {
        xfer += oprot->writeString(_iter685->first);
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter685->second.size()));
          std::vector<io_changed_range> ::const_iterator _iter686;
          for (_iter686 = _iter685->second.begin(); _iter686 != _iter685->second.end(); ++_iter686)
          {
            xfer += (*_iter686).write(oprot);
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.completed_blocks) {
    xfer += oprot->writeFieldBegin("completed_blocks", ::apache::thrift::protocol::T_MAP, 8);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->completed_blocks.size()));
      std::map<std::string, std::vector<io_changed_range> > ::const_iterator _iter687;
      for (_iter687 = this->completed_blocks.begin(); _iter687 != this->completed_blocks.end(); ++_iter687)
      {
        xfer += oprot->writeString(_iter687->first);
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter687->second.size()));
          std::vector<io_changed_range> ::const_iterator _iter688;
          for (_iter688 = _iter687->second.begin(); _iter688 != _iter687->second.end(); ++_iter688)
          {
            xfer += (*_iter688).write(oprot);
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(physical_packer_job_detail &a, physical_packer_job_detail &b) {
  using ::std::swap;
  swap(a.original_size, b.original_size);
  swap(a.backup_size, b.backup_size);
  swap(a.backup_progress, b.backup_progress);
  swap(a.backup_image_offset, b.backup_image_offset);
  swap(a.vcbt_journals, b.vcbt_journals);
  swap(a.guest_os_type, b.guest_os_type);
  swap(a.cdr_changed_ranges, b.cdr_changed_ranges);
  swap(a.completed_blocks, b.completed_blocks);
  swap(a.__isset, b.__isset);
}

physical_packer_job_detail::physical_packer_job_detail(const physical_packer_job_detail& other689) {
  original_size = other689.original_size;
  backup_size = other689.backup_size;
  backup_progress = other689.backup_progress;
  backup_image_offset = other689.backup_image_offset;
  vcbt_journals = other689.vcbt_journals;
  guest_os_type = other689.guest_os_type;
  cdr_changed_ranges = other689.cdr_changed_ranges;
  completed_blocks = other689.completed_blocks;
  __isset = other689.__isset;
}
physical_packer_job_detail& physical_packer_job_detail::operator=(const physical_packer_job_detail& other690) {
  original_size = other690.original_size;
  backup_size = other690.backup_size;
  backup_progress = other690.backup_progress;
  backup_image_offset = other690.backup_image_offset;
  vcbt_journals = other690.vcbt_journals;
  guest_os_type = other690.guest_os_type;
  cdr_changed_ranges = other690.cdr_changed_ranges;
  completed_blocks = other690.completed_blocks;
  __isset = other690.__isset;
  return *this;
}
void physical_packer_job_detail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "physical_packer_job_detail(";
  out << "original_size="; (__isset.original_size ? (out << to_string(original_size)) : (out << "<null>"));
  out << ", " << "backup_size="; (__isset.backup_size ? (out << to_string(backup_size)) : (out << "<null>"));
  out << ", " << "backup_progress="; (__isset.backup_progress ? (out << to_string(backup_progress)) : (out << "<null>"));
  out << ", " << "backup_image_offset="; (__isset.backup_image_offset ? (out << to_string(backup_image_offset)) : (out << "<null>"));
  out << ", " << "vcbt_journals="; (__isset.vcbt_journals ? (out << to_string(vcbt_journals)) : (out << "<null>"));
  out << ", " << "guest_os_type="; (__isset.guest_os_type ? (out << to_string(guest_os_type)) : (out << "<null>"));
  out << ", " << "cdr_changed_ranges="; (__isset.cdr_changed_ranges ? (out << to_string(cdr_changed_ranges)) : (out << "<null>"));
  out << ", " << "completed_blocks="; (__isset.completed_blocks ? (out << to_string(completed_blocks)) : (out << "<null>"));
  out << ")";
}


_packer_job_detail::~_packer_job_detail() throw() {
}


void _packer_job_detail::__set_p(const physical_packer_job_detail& val) {
  this->p = val;
__isset.p = true;
}

void _packer_job_detail::__set_v(const virtual_packer_job_detail& val) {
  this->v = val;
__isset.v = true;
}
std::ostream& operator<<(std::ostream& out, const _packer_job_detail& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t _packer_job_detail::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->p.read(iprot);
          this->__isset.p = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->v.read(iprot);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t _packer_job_detail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("_packer_job_detail");

  if (this->__isset.p) {
    xfer += oprot->writeFieldBegin("p", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->p.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.v) {
    xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->v.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(_packer_job_detail &a, _packer_job_detail &b) {
  using ::std::swap;
  swap(a.p, b.p);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

_packer_job_detail::_packer_job_detail(const _packer_job_detail& other691) {
  p = other691.p;
  v = other691.v;
  __isset = other691.__isset;
}
_packer_job_detail& _packer_job_detail::operator=(const _packer_job_detail& other692) {
  p = other692.p;
  v = other692.v;
  __isset = other692.__isset;
  return *this;
}
void _packer_job_detail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "_packer_job_detail(";
  out << "p="; (__isset.p ? (out << to_string(p)) : (out << "<null>"));
  out << ", " << "v="; (__isset.v ? (out << to_string(v)) : (out << "<null>"));
  out << ")";
}


packer_job_detail::~packer_job_detail() throw() {
}


void packer_job_detail::__set_id(const std::string& val) {
  this->id = val;
__isset.id = true;
}

void packer_job_detail::__set_type(const job_type::type val) {
  this->type = val;
__isset.type = true;
}

void packer_job_detail::__set_state(const job_state::type val) {
  this->state = val;
__isset.state = true;
}

void packer_job_detail::__set_created_time(const std::string& val) {
  this->created_time = val;
__isset.created_time = true;
}

void packer_job_detail::__set_updated_time(const std::string& val) {
  this->updated_time = val;
__isset.updated_time = true;
}

void packer_job_detail::__set_histories(const std::vector<job_history> & val) {
  this->histories = val;
__isset.histories = true;
}

void packer_job_detail::__set_detail(const _packer_job_detail& val) {
  this->detail = val;
__isset.detail = true;
}

void packer_job_detail::__set_is_error(const bool val) {
  this->is_error = val;
__isset.is_error = true;
}

void packer_job_detail::__set_boot_disk(const std::string& val) {
  this->boot_disk = val;
__isset.boot_disk = true;
}

void packer_job_detail::__set_system_disks(const std::vector<std::string> & val) {
  this->system_disks = val;
__isset.system_disks = true;
}

void packer_job_detail::__set_completed_blocks(const std::map<std::string, std::vector<io_changed_range> > & val) {
  this->completed_blocks = val;
__isset.completed_blocks = true;
}
std::ostream& operator<<(std::ostream& out, const packer_job_detail& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t packer_job_detail::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast693;
          xfer += iprot->readI32(ecast693);
          this->type = (job_type::type)ecast693;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast694;
          xfer += iprot->readI32(ecast694);
          this->state = (job_state::type)ecast694;
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->created_time);
          this->__isset.created_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->updated_time);
          this->__isset.updated_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->histories.clear();
            uint32_t _size695;
            ::apache::thrift::protocol::TType _etype698;
            xfer += iprot->readListBegin(_etype698, _size695);
            this->histories.resize(_size695);
            uint32_t _i699;
            for (_i699 = 0; _i699 < _size695; ++_i699)
            {
              xfer += this->histories[_i699].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.histories = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->detail.read(iprot);
          this->__isset.detail = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_error);
          this->__isset.is_error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->boot_disk);
          this->__isset.boot_disk = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->system_disks.clear();
            uint32_t _size700;
            ::apache::thrift::protocol::TType _etype703;
            xfer += iprot->readListBegin(_etype703, _size700);
            this->system_disks.resize(_size700);
            uint32_t _i704;
            for (_i704 = 0; _i704 < _size700; ++_i704)
            {
              xfer += iprot->readString(this->system_disks[_i704]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.system_disks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->completed_blocks.clear();
            uint32_t _size705;
            ::apache::thrift::protocol::TType _ktype706;
            ::apache::thrift::protocol::TType _vtype707;
            xfer += iprot->readMapBegin(_ktype706, _vtype707, _size705);
            uint32_t _i709;
            for (_i709 = 0; _i709 < _size705; ++_i709)
            {
              std::string _key710;
              xfer += iprot->readString(_key710);
              std::vector<io_changed_range> & _val711 = this->completed_blocks[_key710];
              {
                _val711.clear();
                uint32_t _size712;
                ::apache::thrift::protocol::TType _etype715;
                xfer += iprot->readListBegin(_etype715, _size712);
                _val711.resize(_size712);
                uint32_t _i716;
                for (_i716 = 0; _i716 < _size712; ++_i716)
                {
                  xfer += _val711[_i716].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.completed_blocks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t packer_job_detail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("packer_job_detail");

  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.type) {
    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32((int32_t)this->type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.state) {
    xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32((int32_t)this->state);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.created_time) {
    xfer += oprot->writeFieldBegin("created_time", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->created_time);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.updated_time) {
    xfer += oprot->writeFieldBegin("updated_time", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->updated_time);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.histories) {
    xfer += oprot->writeFieldBegin("histories", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->histories.size()));
      std::vector<job_history> ::const_iterator _iter717;
      for (_iter717 = this->histories.begin(); _iter717 != this->histories.end(); ++_iter717)
      {
        xfer += (*_iter717).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.detail) {
    xfer += oprot->writeFieldBegin("detail", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->detail.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_error) {
    xfer += oprot->writeFieldBegin("is_error", ::apache::thrift::protocol::T_BOOL, 8);
    xfer += oprot->writeBool(this->is_error);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.boot_disk) {
    xfer += oprot->writeFieldBegin("boot_disk", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->boot_disk);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.system_disks) {
    xfer += oprot->writeFieldBegin("system_disks", ::apache::thrift::protocol::T_LIST, 10);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->system_disks.size()));
      std::vector<std::string> ::const_iterator _iter718;
      for (_iter718 = this->system_disks.begin(); _iter718 != this->system_disks.end(); ++_iter718)
      {
        xfer += oprot->writeString((*_iter718));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.completed_blocks) {
    xfer += oprot->writeFieldBegin("completed_blocks", ::apache::thrift::protocol::T_MAP, 11);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->completed_blocks.size()));
      std::map<std::string, std::vector<io_changed_range> > ::const_iterator _iter719;
      for (_iter719 = this->completed_blocks.begin(); _iter719 != this->completed_blocks.end(); ++_iter719)
      {
        xfer += oprot->writeString(_iter719->first);
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter719->second.size()));
          std::vector<io_changed_range> ::const_iterator _iter720;
          for (_iter720 = _iter719->second.begin(); _iter720 != _iter719->second.end(); ++_iter720)
          {
            xfer += (*_iter720).write(oprot);
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(packer_job_detail &a, packer_job_detail &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.type, b.type);
  swap(a.state, b.state);
  swap(a.created_time, b.created_time);
  swap(a.updated_time, b.updated_time);
  swap(a.histories, b.histories);
  swap(a.detail, b.detail);
  swap(a.is_error, b.is_error);
  swap(a.boot_disk, b.boot_disk);
  swap(a.system_disks, b.system_disks);
  swap(a.completed_blocks, b.completed_blocks);
  swap(a.__isset, b.__isset);
}

packer_job_detail::packer_job_detail(const packer_job_detail& other721) {
  id = other721.id;
  type = other721.type;
  state = other721.state;
  created_time = other721.created_time;
  updated_time = other721.updated_time;
  histories = other721.histories;
  detail = other721.detail;
  is_error = other721.is_error;
  boot_disk = other721.boot_disk;
  system_disks = other721.system_disks;
  completed_blocks = other721.completed_blocks;
  __isset = other721.__isset;
}
packer_job_detail& packer_job_detail::operator=(const packer_job_detail& other722) {
  id = other722.id;
  type = other722.type;
  state = other722.state;
  created_time = other722.created_time;
  updated_time = other722.updated_time;
  histories = other722.histories;
  detail = other722.detail;
  is_error = other722.is_error;
  boot_disk = other722.boot_disk;
  system_disks = other722.system_disks;
  completed_blocks = other722.completed_blocks;
  __isset = other722.__isset;
  return *this;
}
void packer_job_detail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "packer_job_detail(";
  out << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "type="; (__isset.type ? (out << to_string(type)) : (out << "<null>"));
  out << ", " << "state="; (__isset.state ? (out << to_string(state)) : (out << "<null>"));
  out << ", " << "created_time="; (__isset.created_time ? (out << to_string(created_time)) : (out << "<null>"));
  out << ", " << "updated_time="; (__isset.updated_time ? (out << to_string(updated_time)) : (out << "<null>"));
  out << ", " << "histories="; (__isset.histories ? (out << to_string(histories)) : (out << "<null>"));
  out << ", " << "detail="; (__isset.detail ? (out << to_string(detail)) : (out << "<null>"));
  out << ", " << "is_error="; (__isset.is_error ? (out << to_string(is_error)) : (out << "<null>"));
  out << ", " << "boot_disk="; (__isset.boot_disk ? (out << to_string(boot_disk)) : (out << "<null>"));
  out << ", " << "system_disks="; (__isset.system_disks ? (out << to_string(system_disks)) : (out << "<null>"));
  out << ", " << "completed_blocks="; (__isset.completed_blocks ? (out << to_string(completed_blocks)) : (out << "<null>"));
  out << ")";
}


replica_job_detail::~replica_job_detail() throw() {
}


void replica_job_detail::__set_replica_id(const std::string& val) {
  this->replica_id = val;
__isset.replica_id = true;
}

void replica_job_detail::__set_host(const std::string& val) {
  this->host = val;
__isset.host = true;
}

void replica_job_detail::__set_id(const std::string& val) {
  this->id = val;
__isset.id = true;
}

void replica_job_detail::__set_type(const job_type::type val) {
  this->type = val;
__isset.type = true;
}

void replica_job_detail::__set_state(const job_state::type val) {
  this->state = val;
__isset.state = true;
}

void replica_job_detail::__set_is_error(const bool val) {
  this->is_error = val;
__isset.is_error = true;
}

void replica_job_detail::__set_created_time(const std::string& val) {
  this->created_time = val;
__isset.created_time = true;
}

void replica_job_detail::__set_updated_time(const std::string& val) {
  this->updated_time = val;
__isset.updated_time = true;
}

void replica_job_detail::__set_virtual_machine_id(const std::string& val) {
  this->virtual_machine_id = val;
__isset.virtual_machine_id = true;
}

void replica_job_detail::__set_disks(const std::set<std::string> & val) {
  this->disks = val;
__isset.disks = true;
}

void replica_job_detail::__set_connection_id(const std::string& val) {
  this->connection_id = val;
__isset.connection_id = true;
}

void replica_job_detail::__set_original_size(const std::map<std::string, int64_t> & val) {
  this->original_size = val;
__isset.original_size = true;
}

void replica_job_detail::__set_backup_progress(const std::map<std::string, int64_t> & val) {
  this->backup_progress = val;
__isset.backup_progress = true;
}

void replica_job_detail::__set_snapshot_mapping(const std::map<std::string, std::string> & val) {
  this->snapshot_mapping = val;
__isset.snapshot_mapping = true;
}

void replica_job_detail::__set_backup_size(const std::map<std::string, int64_t> & val) {
  this->backup_size = val;
__isset.backup_size = true;
}

void replica_job_detail::__set_backup_image_offset(const std::map<std::string, int64_t> & val) {
  this->backup_image_offset = val;
__isset.backup_image_offset = true;
}

void replica_job_detail::__set_cbt_info(const std::string& val) {
  this->cbt_info = val;
__isset.cbt_info = true;
}

void replica_job_detail::__set_histories(const std::vector<job_history> & val) {
  this->histories = val;
__isset.histories = true;
}

void replica_job_detail::__set_snapshot_time(const std::string& val) {
  this->snapshot_time = val;
__isset.snapshot_time = true;
}

void replica_job_detail::__set_snapshot_info(const std::string& val) {
  this->snapshot_info = val;
__isset.snapshot_info = true;
}

void replica_job_detail::__set_boot_disk(const std::string& val) {
  this->boot_disk = val;
__isset.boot_disk = true;
}

void replica_job_detail::__set_system_disks(const std::vector<std::string> & val) {
  this->system_disks = val;
__isset.system_disks = true;
}

void replica_job_detail::__set_is_pending_rerun(const bool val) {
  this->is_pending_rerun = val;
__isset.is_pending_rerun = true;
}

void replica_job_detail::__set_is_cdr(const bool val) {
  this->is_cdr = val;
__isset.is_cdr = true;
}

void replica_job_detail::__set_virtual_disk_infos(const std::vector<virtual_disk_info_ex> & val) {
  this->virtual_disk_infos = val;
__isset.virtual_disk_infos = true;
}

void replica_job_detail::__set_excluded_paths(const std::set<std::string> & val) {
  this->excluded_paths = val;
__isset.excluded_paths = true;
}
std::ostream& operator<<(std::ostream& out, const replica_job_detail& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t replica_job_detail::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->replica_id);
          this->__isset.replica_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host);
          this->__isset.host = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast723;
          xfer += iprot->readI32(ecast723);
          this->type = (job_type::type)ecast723;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast724;
          xfer += iprot->readI32(ecast724);
          this->state = (job_state::type)ecast724;
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_error);
          this->__isset.is_error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->created_time);
          this->__isset.created_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->updated_time);
          this->__isset.updated_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->virtual_machine_id);
          this->__isset.virtual_machine_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->disks.clear();
            uint32_t _size725;
            ::apache::thrift::protocol::TType _etype728;
            xfer += iprot->readSetBegin(_etype728, _size725);
            uint32_t _i729;
            for (_i729 = 0; _i729 < _size725; ++_i729)
            {
              std::string _elem730;
              xfer += iprot->readString(_elem730);
              this->disks.insert(_elem730);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.disks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->connection_id);
          this->__isset.connection_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->original_size.clear();
            uint32_t _size731;
            ::apache::thrift::protocol::TType _ktype732;
            ::apache::thrift::protocol::TType _vtype733;
            xfer += iprot->readMapBegin(_ktype732, _vtype733, _size731);
            uint32_t _i735;
            for (_i735 = 0; _i735 < _size731; ++_i735)
            {
              std::string _key736;
              xfer += iprot->readString(_key736);
              int64_t& _val737 = this->original_size[_key736];
              xfer += iprot->readI64(_val737);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.original_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->backup_progress.clear();
            uint32_t _size738;
            ::apache::thrift::protocol::TType _ktype739;
            ::apache::thrift::protocol::TType _vtype740;
            xfer += iprot->readMapBegin(_ktype739, _vtype740, _size738);
            uint32_t _i742;
            for (_i742 = 0; _i742 < _size738; ++_i742)
            {
              std::string _key743;
              xfer += iprot->readString(_key743);
              int64_t& _val744 = this->backup_progress[_key743];
              xfer += iprot->readI64(_val744);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.backup_progress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->snapshot_mapping.clear();
            uint32_t _size745;
            ::apache::thrift::protocol::TType _ktype746;
            ::apache::thrift::protocol::TType _vtype747;
            xfer += iprot->readMapBegin(_ktype746, _vtype747, _size745);
            uint32_t _i749;
            for (_i749 = 0; _i749 < _size745; ++_i749)
            {
              std::string _key750;
              xfer += iprot->readString(_key750);
              std::string& _val751 = this->snapshot_mapping[_key750];
              xfer += iprot->readString(_val751);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.snapshot_mapping = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->backup_size.clear();
            uint32_t _size752;
            ::apache::thrift::protocol::TType _ktype753;
            ::apache::thrift::protocol::TType _vtype754;
            xfer += iprot->readMapBegin(_ktype753, _vtype754, _size752);
            uint32_t _i756;
            for (_i756 = 0; _i756 < _size752; ++_i756)
            {
              std::string _key757;
              xfer += iprot->readString(_key757);
              int64_t& _val758 = this->backup_size[_key757];
              xfer += iprot->readI64(_val758);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.backup_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->backup_image_offset.clear();
            uint32_t _size759;
            ::apache::thrift::protocol::TType _ktype760;
            ::apache::thrift::protocol::TType _vtype761;
            xfer += iprot->readMapBegin(_ktype760, _vtype761, _size759);
            uint32_t _i763;
            for (_i763 = 0; _i763 < _size759; ++_i763)
            {
              std::string _key764;
              xfer += iprot->readString(_key764);
              int64_t& _val765 = this->backup_image_offset[_key764];
              xfer += iprot->readI64(_val765);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.backup_image_offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cbt_info);
          this->__isset.cbt_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->histories.clear();
            uint32_t _size766;
            ::apache::thrift::protocol::TType _etype769;
            xfer += iprot->readListBegin(_etype769, _size766);
            this->histories.resize(_size766);
            uint32_t _i770;
            for (_i770 = 0; _i770 < _size766; ++_i770)
            {
              xfer += this->histories[_i770].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.histories = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->snapshot_time);
          this->__isset.snapshot_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->snapshot_info);
          this->__isset.snapshot_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->boot_disk);
          this->__isset.boot_disk = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->system_disks.clear();
            uint32_t _size771;
            ::apache::thrift::protocol::TType _etype774;
            xfer += iprot->readListBegin(_etype774, _size771);
            this->system_disks.resize(_size771);
            uint32_t _i775;
            for (_i775 = 0; _i775 < _size771; ++_i775)
            {
              xfer += iprot->readString(this->system_disks[_i775]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.system_disks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_pending_rerun);
          this->__isset.is_pending_rerun = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_cdr);
          this->__isset.is_cdr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->virtual_disk_infos.clear();
            uint32_t _size776;
            ::apache::thrift::protocol::TType _etype779;
            xfer += iprot->readListBegin(_etype779, _size776);
            this->virtual_disk_infos.resize(_size776);
            uint32_t _i780;
            for (_i780 = 0; _i780 < _size776; ++_i780)
            {
              xfer += this->virtual_disk_infos[_i780].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.virtual_disk_infos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 26:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->excluded_paths.clear();
            uint32_t _size781;
            ::apache::thrift::protocol::TType _etype784;
            xfer += iprot->readSetBegin(_etype784, _size781);
            uint32_t _i785;
            for (_i785 = 0; _i785 < _size781; ++_i785)
            {
              std::string _elem786;
              xfer += iprot->readString(_elem786);
              this->excluded_paths.insert(_elem786);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.excluded_paths = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t replica_job_detail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("replica_job_detail");

  if (this->__isset.replica_id) {
    xfer += oprot->writeFieldBegin("replica_id", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->replica_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.host) {
    xfer += oprot->writeFieldBegin("host", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->host);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.type) {
    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32((int32_t)this->type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.state) {
    xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32((int32_t)this->state);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_error) {
    xfer += oprot->writeFieldBegin("is_error", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->is_error);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.created_time) {
    xfer += oprot->writeFieldBegin("created_time", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->created_time);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.updated_time) {
    xfer += oprot->writeFieldBegin("updated_time", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->updated_time);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.virtual_machine_id) {
    xfer += oprot->writeFieldBegin("virtual_machine_id", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->virtual_machine_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.disks) {
    xfer += oprot->writeFieldBegin("disks", ::apache::thrift::protocol::T_SET, 10);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->disks.size()));
      std::set<std::string> ::const_iterator _iter787;
      for (_iter787 = this->disks.begin(); _iter787 != this->disks.end(); ++_iter787)
      {
        xfer += oprot->writeString((*_iter787));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.connection_id) {
    xfer += oprot->writeFieldBegin("connection_id", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeString(this->connection_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.original_size) {
    xfer += oprot->writeFieldBegin("original_size", ::apache::thrift::protocol::T_MAP, 12);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->original_size.size()));
      std::map<std::string, int64_t> ::const_iterator _iter788;
      for (_iter788 = this->original_size.begin(); _iter788 != this->original_size.end(); ++_iter788)
      {
        xfer += oprot->writeString(_iter788->first);
        xfer += oprot->writeI64(_iter788->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.backup_progress) {
    xfer += oprot->writeFieldBegin("backup_progress", ::apache::thrift::protocol::T_MAP, 13);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->backup_progress.size()));
      std::map<std::string, int64_t> ::const_iterator _iter789;
      for (_iter789 = this->backup_progress.begin(); _iter789 != this->backup_progress.end(); ++_iter789)
      {
        xfer += oprot->writeString(_iter789->first);
        xfer += oprot->writeI64(_iter789->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.snapshot_mapping) {
    xfer += oprot->writeFieldBegin("snapshot_mapping", ::apache::thrift::protocol::T_MAP, 14);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->snapshot_mapping.size()));
      std::map<std::string, std::string> ::const_iterator _iter790;
      for (_iter790 = this->snapshot_mapping.begin(); _iter790 != this->snapshot_mapping.end(); ++_iter790)
      {
        xfer += oprot->writeString(_iter790->first);
        xfer += oprot->writeString(_iter790->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.backup_size) {
    xfer += oprot->writeFieldBegin("backup_size", ::apache::thrift::protocol::T_MAP, 15);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->backup_size.size()));
      std::map<std::string, int64_t> ::const_iterator _iter791;
      for (_iter791 = this->backup_size.begin(); _iter791 != this->backup_size.end(); ++_iter791)
      {
        xfer += oprot->writeString(_iter791->first);
        xfer += oprot->writeI64(_iter791->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.backup_image_offset) {
    xfer += oprot->writeFieldBegin("backup_image_offset", ::apache::thrift::protocol::T_MAP, 16);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->backup_image_offset.size()));
      std::map<std::string, int64_t> ::const_iterator _iter792;
      for (_iter792 = this->backup_image_offset.begin(); _iter792 != this->backup_image_offset.end(); ++_iter792)
      {
        xfer += oprot->writeString(_iter792->first);
        xfer += oprot->writeI64(_iter792->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cbt_info) {
    xfer += oprot->writeFieldBegin("cbt_info", ::apache::thrift::protocol::T_STRING, 17);
    xfer += oprot->writeString(this->cbt_info);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.histories) {
    xfer += oprot->writeFieldBegin("histories", ::apache::thrift::protocol::T_LIST, 18);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->histories.size()));
      std::vector<job_history> ::const_iterator _iter793;
      for (_iter793 = this->histories.begin(); _iter793 != this->histories.end(); ++_iter793)
      {
        xfer += (*_iter793).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.snapshot_time) {
    xfer += oprot->writeFieldBegin("snapshot_time", ::apache::thrift::protocol::T_STRING, 19);
    xfer += oprot->writeString(this->snapshot_time);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.snapshot_info) {
    xfer += oprot->writeFieldBegin("snapshot_info", ::apache::thrift::protocol::T_STRING, 20);
    xfer += oprot->writeString(this->snapshot_info);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.boot_disk) {
    xfer += oprot->writeFieldBegin("boot_disk", ::apache::thrift::protocol::T_STRING, 21);
    xfer += oprot->writeString(this->boot_disk);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.system_disks) {
    xfer += oprot->writeFieldBegin("system_disks", ::apache::thrift::protocol::T_LIST, 22);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->system_disks.size()));
      std::vector<std::string> ::const_iterator _iter794;
      for (_iter794 = this->system_disks.begin(); _iter794 != this->system_disks.end(); ++_iter794)
      {
        xfer += oprot->writeString((*_iter794));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_pending_rerun) {
    xfer += oprot->writeFieldBegin("is_pending_rerun", ::apache::thrift::protocol::T_BOOL, 23);
    xfer += oprot->writeBool(this->is_pending_rerun);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_cdr) {
    xfer += oprot->writeFieldBegin("is_cdr", ::apache::thrift::protocol::T_BOOL, 24);
    xfer += oprot->writeBool(this->is_cdr);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.virtual_disk_infos) {
    xfer += oprot->writeFieldBegin("virtual_disk_infos", ::apache::thrift::protocol::T_LIST, 25);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->virtual_disk_infos.size()));
      std::vector<virtual_disk_info_ex> ::const_iterator _iter795;
      for (_iter795 = this->virtual_disk_infos.begin(); _iter795 != this->virtual_disk_infos.end(); ++_iter795)
      {
        xfer += (*_iter795).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.excluded_paths) {
    xfer += oprot->writeFieldBegin("excluded_paths", ::apache::thrift::protocol::T_SET, 26);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->excluded_paths.size()));
      std::set<std::string> ::const_iterator _iter796;
      for (_iter796 = this->excluded_paths.begin(); _iter796 != this->excluded_paths.end(); ++_iter796)
      {
        xfer += oprot->writeString((*_iter796));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(replica_job_detail &a, replica_job_detail &b) {
  using ::std::swap;
  swap(a.replica_id, b.replica_id);
  swap(a.host, b.host);
  swap(a.id, b.id);
  swap(a.type, b.type);
  swap(a.state, b.state);
  swap(a.is_error, b.is_error);
  swap(a.created_time, b.created_time);
  swap(a.updated_time, b.updated_time);
  swap(a.virtual_machine_id, b.virtual_machine_id);
  swap(a.disks, b.disks);
  swap(a.connection_id, b.connection_id);
  swap(a.original_size, b.original_size);
  swap(a.backup_progress, b.backup_progress);
  swap(a.snapshot_mapping, b.snapshot_mapping);
  swap(a.backup_size, b.backup_size);
  swap(a.backup_image_offset, b.backup_image_offset);
  swap(a.cbt_info, b.cbt_info);
  swap(a.histories, b.histories);
  swap(a.snapshot_time, b.snapshot_time);
  swap(a.snapshot_info, b.snapshot_info);
  swap(a.boot_disk, b.boot_disk);
  swap(a.system_disks, b.system_disks);
  swap(a.is_pending_rerun, b.is_pending_rerun);
  swap(a.is_cdr, b.is_cdr);
  swap(a.virtual_disk_infos, b.virtual_disk_infos);
  swap(a.excluded_paths, b.excluded_paths);
  swap(a.__isset, b.__isset);
}

replica_job_detail::replica_job_detail(const replica_job_detail& other797) {
  replica_id = other797.replica_id;
  host = other797.host;
  id = other797.id;
  type = other797.type;
  state = other797.state;
  is_error = other797.is_error;
  created_time = other797.created_time;
  updated_time = other797.updated_time;
  virtual_machine_id = other797.virtual_machine_id;
  disks = other797.disks;
  connection_id = other797.connection_id;
  original_size = other797.original_size;
  backup_progress = other797.backup_progress;
  snapshot_mapping = other797.snapshot_mapping;
  backup_size = other797.backup_size;
  backup_image_offset = other797.backup_image_offset;
  cbt_info = other797.cbt_info;
  histories = other797.histories;
  snapshot_time = other797.snapshot_time;
  snapshot_info = other797.snapshot_info;
  boot_disk = other797.boot_disk;
  system_disks = other797.system_disks;
  is_pending_rerun = other797.is_pending_rerun;
  is_cdr = other797.is_cdr;
  virtual_disk_infos = other797.virtual_disk_infos;
  excluded_paths = other797.excluded_paths;
  __isset = other797.__isset;
}
replica_job_detail& replica_job_detail::operator=(const replica_job_detail& other798) {
  replica_id = other798.replica_id;
  host = other798.host;
  id = other798.id;
  type = other798.type;
  state = other798.state;
  is_error = other798.is_error;
  created_time = other798.created_time;
  updated_time = other798.updated_time;
  virtual_machine_id = other798.virtual_machine_id;
  disks = other798.disks;
  connection_id = other798.connection_id;
  original_size = other798.original_size;
  backup_progress = other798.backup_progress;
  snapshot_mapping = other798.snapshot_mapping;
  backup_size = other798.backup_size;
  backup_image_offset = other798.backup_image_offset;
  cbt_info = other798.cbt_info;
  histories = other798.histories;
  snapshot_time = other798.snapshot_time;
  snapshot_info = other798.snapshot_info;
  boot_disk = other798.boot_disk;
  system_disks = other798.system_disks;
  is_pending_rerun = other798.is_pending_rerun;
  is_cdr = other798.is_cdr;
  virtual_disk_infos = other798.virtual_disk_infos;
  excluded_paths = other798.excluded_paths;
  __isset = other798.__isset;
  return *this;
}
void replica_job_detail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "replica_job_detail(";
  out << "replica_id="; (__isset.replica_id ? (out << to_string(replica_id)) : (out << "<null>"));
  out << ", " << "host="; (__isset.host ? (out << to_string(host)) : (out << "<null>"));
  out << ", " << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "type="; (__isset.type ? (out << to_string(type)) : (out << "<null>"));
  out << ", " << "state="; (__isset.state ? (out << to_string(state)) : (out << "<null>"));
  out << ", " << "is_error="; (__isset.is_error ? (out << to_string(is_error)) : (out << "<null>"));
  out << ", " << "created_time="; (__isset.created_time ? (out << to_string(created_time)) : (out << "<null>"));
  out << ", " << "updated_time="; (__isset.updated_time ? (out << to_string(updated_time)) : (out << "<null>"));
  out << ", " << "virtual_machine_id="; (__isset.virtual_machine_id ? (out << to_string(virtual_machine_id)) : (out << "<null>"));
  out << ", " << "disks="; (__isset.disks ? (out << to_string(disks)) : (out << "<null>"));
  out << ", " << "connection_id="; (__isset.connection_id ? (out << to_string(connection_id)) : (out << "<null>"));
  out << ", " << "original_size="; (__isset.original_size ? (out << to_string(original_size)) : (out << "<null>"));
  out << ", " << "backup_progress="; (__isset.backup_progress ? (out << to_string(backup_progress)) : (out << "<null>"));
  out << ", " << "snapshot_mapping="; (__isset.snapshot_mapping ? (out << to_string(snapshot_mapping)) : (out << "<null>"));
  out << ", " << "backup_size="; (__isset.backup_size ? (out << to_string(backup_size)) : (out << "<null>"));
  out << ", " << "backup_image_offset="; (__isset.backup_image_offset ? (out << to_string(backup_image_offset)) : (out << "<null>"));
  out << ", " << "cbt_info="; (__isset.cbt_info ? (out << to_string(cbt_info)) : (out << "<null>"));
  out << ", " << "histories="; (__isset.histories ? (out << to_string(histories)) : (out << "<null>"));
  out << ", " << "snapshot_time="; (__isset.snapshot_time ? (out << to_string(snapshot_time)) : (out << "<null>"));
  out << ", " << "snapshot_info="; (__isset.snapshot_info ? (out << to_string(snapshot_info)) : (out << "<null>"));
  out << ", " << "boot_disk="; (__isset.boot_disk ? (out << to_string(boot_disk)) : (out << "<null>"));
  out << ", " << "system_disks="; (__isset.system_disks ? (out << to_string(system_disks)) : (out << "<null>"));
  out << ", " << "is_pending_rerun="; (__isset.is_pending_rerun ? (out << to_string(is_pending_rerun)) : (out << "<null>"));
  out << ", " << "is_cdr="; (__isset.is_cdr ? (out << to_string(is_cdr)) : (out << "<null>"));
  out << ", " << "virtual_disk_infos="; (__isset.virtual_disk_infos ? (out << to_string(virtual_disk_infos)) : (out << "<null>"));
  out << ", " << "excluded_paths="; (__isset.excluded_paths ? (out << to_string(excluded_paths)) : (out << "<null>"));
  out << ")";
}


service_info::~service_info() throw() {
}


void service_info::__set_id(const std::string& val) {
  this->id = val;
}

void service_info::__set_version(const std::string& val) {
  this->version = val;
}

void service_info::__set_path(const std::string& val) {
  this->path = val;
}
std::ostream& operator<<(std::ostream& out, const service_info& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t service_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->path);
          this->__isset.path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t service_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("service_info");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(service_info &a, service_info &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.version, b.version);
  swap(a.path, b.path);
  swap(a.__isset, b.__isset);
}

service_info::service_info(const service_info& other799) {
  id = other799.id;
  version = other799.version;
  path = other799.path;
  __isset = other799.__isset;
}
service_info& service_info::operator=(const service_info& other800) {
  id = other800.id;
  version = other800.version;
  path = other800.path;
  __isset = other800.__isset;
  return *this;
}
void service_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "service_info(";
  out << "id=" << to_string(id);
  out << ", " << "version=" << to_string(version);
  out << ", " << "path=" << to_string(path);
  out << ")";
}


vmware_snapshot::~vmware_snapshot() throw() {
}


void vmware_snapshot::__set_id(const std::string& val) {
  this->id = val;
__isset.id = true;
}

void vmware_snapshot::__set_name(const std::string& val) {
  this->name = val;
__isset.name = true;
}

void vmware_snapshot::__set_datetime(const std::string& val) {
  this->datetime = val;
__isset.datetime = true;
}
std::ostream& operator<<(std::ostream& out, const vmware_snapshot& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t vmware_snapshot::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->datetime);
          this->__isset.datetime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t vmware_snapshot::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("vmware_snapshot");

  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.datetime) {
    xfer += oprot->writeFieldBegin("datetime", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->datetime);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(vmware_snapshot &a, vmware_snapshot &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.name, b.name);
  swap(a.datetime, b.datetime);
  swap(a.__isset, b.__isset);
}

vmware_snapshot::vmware_snapshot(const vmware_snapshot& other801) {
  id = other801.id;
  name = other801.name;
  datetime = other801.datetime;
  __isset = other801.__isset;
}
vmware_snapshot& vmware_snapshot::operator=(const vmware_snapshot& other802) {
  id = other802.id;
  name = other802.name;
  datetime = other802.datetime;
  __isset = other802.__isset;
  return *this;
}
void vmware_snapshot::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "vmware_snapshot(";
  out << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
  out << ", " << "datetime="; (__isset.datetime ? (out << to_string(datetime)) : (out << "<null>"));
  out << ")";
}


take_snapshots_parameters::~take_snapshots_parameters() throw() {
}


void take_snapshots_parameters::__set_disks(const std::set<std::string> & val) {
  this->disks = val;
}

void take_snapshots_parameters::__set_pre_script(const std::string& val) {
  this->pre_script = val;
}

void take_snapshots_parameters::__set_post_script(const std::string& val) {
  this->post_script = val;
}

void take_snapshots_parameters::__set_excluded_paths(const std::set<std::string> & val) {
  this->excluded_paths = val;
}
std::ostream& operator<<(std::ostream& out, const take_snapshots_parameters& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t take_snapshots_parameters::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->disks.clear();
            uint32_t _size803;
            ::apache::thrift::protocol::TType _etype806;
            xfer += iprot->readSetBegin(_etype806, _size803);
            uint32_t _i807;
            for (_i807 = 0; _i807 < _size803; ++_i807)
            {
              std::string _elem808;
              xfer += iprot->readString(_elem808);
              this->disks.insert(_elem808);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.disks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pre_script);
          this->__isset.pre_script = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->post_script);
          this->__isset.post_script = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->excluded_paths.clear();
            uint32_t _size809;
            ::apache::thrift::protocol::TType _etype812;
            xfer += iprot->readSetBegin(_etype812, _size809);
            uint32_t _i813;
            for (_i813 = 0; _i813 < _size809; ++_i813)
            {
              std::string _elem814;
              xfer += iprot->readString(_elem814);
              this->excluded_paths.insert(_elem814);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.excluded_paths = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t take_snapshots_parameters::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("take_snapshots_parameters");

  xfer += oprot->writeFieldBegin("disks", ::apache::thrift::protocol::T_SET, 1);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->disks.size()));
    std::set<std::string> ::const_iterator _iter815;
    for (_iter815 = this->disks.begin(); _iter815 != this->disks.end(); ++_iter815)
    {
      xfer += oprot->writeString((*_iter815));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pre_script", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->pre_script);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("post_script", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->post_script);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("excluded_paths", ::apache::thrift::protocol::T_SET, 4);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->excluded_paths.size()));
    std::set<std::string> ::const_iterator _iter816;
    for (_iter816 = this->excluded_paths.begin(); _iter816 != this->excluded_paths.end(); ++_iter816)
    {
      xfer += oprot->writeString((*_iter816));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(take_snapshots_parameters &a, take_snapshots_parameters &b) {
  using ::std::swap;
  swap(a.disks, b.disks);
  swap(a.pre_script, b.pre_script);
  swap(a.post_script, b.post_script);
  swap(a.excluded_paths, b.excluded_paths);
  swap(a.__isset, b.__isset);
}

take_snapshots_parameters::take_snapshots_parameters(const take_snapshots_parameters& other817) {
  disks = other817.disks;
  pre_script = other817.pre_script;
  post_script = other817.post_script;
  excluded_paths = other817.excluded_paths;
  __isset = other817.__isset;
}
take_snapshots_parameters& take_snapshots_parameters::operator=(const take_snapshots_parameters& other818) {
  disks = other818.disks;
  pre_script = other818.pre_script;
  post_script = other818.post_script;
  excluded_paths = other818.excluded_paths;
  __isset = other818.__isset;
  return *this;
}
void take_snapshots_parameters::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "take_snapshots_parameters(";
  out << "disks=" << to_string(disks);
  out << ", " << "pre_script=" << to_string(pre_script);
  out << ", " << "post_script=" << to_string(post_script);
  out << ", " << "excluded_paths=" << to_string(excluded_paths);
  out << ")";
}


local_folder::~local_folder() throw() {
}


void local_folder::__set_path(const std::string& val) {
  this->path = val;
__isset.path = true;
}
std::ostream& operator<<(std::ostream& out, const local_folder& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t local_folder::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->path);
          this->__isset.path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t local_folder::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("local_folder");

  if (this->__isset.path) {
    xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->path);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(local_folder &a, local_folder &b) {
  using ::std::swap;
  swap(a.path, b.path);
  swap(a.__isset, b.__isset);
}

local_folder::local_folder(const local_folder& other819) {
  path = other819.path;
  __isset = other819.__isset;
}
local_folder& local_folder::operator=(const local_folder& other820) {
  path = other820.path;
  __isset = other820.__isset;
  return *this;
}
void local_folder::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "local_folder(";
  out << "path="; (__isset.path ? (out << to_string(path)) : (out << "<null>"));
  out << ")";
}


network_folder::~network_folder() throw() {
}


void network_folder::__set_path(const std::string& val) {
  this->path = val;
__isset.path = true;
}

void network_folder::__set_username(const std::string& val) {
  this->username = val;
__isset.username = true;
}

void network_folder::__set_password(const std::string& val) {
  this->password = val;
__isset.password = true;
}

void network_folder::__set_port(const int32_t val) {
  this->port = val;
__isset.port = true;
}

void network_folder::__set_proxy_host(const std::string& val) {
  this->proxy_host = val;
__isset.proxy_host = true;
}

void network_folder::__set_proxy_port(const int32_t val) {
  this->proxy_port = val;
__isset.proxy_port = true;
}

void network_folder::__set_proxy_username(const std::string& val) {
  this->proxy_username = val;
__isset.proxy_username = true;
}

void network_folder::__set_proxy_password(const std::string& val) {
  this->proxy_password = val;
__isset.proxy_password = true;
}

void network_folder::__set_s3_region(const aws_region::type val) {
  this->s3_region = val;
__isset.s3_region = true;
}

void network_folder::__set_timeout(const int32_t val) {
  this->timeout = val;
__isset.timeout = true;
}
std::ostream& operator<<(std::ostream& out, const network_folder& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t network_folder::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->path);
          this->__isset.path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->username);
          this->__isset.username = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->password);
          this->__isset.password = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->port);
          this->__isset.port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->proxy_host);
          this->__isset.proxy_host = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->proxy_port);
          this->__isset.proxy_port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->proxy_username);
          this->__isset.proxy_username = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->proxy_password);
          this->__isset.proxy_password = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast821;
          xfer += iprot->readI32(ecast821);
          this->s3_region = (aws_region::type)ecast821;
          this->__isset.s3_region = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->timeout);
          this->__isset.timeout = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t network_folder::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("network_folder");

  if (this->__isset.path) {
    xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->path);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.username) {
    xfer += oprot->writeFieldBegin("username", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->username);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.password) {
    xfer += oprot->writeFieldBegin("password", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->password);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.port) {
    xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->port);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.proxy_host) {
    xfer += oprot->writeFieldBegin("proxy_host", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->proxy_host);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.proxy_port) {
    xfer += oprot->writeFieldBegin("proxy_port", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(this->proxy_port);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.proxy_username) {
    xfer += oprot->writeFieldBegin("proxy_username", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->proxy_username);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.proxy_password) {
    xfer += oprot->writeFieldBegin("proxy_password", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->proxy_password);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.s3_region) {
    xfer += oprot->writeFieldBegin("s3_region", ::apache::thrift::protocol::T_I32, 9);
    xfer += oprot->writeI32((int32_t)this->s3_region);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timeout) {
    xfer += oprot->writeFieldBegin("timeout", ::apache::thrift::protocol::T_I32, 10);
    xfer += oprot->writeI32(this->timeout);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(network_folder &a, network_folder &b) {
  using ::std::swap;
  swap(a.path, b.path);
  swap(a.username, b.username);
  swap(a.password, b.password);
  swap(a.port, b.port);
  swap(a.proxy_host, b.proxy_host);
  swap(a.proxy_port, b.proxy_port);
  swap(a.proxy_username, b.proxy_username);
  swap(a.proxy_password, b.proxy_password);
  swap(a.s3_region, b.s3_region);
  swap(a.timeout, b.timeout);
  swap(a.__isset, b.__isset);
}

network_folder::network_folder(const network_folder& other822) {
  path = other822.path;
  username = other822.username;
  password = other822.password;
  port = other822.port;
  proxy_host = other822.proxy_host;
  proxy_port = other822.proxy_port;
  proxy_username = other822.proxy_username;
  proxy_password = other822.proxy_password;
  s3_region = other822.s3_region;
  timeout = other822.timeout;
  __isset = other822.__isset;
}
network_folder& network_folder::operator=(const network_folder& other823) {
  path = other823.path;
  username = other823.username;
  password = other823.password;
  port = other823.port;
  proxy_host = other823.proxy_host;
  proxy_port = other823.proxy_port;
  proxy_username = other823.proxy_username;
  proxy_password = other823.proxy_password;
  s3_region = other823.s3_region;
  timeout = other823.timeout;
  __isset = other823.__isset;
  return *this;
}
void network_folder::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "network_folder(";
  out << "path="; (__isset.path ? (out << to_string(path)) : (out << "<null>"));
  out << ", " << "username="; (__isset.username ? (out << to_string(username)) : (out << "<null>"));
  out << ", " << "password="; (__isset.password ? (out << to_string(password)) : (out << "<null>"));
  out << ", " << "port="; (__isset.port ? (out << to_string(port)) : (out << "<null>"));
  out << ", " << "proxy_host="; (__isset.proxy_host ? (out << to_string(proxy_host)) : (out << "<null>"));
  out << ", " << "proxy_port="; (__isset.proxy_port ? (out << to_string(proxy_port)) : (out << "<null>"));
  out << ", " << "proxy_username="; (__isset.proxy_username ? (out << to_string(proxy_username)) : (out << "<null>"));
  out << ", " << "proxy_password="; (__isset.proxy_password ? (out << to_string(proxy_password)) : (out << "<null>"));
  out << ", " << "s3_region="; (__isset.s3_region ? (out << to_string(s3_region)) : (out << "<null>"));
  out << ", " << "timeout="; (__isset.timeout ? (out << to_string(timeout)) : (out << "<null>"));
  out << ")";
}


_detail::~_detail() throw() {
}


void _detail::__set_local(const local_folder& val) {
  this->local = val;
}

void _detail::__set_remote(const network_folder& val) {
  this->remote = val;
}
std::ostream& operator<<(std::ostream& out, const _detail& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t _detail::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->local.read(iprot);
          this->__isset.local = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->remote.read(iprot);
          this->__isset.remote = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t _detail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("_detail");

  xfer += oprot->writeFieldBegin("local", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->local.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("remote", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->remote.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(_detail &a, _detail &b) {
  using ::std::swap;
  swap(a.local, b.local);
  swap(a.remote, b.remote);
  swap(a.__isset, b.__isset);
}

_detail::_detail(const _detail& other824) {
  local = other824.local;
  remote = other824.remote;
  __isset = other824.__isset;
}
_detail& _detail::operator=(const _detail& other825) {
  local = other825.local;
  remote = other825.remote;
  __isset = other825.__isset;
  return *this;
}
void _detail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "_detail(";
  out << "local=" << to_string(local);
  out << ", " << "remote=" << to_string(remote);
  out << ")";
}


connection::~connection() throw() {
}


void connection::__set_type(const connection_type::type val) {
  this->type = val;
__isset.type = true;
}

void connection::__set_id(const std::string& val) {
  this->id = val;
__isset.id = true;
}

void connection::__set_options(const std::map<std::string, std::string> & val) {
  this->options = val;
__isset.options = true;
}

void connection::__set_compressed(const bool val) {
  this->compressed = val;
__isset.compressed = true;
}

void connection::__set_checksum(const bool val) {
  this->checksum = val;
__isset.checksum = true;
}

void connection::__set_encrypted(const bool val) {
  this->encrypted = val;
__isset.encrypted = true;
}

void connection::__set_detail(const _detail& val) {
  this->detail = val;
__isset.detail = true;
}
std::ostream& operator<<(std::ostream& out, const connection& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t connection::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast826;
          xfer += iprot->readI32(ecast826);
          this->type = (connection_type::type)ecast826;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->options.clear();
            uint32_t _size827;
            ::apache::thrift::protocol::TType _ktype828;
            ::apache::thrift::protocol::TType _vtype829;
            xfer += iprot->readMapBegin(_ktype828, _vtype829, _size827);
            uint32_t _i831;
            for (_i831 = 0; _i831 < _size827; ++_i831)
            {
              std::string _key832;
              xfer += iprot->readString(_key832);
              std::string& _val833 = this->options[_key832];
              xfer += iprot->readString(_val833);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->compressed);
          this->__isset.compressed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->checksum);
          this->__isset.checksum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->encrypted);
          this->__isset.encrypted = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->detail.read(iprot);
          this->__isset.detail = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t connection::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("connection");

  if (this->__isset.type) {
    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32((int32_t)this->type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.options) {
    xfer += oprot->writeFieldBegin("options", ::apache::thrift::protocol::T_MAP, 3);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->options.size()));
      std::map<std::string, std::string> ::const_iterator _iter834;
      for (_iter834 = this->options.begin(); _iter834 != this->options.end(); ++_iter834)
      {
        xfer += oprot->writeString(_iter834->first);
        xfer += oprot->writeString(_iter834->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.compressed) {
    xfer += oprot->writeFieldBegin("compressed", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->compressed);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.checksum) {
    xfer += oprot->writeFieldBegin("checksum", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->checksum);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.encrypted) {
    xfer += oprot->writeFieldBegin("encrypted", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->encrypted);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.detail) {
    xfer += oprot->writeFieldBegin("detail", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->detail.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(connection &a, connection &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.id, b.id);
  swap(a.options, b.options);
  swap(a.compressed, b.compressed);
  swap(a.checksum, b.checksum);
  swap(a.encrypted, b.encrypted);
  swap(a.detail, b.detail);
  swap(a.__isset, b.__isset);
}

connection::connection(const connection& other835) {
  type = other835.type;
  id = other835.id;
  options = other835.options;
  compressed = other835.compressed;
  checksum = other835.checksum;
  encrypted = other835.encrypted;
  detail = other835.detail;
  __isset = other835.__isset;
}
connection& connection::operator=(const connection& other836) {
  type = other836.type;
  id = other836.id;
  options = other836.options;
  compressed = other836.compressed;
  checksum = other836.checksum;
  encrypted = other836.encrypted;
  detail = other836.detail;
  __isset = other836.__isset;
  return *this;
}
void connection::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "connection(";
  out << "type="; (__isset.type ? (out << to_string(type)) : (out << "<null>"));
  out << ", " << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "options="; (__isset.options ? (out << to_string(options)) : (out << "<null>"));
  out << ", " << "compressed="; (__isset.compressed ? (out << to_string(compressed)) : (out << "<null>"));
  out << ", " << "checksum="; (__isset.checksum ? (out << to_string(checksum)) : (out << "<null>"));
  out << ", " << "encrypted="; (__isset.encrypted ? (out << to_string(encrypted)) : (out << "<null>"));
  out << ", " << "detail="; (__isset.detail ? (out << to_string(detail)) : (out << "<null>"));
  out << ")";
}


image_map_info::~image_map_info() throw() {
}


void image_map_info::__set_image(const std::string& val) {
  this->image = val;
__isset.image = true;
}

void image_map_info::__set_base_image(const std::string& val) {
  this->base_image = val;
__isset.base_image = true;
}

void image_map_info::__set_connection_ids(const std::set<std::string> & val) {
  this->connection_ids = val;
__isset.connection_ids = true;
}
std::ostream& operator<<(std::ostream& out, const image_map_info& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t image_map_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->image);
          this->__isset.image = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->base_image);
          this->__isset.base_image = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->connection_ids.clear();
            uint32_t _size837;
            ::apache::thrift::protocol::TType _etype840;
            xfer += iprot->readSetBegin(_etype840, _size837);
            uint32_t _i841;
            for (_i841 = 0; _i841 < _size837; ++_i841)
            {
              std::string _elem842;
              xfer += iprot->readString(_elem842);
              this->connection_ids.insert(_elem842);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.connection_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t image_map_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("image_map_info");

  if (this->__isset.image) {
    xfer += oprot->writeFieldBegin("image", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->image);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.base_image) {
    xfer += oprot->writeFieldBegin("base_image", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->base_image);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.connection_ids) {
    xfer += oprot->writeFieldBegin("connection_ids", ::apache::thrift::protocol::T_SET, 3);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->connection_ids.size()));
      std::set<std::string> ::const_iterator _iter843;
      for (_iter843 = this->connection_ids.begin(); _iter843 != this->connection_ids.end(); ++_iter843)
      {
        xfer += oprot->writeString((*_iter843));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(image_map_info &a, image_map_info &b) {
  using ::std::swap;
  swap(a.image, b.image);
  swap(a.base_image, b.base_image);
  swap(a.connection_ids, b.connection_ids);
  swap(a.__isset, b.__isset);
}

image_map_info::image_map_info(const image_map_info& other844) {
  image = other844.image;
  base_image = other844.base_image;
  connection_ids = other844.connection_ids;
  __isset = other844.__isset;
}
image_map_info& image_map_info::operator=(const image_map_info& other845) {
  image = other845.image;
  base_image = other845.base_image;
  connection_ids = other845.connection_ids;
  __isset = other845.__isset;
  return *this;
}
void image_map_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "image_map_info(";
  out << "image="; (__isset.image ? (out << to_string(image)) : (out << "<null>"));
  out << ", " << "base_image="; (__isset.base_image ? (out << to_string(base_image)) : (out << "<null>"));
  out << ", " << "connection_ids="; (__isset.connection_ids ? (out << to_string(connection_ids)) : (out << "<null>"));
  out << ")";
}


create_image_info::~create_image_info() throw() {
}


void create_image_info::__set_name(const std::string& val) {
  this->name = val;
__isset.name = true;
}

void create_image_info::__set_base(const std::string& val) {
  this->base = val;
__isset.base = true;
}

void create_image_info::__set_parent(const std::string& val) {
  this->parent = val;
__isset.parent = true;
}

void create_image_info::__set_connection_ids(const std::set<std::string> & val) {
  this->connection_ids = val;
__isset.connection_ids = true;
}

void create_image_info::__set_size(const int64_t val) {
  this->size = val;
__isset.size = true;
}

void create_image_info::__set_block_size(const int32_t val) {
  this->block_size = val;
__isset.block_size = true;
}

void create_image_info::__set_checksum_verify(const bool val) {
  this->checksum_verify = val;
__isset.checksum_verify = true;
}

void create_image_info::__set_comment(const std::string& val) {
  this->comment = val;
__isset.comment = true;
}

void create_image_info::__set_version(const create_image_option::type val) {
  this->version = val;
__isset.version = true;
}

void create_image_info::__set_compressed(const bool val) {
  this->compressed = val;
__isset.compressed = true;
}

void create_image_info::__set_checksum(const bool val) {
  this->checksum = val;
__isset.checksum = true;
}

void create_image_info::__set_cdr(const bool val) {
  this->cdr = val;
__isset.cdr = true;
}

void create_image_info::__set_mode(const int8_t val) {
  this->mode = val;
__isset.mode = true;
}
std::ostream& operator<<(std::ostream& out, const create_image_info& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t create_image_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->base);
          this->__isset.base = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->parent);
          this->__isset.parent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->connection_ids.clear();
            uint32_t _size846;
            ::apache::thrift::protocol::TType _etype849;
            xfer += iprot->readSetBegin(_etype849, _size846);
            uint32_t _i850;
            for (_i850 = 0; _i850 < _size846; ++_i850)
            {
              std::string _elem851;
              xfer += iprot->readString(_elem851);
              this->connection_ids.insert(_elem851);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.connection_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->size);
          this->__isset.size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->block_size);
          this->__isset.block_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->checksum_verify);
          this->__isset.checksum_verify = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comment);
          this->__isset.comment = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast852;
          xfer += iprot->readI32(ecast852);
          this->version = (create_image_option::type)ecast852;
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->compressed);
          this->__isset.compressed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->checksum);
          this->__isset.checksum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->cdr);
          this->__isset.cdr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->mode);
          this->__isset.mode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t create_image_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("create_image_info");

  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.base) {
    xfer += oprot->writeFieldBegin("base", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->base);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.parent) {
    xfer += oprot->writeFieldBegin("parent", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->parent);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.connection_ids) {
    xfer += oprot->writeFieldBegin("connection_ids", ::apache::thrift::protocol::T_SET, 4);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->connection_ids.size()));
      std::set<std::string> ::const_iterator _iter853;
      for (_iter853 = this->connection_ids.begin(); _iter853 != this->connection_ids.end(); ++_iter853)
      {
        xfer += oprot->writeString((*_iter853));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.size) {
    xfer += oprot->writeFieldBegin("size", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.block_size) {
    xfer += oprot->writeFieldBegin("block_size", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(this->block_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.checksum_verify) {
    xfer += oprot->writeFieldBegin("checksum_verify", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->checksum_verify);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.comment) {
    xfer += oprot->writeFieldBegin("comment", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->comment);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.version) {
    xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_I32, 9);
    xfer += oprot->writeI32((int32_t)this->version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.compressed) {
    xfer += oprot->writeFieldBegin("compressed", ::apache::thrift::protocol::T_BOOL, 10);
    xfer += oprot->writeBool(this->compressed);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.checksum) {
    xfer += oprot->writeFieldBegin("checksum", ::apache::thrift::protocol::T_BOOL, 11);
    xfer += oprot->writeBool(this->checksum);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cdr) {
    xfer += oprot->writeFieldBegin("cdr", ::apache::thrift::protocol::T_BOOL, 12);
    xfer += oprot->writeBool(this->cdr);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mode) {
    xfer += oprot->writeFieldBegin("mode", ::apache::thrift::protocol::T_BYTE, 13);
    xfer += oprot->writeByte(this->mode);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(create_image_info &a, create_image_info &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.base, b.base);
  swap(a.parent, b.parent);
  swap(a.connection_ids, b.connection_ids);
  swap(a.size, b.size);
  swap(a.block_size, b.block_size);
  swap(a.checksum_verify, b.checksum_verify);
  swap(a.comment, b.comment);
  swap(a.version, b.version);
  swap(a.compressed, b.compressed);
  swap(a.checksum, b.checksum);
  swap(a.cdr, b.cdr);
  swap(a.mode, b.mode);
  swap(a.__isset, b.__isset);
}

create_image_info::create_image_info(const create_image_info& other854) {
  name = other854.name;
  base = other854.base;
  parent = other854.parent;
  connection_ids = other854.connection_ids;
  size = other854.size;
  block_size = other854.block_size;
  checksum_verify = other854.checksum_verify;
  comment = other854.comment;
  version = other854.version;
  compressed = other854.compressed;
  checksum = other854.checksum;
  cdr = other854.cdr;
  mode = other854.mode;
  __isset = other854.__isset;
}
create_image_info& create_image_info::operator=(const create_image_info& other855) {
  name = other855.name;
  base = other855.base;
  parent = other855.parent;
  connection_ids = other855.connection_ids;
  size = other855.size;
  block_size = other855.block_size;
  checksum_verify = other855.checksum_verify;
  comment = other855.comment;
  version = other855.version;
  compressed = other855.compressed;
  checksum = other855.checksum;
  cdr = other855.cdr;
  mode = other855.mode;
  __isset = other855.__isset;
  return *this;
}
void create_image_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "create_image_info(";
  out << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
  out << ", " << "base="; (__isset.base ? (out << to_string(base)) : (out << "<null>"));
  out << ", " << "parent="; (__isset.parent ? (out << to_string(parent)) : (out << "<null>"));
  out << ", " << "connection_ids="; (__isset.connection_ids ? (out << to_string(connection_ids)) : (out << "<null>"));
  out << ", " << "size="; (__isset.size ? (out << to_string(size)) : (out << "<null>"));
  out << ", " << "block_size="; (__isset.block_size ? (out << to_string(block_size)) : (out << "<null>"));
  out << ", " << "checksum_verify="; (__isset.checksum_verify ? (out << to_string(checksum_verify)) : (out << "<null>"));
  out << ", " << "comment="; (__isset.comment ? (out << to_string(comment)) : (out << "<null>"));
  out << ", " << "version="; (__isset.version ? (out << to_string(version)) : (out << "<null>"));
  out << ", " << "compressed="; (__isset.compressed ? (out << to_string(compressed)) : (out << "<null>"));
  out << ", " << "checksum="; (__isset.checksum ? (out << to_string(checksum)) : (out << "<null>"));
  out << ", " << "cdr="; (__isset.cdr ? (out << to_string(cdr)) : (out << "<null>"));
  out << ", " << "mode="; (__isset.mode ? (out << to_string(mode)) : (out << "<null>"));
  out << ")";
}


loader_job_detail::~loader_job_detail() throw() {
}


void loader_job_detail::__set_replica_id(const std::string& val) {
  this->replica_id = val;
__isset.replica_id = true;
}

void loader_job_detail::__set_id(const std::string& val) {
  this->id = val;
__isset.id = true;
}

void loader_job_detail::__set_state(const job_state::type val) {
  this->state = val;
__isset.state = true;
}

void loader_job_detail::__set_created_time(const std::string& val) {
  this->created_time = val;
__isset.created_time = true;
}

void loader_job_detail::__set_updated_time(const std::string& val) {
  this->updated_time = val;
__isset.updated_time = true;
}

void loader_job_detail::__set_progress(const std::map<std::string, int64_t> & val) {
  this->progress = val;
__isset.progress = true;
}

void loader_job_detail::__set_histories(const std::vector<job_history> & val) {
  this->histories = val;
__isset.histories = true;
}

void loader_job_detail::__set_connection_id(const std::string& val) {
  this->connection_id = val;
__isset.connection_id = true;
}

void loader_job_detail::__set_data(const std::map<std::string, int64_t> & val) {
  this->data = val;
__isset.data = true;
}

void loader_job_detail::__set_snapshot_id(const std::string& val) {
  this->snapshot_id = val;
__isset.snapshot_id = true;
}

void loader_job_detail::__set_duplicated_data(const std::map<std::string, int64_t> & val) {
  this->duplicated_data = val;
__isset.duplicated_data = true;
}

void loader_job_detail::__set_transport_data(const std::map<std::string, int64_t> & val) {
  this->transport_data = val;
__isset.transport_data = true;
}
std::ostream& operator<<(std::ostream& out, const loader_job_detail& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t loader_job_detail::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->replica_id);
          this->__isset.replica_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast856;
          xfer += iprot->readI32(ecast856);
          this->state = (job_state::type)ecast856;
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->created_time);
          this->__isset.created_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->updated_time);
          this->__isset.updated_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->progress.clear();
            uint32_t _size857;
            ::apache::thrift::protocol::TType _ktype858;
            ::apache::thrift::protocol::TType _vtype859;
            xfer += iprot->readMapBegin(_ktype858, _vtype859, _size857);
            uint32_t _i861;
            for (_i861 = 0; _i861 < _size857; ++_i861)
            {
              std::string _key862;
              xfer += iprot->readString(_key862);
              int64_t& _val863 = this->progress[_key862];
              xfer += iprot->readI64(_val863);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.progress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->histories.clear();
            uint32_t _size864;
            ::apache::thrift::protocol::TType _etype867;
            xfer += iprot->readListBegin(_etype867, _size864);
            this->histories.resize(_size864);
            uint32_t _i868;
            for (_i868 = 0; _i868 < _size864; ++_i868)
            {
              xfer += this->histories[_i868].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.histories = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->connection_id);
          this->__isset.connection_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->data.clear();
            uint32_t _size869;
            ::apache::thrift::protocol::TType _ktype870;
            ::apache::thrift::protocol::TType _vtype871;
            xfer += iprot->readMapBegin(_ktype870, _vtype871, _size869);
            uint32_t _i873;
            for (_i873 = 0; _i873 < _size869; ++_i873)
            {
              std::string _key874;
              xfer += iprot->readString(_key874);
              int64_t& _val875 = this->data[_key874];
              xfer += iprot->readI64(_val875);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->snapshot_id);
          this->__isset.snapshot_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->duplicated_data.clear();
            uint32_t _size876;
            ::apache::thrift::protocol::TType _ktype877;
            ::apache::thrift::protocol::TType _vtype878;
            xfer += iprot->readMapBegin(_ktype877, _vtype878, _size876);
            uint32_t _i880;
            for (_i880 = 0; _i880 < _size876; ++_i880)
            {
              std::string _key881;
              xfer += iprot->readString(_key881);
              int64_t& _val882 = this->duplicated_data[_key881];
              xfer += iprot->readI64(_val882);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.duplicated_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->transport_data.clear();
            uint32_t _size883;
            ::apache::thrift::protocol::TType _ktype884;
            ::apache::thrift::protocol::TType _vtype885;
            xfer += iprot->readMapBegin(_ktype884, _vtype885, _size883);
            uint32_t _i887;
            for (_i887 = 0; _i887 < _size883; ++_i887)
            {
              std::string _key888;
              xfer += iprot->readString(_key888);
              int64_t& _val889 = this->transport_data[_key888];
              xfer += iprot->readI64(_val889);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.transport_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t loader_job_detail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("loader_job_detail");

  if (this->__isset.replica_id) {
    xfer += oprot->writeFieldBegin("replica_id", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->replica_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.state) {
    xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32((int32_t)this->state);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.created_time) {
    xfer += oprot->writeFieldBegin("created_time", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->created_time);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.updated_time) {
    xfer += oprot->writeFieldBegin("updated_time", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->updated_time);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.progress) {
    xfer += oprot->writeFieldBegin("progress", ::apache::thrift::protocol::T_MAP, 6);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->progress.size()));
      std::map<std::string, int64_t> ::const_iterator _iter890;
      for (_iter890 = this->progress.begin(); _iter890 != this->progress.end(); ++_iter890)
      {
        xfer += oprot->writeString(_iter890->first);
        xfer += oprot->writeI64(_iter890->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.histories) {
    xfer += oprot->writeFieldBegin("histories", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->histories.size()));
      std::vector<job_history> ::const_iterator _iter891;
      for (_iter891 = this->histories.begin(); _iter891 != this->histories.end(); ++_iter891)
      {
        xfer += (*_iter891).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.connection_id) {
    xfer += oprot->writeFieldBegin("connection_id", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->connection_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.data) {
    xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_MAP, 9);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->data.size()));
      std::map<std::string, int64_t> ::const_iterator _iter892;
      for (_iter892 = this->data.begin(); _iter892 != this->data.end(); ++_iter892)
      {
        xfer += oprot->writeString(_iter892->first);
        xfer += oprot->writeI64(_iter892->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.snapshot_id) {
    xfer += oprot->writeFieldBegin("snapshot_id", ::apache::thrift::protocol::T_STRING, 10);
    xfer += oprot->writeString(this->snapshot_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.duplicated_data) {
    xfer += oprot->writeFieldBegin("duplicated_data", ::apache::thrift::protocol::T_MAP, 11);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->duplicated_data.size()));
      std::map<std::string, int64_t> ::const_iterator _iter893;
      for (_iter893 = this->duplicated_data.begin(); _iter893 != this->duplicated_data.end(); ++_iter893)
      {
        xfer += oprot->writeString(_iter893->first);
        xfer += oprot->writeI64(_iter893->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.transport_data) {
    xfer += oprot->writeFieldBegin("transport_data", ::apache::thrift::protocol::T_MAP, 12);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->transport_data.size()));
      std::map<std::string, int64_t> ::const_iterator _iter894;
      for (_iter894 = this->transport_data.begin(); _iter894 != this->transport_data.end(); ++_iter894)
      {
        xfer += oprot->writeString(_iter894->first);
        xfer += oprot->writeI64(_iter894->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(loader_job_detail &a, loader_job_detail &b) {
  using ::std::swap;
  swap(a.replica_id, b.replica_id);
  swap(a.id, b.id);
  swap(a.state, b.state);
  swap(a.created_time, b.created_time);
  swap(a.updated_time, b.updated_time);
  swap(a.progress, b.progress);
  swap(a.histories, b.histories);
  swap(a.connection_id, b.connection_id);
  swap(a.data, b.data);
  swap(a.snapshot_id, b.snapshot_id);
  swap(a.duplicated_data, b.duplicated_data);
  swap(a.transport_data, b.transport_data);
  swap(a.__isset, b.__isset);
}

loader_job_detail::loader_job_detail(const loader_job_detail& other895) {
  replica_id = other895.replica_id;
  id = other895.id;
  state = other895.state;
  created_time = other895.created_time;
  updated_time = other895.updated_time;
  progress = other895.progress;
  histories = other895.histories;
  connection_id = other895.connection_id;
  data = other895.data;
  snapshot_id = other895.snapshot_id;
  duplicated_data = other895.duplicated_data;
  transport_data = other895.transport_data;
  __isset = other895.__isset;
}
loader_job_detail& loader_job_detail::operator=(const loader_job_detail& other896) {
  replica_id = other896.replica_id;
  id = other896.id;
  state = other896.state;
  created_time = other896.created_time;
  updated_time = other896.updated_time;
  progress = other896.progress;
  histories = other896.histories;
  connection_id = other896.connection_id;
  data = other896.data;
  snapshot_id = other896.snapshot_id;
  duplicated_data = other896.duplicated_data;
  transport_data = other896.transport_data;
  __isset = other896.__isset;
  return *this;
}
void loader_job_detail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "loader_job_detail(";
  out << "replica_id="; (__isset.replica_id ? (out << to_string(replica_id)) : (out << "<null>"));
  out << ", " << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "state="; (__isset.state ? (out << to_string(state)) : (out << "<null>"));
  out << ", " << "created_time="; (__isset.created_time ? (out << to_string(created_time)) : (out << "<null>"));
  out << ", " << "updated_time="; (__isset.updated_time ? (out << to_string(updated_time)) : (out << "<null>"));
  out << ", " << "progress="; (__isset.progress ? (out << to_string(progress)) : (out << "<null>"));
  out << ", " << "histories="; (__isset.histories ? (out << to_string(histories)) : (out << "<null>"));
  out << ", " << "connection_id="; (__isset.connection_id ? (out << to_string(connection_id)) : (out << "<null>"));
  out << ", " << "data="; (__isset.data ? (out << to_string(data)) : (out << "<null>"));
  out << ", " << "snapshot_id="; (__isset.snapshot_id ? (out << to_string(snapshot_id)) : (out << "<null>"));
  out << ", " << "duplicated_data="; (__isset.duplicated_data ? (out << to_string(duplicated_data)) : (out << "<null>"));
  out << ", " << "transport_data="; (__isset.transport_data ? (out << to_string(transport_data)) : (out << "<null>"));
  out << ")";
}


upload_progress::~upload_progress() throw() {
}


void upload_progress::__set_size(const int64_t val) {
  this->size = val;
__isset.size = true;
}

void upload_progress::__set_progress(const int64_t val) {
  this->progress = val;
__isset.progress = true;
}

void upload_progress::__set_vhd_size(const int64_t val) {
  this->vhd_size = val;
__isset.vhd_size = true;
}

void upload_progress::__set_upload_id(const std::string& val) {
  this->upload_id = val;
__isset.upload_id = true;
}

void upload_progress::__set_completed(const bool val) {
  this->completed = val;
__isset.completed = true;
}
std::ostream& operator<<(std::ostream& out, const upload_progress& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t upload_progress::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->size);
          this->__isset.size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->progress);
          this->__isset.progress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->vhd_size);
          this->__isset.vhd_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->upload_id);
          this->__isset.upload_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->completed);
          this->__isset.completed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t upload_progress::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("upload_progress");

  if (this->__isset.size) {
    xfer += oprot->writeFieldBegin("size", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.progress) {
    xfer += oprot->writeFieldBegin("progress", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->progress);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vhd_size) {
    xfer += oprot->writeFieldBegin("vhd_size", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->vhd_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.upload_id) {
    xfer += oprot->writeFieldBegin("upload_id", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->upload_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.completed) {
    xfer += oprot->writeFieldBegin("completed", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->completed);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(upload_progress &a, upload_progress &b) {
  using ::std::swap;
  swap(a.size, b.size);
  swap(a.progress, b.progress);
  swap(a.vhd_size, b.vhd_size);
  swap(a.upload_id, b.upload_id);
  swap(a.completed, b.completed);
  swap(a.__isset, b.__isset);
}

upload_progress::upload_progress(const upload_progress& other897) {
  size = other897.size;
  progress = other897.progress;
  vhd_size = other897.vhd_size;
  upload_id = other897.upload_id;
  completed = other897.completed;
  __isset = other897.__isset;
}
upload_progress& upload_progress::operator=(const upload_progress& other898) {
  size = other898.size;
  progress = other898.progress;
  vhd_size = other898.vhd_size;
  upload_id = other898.upload_id;
  completed = other898.completed;
  __isset = other898.__isset;
  return *this;
}
void upload_progress::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "upload_progress(";
  out << "size="; (__isset.size ? (out << to_string(size)) : (out << "<null>"));
  out << ", " << "progress="; (__isset.progress ? (out << to_string(progress)) : (out << "<null>"));
  out << ", " << "vhd_size="; (__isset.vhd_size ? (out << to_string(vhd_size)) : (out << "<null>"));
  out << ", " << "upload_id="; (__isset.upload_id ? (out << to_string(upload_id)) : (out << "<null>"));
  out << ", " << "completed="; (__isset.completed ? (out << to_string(completed)) : (out << "<null>"));
  out << ")";
}


launcher_job_detail::~launcher_job_detail() throw() {
}


void launcher_job_detail::__set_replica_id(const std::string& val) {
  this->replica_id = val;
__isset.replica_id = true;
}

void launcher_job_detail::__set_id(const std::string& val) {
  this->id = val;
__isset.id = true;
}

void launcher_job_detail::__set_state(const job_state::type val) {
  this->state = val;
__isset.state = true;
}

void launcher_job_detail::__set_created_time(const std::string& val) {
  this->created_time = val;
__isset.created_time = true;
}

void launcher_job_detail::__set_updated_time(const std::string& val) {
  this->updated_time = val;
__isset.updated_time = true;
}

void launcher_job_detail::__set_boot_disk(const std::string& val) {
  this->boot_disk = val;
__isset.boot_disk = true;
}

void launcher_job_detail::__set_histories(const std::vector<job_history> & val) {
  this->histories = val;
__isset.histories = true;
}

void launcher_job_detail::__set_is_error(const bool val) {
  this->is_error = val;
__isset.is_error = true;
}

void launcher_job_detail::__set_is_windows_update(const bool val) {
  this->is_windows_update = val;
__isset.is_windows_update = true;
}

void launcher_job_detail::__set_platform(const std::string& val) {
  this->platform = val;
__isset.platform = true;
}

void launcher_job_detail::__set_architecture(const std::string& val) {
  this->architecture = val;
__isset.architecture = true;
}

void launcher_job_detail::__set_size(const int64_t val) {
  this->size = val;
__isset.size = true;
}

void launcher_job_detail::__set_progress(const int64_t val) {
  this->progress = val;
__isset.progress = true;
}

void launcher_job_detail::__set_vhd_size(const int64_t val) {
  this->vhd_size = val;
__isset.vhd_size = true;
}

void launcher_job_detail::__set_upload_id(const std::string& val) {
  this->upload_id = val;
__isset.upload_id = true;
}

void launcher_job_detail::__set_host_name(const std::string& val) {
  this->host_name = val;
__isset.host_name = true;
}

void launcher_job_detail::__set_vhd_upload_progress(const std::map<std::string, upload_progress> & val) {
  this->vhd_upload_progress = val;
__isset.vhd_upload_progress = true;
}

void launcher_job_detail::__set_virtual_machine_id(const std::string& val) {
  this->virtual_machine_id = val;
__isset.virtual_machine_id = true;
}
std::ostream& operator<<(std::ostream& out, const launcher_job_detail& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t launcher_job_detail::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->replica_id);
          this->__isset.replica_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast899;
          xfer += iprot->readI32(ecast899);
          this->state = (job_state::type)ecast899;
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->created_time);
          this->__isset.created_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->updated_time);
          this->__isset.updated_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->boot_disk);
          this->__isset.boot_disk = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->histories.clear();
            uint32_t _size900;
            ::apache::thrift::protocol::TType _etype903;
            xfer += iprot->readListBegin(_etype903, _size900);
            this->histories.resize(_size900);
            uint32_t _i904;
            for (_i904 = 0; _i904 < _size900; ++_i904)
            {
              xfer += this->histories[_i904].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.histories = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_error);
          this->__isset.is_error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_windows_update);
          this->__isset.is_windows_update = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->platform);
          this->__isset.platform = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->architecture);
          this->__isset.architecture = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->size);
          this->__isset.size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->progress);
          this->__isset.progress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->vhd_size);
          this->__isset.vhd_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->upload_id);
          this->__isset.upload_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host_name);
          this->__isset.host_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->vhd_upload_progress.clear();
            uint32_t _size905;
            ::apache::thrift::protocol::TType _ktype906;
            ::apache::thrift::protocol::TType _vtype907;
            xfer += iprot->readMapBegin(_ktype906, _vtype907, _size905);
            uint32_t _i909;
            for (_i909 = 0; _i909 < _size905; ++_i909)
            {
              std::string _key910;
              xfer += iprot->readString(_key910);
              upload_progress& _val911 = this->vhd_upload_progress[_key910];
              xfer += _val911.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.vhd_upload_progress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->virtual_machine_id);
          this->__isset.virtual_machine_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t launcher_job_detail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("launcher_job_detail");

  if (this->__isset.replica_id) {
    xfer += oprot->writeFieldBegin("replica_id", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->replica_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.state) {
    xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32((int32_t)this->state);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.created_time) {
    xfer += oprot->writeFieldBegin("created_time", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->created_time);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.updated_time) {
    xfer += oprot->writeFieldBegin("updated_time", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->updated_time);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.boot_disk) {
    xfer += oprot->writeFieldBegin("boot_disk", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->boot_disk);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.histories) {
    xfer += oprot->writeFieldBegin("histories", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->histories.size()));
      std::vector<job_history> ::const_iterator _iter912;
      for (_iter912 = this->histories.begin(); _iter912 != this->histories.end(); ++_iter912)
      {
        xfer += (*_iter912).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_error) {
    xfer += oprot->writeFieldBegin("is_error", ::apache::thrift::protocol::T_BOOL, 8);
    xfer += oprot->writeBool(this->is_error);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_windows_update) {
    xfer += oprot->writeFieldBegin("is_windows_update", ::apache::thrift::protocol::T_BOOL, 9);
    xfer += oprot->writeBool(this->is_windows_update);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.platform) {
    xfer += oprot->writeFieldBegin("platform", ::apache::thrift::protocol::T_STRING, 10);
    xfer += oprot->writeString(this->platform);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.architecture) {
    xfer += oprot->writeFieldBegin("architecture", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeString(this->architecture);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.size) {
    xfer += oprot->writeFieldBegin("size", ::apache::thrift::protocol::T_I64, 12);
    xfer += oprot->writeI64(this->size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.progress) {
    xfer += oprot->writeFieldBegin("progress", ::apache::thrift::protocol::T_I64, 13);
    xfer += oprot->writeI64(this->progress);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vhd_size) {
    xfer += oprot->writeFieldBegin("vhd_size", ::apache::thrift::protocol::T_I64, 14);
    xfer += oprot->writeI64(this->vhd_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.upload_id) {
    xfer += oprot->writeFieldBegin("upload_id", ::apache::thrift::protocol::T_STRING, 15);
    xfer += oprot->writeString(this->upload_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.host_name) {
    xfer += oprot->writeFieldBegin("host_name", ::apache::thrift::protocol::T_STRING, 16);
    xfer += oprot->writeString(this->host_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vhd_upload_progress) {
    xfer += oprot->writeFieldBegin("vhd_upload_progress", ::apache::thrift::protocol::T_MAP, 17);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->vhd_upload_progress.size()));
      std::map<std::string, upload_progress> ::const_iterator _iter913;
      for (_iter913 = this->vhd_upload_progress.begin(); _iter913 != this->vhd_upload_progress.end(); ++_iter913)
      {
        xfer += oprot->writeString(_iter913->first);
        xfer += _iter913->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.virtual_machine_id) {
    xfer += oprot->writeFieldBegin("virtual_machine_id", ::apache::thrift::protocol::T_STRING, 18);
    xfer += oprot->writeString(this->virtual_machine_id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(launcher_job_detail &a, launcher_job_detail &b) {
  using ::std::swap;
  swap(a.replica_id, b.replica_id);
  swap(a.id, b.id);
  swap(a.state, b.state);
  swap(a.created_time, b.created_time);
  swap(a.updated_time, b.updated_time);
  swap(a.boot_disk, b.boot_disk);
  swap(a.histories, b.histories);
  swap(a.is_error, b.is_error);
  swap(a.is_windows_update, b.is_windows_update);
  swap(a.platform, b.platform);
  swap(a.architecture, b.architecture);
  swap(a.size, b.size);
  swap(a.progress, b.progress);
  swap(a.vhd_size, b.vhd_size);
  swap(a.upload_id, b.upload_id);
  swap(a.host_name, b.host_name);
  swap(a.vhd_upload_progress, b.vhd_upload_progress);
  swap(a.virtual_machine_id, b.virtual_machine_id);
  swap(a.__isset, b.__isset);
}

launcher_job_detail::launcher_job_detail(const launcher_job_detail& other914) {
  replica_id = other914.replica_id;
  id = other914.id;
  state = other914.state;
  created_time = other914.created_time;
  updated_time = other914.updated_time;
  boot_disk = other914.boot_disk;
  histories = other914.histories;
  is_error = other914.is_error;
  is_windows_update = other914.is_windows_update;
  platform = other914.platform;
  architecture = other914.architecture;
  size = other914.size;
  progress = other914.progress;
  vhd_size = other914.vhd_size;
  upload_id = other914.upload_id;
  host_name = other914.host_name;
  vhd_upload_progress = other914.vhd_upload_progress;
  virtual_machine_id = other914.virtual_machine_id;
  __isset = other914.__isset;
}
launcher_job_detail& launcher_job_detail::operator=(const launcher_job_detail& other915) {
  replica_id = other915.replica_id;
  id = other915.id;
  state = other915.state;
  created_time = other915.created_time;
  updated_time = other915.updated_time;
  boot_disk = other915.boot_disk;
  histories = other915.histories;
  is_error = other915.is_error;
  is_windows_update = other915.is_windows_update;
  platform = other915.platform;
  architecture = other915.architecture;
  size = other915.size;
  progress = other915.progress;
  vhd_size = other915.vhd_size;
  upload_id = other915.upload_id;
  host_name = other915.host_name;
  vhd_upload_progress = other915.vhd_upload_progress;
  virtual_machine_id = other915.virtual_machine_id;
  __isset = other915.__isset;
  return *this;
}
void launcher_job_detail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "launcher_job_detail(";
  out << "replica_id="; (__isset.replica_id ? (out << to_string(replica_id)) : (out << "<null>"));
  out << ", " << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "state="; (__isset.state ? (out << to_string(state)) : (out << "<null>"));
  out << ", " << "created_time="; (__isset.created_time ? (out << to_string(created_time)) : (out << "<null>"));
  out << ", " << "updated_time="; (__isset.updated_time ? (out << to_string(updated_time)) : (out << "<null>"));
  out << ", " << "boot_disk="; (__isset.boot_disk ? (out << to_string(boot_disk)) : (out << "<null>"));
  out << ", " << "histories="; (__isset.histories ? (out << to_string(histories)) : (out << "<null>"));
  out << ", " << "is_error="; (__isset.is_error ? (out << to_string(is_error)) : (out << "<null>"));
  out << ", " << "is_windows_update="; (__isset.is_windows_update ? (out << to_string(is_windows_update)) : (out << "<null>"));
  out << ", " << "platform="; (__isset.platform ? (out << to_string(platform)) : (out << "<null>"));
  out << ", " << "architecture="; (__isset.architecture ? (out << to_string(architecture)) : (out << "<null>"));
  out << ", " << "size="; (__isset.size ? (out << to_string(size)) : (out << "<null>"));
  out << ", " << "progress="; (__isset.progress ? (out << to_string(progress)) : (out << "<null>"));
  out << ", " << "vhd_size="; (__isset.vhd_size ? (out << to_string(vhd_size)) : (out << "<null>"));
  out << ", " << "upload_id="; (__isset.upload_id ? (out << to_string(upload_id)) : (out << "<null>"));
  out << ", " << "host_name="; (__isset.host_name ? (out << to_string(host_name)) : (out << "<null>"));
  out << ", " << "vhd_upload_progress="; (__isset.vhd_upload_progress ? (out << to_string(vhd_upload_progress)) : (out << "<null>"));
  out << ", " << "virtual_machine_id="; (__isset.virtual_machine_id ? (out << to_string(virtual_machine_id)) : (out << "<null>"));
  out << ")";
}


job_detail::~job_detail() throw() {
}


void job_detail::__set_scheduler(const replica_job_detail& val) {
  this->scheduler = val;
__isset.scheduler = true;
}

void job_detail::__set_launcher(const launcher_job_detail& val) {
  this->launcher = val;
__isset.launcher = true;
}

void job_detail::__set_loader(const loader_job_detail& val) {
  this->loader = val;
__isset.loader = true;
}
std::ostream& operator<<(std::ostream& out, const job_detail& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t job_detail::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->scheduler.read(iprot);
          this->__isset.scheduler = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->launcher.read(iprot);
          this->__isset.launcher = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->loader.read(iprot);
          this->__isset.loader = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t job_detail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("job_detail");

  if (this->__isset.scheduler) {
    xfer += oprot->writeFieldBegin("scheduler", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->scheduler.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.launcher) {
    xfer += oprot->writeFieldBegin("launcher", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->launcher.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.loader) {
    xfer += oprot->writeFieldBegin("loader", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->loader.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(job_detail &a, job_detail &b) {
  using ::std::swap;
  swap(a.scheduler, b.scheduler);
  swap(a.launcher, b.launcher);
  swap(a.loader, b.loader);
  swap(a.__isset, b.__isset);
}

job_detail::job_detail(const job_detail& other916) {
  scheduler = other916.scheduler;
  launcher = other916.launcher;
  loader = other916.loader;
  __isset = other916.__isset;
}
job_detail& job_detail::operator=(const job_detail& other917) {
  scheduler = other917.scheduler;
  launcher = other917.launcher;
  loader = other917.loader;
  __isset = other917.__isset;
  return *this;
}
void job_detail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "job_detail(";
  out << "scheduler="; (__isset.scheduler ? (out << to_string(scheduler)) : (out << "<null>"));
  out << ", " << "launcher="; (__isset.launcher ? (out << to_string(launcher)) : (out << "<null>"));
  out << ", " << "loader="; (__isset.loader ? (out << to_string(loader)) : (out << "<null>"));
  out << ")";
}


replica_job_create_detail::~replica_job_create_detail() throw() {
}


void replica_job_create_detail::__set_host(const std::string& val) {
  this->host = val;
__isset.host = true;
}

void replica_job_create_detail::__set_addr(const std::set<std::string> & val) {
  this->addr = val;
__isset.addr = true;
}

void replica_job_create_detail::__set_username(const std::string& val) {
  this->username = val;
__isset.username = true;
}

void replica_job_create_detail::__set_password(const std::string& val) {
  this->password = val;
__isset.password = true;
}

void replica_job_create_detail::__set_type(const job_type::type val) {
  this->type = val;
__isset.type = true;
}

void replica_job_create_detail::__set_virtual_machine_id(const std::string& val) {
  this->virtual_machine_id = val;
__isset.virtual_machine_id = true;
}

void replica_job_create_detail::__set_disks(const std::set<std::string> & val) {
  this->disks = val;
__isset.disks = true;
}

void replica_job_create_detail::__set_targets(const std::map<std::string, std::string> & val) {
  this->targets = val;
__isset.targets = true;
}

void replica_job_create_detail::__set_carriers(const std::map<std::string, std::set<std::string> > & val) {
  this->carriers = val;
__isset.carriers = true;
}

void replica_job_create_detail::__set_full_replicas(const std::set<std::string> & val) {
  this->full_replicas = val;
__isset.full_replicas = true;
}

void replica_job_create_detail::__set_disk_ids(const std::map<std::string, std::string> & val) {
  this->disk_ids = val;
__isset.disk_ids = true;
}

void replica_job_create_detail::__set_cbt_info(const std::string& val) {
  this->cbt_info = val;
__isset.cbt_info = true;
}

void replica_job_create_detail::__set_snapshot_info(const std::string& val) {
  this->snapshot_info = val;
__isset.snapshot_info = true;
}

void replica_job_create_detail::__set_checksum_verify(const bool val) {
  this->checksum_verify = val;
__isset.checksum_verify = true;
}

void replica_job_create_detail::__set_always_retry(const bool val) {
  this->always_retry = val;
__isset.always_retry = true;
}

void replica_job_create_detail::__set_timeout(const int32_t val) {
  this->timeout = val;
__isset.timeout = true;
}

void replica_job_create_detail::__set_is_encrypted(const bool val) {
  this->is_encrypted = val;
__isset.is_encrypted = true;
}

void replica_job_create_detail::__set_is_paused(const bool val) {
  this->is_paused = val;
__isset.is_paused = true;
}

void replica_job_create_detail::__set_worker_thread_number(const int32_t val) {
  this->worker_thread_number = val;
__isset.worker_thread_number = true;
}

void replica_job_create_detail::__set_block_mode_enable(const bool val) {
  this->block_mode_enable = val;
__isset.block_mode_enable = true;
}

void replica_job_create_detail::__set_file_system_filter_enable(const bool val) {
  this->file_system_filter_enable = val;
__isset.file_system_filter_enable = true;
}

void replica_job_create_detail::__set_min_transport_size(const int32_t val) {
  this->min_transport_size = val;
__isset.min_transport_size = true;
}

void replica_job_create_detail::__set_full_min_transport_size(const int32_t val) {
  this->full_min_transport_size = val;
__isset.full_min_transport_size = true;
}

void replica_job_create_detail::__set_is_full_replica(const bool val) {
  this->is_full_replica = val;
__isset.is_full_replica = true;
}

void replica_job_create_detail::__set_buffer_size(const int32_t val) {
  this->buffer_size = val;
__isset.buffer_size = true;
}

void replica_job_create_detail::__set_is_compressed(const bool val) {
  this->is_compressed = val;
__isset.is_compressed = true;
}

void replica_job_create_detail::__set_is_checksum(const bool val) {
  this->is_checksum = val;
__isset.is_checksum = true;
}

void replica_job_create_detail::__set_time(const std::string& val) {
  this->time = val;
__isset.time = true;
}

void replica_job_create_detail::__set_priority_carrier(const std::map<std::string, std::string> & val) {
  this->priority_carrier = val;
__isset.priority_carrier = true;
}

void replica_job_create_detail::__set_is_only_single_system_disk(const bool val) {
  this->is_only_single_system_disk = val;
__isset.is_only_single_system_disk = true;
}

void replica_job_create_detail::__set_is_continuous_data_replication(const bool val) {
  this->is_continuous_data_replication = val;
__isset.is_continuous_data_replication = true;
}

void replica_job_create_detail::__set_pre_snapshot_script(const std::string& val) {
  this->pre_snapshot_script = val;
__isset.pre_snapshot_script = true;
}

void replica_job_create_detail::__set_post_snapshot_script(const std::string& val) {
  this->post_snapshot_script = val;
__isset.post_snapshot_script = true;
}

void replica_job_create_detail::__set_is_compressed_by_packer(const bool val) {
  this->is_compressed_by_packer = val;
__isset.is_compressed_by_packer = true;
}

void replica_job_create_detail::__set_excluded_paths(const std::set<std::string> & val) {
  this->excluded_paths = val;
__isset.excluded_paths = true;
}

void replica_job_create_detail::__set_previous_excluded_paths(const std::set<std::string> & val) {
  this->previous_excluded_paths = val;
__isset.previous_excluded_paths = true;
}

void replica_job_create_detail::__set_checksum_target(const std::map<std::string, std::string> & val) {
  this->checksum_target = val;
__isset.checksum_target = true;
}
std::ostream& operator<<(std::ostream& out, const replica_job_create_detail& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t replica_job_create_detail::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host);
          this->__isset.host = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->addr.clear();
            uint32_t _size918;
            ::apache::thrift::protocol::TType _etype921;
            xfer += iprot->readSetBegin(_etype921, _size918);
            uint32_t _i922;
            for (_i922 = 0; _i922 < _size918; ++_i922)
            {
              std::string _elem923;
              xfer += iprot->readString(_elem923);
              this->addr.insert(_elem923);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->username);
          this->__isset.username = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->password);
          this->__isset.password = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast924;
          xfer += iprot->readI32(ecast924);
          this->type = (job_type::type)ecast924;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->virtual_machine_id);
          this->__isset.virtual_machine_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->disks.clear();
            uint32_t _size925;
            ::apache::thrift::protocol::TType _etype928;
            xfer += iprot->readSetBegin(_etype928, _size925);
            uint32_t _i929;
            for (_i929 = 0; _i929 < _size925; ++_i929)
            {
              std::string _elem930;
              xfer += iprot->readString(_elem930);
              this->disks.insert(_elem930);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.disks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->targets.clear();
            uint32_t _size931;
            ::apache::thrift::protocol::TType _ktype932;
            ::apache::thrift::protocol::TType _vtype933;
            xfer += iprot->readMapBegin(_ktype932, _vtype933, _size931);
            uint32_t _i935;
            for (_i935 = 0; _i935 < _size931; ++_i935)
            {
              std::string _key936;
              xfer += iprot->readString(_key936);
              std::string& _val937 = this->targets[_key936];
              xfer += iprot->readString(_val937);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.targets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->carriers.clear();
            uint32_t _size938;
            ::apache::thrift::protocol::TType _ktype939;
            ::apache::thrift::protocol::TType _vtype940;
            xfer += iprot->readMapBegin(_ktype939, _vtype940, _size938);
            uint32_t _i942;
            for (_i942 = 0; _i942 < _size938; ++_i942)
            {
              std::string _key943;
              xfer += iprot->readString(_key943);
              std::set<std::string> & _val944 = this->carriers[_key943];
              {
                _val944.clear();
                uint32_t _size945;
                ::apache::thrift::protocol::TType _etype948;
                xfer += iprot->readSetBegin(_etype948, _size945);
                uint32_t _i949;
                for (_i949 = 0; _i949 < _size945; ++_i949)
                {
                  std::string _elem950;
                  xfer += iprot->readString(_elem950);
                  _val944.insert(_elem950);
                }
                xfer += iprot->readSetEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.carriers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->full_replicas.clear();
            uint32_t _size951;
            ::apache::thrift::protocol::TType _etype954;
            xfer += iprot->readSetBegin(_etype954, _size951);
            uint32_t _i955;
            for (_i955 = 0; _i955 < _size951; ++_i955)
            {
              std::string _elem956;
              xfer += iprot->readString(_elem956);
              this->full_replicas.insert(_elem956);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.full_replicas = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->disk_ids.clear();
            uint32_t _size957;
            ::apache::thrift::protocol::TType _ktype958;
            ::apache::thrift::protocol::TType _vtype959;
            xfer += iprot->readMapBegin(_ktype958, _vtype959, _size957);
            uint32_t _i961;
            for (_i961 = 0; _i961 < _size957; ++_i961)
            {
              std::string _key962;
              xfer += iprot->readString(_key962);
              std::string& _val963 = this->disk_ids[_key962];
              xfer += iprot->readString(_val963);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.disk_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cbt_info);
          this->__isset.cbt_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->snapshot_info);
          this->__isset.snapshot_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->checksum_verify);
          this->__isset.checksum_verify = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->always_retry);
          this->__isset.always_retry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->timeout);
          this->__isset.timeout = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_encrypted);
          this->__isset.is_encrypted = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_paused);
          this->__isset.is_paused = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->worker_thread_number);
          this->__isset.worker_thread_number = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->block_mode_enable);
          this->__isset.block_mode_enable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->file_system_filter_enable);
          this->__isset.file_system_filter_enable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->min_transport_size);
          this->__isset.min_transport_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->full_min_transport_size);
          this->__isset.full_min_transport_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_full_replica);
          this->__isset.is_full_replica = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->buffer_size);
          this->__isset.buffer_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 26:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_compressed);
          this->__isset.is_compressed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 27:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_checksum);
          this->__isset.is_checksum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 28:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->time);
          this->__isset.time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 29:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->priority_carrier.clear();
            uint32_t _size964;
            ::apache::thrift::protocol::TType _ktype965;
            ::apache::thrift::protocol::TType _vtype966;
            xfer += iprot->readMapBegin(_ktype965, _vtype966, _size964);
            uint32_t _i968;
            for (_i968 = 0; _i968 < _size964; ++_i968)
            {
              std::string _key969;
              xfer += iprot->readString(_key969);
              std::string& _val970 = this->priority_carrier[_key969];
              xfer += iprot->readString(_val970);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.priority_carrier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_only_single_system_disk);
          this->__isset.is_only_single_system_disk = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 31:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_continuous_data_replication);
          this->__isset.is_continuous_data_replication = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 32:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pre_snapshot_script);
          this->__isset.pre_snapshot_script = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 33:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->post_snapshot_script);
          this->__isset.post_snapshot_script = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 34:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_compressed_by_packer);
          this->__isset.is_compressed_by_packer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 35:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->excluded_paths.clear();
            uint32_t _size971;
            ::apache::thrift::protocol::TType _etype974;
            xfer += iprot->readSetBegin(_etype974, _size971);
            uint32_t _i975;
            for (_i975 = 0; _i975 < _size971; ++_i975)
            {
              std::string _elem976;
              xfer += iprot->readString(_elem976);
              this->excluded_paths.insert(_elem976);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.excluded_paths = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 36:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->previous_excluded_paths.clear();
            uint32_t _size977;
            ::apache::thrift::protocol::TType _etype980;
            xfer += iprot->readSetBegin(_etype980, _size977);
            uint32_t _i981;
            for (_i981 = 0; _i981 < _size977; ++_i981)
            {
              std::string _elem982;
              xfer += iprot->readString(_elem982);
              this->previous_excluded_paths.insert(_elem982);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.previous_excluded_paths = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 37:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->checksum_target.clear();
            uint32_t _size983;
            ::apache::thrift::protocol::TType _ktype984;
            ::apache::thrift::protocol::TType _vtype985;
            xfer += iprot->readMapBegin(_ktype984, _vtype985, _size983);
            uint32_t _i987;
            for (_i987 = 0; _i987 < _size983; ++_i987)
            {
              std::string _key988;
              xfer += iprot->readString(_key988);
              std::string& _val989 = this->checksum_target[_key988];
              xfer += iprot->readString(_val989);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.checksum_target = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t replica_job_create_detail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("replica_job_create_detail");

  if (this->__isset.host) {
    xfer += oprot->writeFieldBegin("host", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->host);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.addr) {
    xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_SET, 2);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->addr.size()));
      std::set<std::string> ::const_iterator _iter990;
      for (_iter990 = this->addr.begin(); _iter990 != this->addr.end(); ++_iter990)
      {
        xfer += oprot->writeString((*_iter990));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.username) {
    xfer += oprot->writeFieldBegin("username", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->username);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.password) {
    xfer += oprot->writeFieldBegin("password", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->password);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.type) {
    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32((int32_t)this->type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.virtual_machine_id) {
    xfer += oprot->writeFieldBegin("virtual_machine_id", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->virtual_machine_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.disks) {
    xfer += oprot->writeFieldBegin("disks", ::apache::thrift::protocol::T_SET, 7);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->disks.size()));
      std::set<std::string> ::const_iterator _iter991;
      for (_iter991 = this->disks.begin(); _iter991 != this->disks.end(); ++_iter991)
      {
        xfer += oprot->writeString((*_iter991));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.targets) {
    xfer += oprot->writeFieldBegin("targets", ::apache::thrift::protocol::T_MAP, 8);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->targets.size()));
      std::map<std::string, std::string> ::const_iterator _iter992;
      for (_iter992 = this->targets.begin(); _iter992 != this->targets.end(); ++_iter992)
      {
        xfer += oprot->writeString(_iter992->first);
        xfer += oprot->writeString(_iter992->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.carriers) {
    xfer += oprot->writeFieldBegin("carriers", ::apache::thrift::protocol::T_MAP, 9);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_SET, static_cast<uint32_t>(this->carriers.size()));
      std::map<std::string, std::set<std::string> > ::const_iterator _iter993;
      for (_iter993 = this->carriers.begin(); _iter993 != this->carriers.end(); ++_iter993)
      {
        xfer += oprot->writeString(_iter993->first);
        {
          xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter993->second.size()));
          std::set<std::string> ::const_iterator _iter994;
          for (_iter994 = _iter993->second.begin(); _iter994 != _iter993->second.end(); ++_iter994)
          {
            xfer += oprot->writeString((*_iter994));
          }
          xfer += oprot->writeSetEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.full_replicas) {
    xfer += oprot->writeFieldBegin("full_replicas", ::apache::thrift::protocol::T_SET, 10);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->full_replicas.size()));
      std::set<std::string> ::const_iterator _iter995;
      for (_iter995 = this->full_replicas.begin(); _iter995 != this->full_replicas.end(); ++_iter995)
      {
        xfer += oprot->writeString((*_iter995));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.disk_ids) {
    xfer += oprot->writeFieldBegin("disk_ids", ::apache::thrift::protocol::T_MAP, 11);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->disk_ids.size()));
      std::map<std::string, std::string> ::const_iterator _iter996;
      for (_iter996 = this->disk_ids.begin(); _iter996 != this->disk_ids.end(); ++_iter996)
      {
        xfer += oprot->writeString(_iter996->first);
        xfer += oprot->writeString(_iter996->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cbt_info) {
    xfer += oprot->writeFieldBegin("cbt_info", ::apache::thrift::protocol::T_STRING, 12);
    xfer += oprot->writeString(this->cbt_info);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.snapshot_info) {
    xfer += oprot->writeFieldBegin("snapshot_info", ::apache::thrift::protocol::T_STRING, 13);
    xfer += oprot->writeString(this->snapshot_info);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.checksum_verify) {
    xfer += oprot->writeFieldBegin("checksum_verify", ::apache::thrift::protocol::T_BOOL, 14);
    xfer += oprot->writeBool(this->checksum_verify);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.always_retry) {
    xfer += oprot->writeFieldBegin("always_retry", ::apache::thrift::protocol::T_BOOL, 15);
    xfer += oprot->writeBool(this->always_retry);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timeout) {
    xfer += oprot->writeFieldBegin("timeout", ::apache::thrift::protocol::T_I32, 16);
    xfer += oprot->writeI32(this->timeout);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_encrypted) {
    xfer += oprot->writeFieldBegin("is_encrypted", ::apache::thrift::protocol::T_BOOL, 17);
    xfer += oprot->writeBool(this->is_encrypted);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_paused) {
    xfer += oprot->writeFieldBegin("is_paused", ::apache::thrift::protocol::T_BOOL, 18);
    xfer += oprot->writeBool(this->is_paused);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.worker_thread_number) {
    xfer += oprot->writeFieldBegin("worker_thread_number", ::apache::thrift::protocol::T_I32, 19);
    xfer += oprot->writeI32(this->worker_thread_number);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.block_mode_enable) {
    xfer += oprot->writeFieldBegin("block_mode_enable", ::apache::thrift::protocol::T_BOOL, 20);
    xfer += oprot->writeBool(this->block_mode_enable);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.file_system_filter_enable) {
    xfer += oprot->writeFieldBegin("file_system_filter_enable", ::apache::thrift::protocol::T_BOOL, 21);
    xfer += oprot->writeBool(this->file_system_filter_enable);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.min_transport_size) {
    xfer += oprot->writeFieldBegin("min_transport_size", ::apache::thrift::protocol::T_I32, 22);
    xfer += oprot->writeI32(this->min_transport_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.full_min_transport_size) {
    xfer += oprot->writeFieldBegin("full_min_transport_size", ::apache::thrift::protocol::T_I32, 23);
    xfer += oprot->writeI32(this->full_min_transport_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_full_replica) {
    xfer += oprot->writeFieldBegin("is_full_replica", ::apache::thrift::protocol::T_BOOL, 24);
    xfer += oprot->writeBool(this->is_full_replica);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.buffer_size) {
    xfer += oprot->writeFieldBegin("buffer_size", ::apache::thrift::protocol::T_I32, 25);
    xfer += oprot->writeI32(this->buffer_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_compressed) {
    xfer += oprot->writeFieldBegin("is_compressed", ::apache::thrift::protocol::T_BOOL, 26);
    xfer += oprot->writeBool(this->is_compressed);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_checksum) {
    xfer += oprot->writeFieldBegin("is_checksum", ::apache::thrift::protocol::T_BOOL, 27);
    xfer += oprot->writeBool(this->is_checksum);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.time) {
    xfer += oprot->writeFieldBegin("time", ::apache::thrift::protocol::T_STRING, 28);
    xfer += oprot->writeString(this->time);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.priority_carrier) {
    xfer += oprot->writeFieldBegin("priority_carrier", ::apache::thrift::protocol::T_MAP, 29);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->priority_carrier.size()));
      std::map<std::string, std::string> ::const_iterator _iter997;
      for (_iter997 = this->priority_carrier.begin(); _iter997 != this->priority_carrier.end(); ++_iter997)
      {
        xfer += oprot->writeString(_iter997->first);
        xfer += oprot->writeString(_iter997->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_only_single_system_disk) {
    xfer += oprot->writeFieldBegin("is_only_single_system_disk", ::apache::thrift::protocol::T_BOOL, 30);
    xfer += oprot->writeBool(this->is_only_single_system_disk);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_continuous_data_replication) {
    xfer += oprot->writeFieldBegin("is_continuous_data_replication", ::apache::thrift::protocol::T_BOOL, 31);
    xfer += oprot->writeBool(this->is_continuous_data_replication);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.pre_snapshot_script) {
    xfer += oprot->writeFieldBegin("pre_snapshot_script", ::apache::thrift::protocol::T_STRING, 32);
    xfer += oprot->writeString(this->pre_snapshot_script);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.post_snapshot_script) {
    xfer += oprot->writeFieldBegin("post_snapshot_script", ::apache::thrift::protocol::T_STRING, 33);
    xfer += oprot->writeString(this->post_snapshot_script);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_compressed_by_packer) {
    xfer += oprot->writeFieldBegin("is_compressed_by_packer", ::apache::thrift::protocol::T_BOOL, 34);
    xfer += oprot->writeBool(this->is_compressed_by_packer);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.excluded_paths) {
    xfer += oprot->writeFieldBegin("excluded_paths", ::apache::thrift::protocol::T_SET, 35);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->excluded_paths.size()));
      std::set<std::string> ::const_iterator _iter998;
      for (_iter998 = this->excluded_paths.begin(); _iter998 != this->excluded_paths.end(); ++_iter998)
      {
        xfer += oprot->writeString((*_iter998));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.previous_excluded_paths) {
    xfer += oprot->writeFieldBegin("previous_excluded_paths", ::apache::thrift::protocol::T_SET, 36);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->previous_excluded_paths.size()));
      std::set<std::string> ::const_iterator _iter999;
      for (_iter999 = this->previous_excluded_paths.begin(); _iter999 != this->previous_excluded_paths.end(); ++_iter999)
      {
        xfer += oprot->writeString((*_iter999));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.checksum_target) {
    xfer += oprot->writeFieldBegin("checksum_target", ::apache::thrift::protocol::T_MAP, 37);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->checksum_target.size()));
      std::map<std::string, std::string> ::const_iterator _iter1000;
      for (_iter1000 = this->checksum_target.begin(); _iter1000 != this->checksum_target.end(); ++_iter1000)
      {
        xfer += oprot->writeString(_iter1000->first);
        xfer += oprot->writeString(_iter1000->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(replica_job_create_detail &a, replica_job_create_detail &b) {
  using ::std::swap;
  swap(a.host, b.host);
  swap(a.addr, b.addr);
  swap(a.username, b.username);
  swap(a.password, b.password);
  swap(a.type, b.type);
  swap(a.virtual_machine_id, b.virtual_machine_id);
  swap(a.disks, b.disks);
  swap(a.targets, b.targets);
  swap(a.carriers, b.carriers);
  swap(a.full_replicas, b.full_replicas);
  swap(a.disk_ids, b.disk_ids);
  swap(a.cbt_info, b.cbt_info);
  swap(a.snapshot_info, b.snapshot_info);
  swap(a.checksum_verify, b.checksum_verify);
  swap(a.always_retry, b.always_retry);
  swap(a.timeout, b.timeout);
  swap(a.is_encrypted, b.is_encrypted);
  swap(a.is_paused, b.is_paused);
  swap(a.worker_thread_number, b.worker_thread_number);
  swap(a.block_mode_enable, b.block_mode_enable);
  swap(a.file_system_filter_enable, b.file_system_filter_enable);
  swap(a.min_transport_size, b.min_transport_size);
  swap(a.full_min_transport_size, b.full_min_transport_size);
  swap(a.is_full_replica, b.is_full_replica);
  swap(a.buffer_size, b.buffer_size);
  swap(a.is_compressed, b.is_compressed);
  swap(a.is_checksum, b.is_checksum);
  swap(a.time, b.time);
  swap(a.priority_carrier, b.priority_carrier);
  swap(a.is_only_single_system_disk, b.is_only_single_system_disk);
  swap(a.is_continuous_data_replication, b.is_continuous_data_replication);
  swap(a.pre_snapshot_script, b.pre_snapshot_script);
  swap(a.post_snapshot_script, b.post_snapshot_script);
  swap(a.is_compressed_by_packer, b.is_compressed_by_packer);
  swap(a.excluded_paths, b.excluded_paths);
  swap(a.previous_excluded_paths, b.previous_excluded_paths);
  swap(a.checksum_target, b.checksum_target);
  swap(a.__isset, b.__isset);
}

replica_job_create_detail::replica_job_create_detail(const replica_job_create_detail& other1001) {
  host = other1001.host;
  addr = other1001.addr;
  username = other1001.username;
  password = other1001.password;
  type = other1001.type;
  virtual_machine_id = other1001.virtual_machine_id;
  disks = other1001.disks;
  targets = other1001.targets;
  carriers = other1001.carriers;
  full_replicas = other1001.full_replicas;
  disk_ids = other1001.disk_ids;
  cbt_info = other1001.cbt_info;
  snapshot_info = other1001.snapshot_info;
  checksum_verify = other1001.checksum_verify;
  always_retry = other1001.always_retry;
  timeout = other1001.timeout;
  is_encrypted = other1001.is_encrypted;
  is_paused = other1001.is_paused;
  worker_thread_number = other1001.worker_thread_number;
  block_mode_enable = other1001.block_mode_enable;
  file_system_filter_enable = other1001.file_system_filter_enable;
  min_transport_size = other1001.min_transport_size;
  full_min_transport_size = other1001.full_min_transport_size;
  is_full_replica = other1001.is_full_replica;
  buffer_size = other1001.buffer_size;
  is_compressed = other1001.is_compressed;
  is_checksum = other1001.is_checksum;
  time = other1001.time;
  priority_carrier = other1001.priority_carrier;
  is_only_single_system_disk = other1001.is_only_single_system_disk;
  is_continuous_data_replication = other1001.is_continuous_data_replication;
  pre_snapshot_script = other1001.pre_snapshot_script;
  post_snapshot_script = other1001.post_snapshot_script;
  is_compressed_by_packer = other1001.is_compressed_by_packer;
  excluded_paths = other1001.excluded_paths;
  previous_excluded_paths = other1001.previous_excluded_paths;
  checksum_target = other1001.checksum_target;
  __isset = other1001.__isset;
}
replica_job_create_detail& replica_job_create_detail::operator=(const replica_job_create_detail& other1002) {
  host = other1002.host;
  addr = other1002.addr;
  username = other1002.username;
  password = other1002.password;
  type = other1002.type;
  virtual_machine_id = other1002.virtual_machine_id;
  disks = other1002.disks;
  targets = other1002.targets;
  carriers = other1002.carriers;
  full_replicas = other1002.full_replicas;
  disk_ids = other1002.disk_ids;
  cbt_info = other1002.cbt_info;
  snapshot_info = other1002.snapshot_info;
  checksum_verify = other1002.checksum_verify;
  always_retry = other1002.always_retry;
  timeout = other1002.timeout;
  is_encrypted = other1002.is_encrypted;
  is_paused = other1002.is_paused;
  worker_thread_number = other1002.worker_thread_number;
  block_mode_enable = other1002.block_mode_enable;
  file_system_filter_enable = other1002.file_system_filter_enable;
  min_transport_size = other1002.min_transport_size;
  full_min_transport_size = other1002.full_min_transport_size;
  is_full_replica = other1002.is_full_replica;
  buffer_size = other1002.buffer_size;
  is_compressed = other1002.is_compressed;
  is_checksum = other1002.is_checksum;
  time = other1002.time;
  priority_carrier = other1002.priority_carrier;
  is_only_single_system_disk = other1002.is_only_single_system_disk;
  is_continuous_data_replication = other1002.is_continuous_data_replication;
  pre_snapshot_script = other1002.pre_snapshot_script;
  post_snapshot_script = other1002.post_snapshot_script;
  is_compressed_by_packer = other1002.is_compressed_by_packer;
  excluded_paths = other1002.excluded_paths;
  previous_excluded_paths = other1002.previous_excluded_paths;
  checksum_target = other1002.checksum_target;
  __isset = other1002.__isset;
  return *this;
}
void replica_job_create_detail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "replica_job_create_detail(";
  out << "host="; (__isset.host ? (out << to_string(host)) : (out << "<null>"));
  out << ", " << "addr="; (__isset.addr ? (out << to_string(addr)) : (out << "<null>"));
  out << ", " << "username="; (__isset.username ? (out << to_string(username)) : (out << "<null>"));
  out << ", " << "password="; (__isset.password ? (out << to_string(password)) : (out << "<null>"));
  out << ", " << "type="; (__isset.type ? (out << to_string(type)) : (out << "<null>"));
  out << ", " << "virtual_machine_id="; (__isset.virtual_machine_id ? (out << to_string(virtual_machine_id)) : (out << "<null>"));
  out << ", " << "disks="; (__isset.disks ? (out << to_string(disks)) : (out << "<null>"));
  out << ", " << "targets="; (__isset.targets ? (out << to_string(targets)) : (out << "<null>"));
  out << ", " << "carriers="; (__isset.carriers ? (out << to_string(carriers)) : (out << "<null>"));
  out << ", " << "full_replicas="; (__isset.full_replicas ? (out << to_string(full_replicas)) : (out << "<null>"));
  out << ", " << "disk_ids="; (__isset.disk_ids ? (out << to_string(disk_ids)) : (out << "<null>"));
  out << ", " << "cbt_info="; (__isset.cbt_info ? (out << to_string(cbt_info)) : (out << "<null>"));
  out << ", " << "snapshot_info="; (__isset.snapshot_info ? (out << to_string(snapshot_info)) : (out << "<null>"));
  out << ", " << "checksum_verify="; (__isset.checksum_verify ? (out << to_string(checksum_verify)) : (out << "<null>"));
  out << ", " << "always_retry="; (__isset.always_retry ? (out << to_string(always_retry)) : (out << "<null>"));
  out << ", " << "timeout="; (__isset.timeout ? (out << to_string(timeout)) : (out << "<null>"));
  out << ", " << "is_encrypted="; (__isset.is_encrypted ? (out << to_string(is_encrypted)) : (out << "<null>"));
  out << ", " << "is_paused="; (__isset.is_paused ? (out << to_string(is_paused)) : (out << "<null>"));
  out << ", " << "worker_thread_number="; (__isset.worker_thread_number ? (out << to_string(worker_thread_number)) : (out << "<null>"));
  out << ", " << "block_mode_enable="; (__isset.block_mode_enable ? (out << to_string(block_mode_enable)) : (out << "<null>"));
  out << ", " << "file_system_filter_enable="; (__isset.file_system_filter_enable ? (out << to_string(file_system_filter_enable)) : (out << "<null>"));
  out << ", " << "min_transport_size="; (__isset.min_transport_size ? (out << to_string(min_transport_size)) : (out << "<null>"));
  out << ", " << "full_min_transport_size="; (__isset.full_min_transport_size ? (out << to_string(full_min_transport_size)) : (out << "<null>"));
  out << ", " << "is_full_replica="; (__isset.is_full_replica ? (out << to_string(is_full_replica)) : (out << "<null>"));
  out << ", " << "buffer_size="; (__isset.buffer_size ? (out << to_string(buffer_size)) : (out << "<null>"));
  out << ", " << "is_compressed="; (__isset.is_compressed ? (out << to_string(is_compressed)) : (out << "<null>"));
  out << ", " << "is_checksum="; (__isset.is_checksum ? (out << to_string(is_checksum)) : (out << "<null>"));
  out << ", " << "time="; (__isset.time ? (out << to_string(time)) : (out << "<null>"));
  out << ", " << "priority_carrier="; (__isset.priority_carrier ? (out << to_string(priority_carrier)) : (out << "<null>"));
  out << ", " << "is_only_single_system_disk="; (__isset.is_only_single_system_disk ? (out << to_string(is_only_single_system_disk)) : (out << "<null>"));
  out << ", " << "is_continuous_data_replication="; (__isset.is_continuous_data_replication ? (out << to_string(is_continuous_data_replication)) : (out << "<null>"));
  out << ", " << "pre_snapshot_script="; (__isset.pre_snapshot_script ? (out << to_string(pre_snapshot_script)) : (out << "<null>"));
  out << ", " << "post_snapshot_script="; (__isset.post_snapshot_script ? (out << to_string(post_snapshot_script)) : (out << "<null>"));
  out << ", " << "is_compressed_by_packer="; (__isset.is_compressed_by_packer ? (out << to_string(is_compressed_by_packer)) : (out << "<null>"));
  out << ", " << "excluded_paths="; (__isset.excluded_paths ? (out << to_string(excluded_paths)) : (out << "<null>"));
  out << ", " << "previous_excluded_paths="; (__isset.previous_excluded_paths ? (out << to_string(previous_excluded_paths)) : (out << "<null>"));
  out << ", " << "checksum_target="; (__isset.checksum_target ? (out << to_string(checksum_target)) : (out << "<null>"));
  out << ")";
}


vmware_connection_info::~vmware_connection_info() throw() {
}


void vmware_connection_info::__set_host(const std::string& val) {
  this->host = val;
__isset.host = true;
}

void vmware_connection_info::__set_username(const std::string& val) {
  this->username = val;
__isset.username = true;
}

void vmware_connection_info::__set_password(const std::string& val) {
  this->password = val;
__isset.password = true;
}

void vmware_connection_info::__set_esx(const std::string& val) {
  this->esx = val;
__isset.esx = true;
}

void vmware_connection_info::__set_datastore(const std::string& val) {
  this->datastore = val;
__isset.datastore = true;
}

void vmware_connection_info::__set_folder_path(const std::string& val) {
  this->folder_path = val;
__isset.folder_path = true;
}
std::ostream& operator<<(std::ostream& out, const vmware_connection_info& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t vmware_connection_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host);
          this->__isset.host = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->username);
          this->__isset.username = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->password);
          this->__isset.password = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->esx);
          this->__isset.esx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->datastore);
          this->__isset.datastore = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->folder_path);
          this->__isset.folder_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t vmware_connection_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("vmware_connection_info");

  if (this->__isset.host) {
    xfer += oprot->writeFieldBegin("host", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->host);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.username) {
    xfer += oprot->writeFieldBegin("username", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->username);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.password) {
    xfer += oprot->writeFieldBegin("password", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->password);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.esx) {
    xfer += oprot->writeFieldBegin("esx", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->esx);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.datastore) {
    xfer += oprot->writeFieldBegin("datastore", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->datastore);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.folder_path) {
    xfer += oprot->writeFieldBegin("folder_path", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->folder_path);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(vmware_connection_info &a, vmware_connection_info &b) {
  using ::std::swap;
  swap(a.host, b.host);
  swap(a.username, b.username);
  swap(a.password, b.password);
  swap(a.esx, b.esx);
  swap(a.datastore, b.datastore);
  swap(a.folder_path, b.folder_path);
  swap(a.__isset, b.__isset);
}

vmware_connection_info::vmware_connection_info(const vmware_connection_info& other1003) {
  host = other1003.host;
  username = other1003.username;
  password = other1003.password;
  esx = other1003.esx;
  datastore = other1003.datastore;
  folder_path = other1003.folder_path;
  __isset = other1003.__isset;
}
vmware_connection_info& vmware_connection_info::operator=(const vmware_connection_info& other1004) {
  host = other1004.host;
  username = other1004.username;
  password = other1004.password;
  esx = other1004.esx;
  datastore = other1004.datastore;
  folder_path = other1004.folder_path;
  __isset = other1004.__isset;
  return *this;
}
void vmware_connection_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "vmware_connection_info(";
  out << "host="; (__isset.host ? (out << to_string(host)) : (out << "<null>"));
  out << ", " << "username="; (__isset.username ? (out << to_string(username)) : (out << "<null>"));
  out << ", " << "password="; (__isset.password ? (out << to_string(password)) : (out << "<null>"));
  out << ", " << "esx="; (__isset.esx ? (out << to_string(esx)) : (out << "<null>"));
  out << ", " << "datastore="; (__isset.datastore ? (out << to_string(datastore)) : (out << "<null>"));
  out << ", " << "folder_path="; (__isset.folder_path ? (out << to_string(folder_path)) : (out << "<null>"));
  out << ")";
}


vmware_options::~vmware_options() throw() {
}


void vmware_options::__set_connection(const vmware_connection_info& val) {
  this->connection = val;
__isset.connection = true;
}

void vmware_options::__set_virtual_machine_id(const std::string& val) {
  this->virtual_machine_id = val;
__isset.virtual_machine_id = true;
}

void vmware_options::__set_virtual_machine_snapshot(const std::string& val) {
  this->virtual_machine_snapshot = val;
__isset.virtual_machine_snapshot = true;
}

void vmware_options::__set_number_of_cpus(const int32_t val) {
  this->number_of_cpus = val;
__isset.number_of_cpus = true;
}

void vmware_options::__set_number_of_memory_in_mb(const int32_t val) {
  this->number_of_memory_in_mb = val;
__isset.number_of_memory_in_mb = true;
}

void vmware_options::__set_vm_name(const std::string& val) {
  this->vm_name = val;
__isset.vm_name = true;
}

void vmware_options::__set_network_connections(const std::vector<std::string> & val) {
  this->network_connections = val;
__isset.network_connections = true;
}

void vmware_options::__set_network_adapters(const std::vector<std::string> & val) {
  this->network_adapters = val;
__isset.network_adapters = true;
}

void vmware_options::__set_scsi_adapters(const std::map<hv_controller_type::type, std::vector<std::string> > & val) {
  this->scsi_adapters = val;
__isset.scsi_adapters = true;
}

void vmware_options::__set_guest_id(const std::string& val) {
  this->guest_id = val;
__isset.guest_id = true;
}

void vmware_options::__set_firmware(const hv_vm_firmware::type val) {
  this->firmware = val;
__isset.firmware = true;
}

void vmware_options::__set_install_vm_tools(const bool val) {
  this->install_vm_tools = val;
__isset.install_vm_tools = true;
}

void vmware_options::__set_mac_addresses(const std::vector<std::string> & val) {
  this->mac_addresses = val;
__isset.mac_addresses = true;
}
std::ostream& operator<<(std::ostream& out, const vmware_options& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t vmware_options::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->connection.read(iprot);
          this->__isset.connection = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->virtual_machine_id);
          this->__isset.virtual_machine_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->virtual_machine_snapshot);
          this->__isset.virtual_machine_snapshot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->number_of_cpus);
          this->__isset.number_of_cpus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->number_of_memory_in_mb);
          this->__isset.number_of_memory_in_mb = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->vm_name);
          this->__isset.vm_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->network_connections.clear();
            uint32_t _size1005;
            ::apache::thrift::protocol::TType _etype1008;
            xfer += iprot->readListBegin(_etype1008, _size1005);
            this->network_connections.resize(_size1005);
            uint32_t _i1009;
            for (_i1009 = 0; _i1009 < _size1005; ++_i1009)
            {
              xfer += iprot->readString(this->network_connections[_i1009]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.network_connections = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->network_adapters.clear();
            uint32_t _size1010;
            ::apache::thrift::protocol::TType _etype1013;
            xfer += iprot->readListBegin(_etype1013, _size1010);
            this->network_adapters.resize(_size1010);
            uint32_t _i1014;
            for (_i1014 = 0; _i1014 < _size1010; ++_i1014)
            {
              xfer += iprot->readString(this->network_adapters[_i1014]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.network_adapters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->scsi_adapters.clear();
            uint32_t _size1015;
            ::apache::thrift::protocol::TType _ktype1016;
            ::apache::thrift::protocol::TType _vtype1017;
            xfer += iprot->readMapBegin(_ktype1016, _vtype1017, _size1015);
            uint32_t _i1019;
            for (_i1019 = 0; _i1019 < _size1015; ++_i1019)
            {
              hv_controller_type::type _key1020;
              int32_t ecast1022;
              xfer += iprot->readI32(ecast1022);
              _key1020 = (hv_controller_type::type)ecast1022;
              std::vector<std::string> & _val1021 = this->scsi_adapters[_key1020];
              {
                _val1021.clear();
                uint32_t _size1023;
                ::apache::thrift::protocol::TType _etype1026;
                xfer += iprot->readListBegin(_etype1026, _size1023);
                _val1021.resize(_size1023);
                uint32_t _i1027;
                for (_i1027 = 0; _i1027 < _size1023; ++_i1027)
                {
                  xfer += iprot->readString(_val1021[_i1027]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.scsi_adapters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guest_id);
          this->__isset.guest_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1028;
          xfer += iprot->readI32(ecast1028);
          this->firmware = (hv_vm_firmware::type)ecast1028;
          this->__isset.firmware = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->install_vm_tools);
          this->__isset.install_vm_tools = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->mac_addresses.clear();
            uint32_t _size1029;
            ::apache::thrift::protocol::TType _etype1032;
            xfer += iprot->readListBegin(_etype1032, _size1029);
            this->mac_addresses.resize(_size1029);
            uint32_t _i1033;
            for (_i1033 = 0; _i1033 < _size1029; ++_i1033)
            {
              xfer += iprot->readString(this->mac_addresses[_i1033]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.mac_addresses = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t vmware_options::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("vmware_options");

  if (this->__isset.connection) {
    xfer += oprot->writeFieldBegin("connection", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->connection.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.virtual_machine_id) {
    xfer += oprot->writeFieldBegin("virtual_machine_id", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->virtual_machine_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.virtual_machine_snapshot) {
    xfer += oprot->writeFieldBegin("virtual_machine_snapshot", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->virtual_machine_snapshot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.number_of_cpus) {
    xfer += oprot->writeFieldBegin("number_of_cpus", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->number_of_cpus);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.number_of_memory_in_mb) {
    xfer += oprot->writeFieldBegin("number_of_memory_in_mb", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->number_of_memory_in_mb);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vm_name) {
    xfer += oprot->writeFieldBegin("vm_name", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->vm_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.network_connections) {
    xfer += oprot->writeFieldBegin("network_connections", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->network_connections.size()));
      std::vector<std::string> ::const_iterator _iter1034;
      for (_iter1034 = this->network_connections.begin(); _iter1034 != this->network_connections.end(); ++_iter1034)
      {
        xfer += oprot->writeString((*_iter1034));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.network_adapters) {
    xfer += oprot->writeFieldBegin("network_adapters", ::apache::thrift::protocol::T_LIST, 8);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->network_adapters.size()));
      std::vector<std::string> ::const_iterator _iter1035;
      for (_iter1035 = this->network_adapters.begin(); _iter1035 != this->network_adapters.end(); ++_iter1035)
      {
        xfer += oprot->writeString((*_iter1035));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.scsi_adapters) {
    xfer += oprot->writeFieldBegin("scsi_adapters", ::apache::thrift::protocol::T_MAP, 9);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->scsi_adapters.size()));
      std::map<hv_controller_type::type, std::vector<std::string> > ::const_iterator _iter1036;
      for (_iter1036 = this->scsi_adapters.begin(); _iter1036 != this->scsi_adapters.end(); ++_iter1036)
      {
        xfer += oprot->writeI32((int32_t)_iter1036->first);
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter1036->second.size()));
          std::vector<std::string> ::const_iterator _iter1037;
          for (_iter1037 = _iter1036->second.begin(); _iter1037 != _iter1036->second.end(); ++_iter1037)
          {
            xfer += oprot->writeString((*_iter1037));
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.guest_id) {
    xfer += oprot->writeFieldBegin("guest_id", ::apache::thrift::protocol::T_STRING, 10);
    xfer += oprot->writeString(this->guest_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.firmware) {
    xfer += oprot->writeFieldBegin("firmware", ::apache::thrift::protocol::T_I32, 11);
    xfer += oprot->writeI32((int32_t)this->firmware);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.install_vm_tools) {
    xfer += oprot->writeFieldBegin("install_vm_tools", ::apache::thrift::protocol::T_BOOL, 12);
    xfer += oprot->writeBool(this->install_vm_tools);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mac_addresses) {
    xfer += oprot->writeFieldBegin("mac_addresses", ::apache::thrift::protocol::T_LIST, 13);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->mac_addresses.size()));
      std::vector<std::string> ::const_iterator _iter1038;
      for (_iter1038 = this->mac_addresses.begin(); _iter1038 != this->mac_addresses.end(); ++_iter1038)
      {
        xfer += oprot->writeString((*_iter1038));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(vmware_options &a, vmware_options &b) {
  using ::std::swap;
  swap(a.connection, b.connection);
  swap(a.virtual_machine_id, b.virtual_machine_id);
  swap(a.virtual_machine_snapshot, b.virtual_machine_snapshot);
  swap(a.number_of_cpus, b.number_of_cpus);
  swap(a.number_of_memory_in_mb, b.number_of_memory_in_mb);
  swap(a.vm_name, b.vm_name);
  swap(a.network_connections, b.network_connections);
  swap(a.network_adapters, b.network_adapters);
  swap(a.scsi_adapters, b.scsi_adapters);
  swap(a.guest_id, b.guest_id);
  swap(a.firmware, b.firmware);
  swap(a.install_vm_tools, b.install_vm_tools);
  swap(a.mac_addresses, b.mac_addresses);
  swap(a.__isset, b.__isset);
}

vmware_options::vmware_options(const vmware_options& other1039) {
  connection = other1039.connection;
  virtual_machine_id = other1039.virtual_machine_id;
  virtual_machine_snapshot = other1039.virtual_machine_snapshot;
  number_of_cpus = other1039.number_of_cpus;
  number_of_memory_in_mb = other1039.number_of_memory_in_mb;
  vm_name = other1039.vm_name;
  network_connections = other1039.network_connections;
  network_adapters = other1039.network_adapters;
  scsi_adapters = other1039.scsi_adapters;
  guest_id = other1039.guest_id;
  firmware = other1039.firmware;
  install_vm_tools = other1039.install_vm_tools;
  mac_addresses = other1039.mac_addresses;
  __isset = other1039.__isset;
}
vmware_options& vmware_options::operator=(const vmware_options& other1040) {
  connection = other1040.connection;
  virtual_machine_id = other1040.virtual_machine_id;
  virtual_machine_snapshot = other1040.virtual_machine_snapshot;
  number_of_cpus = other1040.number_of_cpus;
  number_of_memory_in_mb = other1040.number_of_memory_in_mb;
  vm_name = other1040.vm_name;
  network_connections = other1040.network_connections;
  network_adapters = other1040.network_adapters;
  scsi_adapters = other1040.scsi_adapters;
  guest_id = other1040.guest_id;
  firmware = other1040.firmware;
  install_vm_tools = other1040.install_vm_tools;
  mac_addresses = other1040.mac_addresses;
  __isset = other1040.__isset;
  return *this;
}
void vmware_options::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "vmware_options(";
  out << "connection="; (__isset.connection ? (out << to_string(connection)) : (out << "<null>"));
  out << ", " << "virtual_machine_id="; (__isset.virtual_machine_id ? (out << to_string(virtual_machine_id)) : (out << "<null>"));
  out << ", " << "virtual_machine_snapshot="; (__isset.virtual_machine_snapshot ? (out << to_string(virtual_machine_snapshot)) : (out << "<null>"));
  out << ", " << "number_of_cpus="; (__isset.number_of_cpus ? (out << to_string(number_of_cpus)) : (out << "<null>"));
  out << ", " << "number_of_memory_in_mb="; (__isset.number_of_memory_in_mb ? (out << to_string(number_of_memory_in_mb)) : (out << "<null>"));
  out << ", " << "vm_name="; (__isset.vm_name ? (out << to_string(vm_name)) : (out << "<null>"));
  out << ", " << "network_connections="; (__isset.network_connections ? (out << to_string(network_connections)) : (out << "<null>"));
  out << ", " << "network_adapters="; (__isset.network_adapters ? (out << to_string(network_adapters)) : (out << "<null>"));
  out << ", " << "scsi_adapters="; (__isset.scsi_adapters ? (out << to_string(scsi_adapters)) : (out << "<null>"));
  out << ", " << "guest_id="; (__isset.guest_id ? (out << to_string(guest_id)) : (out << "<null>"));
  out << ", " << "firmware="; (__isset.firmware ? (out << to_string(firmware)) : (out << "<null>"));
  out << ", " << "install_vm_tools="; (__isset.install_vm_tools ? (out << to_string(install_vm_tools)) : (out << "<null>"));
  out << ", " << "mac_addresses="; (__isset.mac_addresses ? (out << to_string(mac_addresses)) : (out << "<null>"));
  out << ")";
}


aliyun_options::~aliyun_options() throw() {
}


void aliyun_options::__set_access_key(const std::string& val) {
  this->access_key = val;
__isset.access_key = true;
}

void aliyun_options::__set_secret_key(const std::string& val) {
  this->secret_key = val;
__isset.secret_key = true;
}

void aliyun_options::__set_objectname(const std::string& val) {
  this->objectname = val;
__isset.objectname = true;
}

void aliyun_options::__set_bucketname(const std::string& val) {
  this->bucketname = val;
__isset.bucketname = true;
}

void aliyun_options::__set_region(const std::string& val) {
  this->region = val;
__isset.region = true;
}

void aliyun_options::__set_max_size(const int32_t val) {
  this->max_size = val;
__isset.max_size = true;
}

void aliyun_options::__set_file_system_filter_enable(const bool val) {
  this->file_system_filter_enable = val;
__isset.file_system_filter_enable = true;
}

void aliyun_options::__set_number_of_upload_threads(const int16_t val) {
  this->number_of_upload_threads = val;
__isset.number_of_upload_threads = true;
}

void aliyun_options::__set_disks_object_name_mapping(const std::map<std::string, std::string> & val) {
  this->disks_object_name_mapping = val;
__isset.disks_object_name_mapping = true;
}
std::ostream& operator<<(std::ostream& out, const aliyun_options& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t aliyun_options::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->access_key);
          this->__isset.access_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->secret_key);
          this->__isset.secret_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->objectname);
          this->__isset.objectname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->bucketname);
          this->__isset.bucketname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->region);
          this->__isset.region = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->max_size);
          this->__isset.max_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->file_system_filter_enable);
          this->__isset.file_system_filter_enable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->number_of_upload_threads);
          this->__isset.number_of_upload_threads = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->disks_object_name_mapping.clear();
            uint32_t _size1041;
            ::apache::thrift::protocol::TType _ktype1042;
            ::apache::thrift::protocol::TType _vtype1043;
            xfer += iprot->readMapBegin(_ktype1042, _vtype1043, _size1041);
            uint32_t _i1045;
            for (_i1045 = 0; _i1045 < _size1041; ++_i1045)
            {
              std::string _key1046;
              xfer += iprot->readString(_key1046);
              std::string& _val1047 = this->disks_object_name_mapping[_key1046];
              xfer += iprot->readString(_val1047);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.disks_object_name_mapping = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t aliyun_options::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("aliyun_options");

  if (this->__isset.access_key) {
    xfer += oprot->writeFieldBegin("access_key", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->access_key);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.secret_key) {
    xfer += oprot->writeFieldBegin("secret_key", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->secret_key);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.objectname) {
    xfer += oprot->writeFieldBegin("objectname", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->objectname);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.bucketname) {
    xfer += oprot->writeFieldBegin("bucketname", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->bucketname);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.region) {
    xfer += oprot->writeFieldBegin("region", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->region);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.max_size) {
    xfer += oprot->writeFieldBegin("max_size", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(this->max_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.file_system_filter_enable) {
    xfer += oprot->writeFieldBegin("file_system_filter_enable", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->file_system_filter_enable);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.number_of_upload_threads) {
    xfer += oprot->writeFieldBegin("number_of_upload_threads", ::apache::thrift::protocol::T_I16, 8);
    xfer += oprot->writeI16(this->number_of_upload_threads);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.disks_object_name_mapping) {
    xfer += oprot->writeFieldBegin("disks_object_name_mapping", ::apache::thrift::protocol::T_MAP, 9);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->disks_object_name_mapping.size()));
      std::map<std::string, std::string> ::const_iterator _iter1048;
      for (_iter1048 = this->disks_object_name_mapping.begin(); _iter1048 != this->disks_object_name_mapping.end(); ++_iter1048)
      {
        xfer += oprot->writeString(_iter1048->first);
        xfer += oprot->writeString(_iter1048->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(aliyun_options &a, aliyun_options &b) {
  using ::std::swap;
  swap(a.access_key, b.access_key);
  swap(a.secret_key, b.secret_key);
  swap(a.objectname, b.objectname);
  swap(a.bucketname, b.bucketname);
  swap(a.region, b.region);
  swap(a.max_size, b.max_size);
  swap(a.file_system_filter_enable, b.file_system_filter_enable);
  swap(a.number_of_upload_threads, b.number_of_upload_threads);
  swap(a.disks_object_name_mapping, b.disks_object_name_mapping);
  swap(a.__isset, b.__isset);
}

aliyun_options::aliyun_options(const aliyun_options& other1049) {
  access_key = other1049.access_key;
  secret_key = other1049.secret_key;
  objectname = other1049.objectname;
  bucketname = other1049.bucketname;
  region = other1049.region;
  max_size = other1049.max_size;
  file_system_filter_enable = other1049.file_system_filter_enable;
  number_of_upload_threads = other1049.number_of_upload_threads;
  disks_object_name_mapping = other1049.disks_object_name_mapping;
  __isset = other1049.__isset;
}
aliyun_options& aliyun_options::operator=(const aliyun_options& other1050) {
  access_key = other1050.access_key;
  secret_key = other1050.secret_key;
  objectname = other1050.objectname;
  bucketname = other1050.bucketname;
  region = other1050.region;
  max_size = other1050.max_size;
  file_system_filter_enable = other1050.file_system_filter_enable;
  number_of_upload_threads = other1050.number_of_upload_threads;
  disks_object_name_mapping = other1050.disks_object_name_mapping;
  __isset = other1050.__isset;
  return *this;
}
void aliyun_options::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "aliyun_options(";
  out << "access_key="; (__isset.access_key ? (out << to_string(access_key)) : (out << "<null>"));
  out << ", " << "secret_key="; (__isset.secret_key ? (out << to_string(secret_key)) : (out << "<null>"));
  out << ", " << "objectname="; (__isset.objectname ? (out << to_string(objectname)) : (out << "<null>"));
  out << ", " << "bucketname="; (__isset.bucketname ? (out << to_string(bucketname)) : (out << "<null>"));
  out << ", " << "region="; (__isset.region ? (out << to_string(region)) : (out << "<null>"));
  out << ", " << "max_size="; (__isset.max_size ? (out << to_string(max_size)) : (out << "<null>"));
  out << ", " << "file_system_filter_enable="; (__isset.file_system_filter_enable ? (out << to_string(file_system_filter_enable)) : (out << "<null>"));
  out << ", " << "number_of_upload_threads="; (__isset.number_of_upload_threads ? (out << to_string(number_of_upload_threads)) : (out << "<null>"));
  out << ", " << "disks_object_name_mapping="; (__isset.disks_object_name_mapping ? (out << to_string(disks_object_name_mapping)) : (out << "<null>"));
  out << ")";
}


tencent_options::~tencent_options() throw() {
}


void tencent_options::__set_access_key(const std::string& val) {
  this->access_key = val;
__isset.access_key = true;
}

void tencent_options::__set_secret_key(const std::string& val) {
  this->secret_key = val;
__isset.secret_key = true;
}

void tencent_options::__set_objectname(const std::string& val) {
  this->objectname = val;
__isset.objectname = true;
}

void tencent_options::__set_bucketname(const std::string& val) {
  this->bucketname = val;
__isset.bucketname = true;
}

void tencent_options::__set_region(const std::string& val) {
  this->region = val;
__isset.region = true;
}

void tencent_options::__set_max_size(const int32_t val) {
  this->max_size = val;
__isset.max_size = true;
}

void tencent_options::__set_file_system_filter_enable(const bool val) {
  this->file_system_filter_enable = val;
__isset.file_system_filter_enable = true;
}

void tencent_options::__set_number_of_upload_threads(const int16_t val) {
  this->number_of_upload_threads = val;
__isset.number_of_upload_threads = true;
}

void tencent_options::__set_disks_object_name_mapping(const std::map<std::string, std::string> & val) {
  this->disks_object_name_mapping = val;
__isset.disks_object_name_mapping = true;
}
std::ostream& operator<<(std::ostream& out, const tencent_options& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t tencent_options::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->access_key);
          this->__isset.access_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->secret_key);
          this->__isset.secret_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->objectname);
          this->__isset.objectname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->bucketname);
          this->__isset.bucketname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->region);
          this->__isset.region = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->max_size);
          this->__isset.max_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->file_system_filter_enable);
          this->__isset.file_system_filter_enable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->number_of_upload_threads);
          this->__isset.number_of_upload_threads = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->disks_object_name_mapping.clear();
            uint32_t _size1051;
            ::apache::thrift::protocol::TType _ktype1052;
            ::apache::thrift::protocol::TType _vtype1053;
            xfer += iprot->readMapBegin(_ktype1052, _vtype1053, _size1051);
            uint32_t _i1055;
            for (_i1055 = 0; _i1055 < _size1051; ++_i1055)
            {
              std::string _key1056;
              xfer += iprot->readString(_key1056);
              std::string& _val1057 = this->disks_object_name_mapping[_key1056];
              xfer += iprot->readString(_val1057);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.disks_object_name_mapping = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t tencent_options::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("tencent_options");

  if (this->__isset.access_key) {
    xfer += oprot->writeFieldBegin("access_key", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->access_key);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.secret_key) {
    xfer += oprot->writeFieldBegin("secret_key", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->secret_key);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.objectname) {
    xfer += oprot->writeFieldBegin("objectname", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->objectname);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.bucketname) {
    xfer += oprot->writeFieldBegin("bucketname", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->bucketname);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.region) {
    xfer += oprot->writeFieldBegin("region", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->region);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.max_size) {
    xfer += oprot->writeFieldBegin("max_size", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(this->max_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.file_system_filter_enable) {
    xfer += oprot->writeFieldBegin("file_system_filter_enable", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->file_system_filter_enable);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.number_of_upload_threads) {
    xfer += oprot->writeFieldBegin("number_of_upload_threads", ::apache::thrift::protocol::T_I16, 8);
    xfer += oprot->writeI16(this->number_of_upload_threads);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.disks_object_name_mapping) {
    xfer += oprot->writeFieldBegin("disks_object_name_mapping", ::apache::thrift::protocol::T_MAP, 9);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->disks_object_name_mapping.size()));
      std::map<std::string, std::string> ::const_iterator _iter1058;
      for (_iter1058 = this->disks_object_name_mapping.begin(); _iter1058 != this->disks_object_name_mapping.end(); ++_iter1058)
      {
        xfer += oprot->writeString(_iter1058->first);
        xfer += oprot->writeString(_iter1058->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(tencent_options &a, tencent_options &b) {
  using ::std::swap;
  swap(a.access_key, b.access_key);
  swap(a.secret_key, b.secret_key);
  swap(a.objectname, b.objectname);
  swap(a.bucketname, b.bucketname);
  swap(a.region, b.region);
  swap(a.max_size, b.max_size);
  swap(a.file_system_filter_enable, b.file_system_filter_enable);
  swap(a.number_of_upload_threads, b.number_of_upload_threads);
  swap(a.disks_object_name_mapping, b.disks_object_name_mapping);
  swap(a.__isset, b.__isset);
}

tencent_options::tencent_options(const tencent_options& other1059) {
  access_key = other1059.access_key;
  secret_key = other1059.secret_key;
  objectname = other1059.objectname;
  bucketname = other1059.bucketname;
  region = other1059.region;
  max_size = other1059.max_size;
  file_system_filter_enable = other1059.file_system_filter_enable;
  number_of_upload_threads = other1059.number_of_upload_threads;
  disks_object_name_mapping = other1059.disks_object_name_mapping;
  __isset = other1059.__isset;
}
tencent_options& tencent_options::operator=(const tencent_options& other1060) {
  access_key = other1060.access_key;
  secret_key = other1060.secret_key;
  objectname = other1060.objectname;
  bucketname = other1060.bucketname;
  region = other1060.region;
  max_size = other1060.max_size;
  file_system_filter_enable = other1060.file_system_filter_enable;
  number_of_upload_threads = other1060.number_of_upload_threads;
  disks_object_name_mapping = other1060.disks_object_name_mapping;
  __isset = other1060.__isset;
  return *this;
}
void tencent_options::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "tencent_options(";
  out << "access_key="; (__isset.access_key ? (out << to_string(access_key)) : (out << "<null>"));
  out << ", " << "secret_key="; (__isset.secret_key ? (out << to_string(secret_key)) : (out << "<null>"));
  out << ", " << "objectname="; (__isset.objectname ? (out << to_string(objectname)) : (out << "<null>"));
  out << ", " << "bucketname="; (__isset.bucketname ? (out << to_string(bucketname)) : (out << "<null>"));
  out << ", " << "region="; (__isset.region ? (out << to_string(region)) : (out << "<null>"));
  out << ", " << "max_size="; (__isset.max_size ? (out << to_string(max_size)) : (out << "<null>"));
  out << ", " << "file_system_filter_enable="; (__isset.file_system_filter_enable ? (out << to_string(file_system_filter_enable)) : (out << "<null>"));
  out << ", " << "number_of_upload_threads="; (__isset.number_of_upload_threads ? (out << to_string(number_of_upload_threads)) : (out << "<null>"));
  out << ", " << "disks_object_name_mapping="; (__isset.disks_object_name_mapping ? (out << to_string(disks_object_name_mapping)) : (out << "<null>"));
  out << ")";
}


extra_options::~extra_options() throw() {
}


void extra_options::__set_aliyun(const aliyun_options& val) {
  this->aliyun = val;
__isset.aliyun = true;
}

void extra_options::__set_tencent(const tencent_options& val) {
  this->tencent = val;
__isset.tencent = true;
}
std::ostream& operator<<(std::ostream& out, const extra_options& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t extra_options::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->aliyun.read(iprot);
          this->__isset.aliyun = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tencent.read(iprot);
          this->__isset.tencent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t extra_options::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("extra_options");

  if (this->__isset.aliyun) {
    xfer += oprot->writeFieldBegin("aliyun", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->aliyun.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tencent) {
    xfer += oprot->writeFieldBegin("tencent", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->tencent.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(extra_options &a, extra_options &b) {
  using ::std::swap;
  swap(a.aliyun, b.aliyun);
  swap(a.tencent, b.tencent);
  swap(a.__isset, b.__isset);
}

extra_options::extra_options(const extra_options& other1061) {
  aliyun = other1061.aliyun;
  tencent = other1061.tencent;
  __isset = other1061.__isset;
}
extra_options& extra_options::operator=(const extra_options& other1062) {
  aliyun = other1062.aliyun;
  tencent = other1062.tencent;
  __isset = other1062.__isset;
  return *this;
}
void extra_options::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "extra_options(";
  out << "aliyun="; (__isset.aliyun ? (out << to_string(aliyun)) : (out << "<null>"));
  out << ", " << "tencent="; (__isset.tencent ? (out << to_string(tencent)) : (out << "<null>"));
  out << ")";
}


vhd_snapshot::~vhd_snapshot() throw() {
}


void vhd_snapshot::__set_id(const std::string& val) {
  this->id = val;
__isset.id = true;
}

void vhd_snapshot::__set_datetime(const std::string& val) {
  this->datetime = val;
__isset.datetime = true;
}

void vhd_snapshot::__set_name(const std::string& val) {
  this->name = val;
__isset.name = true;
}
std::ostream& operator<<(std::ostream& out, const vhd_snapshot& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t vhd_snapshot::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->datetime);
          this->__isset.datetime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t vhd_snapshot::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("vhd_snapshot");

  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.datetime) {
    xfer += oprot->writeFieldBegin("datetime", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->datetime);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(vhd_snapshot &a, vhd_snapshot &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.datetime, b.datetime);
  swap(a.name, b.name);
  swap(a.__isset, b.__isset);
}

vhd_snapshot::vhd_snapshot(const vhd_snapshot& other1063) {
  id = other1063.id;
  datetime = other1063.datetime;
  name = other1063.name;
  __isset = other1063.__isset;
}
vhd_snapshot& vhd_snapshot::operator=(const vhd_snapshot& other1064) {
  id = other1064.id;
  datetime = other1064.datetime;
  name = other1064.name;
  __isset = other1064.__isset;
  return *this;
}
void vhd_snapshot::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "vhd_snapshot(";
  out << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "datetime="; (__isset.datetime ? (out << to_string(datetime)) : (out << "<null>"));
  out << ", " << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
  out << ")";
}


cascading::~cascading() throw() {
}


void cascading::__set_level(const int32_t val) {
  this->level = val;
__isset.level = true;
}

void cascading::__set_machine_id(const std::string& val) {
  this->machine_id = val;
__isset.machine_id = true;
}

void cascading::__set_connection_info(const connection& val) {
  this->connection_info = val;
__isset.connection_info = true;
}

void cascading::__set_branches(const std::map<std::string, cascading> & val) {
  this->branches = val;
__isset.branches = true;
}
std::ostream& operator<<(std::ostream& out, const cascading& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t cascading::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->level);
          this->__isset.level = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->machine_id);
          this->__isset.machine_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->connection_info.read(iprot);
          this->__isset.connection_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->branches.clear();
            uint32_t _size1065;
            ::apache::thrift::protocol::TType _ktype1066;
            ::apache::thrift::protocol::TType _vtype1067;
            xfer += iprot->readMapBegin(_ktype1066, _vtype1067, _size1065);
            uint32_t _i1069;
            for (_i1069 = 0; _i1069 < _size1065; ++_i1069)
            {
              std::string _key1070;
              xfer += iprot->readString(_key1070);
              cascading& _val1071 = this->branches[_key1070];
              xfer += _val1071.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.branches = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t cascading::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("cascading");

  if (this->__isset.level) {
    xfer += oprot->writeFieldBegin("level", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->level);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.machine_id) {
    xfer += oprot->writeFieldBegin("machine_id", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->machine_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.connection_info) {
    xfer += oprot->writeFieldBegin("connection_info", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->connection_info.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.branches) {
    xfer += oprot->writeFieldBegin("branches", ::apache::thrift::protocol::T_MAP, 4);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->branches.size()));
      std::map<std::string, cascading> ::const_iterator _iter1072;
      for (_iter1072 = this->branches.begin(); _iter1072 != this->branches.end(); ++_iter1072)
      {
        xfer += oprot->writeString(_iter1072->first);
        xfer += _iter1072->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(cascading &a, cascading &b) {
  using ::std::swap;
  swap(a.level, b.level);
  swap(a.machine_id, b.machine_id);
  swap(a.connection_info, b.connection_info);
  swap(a.branches, b.branches);
  swap(a.__isset, b.__isset);
}

cascading::cascading(const cascading& other1073) {
  level = other1073.level;
  machine_id = other1073.machine_id;
  connection_info = other1073.connection_info;
  branches = other1073.branches;
  __isset = other1073.__isset;
}
cascading& cascading::operator=(const cascading& other1074) {
  level = other1074.level;
  machine_id = other1074.machine_id;
  connection_info = other1074.connection_info;
  branches = other1074.branches;
  __isset = other1074.__isset;
  return *this;
}
void cascading::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "cascading(";
  out << "level="; (__isset.level ? (out << to_string(level)) : (out << "<null>"));
  out << ", " << "machine_id="; (__isset.machine_id ? (out << to_string(machine_id)) : (out << "<null>"));
  out << ", " << "connection_info="; (__isset.connection_info ? (out << to_string(connection_info)) : (out << "<null>"));
  out << ", " << "branches="; (__isset.branches ? (out << to_string(branches)) : (out << "<null>"));
  out << ")";
}


loader_job_create_detail::~loader_job_create_detail() throw() {
}


void loader_job_create_detail::__set_replica_id(const std::string& val) {
  this->replica_id = val;
__isset.replica_id = true;
}

void loader_job_create_detail::__set_disks_lun_mapping(const std::map<std::string, std::string> & val) {
  this->disks_lun_mapping = val;
__isset.disks_lun_mapping = true;
}

void loader_job_create_detail::__set_snapshots(const std::vector<std::string> & val) {
  this->snapshots = val;
__isset.snapshots = true;
}

void loader_job_create_detail::__set_disks_snapshot_mapping(const std::map<std::string, std::map<std::string, std::string> > & val) {
  this->disks_snapshot_mapping = val;
__isset.disks_snapshot_mapping = true;
}

void loader_job_create_detail::__set_connection_id(const std::string& val) {
  this->connection_id = val;
__isset.connection_id = true;
}

void loader_job_create_detail::__set_block_mode_enable(const bool val) {
  this->block_mode_enable = val;
__isset.block_mode_enable = true;
}

void loader_job_create_detail::__set_purge_data(const bool val) {
  this->purge_data = val;
__isset.purge_data = true;
}

void loader_job_create_detail::__set_remap(const bool val) {
  this->remap = val;
__isset.remap = true;
}

void loader_job_create_detail::__set_detect_type(const disk_detect_type::type val) {
  this->detect_type = val;
__isset.detect_type = true;
}

void loader_job_create_detail::__set_worker_thread_number(const int32_t val) {
  this->worker_thread_number = val;
__isset.worker_thread_number = true;
}

void loader_job_create_detail::__set_host_name(const std::string& val) {
  this->host_name = val;
__isset.host_name = true;
}

void loader_job_create_detail::__set_export_disk_type(const virtual_disk_type::type val) {
  this->export_disk_type = val;
__isset.export_disk_type = true;
}

void loader_job_create_detail::__set_export_path(const std::string& val) {
  this->export_path = val;
__isset.export_path = true;
}

void loader_job_create_detail::__set_disks_size_mapping(const std::map<std::string, int64_t> & val) {
  this->disks_size_mapping = val;
__isset.disks_size_mapping = true;
}

void loader_job_create_detail::__set_keep_alive(const bool val) {
  this->keep_alive = val;
__isset.keep_alive = true;
}

void loader_job_create_detail::__set_time(const std::string& val) {
  this->time = val;
__isset.time = true;
}

void loader_job_create_detail::__set_is_continuous_data_replication(const bool val) {
  this->is_continuous_data_replication = val;
__isset.is_continuous_data_replication = true;
}

void loader_job_create_detail::__set_azure_storage_connection_string(const std::string& val) {
  this->azure_storage_connection_string = val;
__isset.azure_storage_connection_string = true;
}

void loader_job_create_detail::__set_vmware_connection(const vmware_connection_info& val) {
  this->vmware_connection = val;
__isset.vmware_connection = true;
}

void loader_job_create_detail::__set_thin_provisioned(const bool val) {
  this->thin_provisioned = val;
__isset.thin_provisioned = true;
}

void loader_job_create_detail::__set_is_paused(const bool val) {
  this->is_paused = val;
__isset.is_paused = true;
}

void loader_job_create_detail::__set_cascadings(const cascading& val) {
  this->cascadings = val;
__isset.cascadings = true;
}

void loader_job_create_detail::__set_post_snapshot_script(const std::string& val) {
  this->post_snapshot_script = val;
__isset.post_snapshot_script = true;
}

void loader_job_create_detail::__set_disks_order(const std::vector<std::string> & val) {
  this->disks_order = val;
__isset.disks_order = true;
}
std::ostream& operator<<(std::ostream& out, const loader_job_create_detail& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t loader_job_create_detail::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->replica_id);
          this->__isset.replica_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->disks_lun_mapping.clear();
            uint32_t _size1075;
            ::apache::thrift::protocol::TType _ktype1076;
            ::apache::thrift::protocol::TType _vtype1077;
            xfer += iprot->readMapBegin(_ktype1076, _vtype1077, _size1075);
            uint32_t _i1079;
            for (_i1079 = 0; _i1079 < _size1075; ++_i1079)
            {
              std::string _key1080;
              xfer += iprot->readString(_key1080);
              std::string& _val1081 = this->disks_lun_mapping[_key1080];
              xfer += iprot->readString(_val1081);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.disks_lun_mapping = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->snapshots.clear();
            uint32_t _size1082;
            ::apache::thrift::protocol::TType _etype1085;
            xfer += iprot->readListBegin(_etype1085, _size1082);
            this->snapshots.resize(_size1082);
            uint32_t _i1086;
            for (_i1086 = 0; _i1086 < _size1082; ++_i1086)
            {
              xfer += iprot->readString(this->snapshots[_i1086]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.snapshots = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->disks_snapshot_mapping.clear();
            uint32_t _size1087;
            ::apache::thrift::protocol::TType _ktype1088;
            ::apache::thrift::protocol::TType _vtype1089;
            xfer += iprot->readMapBegin(_ktype1088, _vtype1089, _size1087);
            uint32_t _i1091;
            for (_i1091 = 0; _i1091 < _size1087; ++_i1091)
            {
              std::string _key1092;
              xfer += iprot->readString(_key1092);
              std::map<std::string, std::string> & _val1093 = this->disks_snapshot_mapping[_key1092];
              {
                _val1093.clear();
                uint32_t _size1094;
                ::apache::thrift::protocol::TType _ktype1095;
                ::apache::thrift::protocol::TType _vtype1096;
                xfer += iprot->readMapBegin(_ktype1095, _vtype1096, _size1094);
                uint32_t _i1098;
                for (_i1098 = 0; _i1098 < _size1094; ++_i1098)
                {
                  std::string _key1099;
                  xfer += iprot->readString(_key1099);
                  std::string& _val1100 = _val1093[_key1099];
                  xfer += iprot->readString(_val1100);
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.disks_snapshot_mapping = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->connection_id);
          this->__isset.connection_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->block_mode_enable);
          this->__isset.block_mode_enable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->purge_data);
          this->__isset.purge_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->remap);
          this->__isset.remap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1101;
          xfer += iprot->readI32(ecast1101);
          this->detect_type = (disk_detect_type::type)ecast1101;
          this->__isset.detect_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->worker_thread_number);
          this->__isset.worker_thread_number = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host_name);
          this->__isset.host_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1102;
          xfer += iprot->readI32(ecast1102);
          this->export_disk_type = (virtual_disk_type::type)ecast1102;
          this->__isset.export_disk_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->export_path);
          this->__isset.export_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->disks_size_mapping.clear();
            uint32_t _size1103;
            ::apache::thrift::protocol::TType _ktype1104;
            ::apache::thrift::protocol::TType _vtype1105;
            xfer += iprot->readMapBegin(_ktype1104, _vtype1105, _size1103);
            uint32_t _i1107;
            for (_i1107 = 0; _i1107 < _size1103; ++_i1107)
            {
              std::string _key1108;
              xfer += iprot->readString(_key1108);
              int64_t& _val1109 = this->disks_size_mapping[_key1108];
              xfer += iprot->readI64(_val1109);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.disks_size_mapping = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->keep_alive);
          this->__isset.keep_alive = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->time);
          this->__isset.time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_continuous_data_replication);
          this->__isset.is_continuous_data_replication = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->azure_storage_connection_string);
          this->__isset.azure_storage_connection_string = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->vmware_connection.read(iprot);
          this->__isset.vmware_connection = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->thin_provisioned);
          this->__isset.thin_provisioned = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_paused);
          this->__isset.is_paused = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cascadings.read(iprot);
          this->__isset.cascadings = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->post_snapshot_script);
          this->__isset.post_snapshot_script = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->disks_order.clear();
            uint32_t _size1110;
            ::apache::thrift::protocol::TType _etype1113;
            xfer += iprot->readListBegin(_etype1113, _size1110);
            this->disks_order.resize(_size1110);
            uint32_t _i1114;
            for (_i1114 = 0; _i1114 < _size1110; ++_i1114)
            {
              xfer += iprot->readString(this->disks_order[_i1114]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.disks_order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t loader_job_create_detail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("loader_job_create_detail");

  if (this->__isset.replica_id) {
    xfer += oprot->writeFieldBegin("replica_id", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->replica_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.disks_lun_mapping) {
    xfer += oprot->writeFieldBegin("disks_lun_mapping", ::apache::thrift::protocol::T_MAP, 2);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->disks_lun_mapping.size()));
      std::map<std::string, std::string> ::const_iterator _iter1115;
      for (_iter1115 = this->disks_lun_mapping.begin(); _iter1115 != this->disks_lun_mapping.end(); ++_iter1115)
      {
        xfer += oprot->writeString(_iter1115->first);
        xfer += oprot->writeString(_iter1115->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.snapshots) {
    xfer += oprot->writeFieldBegin("snapshots", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->snapshots.size()));
      std::vector<std::string> ::const_iterator _iter1116;
      for (_iter1116 = this->snapshots.begin(); _iter1116 != this->snapshots.end(); ++_iter1116)
      {
        xfer += oprot->writeString((*_iter1116));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.disks_snapshot_mapping) {
    xfer += oprot->writeFieldBegin("disks_snapshot_mapping", ::apache::thrift::protocol::T_MAP, 4);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->disks_snapshot_mapping.size()));
      std::map<std::string, std::map<std::string, std::string> > ::const_iterator _iter1117;
      for (_iter1117 = this->disks_snapshot_mapping.begin(); _iter1117 != this->disks_snapshot_mapping.end(); ++_iter1117)
      {
        xfer += oprot->writeString(_iter1117->first);
        {
          xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter1117->second.size()));
          std::map<std::string, std::string> ::const_iterator _iter1118;
          for (_iter1118 = _iter1117->second.begin(); _iter1118 != _iter1117->second.end(); ++_iter1118)
          {
            xfer += oprot->writeString(_iter1118->first);
            xfer += oprot->writeString(_iter1118->second);
          }
          xfer += oprot->writeMapEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.connection_id) {
    xfer += oprot->writeFieldBegin("connection_id", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->connection_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.block_mode_enable) {
    xfer += oprot->writeFieldBegin("block_mode_enable", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->block_mode_enable);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.purge_data) {
    xfer += oprot->writeFieldBegin("purge_data", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->purge_data);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.remap) {
    xfer += oprot->writeFieldBegin("remap", ::apache::thrift::protocol::T_BOOL, 8);
    xfer += oprot->writeBool(this->remap);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.detect_type) {
    xfer += oprot->writeFieldBegin("detect_type", ::apache::thrift::protocol::T_I32, 9);
    xfer += oprot->writeI32((int32_t)this->detect_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.worker_thread_number) {
    xfer += oprot->writeFieldBegin("worker_thread_number", ::apache::thrift::protocol::T_I32, 10);
    xfer += oprot->writeI32(this->worker_thread_number);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.host_name) {
    xfer += oprot->writeFieldBegin("host_name", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeString(this->host_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.export_disk_type) {
    xfer += oprot->writeFieldBegin("export_disk_type", ::apache::thrift::protocol::T_I32, 12);
    xfer += oprot->writeI32((int32_t)this->export_disk_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.export_path) {
    xfer += oprot->writeFieldBegin("export_path", ::apache::thrift::protocol::T_STRING, 13);
    xfer += oprot->writeString(this->export_path);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.disks_size_mapping) {
    xfer += oprot->writeFieldBegin("disks_size_mapping", ::apache::thrift::protocol::T_MAP, 14);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->disks_size_mapping.size()));
      std::map<std::string, int64_t> ::const_iterator _iter1119;
      for (_iter1119 = this->disks_size_mapping.begin(); _iter1119 != this->disks_size_mapping.end(); ++_iter1119)
      {
        xfer += oprot->writeString(_iter1119->first);
        xfer += oprot->writeI64(_iter1119->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.keep_alive) {
    xfer += oprot->writeFieldBegin("keep_alive", ::apache::thrift::protocol::T_BOOL, 15);
    xfer += oprot->writeBool(this->keep_alive);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.time) {
    xfer += oprot->writeFieldBegin("time", ::apache::thrift::protocol::T_STRING, 16);
    xfer += oprot->writeString(this->time);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_continuous_data_replication) {
    xfer += oprot->writeFieldBegin("is_continuous_data_replication", ::apache::thrift::protocol::T_BOOL, 17);
    xfer += oprot->writeBool(this->is_continuous_data_replication);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.azure_storage_connection_string) {
    xfer += oprot->writeFieldBegin("azure_storage_connection_string", ::apache::thrift::protocol::T_STRING, 18);
    xfer += oprot->writeString(this->azure_storage_connection_string);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vmware_connection) {
    xfer += oprot->writeFieldBegin("vmware_connection", ::apache::thrift::protocol::T_STRUCT, 19);
    xfer += this->vmware_connection.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.thin_provisioned) {
    xfer += oprot->writeFieldBegin("thin_provisioned", ::apache::thrift::protocol::T_BOOL, 20);
    xfer += oprot->writeBool(this->thin_provisioned);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_paused) {
    xfer += oprot->writeFieldBegin("is_paused", ::apache::thrift::protocol::T_BOOL, 21);
    xfer += oprot->writeBool(this->is_paused);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cascadings) {
    xfer += oprot->writeFieldBegin("cascadings", ::apache::thrift::protocol::T_STRUCT, 22);
    xfer += this->cascadings.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.post_snapshot_script) {
    xfer += oprot->writeFieldBegin("post_snapshot_script", ::apache::thrift::protocol::T_STRING, 23);
    xfer += oprot->writeString(this->post_snapshot_script);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.disks_order) {
    xfer += oprot->writeFieldBegin("disks_order", ::apache::thrift::protocol::T_LIST, 24);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->disks_order.size()));
      std::vector<std::string> ::const_iterator _iter1120;
      for (_iter1120 = this->disks_order.begin(); _iter1120 != this->disks_order.end(); ++_iter1120)
      {
        xfer += oprot->writeString((*_iter1120));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(loader_job_create_detail &a, loader_job_create_detail &b) {
  using ::std::swap;
  swap(a.replica_id, b.replica_id);
  swap(a.disks_lun_mapping, b.disks_lun_mapping);
  swap(a.snapshots, b.snapshots);
  swap(a.disks_snapshot_mapping, b.disks_snapshot_mapping);
  swap(a.connection_id, b.connection_id);
  swap(a.block_mode_enable, b.block_mode_enable);
  swap(a.purge_data, b.purge_data);
  swap(a.remap, b.remap);
  swap(a.detect_type, b.detect_type);
  swap(a.worker_thread_number, b.worker_thread_number);
  swap(a.host_name, b.host_name);
  swap(a.export_disk_type, b.export_disk_type);
  swap(a.export_path, b.export_path);
  swap(a.disks_size_mapping, b.disks_size_mapping);
  swap(a.keep_alive, b.keep_alive);
  swap(a.time, b.time);
  swap(a.is_continuous_data_replication, b.is_continuous_data_replication);
  swap(a.azure_storage_connection_string, b.azure_storage_connection_string);
  swap(a.vmware_connection, b.vmware_connection);
  swap(a.thin_provisioned, b.thin_provisioned);
  swap(a.is_paused, b.is_paused);
  swap(a.cascadings, b.cascadings);
  swap(a.post_snapshot_script, b.post_snapshot_script);
  swap(a.disks_order, b.disks_order);
  swap(a.__isset, b.__isset);
}

loader_job_create_detail::loader_job_create_detail(const loader_job_create_detail& other1121) {
  replica_id = other1121.replica_id;
  disks_lun_mapping = other1121.disks_lun_mapping;
  snapshots = other1121.snapshots;
  disks_snapshot_mapping = other1121.disks_snapshot_mapping;
  connection_id = other1121.connection_id;
  block_mode_enable = other1121.block_mode_enable;
  purge_data = other1121.purge_data;
  remap = other1121.remap;
  detect_type = other1121.detect_type;
  worker_thread_number = other1121.worker_thread_number;
  host_name = other1121.host_name;
  export_disk_type = other1121.export_disk_type;
  export_path = other1121.export_path;
  disks_size_mapping = other1121.disks_size_mapping;
  keep_alive = other1121.keep_alive;
  time = other1121.time;
  is_continuous_data_replication = other1121.is_continuous_data_replication;
  azure_storage_connection_string = other1121.azure_storage_connection_string;
  vmware_connection = other1121.vmware_connection;
  thin_provisioned = other1121.thin_provisioned;
  is_paused = other1121.is_paused;
  cascadings = other1121.cascadings;
  post_snapshot_script = other1121.post_snapshot_script;
  disks_order = other1121.disks_order;
  __isset = other1121.__isset;
}
loader_job_create_detail& loader_job_create_detail::operator=(const loader_job_create_detail& other1122) {
  replica_id = other1122.replica_id;
  disks_lun_mapping = other1122.disks_lun_mapping;
  snapshots = other1122.snapshots;
  disks_snapshot_mapping = other1122.disks_snapshot_mapping;
  connection_id = other1122.connection_id;
  block_mode_enable = other1122.block_mode_enable;
  purge_data = other1122.purge_data;
  remap = other1122.remap;
  detect_type = other1122.detect_type;
  worker_thread_number = other1122.worker_thread_number;
  host_name = other1122.host_name;
  export_disk_type = other1122.export_disk_type;
  export_path = other1122.export_path;
  disks_size_mapping = other1122.disks_size_mapping;
  keep_alive = other1122.keep_alive;
  time = other1122.time;
  is_continuous_data_replication = other1122.is_continuous_data_replication;
  azure_storage_connection_string = other1122.azure_storage_connection_string;
  vmware_connection = other1122.vmware_connection;
  thin_provisioned = other1122.thin_provisioned;
  is_paused = other1122.is_paused;
  cascadings = other1122.cascadings;
  post_snapshot_script = other1122.post_snapshot_script;
  disks_order = other1122.disks_order;
  __isset = other1122.__isset;
  return *this;
}
void loader_job_create_detail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "loader_job_create_detail(";
  out << "replica_id="; (__isset.replica_id ? (out << to_string(replica_id)) : (out << "<null>"));
  out << ", " << "disks_lun_mapping="; (__isset.disks_lun_mapping ? (out << to_string(disks_lun_mapping)) : (out << "<null>"));
  out << ", " << "snapshots="; (__isset.snapshots ? (out << to_string(snapshots)) : (out << "<null>"));
  out << ", " << "disks_snapshot_mapping="; (__isset.disks_snapshot_mapping ? (out << to_string(disks_snapshot_mapping)) : (out << "<null>"));
  out << ", " << "connection_id="; (__isset.connection_id ? (out << to_string(connection_id)) : (out << "<null>"));
  out << ", " << "block_mode_enable="; (__isset.block_mode_enable ? (out << to_string(block_mode_enable)) : (out << "<null>"));
  out << ", " << "purge_data="; (__isset.purge_data ? (out << to_string(purge_data)) : (out << "<null>"));
  out << ", " << "remap="; (__isset.remap ? (out << to_string(remap)) : (out << "<null>"));
  out << ", " << "detect_type="; (__isset.detect_type ? (out << to_string(detect_type)) : (out << "<null>"));
  out << ", " << "worker_thread_number="; (__isset.worker_thread_number ? (out << to_string(worker_thread_number)) : (out << "<null>"));
  out << ", " << "host_name="; (__isset.host_name ? (out << to_string(host_name)) : (out << "<null>"));
  out << ", " << "export_disk_type="; (__isset.export_disk_type ? (out << to_string(export_disk_type)) : (out << "<null>"));
  out << ", " << "export_path="; (__isset.export_path ? (out << to_string(export_path)) : (out << "<null>"));
  out << ", " << "disks_size_mapping="; (__isset.disks_size_mapping ? (out << to_string(disks_size_mapping)) : (out << "<null>"));
  out << ", " << "keep_alive="; (__isset.keep_alive ? (out << to_string(keep_alive)) : (out << "<null>"));
  out << ", " << "time="; (__isset.time ? (out << to_string(time)) : (out << "<null>"));
  out << ", " << "is_continuous_data_replication="; (__isset.is_continuous_data_replication ? (out << to_string(is_continuous_data_replication)) : (out << "<null>"));
  out << ", " << "azure_storage_connection_string="; (__isset.azure_storage_connection_string ? (out << to_string(azure_storage_connection_string)) : (out << "<null>"));
  out << ", " << "vmware_connection="; (__isset.vmware_connection ? (out << to_string(vmware_connection)) : (out << "<null>"));
  out << ", " << "thin_provisioned="; (__isset.thin_provisioned ? (out << to_string(thin_provisioned)) : (out << "<null>"));
  out << ", " << "is_paused="; (__isset.is_paused ? (out << to_string(is_paused)) : (out << "<null>"));
  out << ", " << "cascadings="; (__isset.cascadings ? (out << to_string(cascadings)) : (out << "<null>"));
  out << ", " << "post_snapshot_script="; (__isset.post_snapshot_script ? (out << to_string(post_snapshot_script)) : (out << "<null>"));
  out << ", " << "disks_order="; (__isset.disks_order ? (out << to_string(disks_order)) : (out << "<null>"));
  out << ")";
}


launcher_job_create_detail::~launcher_job_create_detail() throw() {
}


void launcher_job_create_detail::__set_replica_id(const std::string& val) {
  this->replica_id = val;
__isset.replica_id = true;
}

void launcher_job_create_detail::__set_disks_lun_mapping(const std::map<std::string, std::string> & val) {
  this->disks_lun_mapping = val;
__isset.disks_lun_mapping = true;
}

void launcher_job_create_detail::__set_is_sysvol_authoritative_restore(const bool val) {
  this->is_sysvol_authoritative_restore = val;
__isset.is_sysvol_authoritative_restore = true;
}

void launcher_job_create_detail::__set_is_enable_debug(const bool val) {
  this->is_enable_debug = val;
__isset.is_enable_debug = true;
}

void launcher_job_create_detail::__set_is_disable_machine_password_change(const bool val) {
  this->is_disable_machine_password_change = val;
__isset.is_disable_machine_password_change = true;
}

void launcher_job_create_detail::__set_is_force_normal_boot(const bool val) {
  this->is_force_normal_boot = val;
__isset.is_force_normal_boot = true;
}

void launcher_job_create_detail::__set_network_infos(const std::set<network_info> & val) {
  this->network_infos = val;
__isset.network_infos = true;
}

void launcher_job_create_detail::__set_config(const std::string& val) {
  this->config = val;
__isset.config = true;
}

void launcher_job_create_detail::__set_gpt_to_mbr(const bool val) {
  this->gpt_to_mbr = val;
__isset.gpt_to_mbr = true;
}

void launcher_job_create_detail::__set_detect_type(const disk_detect_type::type val) {
  this->detect_type = val;
__isset.detect_type = true;
}

void launcher_job_create_detail::__set_skip_system_injection(const bool val) {
  this->skip_system_injection = val;
__isset.skip_system_injection = true;
}

void launcher_job_create_detail::__set_reboot_winpe(const bool val) {
  this->reboot_winpe = val;
__isset.reboot_winpe = true;
}

void launcher_job_create_detail::__set_callbacks(const std::set<std::string> & val) {
  this->callbacks = val;
__isset.callbacks = true;
}

void launcher_job_create_detail::__set_callback_timeout(const int32_t val) {
  this->callback_timeout = val;
__isset.callback_timeout = true;
}

void launcher_job_create_detail::__set_host_name(const std::string& val) {
  this->host_name = val;
__isset.host_name = true;
}

void launcher_job_create_detail::__set_export_disk_type(const virtual_disk_type::type val) {
  this->export_disk_type = val;
__isset.export_disk_type = true;
}

void launcher_job_create_detail::__set_export_path(const std::string& val) {
  this->export_path = val;
__isset.export_path = true;
}

void launcher_job_create_detail::__set_target_type(const conversion_type::type val) {
  this->target_type = val;
__isset.target_type = true;
}

void launcher_job_create_detail::__set_os_type(const hv_guest_os_type::type val) {
  this->os_type = val;
__isset.os_type = true;
}

void launcher_job_create_detail::__set_is_update_ex(const bool val) {
  this->is_update_ex = val;
__isset.is_update_ex = true;
}

void launcher_job_create_detail::__set_options_type(const extra_options_type::type val) {
  this->options_type = val;
__isset.options_type = true;
}

void launcher_job_create_detail::__set_options(const extra_options& val) {
  this->options = val;
__isset.options = true;
}

void launcher_job_create_detail::__set_pre_scripts(const std::set<std::string> & val) {
  this->pre_scripts = val;
__isset.pre_scripts = true;
}

void launcher_job_create_detail::__set_post_scripts(const std::set<std::string> & val) {
  this->post_scripts = val;
__isset.post_scripts = true;
}

void launcher_job_create_detail::__set_vmware(const vmware_options& val) {
  this->vmware = val;
__isset.vmware = true;
}

void launcher_job_create_detail::__set_mode(const recovery_type::type val) {
  this->mode = val;
__isset.mode = true;
}

void launcher_job_create_detail::__set_azure_storage_connection_string(const std::string& val) {
  this->azure_storage_connection_string = val;
__isset.azure_storage_connection_string = true;
}
std::ostream& operator<<(std::ostream& out, const launcher_job_create_detail& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t launcher_job_create_detail::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->replica_id);
          this->__isset.replica_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->disks_lun_mapping.clear();
            uint32_t _size1123;
            ::apache::thrift::protocol::TType _ktype1124;
            ::apache::thrift::protocol::TType _vtype1125;
            xfer += iprot->readMapBegin(_ktype1124, _vtype1125, _size1123);
            uint32_t _i1127;
            for (_i1127 = 0; _i1127 < _size1123; ++_i1127)
            {
              std::string _key1128;
              xfer += iprot->readString(_key1128);
              std::string& _val1129 = this->disks_lun_mapping[_key1128];
              xfer += iprot->readString(_val1129);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.disks_lun_mapping = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_sysvol_authoritative_restore);
          this->__isset.is_sysvol_authoritative_restore = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_enable_debug);
          this->__isset.is_enable_debug = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_disable_machine_password_change);
          this->__isset.is_disable_machine_password_change = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_force_normal_boot);
          this->__isset.is_force_normal_boot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->network_infos.clear();
            uint32_t _size1130;
            ::apache::thrift::protocol::TType _etype1133;
            xfer += iprot->readSetBegin(_etype1133, _size1130);
            uint32_t _i1134;
            for (_i1134 = 0; _i1134 < _size1130; ++_i1134)
            {
              network_info _elem1135;
              xfer += _elem1135.read(iprot);
              this->network_infos.insert(_elem1135);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.network_infos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->config);
          this->__isset.config = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->gpt_to_mbr);
          this->__isset.gpt_to_mbr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1136;
          xfer += iprot->readI32(ecast1136);
          this->detect_type = (disk_detect_type::type)ecast1136;
          this->__isset.detect_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->skip_system_injection);
          this->__isset.skip_system_injection = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->reboot_winpe);
          this->__isset.reboot_winpe = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->callbacks.clear();
            uint32_t _size1137;
            ::apache::thrift::protocol::TType _etype1140;
            xfer += iprot->readSetBegin(_etype1140, _size1137);
            uint32_t _i1141;
            for (_i1141 = 0; _i1141 < _size1137; ++_i1141)
            {
              std::string _elem1142;
              xfer += iprot->readString(_elem1142);
              this->callbacks.insert(_elem1142);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.callbacks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->callback_timeout);
          this->__isset.callback_timeout = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host_name);
          this->__isset.host_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1143;
          xfer += iprot->readI32(ecast1143);
          this->export_disk_type = (virtual_disk_type::type)ecast1143;
          this->__isset.export_disk_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->export_path);
          this->__isset.export_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1144;
          xfer += iprot->readI32(ecast1144);
          this->target_type = (conversion_type::type)ecast1144;
          this->__isset.target_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1145;
          xfer += iprot->readI32(ecast1145);
          this->os_type = (hv_guest_os_type::type)ecast1145;
          this->__isset.os_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_update_ex);
          this->__isset.is_update_ex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1146;
          xfer += iprot->readI32(ecast1146);
          this->options_type = (extra_options_type::type)ecast1146;
          this->__isset.options_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->options.read(iprot);
          this->__isset.options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->pre_scripts.clear();
            uint32_t _size1147;
            ::apache::thrift::protocol::TType _etype1150;
            xfer += iprot->readSetBegin(_etype1150, _size1147);
            uint32_t _i1151;
            for (_i1151 = 0; _i1151 < _size1147; ++_i1151)
            {
              std::string _elem1152;
              xfer += iprot->readString(_elem1152);
              this->pre_scripts.insert(_elem1152);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.pre_scripts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->post_scripts.clear();
            uint32_t _size1153;
            ::apache::thrift::protocol::TType _etype1156;
            xfer += iprot->readSetBegin(_etype1156, _size1153);
            uint32_t _i1157;
            for (_i1157 = 0; _i1157 < _size1153; ++_i1157)
            {
              std::string _elem1158;
              xfer += iprot->readString(_elem1158);
              this->post_scripts.insert(_elem1158);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.post_scripts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->vmware.read(iprot);
          this->__isset.vmware = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 26:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1159;
          xfer += iprot->readI32(ecast1159);
          this->mode = (recovery_type::type)ecast1159;
          this->__isset.mode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 27:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->azure_storage_connection_string);
          this->__isset.azure_storage_connection_string = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t launcher_job_create_detail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("launcher_job_create_detail");

  if (this->__isset.replica_id) {
    xfer += oprot->writeFieldBegin("replica_id", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->replica_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.disks_lun_mapping) {
    xfer += oprot->writeFieldBegin("disks_lun_mapping", ::apache::thrift::protocol::T_MAP, 2);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->disks_lun_mapping.size()));
      std::map<std::string, std::string> ::const_iterator _iter1160;
      for (_iter1160 = this->disks_lun_mapping.begin(); _iter1160 != this->disks_lun_mapping.end(); ++_iter1160)
      {
        xfer += oprot->writeString(_iter1160->first);
        xfer += oprot->writeString(_iter1160->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_sysvol_authoritative_restore) {
    xfer += oprot->writeFieldBegin("is_sysvol_authoritative_restore", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->is_sysvol_authoritative_restore);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_enable_debug) {
    xfer += oprot->writeFieldBegin("is_enable_debug", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->is_enable_debug);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_disable_machine_password_change) {
    xfer += oprot->writeFieldBegin("is_disable_machine_password_change", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->is_disable_machine_password_change);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_force_normal_boot) {
    xfer += oprot->writeFieldBegin("is_force_normal_boot", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->is_force_normal_boot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.network_infos) {
    xfer += oprot->writeFieldBegin("network_infos", ::apache::thrift::protocol::T_SET, 7);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->network_infos.size()));
      std::set<network_info> ::const_iterator _iter1161;
      for (_iter1161 = this->network_infos.begin(); _iter1161 != this->network_infos.end(); ++_iter1161)
      {
        xfer += (*_iter1161).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.config) {
    xfer += oprot->writeFieldBegin("config", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->config);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.gpt_to_mbr) {
    xfer += oprot->writeFieldBegin("gpt_to_mbr", ::apache::thrift::protocol::T_BOOL, 9);
    xfer += oprot->writeBool(this->gpt_to_mbr);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.detect_type) {
    xfer += oprot->writeFieldBegin("detect_type", ::apache::thrift::protocol::T_I32, 10);
    xfer += oprot->writeI32((int32_t)this->detect_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.skip_system_injection) {
    xfer += oprot->writeFieldBegin("skip_system_injection", ::apache::thrift::protocol::T_BOOL, 11);
    xfer += oprot->writeBool(this->skip_system_injection);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.reboot_winpe) {
    xfer += oprot->writeFieldBegin("reboot_winpe", ::apache::thrift::protocol::T_BOOL, 12);
    xfer += oprot->writeBool(this->reboot_winpe);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.callbacks) {
    xfer += oprot->writeFieldBegin("callbacks", ::apache::thrift::protocol::T_SET, 13);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->callbacks.size()));
      std::set<std::string> ::const_iterator _iter1162;
      for (_iter1162 = this->callbacks.begin(); _iter1162 != this->callbacks.end(); ++_iter1162)
      {
        xfer += oprot->writeString((*_iter1162));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.callback_timeout) {
    xfer += oprot->writeFieldBegin("callback_timeout", ::apache::thrift::protocol::T_I32, 14);
    xfer += oprot->writeI32(this->callback_timeout);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.host_name) {
    xfer += oprot->writeFieldBegin("host_name", ::apache::thrift::protocol::T_STRING, 15);
    xfer += oprot->writeString(this->host_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.export_disk_type) {
    xfer += oprot->writeFieldBegin("export_disk_type", ::apache::thrift::protocol::T_I32, 16);
    xfer += oprot->writeI32((int32_t)this->export_disk_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.export_path) {
    xfer += oprot->writeFieldBegin("export_path", ::apache::thrift::protocol::T_STRING, 17);
    xfer += oprot->writeString(this->export_path);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.target_type) {
    xfer += oprot->writeFieldBegin("target_type", ::apache::thrift::protocol::T_I32, 18);
    xfer += oprot->writeI32((int32_t)this->target_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.os_type) {
    xfer += oprot->writeFieldBegin("os_type", ::apache::thrift::protocol::T_I32, 19);
    xfer += oprot->writeI32((int32_t)this->os_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_update_ex) {
    xfer += oprot->writeFieldBegin("is_update_ex", ::apache::thrift::protocol::T_BOOL, 20);
    xfer += oprot->writeBool(this->is_update_ex);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.options_type) {
    xfer += oprot->writeFieldBegin("options_type", ::apache::thrift::protocol::T_I32, 21);
    xfer += oprot->writeI32((int32_t)this->options_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.options) {
    xfer += oprot->writeFieldBegin("options", ::apache::thrift::protocol::T_STRUCT, 22);
    xfer += this->options.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.pre_scripts) {
    xfer += oprot->writeFieldBegin("pre_scripts", ::apache::thrift::protocol::T_SET, 23);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->pre_scripts.size()));
      std::set<std::string> ::const_iterator _iter1163;
      for (_iter1163 = this->pre_scripts.begin(); _iter1163 != this->pre_scripts.end(); ++_iter1163)
      {
        xfer += oprot->writeString((*_iter1163));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.post_scripts) {
    xfer += oprot->writeFieldBegin("post_scripts", ::apache::thrift::protocol::T_SET, 24);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->post_scripts.size()));
      std::set<std::string> ::const_iterator _iter1164;
      for (_iter1164 = this->post_scripts.begin(); _iter1164 != this->post_scripts.end(); ++_iter1164)
      {
        xfer += oprot->writeString((*_iter1164));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vmware) {
    xfer += oprot->writeFieldBegin("vmware", ::apache::thrift::protocol::T_STRUCT, 25);
    xfer += this->vmware.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mode) {
    xfer += oprot->writeFieldBegin("mode", ::apache::thrift::protocol::T_I32, 26);
    xfer += oprot->writeI32((int32_t)this->mode);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.azure_storage_connection_string) {
    xfer += oprot->writeFieldBegin("azure_storage_connection_string", ::apache::thrift::protocol::T_STRING, 27);
    xfer += oprot->writeString(this->azure_storage_connection_string);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(launcher_job_create_detail &a, launcher_job_create_detail &b) {
  using ::std::swap;
  swap(a.replica_id, b.replica_id);
  swap(a.disks_lun_mapping, b.disks_lun_mapping);
  swap(a.is_sysvol_authoritative_restore, b.is_sysvol_authoritative_restore);
  swap(a.is_enable_debug, b.is_enable_debug);
  swap(a.is_disable_machine_password_change, b.is_disable_machine_password_change);
  swap(a.is_force_normal_boot, b.is_force_normal_boot);
  swap(a.network_infos, b.network_infos);
  swap(a.config, b.config);
  swap(a.gpt_to_mbr, b.gpt_to_mbr);
  swap(a.detect_type, b.detect_type);
  swap(a.skip_system_injection, b.skip_system_injection);
  swap(a.reboot_winpe, b.reboot_winpe);
  swap(a.callbacks, b.callbacks);
  swap(a.callback_timeout, b.callback_timeout);
  swap(a.host_name, b.host_name);
  swap(a.export_disk_type, b.export_disk_type);
  swap(a.export_path, b.export_path);
  swap(a.target_type, b.target_type);
  swap(a.os_type, b.os_type);
  swap(a.is_update_ex, b.is_update_ex);
  swap(a.options_type, b.options_type);
  swap(a.options, b.options);
  swap(a.pre_scripts, b.pre_scripts);
  swap(a.post_scripts, b.post_scripts);
  swap(a.vmware, b.vmware);
  swap(a.mode, b.mode);
  swap(a.azure_storage_connection_string, b.azure_storage_connection_string);
  swap(a.__isset, b.__isset);
}

launcher_job_create_detail::launcher_job_create_detail(const launcher_job_create_detail& other1165) {
  replica_id = other1165.replica_id;
  disks_lun_mapping = other1165.disks_lun_mapping;
  is_sysvol_authoritative_restore = other1165.is_sysvol_authoritative_restore;
  is_enable_debug = other1165.is_enable_debug;
  is_disable_machine_password_change = other1165.is_disable_machine_password_change;
  is_force_normal_boot = other1165.is_force_normal_boot;
  network_infos = other1165.network_infos;
  config = other1165.config;
  gpt_to_mbr = other1165.gpt_to_mbr;
  detect_type = other1165.detect_type;
  skip_system_injection = other1165.skip_system_injection;
  reboot_winpe = other1165.reboot_winpe;
  callbacks = other1165.callbacks;
  callback_timeout = other1165.callback_timeout;
  host_name = other1165.host_name;
  export_disk_type = other1165.export_disk_type;
  export_path = other1165.export_path;
  target_type = other1165.target_type;
  os_type = other1165.os_type;
  is_update_ex = other1165.is_update_ex;
  options_type = other1165.options_type;
  options = other1165.options;
  pre_scripts = other1165.pre_scripts;
  post_scripts = other1165.post_scripts;
  vmware = other1165.vmware;
  mode = other1165.mode;
  azure_storage_connection_string = other1165.azure_storage_connection_string;
  __isset = other1165.__isset;
}
launcher_job_create_detail& launcher_job_create_detail::operator=(const launcher_job_create_detail& other1166) {
  replica_id = other1166.replica_id;
  disks_lun_mapping = other1166.disks_lun_mapping;
  is_sysvol_authoritative_restore = other1166.is_sysvol_authoritative_restore;
  is_enable_debug = other1166.is_enable_debug;
  is_disable_machine_password_change = other1166.is_disable_machine_password_change;
  is_force_normal_boot = other1166.is_force_normal_boot;
  network_infos = other1166.network_infos;
  config = other1166.config;
  gpt_to_mbr = other1166.gpt_to_mbr;
  detect_type = other1166.detect_type;
  skip_system_injection = other1166.skip_system_injection;
  reboot_winpe = other1166.reboot_winpe;
  callbacks = other1166.callbacks;
  callback_timeout = other1166.callback_timeout;
  host_name = other1166.host_name;
  export_disk_type = other1166.export_disk_type;
  export_path = other1166.export_path;
  target_type = other1166.target_type;
  os_type = other1166.os_type;
  is_update_ex = other1166.is_update_ex;
  options_type = other1166.options_type;
  options = other1166.options;
  pre_scripts = other1166.pre_scripts;
  post_scripts = other1166.post_scripts;
  vmware = other1166.vmware;
  mode = other1166.mode;
  azure_storage_connection_string = other1166.azure_storage_connection_string;
  __isset = other1166.__isset;
  return *this;
}
void launcher_job_create_detail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "launcher_job_create_detail(";
  out << "replica_id="; (__isset.replica_id ? (out << to_string(replica_id)) : (out << "<null>"));
  out << ", " << "disks_lun_mapping="; (__isset.disks_lun_mapping ? (out << to_string(disks_lun_mapping)) : (out << "<null>"));
  out << ", " << "is_sysvol_authoritative_restore="; (__isset.is_sysvol_authoritative_restore ? (out << to_string(is_sysvol_authoritative_restore)) : (out << "<null>"));
  out << ", " << "is_enable_debug="; (__isset.is_enable_debug ? (out << to_string(is_enable_debug)) : (out << "<null>"));
  out << ", " << "is_disable_machine_password_change="; (__isset.is_disable_machine_password_change ? (out << to_string(is_disable_machine_password_change)) : (out << "<null>"));
  out << ", " << "is_force_normal_boot="; (__isset.is_force_normal_boot ? (out << to_string(is_force_normal_boot)) : (out << "<null>"));
  out << ", " << "network_infos="; (__isset.network_infos ? (out << to_string(network_infos)) : (out << "<null>"));
  out << ", " << "config="; (__isset.config ? (out << to_string(config)) : (out << "<null>"));
  out << ", " << "gpt_to_mbr="; (__isset.gpt_to_mbr ? (out << to_string(gpt_to_mbr)) : (out << "<null>"));
  out << ", " << "detect_type="; (__isset.detect_type ? (out << to_string(detect_type)) : (out << "<null>"));
  out << ", " << "skip_system_injection="; (__isset.skip_system_injection ? (out << to_string(skip_system_injection)) : (out << "<null>"));
  out << ", " << "reboot_winpe="; (__isset.reboot_winpe ? (out << to_string(reboot_winpe)) : (out << "<null>"));
  out << ", " << "callbacks="; (__isset.callbacks ? (out << to_string(callbacks)) : (out << "<null>"));
  out << ", " << "callback_timeout="; (__isset.callback_timeout ? (out << to_string(callback_timeout)) : (out << "<null>"));
  out << ", " << "host_name="; (__isset.host_name ? (out << to_string(host_name)) : (out << "<null>"));
  out << ", " << "export_disk_type="; (__isset.export_disk_type ? (out << to_string(export_disk_type)) : (out << "<null>"));
  out << ", " << "export_path="; (__isset.export_path ? (out << to_string(export_path)) : (out << "<null>"));
  out << ", " << "target_type="; (__isset.target_type ? (out << to_string(target_type)) : (out << "<null>"));
  out << ", " << "os_type="; (__isset.os_type ? (out << to_string(os_type)) : (out << "<null>"));
  out << ", " << "is_update_ex="; (__isset.is_update_ex ? (out << to_string(is_update_ex)) : (out << "<null>"));
  out << ", " << "options_type="; (__isset.options_type ? (out << to_string(options_type)) : (out << "<null>"));
  out << ", " << "options="; (__isset.options ? (out << to_string(options)) : (out << "<null>"));
  out << ", " << "pre_scripts="; (__isset.pre_scripts ? (out << to_string(pre_scripts)) : (out << "<null>"));
  out << ", " << "post_scripts="; (__isset.post_scripts ? (out << to_string(post_scripts)) : (out << "<null>"));
  out << ", " << "vmware="; (__isset.vmware ? (out << to_string(vmware)) : (out << "<null>"));
  out << ", " << "mode="; (__isset.mode ? (out << to_string(mode)) : (out << "<null>"));
  out << ", " << "azure_storage_connection_string="; (__isset.azure_storage_connection_string ? (out << to_string(azure_storage_connection_string)) : (out << "<null>"));
  out << ")";
}


register_service_info::~register_service_info() throw() {
}


void register_service_info::__set_mgmt_addr(const std::string& val) {
  this->mgmt_addr = val;
__isset.mgmt_addr = true;
}

void register_service_info::__set_username(const std::string& val) {
  this->username = val;
__isset.username = true;
}

void register_service_info::__set_password(const std::string& val) {
  this->password = val;
__isset.password = true;
}

void register_service_info::__set_service_types(const std::set<std::string> & val) {
  this->service_types = val;
__isset.service_types = true;
}

void register_service_info::__set_version(const std::string& val) {
  this->version = val;
__isset.version = true;
}

void register_service_info::__set_path(const std::string& val) {
  this->path = val;
__isset.path = true;
}
std::ostream& operator<<(std::ostream& out, const register_service_info& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t register_service_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->mgmt_addr);
          this->__isset.mgmt_addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->username);
          this->__isset.username = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->password);
          this->__isset.password = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->service_types.clear();
            uint32_t _size1167;
            ::apache::thrift::protocol::TType _etype1170;
            xfer += iprot->readSetBegin(_etype1170, _size1167);
            uint32_t _i1171;
            for (_i1171 = 0; _i1171 < _size1167; ++_i1171)
            {
              std::string _elem1172;
              xfer += iprot->readString(_elem1172);
              this->service_types.insert(_elem1172);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.service_types = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->path);
          this->__isset.path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t register_service_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("register_service_info");

  if (this->__isset.mgmt_addr) {
    xfer += oprot->writeFieldBegin("mgmt_addr", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->mgmt_addr);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.username) {
    xfer += oprot->writeFieldBegin("username", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->username);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.password) {
    xfer += oprot->writeFieldBegin("password", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->password);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.service_types) {
    xfer += oprot->writeFieldBegin("service_types", ::apache::thrift::protocol::T_SET, 4);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->service_types.size()));
      std::set<std::string> ::const_iterator _iter1173;
      for (_iter1173 = this->service_types.begin(); _iter1173 != this->service_types.end(); ++_iter1173)
      {
        xfer += oprot->writeString((*_iter1173));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.version) {
    xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.path) {
    xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->path);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(register_service_info &a, register_service_info &b) {
  using ::std::swap;
  swap(a.mgmt_addr, b.mgmt_addr);
  swap(a.username, b.username);
  swap(a.password, b.password);
  swap(a.service_types, b.service_types);
  swap(a.version, b.version);
  swap(a.path, b.path);
  swap(a.__isset, b.__isset);
}

register_service_info::register_service_info(const register_service_info& other1174) {
  mgmt_addr = other1174.mgmt_addr;
  username = other1174.username;
  password = other1174.password;
  service_types = other1174.service_types;
  version = other1174.version;
  path = other1174.path;
  __isset = other1174.__isset;
}
register_service_info& register_service_info::operator=(const register_service_info& other1175) {
  mgmt_addr = other1175.mgmt_addr;
  username = other1175.username;
  password = other1175.password;
  service_types = other1175.service_types;
  version = other1175.version;
  path = other1175.path;
  __isset = other1175.__isset;
  return *this;
}
void register_service_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "register_service_info(";
  out << "mgmt_addr="; (__isset.mgmt_addr ? (out << to_string(mgmt_addr)) : (out << "<null>"));
  out << ", " << "username="; (__isset.username ? (out << to_string(username)) : (out << "<null>"));
  out << ", " << "password="; (__isset.password ? (out << to_string(password)) : (out << "<null>"));
  out << ", " << "service_types="; (__isset.service_types ? (out << to_string(service_types)) : (out << "<null>"));
  out << ", " << "version="; (__isset.version ? (out << to_string(version)) : (out << "<null>"));
  out << ", " << "path="; (__isset.path ? (out << to_string(path)) : (out << "<null>"));
  out << ")";
}


register_physical_packer_info::~register_physical_packer_info() throw() {
}


void register_physical_packer_info::__set_mgmt_addr(const std::string& val) {
  this->mgmt_addr = val;
__isset.mgmt_addr = true;
}

void register_physical_packer_info::__set_username(const std::string& val) {
  this->username = val;
__isset.username = true;
}

void register_physical_packer_info::__set_password(const std::string& val) {
  this->password = val;
__isset.password = true;
}

void register_physical_packer_info::__set_packer_addr(const std::string& val) {
  this->packer_addr = val;
__isset.packer_addr = true;
}

void register_physical_packer_info::__set_version(const std::string& val) {
  this->version = val;
__isset.version = true;
}

void register_physical_packer_info::__set_path(const std::string& val) {
  this->path = val;
__isset.path = true;
}
std::ostream& operator<<(std::ostream& out, const register_physical_packer_info& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t register_physical_packer_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->mgmt_addr);
          this->__isset.mgmt_addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->username);
          this->__isset.username = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->password);
          this->__isset.password = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->packer_addr);
          this->__isset.packer_addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->path);
          this->__isset.path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t register_physical_packer_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("register_physical_packer_info");

  if (this->__isset.mgmt_addr) {
    xfer += oprot->writeFieldBegin("mgmt_addr", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->mgmt_addr);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.username) {
    xfer += oprot->writeFieldBegin("username", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->username);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.password) {
    xfer += oprot->writeFieldBegin("password", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->password);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.packer_addr) {
    xfer += oprot->writeFieldBegin("packer_addr", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->packer_addr);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.version) {
    xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.path) {
    xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->path);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(register_physical_packer_info &a, register_physical_packer_info &b) {
  using ::std::swap;
  swap(a.mgmt_addr, b.mgmt_addr);
  swap(a.username, b.username);
  swap(a.password, b.password);
  swap(a.packer_addr, b.packer_addr);
  swap(a.version, b.version);
  swap(a.path, b.path);
  swap(a.__isset, b.__isset);
}

register_physical_packer_info::register_physical_packer_info(const register_physical_packer_info& other1176) {
  mgmt_addr = other1176.mgmt_addr;
  username = other1176.username;
  password = other1176.password;
  packer_addr = other1176.packer_addr;
  version = other1176.version;
  path = other1176.path;
  __isset = other1176.__isset;
}
register_physical_packer_info& register_physical_packer_info::operator=(const register_physical_packer_info& other1177) {
  mgmt_addr = other1177.mgmt_addr;
  username = other1177.username;
  password = other1177.password;
  packer_addr = other1177.packer_addr;
  version = other1177.version;
  path = other1177.path;
  __isset = other1177.__isset;
  return *this;
}
void register_physical_packer_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "register_physical_packer_info(";
  out << "mgmt_addr="; (__isset.mgmt_addr ? (out << to_string(mgmt_addr)) : (out << "<null>"));
  out << ", " << "username="; (__isset.username ? (out << to_string(username)) : (out << "<null>"));
  out << ", " << "password="; (__isset.password ? (out << to_string(password)) : (out << "<null>"));
  out << ", " << "packer_addr="; (__isset.packer_addr ? (out << to_string(packer_addr)) : (out << "<null>"));
  out << ", " << "version="; (__isset.version ? (out << to_string(version)) : (out << "<null>"));
  out << ", " << "path="; (__isset.path ? (out << to_string(path)) : (out << "<null>"));
  out << ")";
}


command_empty::~command_empty() throw() {
}

std::ostream& operator<<(std::ostream& out, const command_empty& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t command_empty::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t command_empty::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("command_empty");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(command_empty &a, command_empty &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

command_empty::command_empty(const command_empty& other1178) : TException() {
  (void) other1178;
}
command_empty& command_empty::operator=(const command_empty& other1179) {
  (void) other1179;
  return *this;
}
void command_empty::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "command_empty(";
  out << ")";
}

const char* command_empty::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: command_empty";
  }
}


invalid_session::~invalid_session() throw() {
}

std::ostream& operator<<(std::ostream& out, const invalid_session& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t invalid_session::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t invalid_session::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("invalid_session");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(invalid_session &a, invalid_session &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

invalid_session::invalid_session(const invalid_session& other1180) : TException() {
  (void) other1180;
}
invalid_session& invalid_session::operator=(const invalid_session& other1181) {
  (void) other1181;
  return *this;
}
void invalid_session::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "invalid_session(";
  out << ")";
}

const char* invalid_session::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: invalid_session";
  }
}


transport_message::~transport_message() throw() {
}


void transport_message::__set_id(const int64_t val) {
  this->id = val;
}

void transport_message::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const transport_message& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t transport_message::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t transport_message::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("transport_message");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(transport_message &a, transport_message &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

transport_message::transport_message(const transport_message& other1182) {
  id = other1182.id;
  message = other1182.message;
  __isset = other1182.__isset;
}
transport_message& transport_message::operator=(const transport_message& other1183) {
  id = other1183.id;
  message = other1183.message;
  __isset = other1183.__isset;
  return *this;
}
void transport_message::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "transport_message(";
  out << "id=" << to_string(id);
  out << ", " << "message=" << to_string(message);
  out << ")";
}


register_return::~register_return() throw() {
}


void register_return::__set_message(const std::string& val) {
  this->message = val;
__isset.message = true;
}

void register_return::__set_session(const std::string& val) {
  this->session = val;
__isset.session = true;
}
std::ostream& operator<<(std::ostream& out, const register_return& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t register_return::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session);
          this->__isset.session = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t register_return::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("register_return");

  if (this->__isset.message) {
    xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->message);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.session) {
    xfer += oprot->writeFieldBegin("session", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->session);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(register_return &a, register_return &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.session, b.session);
  swap(a.__isset, b.__isset);
}

register_return::register_return(const register_return& other1184) {
  message = other1184.message;
  session = other1184.session;
  __isset = other1184.__isset;
}
register_return& register_return::operator=(const register_return& other1185) {
  message = other1185.message;
  session = other1185.session;
  __isset = other1185.__isset;
  return *this;
}
void register_return::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "register_return(";
  out << "message="; (__isset.message ? (out << to_string(message)) : (out << "<null>"));
  out << ", " << "session="; (__isset.session ? (out << to_string(session)) : (out << "<null>"));
  out << ")";
}


license_info::~license_info() throw() {
}


void license_info::__set_key(const std::string& val) {
  this->key = val;
__isset.key = true;
}

void license_info::__set_activated(const std::string& val) {
  this->activated = val;
__isset.activated = true;
}

void license_info::__set_count(const int32_t val) {
  this->count = val;
__isset.count = true;
}

void license_info::__set_expired_date(const std::string& val) {
  this->expired_date = val;
__isset.expired_date = true;
}

void license_info::__set_consumed(const int32_t val) {
  this->consumed = val;
__isset.consumed = true;
}

void license_info::__set_is_active(const bool val) {
  this->is_active = val;
__isset.is_active = true;
}

void license_info::__set_name(const std::string& val) {
  this->name = val;
__isset.name = true;
}

void license_info::__set_email(const std::string& val) {
  this->email = val;
__isset.email = true;
}

void license_info::__set_status(const std::string& val) {
  this->status = val;
__isset.status = true;
}
std::ostream& operator<<(std::ostream& out, const license_info& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t license_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->activated);
          this->__isset.activated = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->count);
          this->__isset.count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->expired_date);
          this->__isset.expired_date = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->consumed);
          this->__isset.consumed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_active);
          this->__isset.is_active = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->email);
          this->__isset.email = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->status);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t license_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("license_info");

  if (this->__isset.key) {
    xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->key);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.activated) {
    xfer += oprot->writeFieldBegin("activated", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->activated);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.count) {
    xfer += oprot->writeFieldBegin("count", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->count);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.expired_date) {
    xfer += oprot->writeFieldBegin("expired_date", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->expired_date);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.consumed) {
    xfer += oprot->writeFieldBegin("consumed", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->consumed);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_active) {
    xfer += oprot->writeFieldBegin("is_active", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->is_active);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.email) {
    xfer += oprot->writeFieldBegin("email", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->email);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.status) {
    xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->status);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(license_info &a, license_info &b) {
  using ::std::swap;
  swap(a.key, b.key);
  swap(a.activated, b.activated);
  swap(a.count, b.count);
  swap(a.expired_date, b.expired_date);
  swap(a.consumed, b.consumed);
  swap(a.is_active, b.is_active);
  swap(a.name, b.name);
  swap(a.email, b.email);
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

license_info::license_info(const license_info& other1186) {
  key = other1186.key;
  activated = other1186.activated;
  count = other1186.count;
  expired_date = other1186.expired_date;
  consumed = other1186.consumed;
  is_active = other1186.is_active;
  name = other1186.name;
  email = other1186.email;
  status = other1186.status;
  __isset = other1186.__isset;
}
license_info& license_info::operator=(const license_info& other1187) {
  key = other1187.key;
  activated = other1187.activated;
  count = other1187.count;
  expired_date = other1187.expired_date;
  consumed = other1187.consumed;
  is_active = other1187.is_active;
  name = other1187.name;
  email = other1187.email;
  status = other1187.status;
  __isset = other1187.__isset;
  return *this;
}
void license_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "license_info(";
  out << "key="; (__isset.key ? (out << to_string(key)) : (out << "<null>"));
  out << ", " << "activated="; (__isset.activated ? (out << to_string(activated)) : (out << "<null>"));
  out << ", " << "count="; (__isset.count ? (out << to_string(count)) : (out << "<null>"));
  out << ", " << "expired_date="; (__isset.expired_date ? (out << to_string(expired_date)) : (out << "<null>"));
  out << ", " << "consumed="; (__isset.consumed ? (out << to_string(consumed)) : (out << "<null>"));
  out << ", " << "is_active="; (__isset.is_active ? (out << to_string(is_active)) : (out << "<null>"));
  out << ", " << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
  out << ", " << "email="; (__isset.email ? (out << to_string(email)) : (out << "<null>"));
  out << ", " << "status="; (__isset.status ? (out << to_string(status)) : (out << "<null>"));
  out << ")";
}


workload_history::~workload_history() throw() {
}


void workload_history::__set_machine_id(const std::string& val) {
  this->machine_id = val;
__isset.machine_id = true;
}

void workload_history::__set_name(const std::string& val) {
  this->name = val;
__isset.name = true;
}

void workload_history::__set_type(const std::string& val) {
  this->type = val;
__isset.type = true;
}

void workload_history::__set_histories(const std::vector<int32_t> & val) {
  this->histories = val;
__isset.histories = true;
}
std::ostream& operator<<(std::ostream& out, const workload_history& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t workload_history::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->machine_id);
          this->__isset.machine_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->histories.clear();
            uint32_t _size1188;
            ::apache::thrift::protocol::TType _etype1191;
            xfer += iprot->readListBegin(_etype1191, _size1188);
            this->histories.resize(_size1188);
            uint32_t _i1192;
            for (_i1192 = 0; _i1192 < _size1188; ++_i1192)
            {
              xfer += iprot->readI32(this->histories[_i1192]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.histories = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t workload_history::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("workload_history");

  if (this->__isset.machine_id) {
    xfer += oprot->writeFieldBegin("machine_id", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->machine_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.type) {
    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.histories) {
    xfer += oprot->writeFieldBegin("histories", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->histories.size()));
      std::vector<int32_t> ::const_iterator _iter1193;
      for (_iter1193 = this->histories.begin(); _iter1193 != this->histories.end(); ++_iter1193)
      {
        xfer += oprot->writeI32((*_iter1193));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(workload_history &a, workload_history &b) {
  using ::std::swap;
  swap(a.machine_id, b.machine_id);
  swap(a.name, b.name);
  swap(a.type, b.type);
  swap(a.histories, b.histories);
  swap(a.__isset, b.__isset);
}

workload_history::workload_history(const workload_history& other1194) {
  machine_id = other1194.machine_id;
  name = other1194.name;
  type = other1194.type;
  histories = other1194.histories;
  __isset = other1194.__isset;
}
workload_history& workload_history::operator=(const workload_history& other1195) {
  machine_id = other1195.machine_id;
  name = other1195.name;
  type = other1195.type;
  histories = other1195.histories;
  __isset = other1195.__isset;
  return *this;
}
void workload_history::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "workload_history(";
  out << "machine_id="; (__isset.machine_id ? (out << to_string(machine_id)) : (out << "<null>"));
  out << ", " << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
  out << ", " << "type="; (__isset.type ? (out << to_string(type)) : (out << "<null>"));
  out << ", " << "histories="; (__isset.histories ? (out << to_string(histories)) : (out << "<null>"));
  out << ")";
}


license_infos::~license_infos() throw() {
}


void license_infos::__set_licenses(const std::vector<license_info> & val) {
  this->licenses = val;
__isset.licenses = true;
}

void license_infos::__set_histories(const std::vector<workload_history> & val) {
  this->histories = val;
__isset.histories = true;
}
std::ostream& operator<<(std::ostream& out, const license_infos& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t license_infos::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->licenses.clear();
            uint32_t _size1196;
            ::apache::thrift::protocol::TType _etype1199;
            xfer += iprot->readListBegin(_etype1199, _size1196);
            this->licenses.resize(_size1196);
            uint32_t _i1200;
            for (_i1200 = 0; _i1200 < _size1196; ++_i1200)
            {
              xfer += this->licenses[_i1200].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.licenses = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->histories.clear();
            uint32_t _size1201;
            ::apache::thrift::protocol::TType _etype1204;
            xfer += iprot->readListBegin(_etype1204, _size1201);
            this->histories.resize(_size1201);
            uint32_t _i1205;
            for (_i1205 = 0; _i1205 < _size1201; ++_i1205)
            {
              xfer += this->histories[_i1205].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.histories = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t license_infos::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("license_infos");

  if (this->__isset.licenses) {
    xfer += oprot->writeFieldBegin("licenses", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->licenses.size()));
      std::vector<license_info> ::const_iterator _iter1206;
      for (_iter1206 = this->licenses.begin(); _iter1206 != this->licenses.end(); ++_iter1206)
      {
        xfer += (*_iter1206).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.histories) {
    xfer += oprot->writeFieldBegin("histories", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->histories.size()));
      std::vector<workload_history> ::const_iterator _iter1207;
      for (_iter1207 = this->histories.begin(); _iter1207 != this->histories.end(); ++_iter1207)
      {
        xfer += (*_iter1207).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(license_infos &a, license_infos &b) {
  using ::std::swap;
  swap(a.licenses, b.licenses);
  swap(a.histories, b.histories);
  swap(a.__isset, b.__isset);
}

license_infos::license_infos(const license_infos& other1208) {
  licenses = other1208.licenses;
  histories = other1208.histories;
  __isset = other1208.__isset;
}
license_infos& license_infos::operator=(const license_infos& other1209) {
  licenses = other1209.licenses;
  histories = other1209.histories;
  __isset = other1209.__isset;
  return *this;
}
void license_infos::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "license_infos(";
  out << "licenses="; (__isset.licenses ? (out << to_string(licenses)) : (out << "<null>"));
  out << ", " << "histories="; (__isset.histories ? (out << to_string(histories)) : (out << "<null>"));
  out << ")";
}


running_task::~running_task() throw() {
}


void running_task::__set_id(const std::string& val) {
  this->id = val;
__isset.id = true;
}

void running_task::__set_triggers(const std::vector<job_trigger> & val) {
  this->triggers = val;
__isset.triggers = true;
}

void running_task::__set_mgmt_addr(const std::string& val) {
  this->mgmt_addr = val;
__isset.mgmt_addr = true;
}

void running_task::__set_mgmt_port(const int32_t val) {
  this->mgmt_port = val;
__isset.mgmt_port = true;
}

void running_task::__set_is_ssl(const bool val) {
  this->is_ssl = val;
__isset.is_ssl = true;
}

void running_task::__set_parameters(const std::string& val) {
  this->parameters = val;
__isset.parameters = true;
}
std::ostream& operator<<(std::ostream& out, const running_task& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t running_task::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->triggers.clear();
            uint32_t _size1210;
            ::apache::thrift::protocol::TType _etype1213;
            xfer += iprot->readListBegin(_etype1213, _size1210);
            this->triggers.resize(_size1210);
            uint32_t _i1214;
            for (_i1214 = 0; _i1214 < _size1210; ++_i1214)
            {
              xfer += this->triggers[_i1214].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.triggers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->mgmt_addr);
          this->__isset.mgmt_addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->mgmt_port);
          this->__isset.mgmt_port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_ssl);
          this->__isset.is_ssl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->parameters);
          this->__isset.parameters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t running_task::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("running_task");

  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.triggers) {
    xfer += oprot->writeFieldBegin("triggers", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->triggers.size()));
      std::vector<job_trigger> ::const_iterator _iter1215;
      for (_iter1215 = this->triggers.begin(); _iter1215 != this->triggers.end(); ++_iter1215)
      {
        xfer += (*_iter1215).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mgmt_addr) {
    xfer += oprot->writeFieldBegin("mgmt_addr", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->mgmt_addr);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mgmt_port) {
    xfer += oprot->writeFieldBegin("mgmt_port", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->mgmt_port);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_ssl) {
    xfer += oprot->writeFieldBegin("is_ssl", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->is_ssl);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.parameters) {
    xfer += oprot->writeFieldBegin("parameters", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->parameters);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(running_task &a, running_task &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.triggers, b.triggers);
  swap(a.mgmt_addr, b.mgmt_addr);
  swap(a.mgmt_port, b.mgmt_port);
  swap(a.is_ssl, b.is_ssl);
  swap(a.parameters, b.parameters);
  swap(a.__isset, b.__isset);
}

running_task::running_task(const running_task& other1216) {
  id = other1216.id;
  triggers = other1216.triggers;
  mgmt_addr = other1216.mgmt_addr;
  mgmt_port = other1216.mgmt_port;
  is_ssl = other1216.is_ssl;
  parameters = other1216.parameters;
  __isset = other1216.__isset;
}
running_task& running_task::operator=(const running_task& other1217) {
  id = other1217.id;
  triggers = other1217.triggers;
  mgmt_addr = other1217.mgmt_addr;
  mgmt_port = other1217.mgmt_port;
  is_ssl = other1217.is_ssl;
  parameters = other1217.parameters;
  __isset = other1217.__isset;
  return *this;
}
void running_task::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "running_task(";
  out << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "triggers="; (__isset.triggers ? (out << to_string(triggers)) : (out << "<null>"));
  out << ", " << "mgmt_addr="; (__isset.mgmt_addr ? (out << to_string(mgmt_addr)) : (out << "<null>"));
  out << ", " << "mgmt_port="; (__isset.mgmt_port ? (out << to_string(mgmt_port)) : (out << "<null>"));
  out << ", " << "is_ssl="; (__isset.is_ssl ? (out << to_string(is_ssl)) : (out << "<null>"));
  out << ", " << "parameters="; (__isset.parameters ? (out << to_string(parameters)) : (out << "<null>"));
  out << ")";
}

}} // namespace
