/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "ironman_image_op_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace mwdc { namespace ironman { namespace image_op {


invalid_operation::~invalid_operation() throw() {
}


void invalid_operation::__set_what_op(const int32_t val) {
  this->what_op = val;
}

void invalid_operation::__set_why(const std::string& val) {
  this->why = val;
}

uint32_t invalid_operation::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->what_op);
          this->__isset.what_op = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->why);
          this->__isset.why = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t invalid_operation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("invalid_operation");

  xfer += oprot->writeFieldBegin("what_op", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->what_op);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("why", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->why);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(invalid_operation &a, invalid_operation &b) {
  using ::std::swap;
  swap(a.what_op, b.what_op);
  swap(a.why, b.why);
  swap(a.__isset, b.__isset);
}

invalid_operation::invalid_operation(const invalid_operation& other0) : TException() {
  what_op = other0.what_op;
  why = other0.why;
  __isset = other0.__isset;
}
invalid_operation& invalid_operation::operator=(const invalid_operation& other1) {
  what_op = other1.what_op;
  why = other1.why;
  __isset = other1.__isset;
  return *this;
}
void invalid_operation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "invalid_operation(";
  out << "what_op=" << to_string(what_op);
  out << ", " << "why=" << to_string(why);
  out << ")";
}

const char* invalid_operation::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: invalid_operation";
  }
}


op_status::~op_status() throw() {
}


void op_status::__set_vmxspec(const std::string& val) {
  this->vmxspec = val;
__isset.vmxspec = true;
}

void op_status::__set_image_name(const std::string& val) {
  this->image_name = val;
__isset.image_name = true;
}

void op_status::__set_snapshot_mor_ref(const std::string& val) {
  this->snapshot_mor_ref = val;
__isset.snapshot_mor_ref = true;
}

void op_status::__set_output_file_path(const std::string& val) {
  this->output_file_path = val;
__isset.output_file_path = true;
}

void op_status::__set_disk_size_bytes(const int64_t val) {
  this->disk_size_bytes = val;
__isset.disk_size_bytes = true;
}

void op_status::__set_last_read_pos_bytes(const int64_t val) {
  this->last_read_pos_bytes = val;
__isset.last_read_pos_bytes = true;
}

void op_status::__set_last_write_pos_bytes(const int64_t val) {
  this->last_write_pos_bytes = val;
__isset.last_write_pos_bytes = true;
}

void op_status::__set_completed_written_bytes(const int64_t val) {
  this->completed_written_bytes = val;
__isset.completed_written_bytes = true;
}

void op_status::__set_error_what(const int64_t val) {
  this->error_what = val;
__isset.error_what = true;
}

void op_status::__set_error_why(const std::string& val) {
  this->error_why = val;
__isset.error_why = true;
}

void op_status::__set_is_windows(const bool val) {
  this->is_windows = val;
__isset.is_windows = true;
}

uint32_t op_status::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->vmxspec);
          this->__isset.vmxspec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->image_name);
          this->__isset.image_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->snapshot_mor_ref);
          this->__isset.snapshot_mor_ref = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->output_file_path);
          this->__isset.output_file_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->disk_size_bytes);
          this->__isset.disk_size_bytes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->last_read_pos_bytes);
          this->__isset.last_read_pos_bytes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->last_write_pos_bytes);
          this->__isset.last_write_pos_bytes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->completed_written_bytes);
          this->__isset.completed_written_bytes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->error_what);
          this->__isset.error_what = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->error_why);
          this->__isset.error_why = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_windows);
          this->__isset.is_windows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t op_status::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("op_status");

  if (this->__isset.vmxspec) {
    xfer += oprot->writeFieldBegin("vmxspec", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->vmxspec);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.image_name) {
    xfer += oprot->writeFieldBegin("image_name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->image_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.snapshot_mor_ref) {
    xfer += oprot->writeFieldBegin("snapshot_mor_ref", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->snapshot_mor_ref);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.output_file_path) {
    xfer += oprot->writeFieldBegin("output_file_path", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->output_file_path);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.disk_size_bytes) {
    xfer += oprot->writeFieldBegin("disk_size_bytes", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->disk_size_bytes);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.last_read_pos_bytes) {
    xfer += oprot->writeFieldBegin("last_read_pos_bytes", ::apache::thrift::protocol::T_I64, 6);
    xfer += oprot->writeI64(this->last_read_pos_bytes);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.last_write_pos_bytes) {
    xfer += oprot->writeFieldBegin("last_write_pos_bytes", ::apache::thrift::protocol::T_I64, 7);
    xfer += oprot->writeI64(this->last_write_pos_bytes);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.completed_written_bytes) {
    xfer += oprot->writeFieldBegin("completed_written_bytes", ::apache::thrift::protocol::T_I64, 8);
    xfer += oprot->writeI64(this->completed_written_bytes);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.error_what) {
    xfer += oprot->writeFieldBegin("error_what", ::apache::thrift::protocol::T_I64, 9);
    xfer += oprot->writeI64(this->error_what);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.error_why) {
    xfer += oprot->writeFieldBegin("error_why", ::apache::thrift::protocol::T_STRING, 10);
    xfer += oprot->writeString(this->error_why);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_windows) {
    xfer += oprot->writeFieldBegin("is_windows", ::apache::thrift::protocol::T_BOOL, 11);
    xfer += oprot->writeBool(this->is_windows);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(op_status &a, op_status &b) {
  using ::std::swap;
  swap(a.vmxspec, b.vmxspec);
  swap(a.image_name, b.image_name);
  swap(a.snapshot_mor_ref, b.snapshot_mor_ref);
  swap(a.output_file_path, b.output_file_path);
  swap(a.disk_size_bytes, b.disk_size_bytes);
  swap(a.last_read_pos_bytes, b.last_read_pos_bytes);
  swap(a.last_write_pos_bytes, b.last_write_pos_bytes);
  swap(a.completed_written_bytes, b.completed_written_bytes);
  swap(a.error_what, b.error_what);
  swap(a.error_why, b.error_why);
  swap(a.is_windows, b.is_windows);
  swap(a.__isset, b.__isset);
}

op_status::op_status(const op_status& other2) {
  vmxspec = other2.vmxspec;
  image_name = other2.image_name;
  snapshot_mor_ref = other2.snapshot_mor_ref;
  output_file_path = other2.output_file_path;
  disk_size_bytes = other2.disk_size_bytes;
  last_read_pos_bytes = other2.last_read_pos_bytes;
  last_write_pos_bytes = other2.last_write_pos_bytes;
  completed_written_bytes = other2.completed_written_bytes;
  error_what = other2.error_what;
  error_why = other2.error_why;
  is_windows = other2.is_windows;
  __isset = other2.__isset;
}
op_status& op_status::operator=(const op_status& other3) {
  vmxspec = other3.vmxspec;
  image_name = other3.image_name;
  snapshot_mor_ref = other3.snapshot_mor_ref;
  output_file_path = other3.output_file_path;
  disk_size_bytes = other3.disk_size_bytes;
  last_read_pos_bytes = other3.last_read_pos_bytes;
  last_write_pos_bytes = other3.last_write_pos_bytes;
  completed_written_bytes = other3.completed_written_bytes;
  error_what = other3.error_what;
  error_why = other3.error_why;
  is_windows = other3.is_windows;
  __isset = other3.__isset;
  return *this;
}
void op_status::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "op_status(";
  out << "vmxspec="; (__isset.vmxspec ? (out << to_string(vmxspec)) : (out << "<null>"));
  out << ", " << "image_name="; (__isset.image_name ? (out << to_string(image_name)) : (out << "<null>"));
  out << ", " << "snapshot_mor_ref="; (__isset.snapshot_mor_ref ? (out << to_string(snapshot_mor_ref)) : (out << "<null>"));
  out << ", " << "output_file_path="; (__isset.output_file_path ? (out << to_string(output_file_path)) : (out << "<null>"));
  out << ", " << "disk_size_bytes="; (__isset.disk_size_bytes ? (out << to_string(disk_size_bytes)) : (out << "<null>"));
  out << ", " << "last_read_pos_bytes="; (__isset.last_read_pos_bytes ? (out << to_string(last_read_pos_bytes)) : (out << "<null>"));
  out << ", " << "last_write_pos_bytes="; (__isset.last_write_pos_bytes ? (out << to_string(last_write_pos_bytes)) : (out << "<null>"));
  out << ", " << "completed_written_bytes="; (__isset.completed_written_bytes ? (out << to_string(completed_written_bytes)) : (out << "<null>"));
  out << ", " << "error_what="; (__isset.error_what ? (out << to_string(error_what)) : (out << "<null>"));
  out << ", " << "error_why="; (__isset.error_why ? (out << to_string(error_why)) : (out << "<null>"));
  out << ", " << "is_windows="; (__isset.is_windows ? (out << to_string(is_windows)) : (out << "<null>"));
  out << ")";
}


data_chunks::~data_chunks() throw() {
}


void data_chunks::__set_start(const int64_t val) {
  this->start = val;
__isset.start = true;
}

void data_chunks::__set_length(const int64_t val) {
  this->length = val;
__isset.length = true;
}

uint32_t data_chunks::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->start);
          this->__isset.start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->length);
          this->__isset.length = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t data_chunks::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("data_chunks");

  if (this->__isset.start) {
    xfer += oprot->writeFieldBegin("start", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->start);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.length) {
    xfer += oprot->writeFieldBegin("length", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->length);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(data_chunks &a, data_chunks &b) {
  using ::std::swap;
  swap(a.start, b.start);
  swap(a.length, b.length);
  swap(a.__isset, b.__isset);
}

data_chunks::data_chunks(const data_chunks& other4) {
  start = other4.start;
  length = other4.length;
  __isset = other4.__isset;
}
data_chunks& data_chunks::operator=(const data_chunks& other5) {
  start = other5.start;
  length = other5.length;
  __isset = other5.__isset;
  return *this;
}
void data_chunks::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "data_chunks(";
  out << "start="; (__isset.start ? (out << to_string(start)) : (out << "<null>"));
  out << ", " << "length="; (__isset.length ? (out << to_string(length)) : (out << "<null>"));
  out << ")";
}


vmdk_to_other_image_req_args::~vmdk_to_other_image_req_args() throw() {
}


void vmdk_to_other_image_req_args::__set_vmxspec(const std::string& val) {
  this->vmxspec = val;
__isset.vmxspec = true;
}

void vmdk_to_other_image_req_args::__set_thumbprint(const std::string& val) {
  this->thumbprint = val;
__isset.thumbprint = true;
}

void vmdk_to_other_image_req_args::__set_source_image_path(const std::string& val) {
  this->source_image_path = val;
__isset.source_image_path = true;
}

void vmdk_to_other_image_req_args::__set_output_file_path(const std::string& val) {
  this->output_file_path = val;
__isset.output_file_path = true;
}

void vmdk_to_other_image_req_args::__set_parent_file(const std::string& val) {
  this->parent_file = val;
__isset.parent_file = true;
}

void vmdk_to_other_image_req_args::__set_snapshot_mor_ref(const std::string& val) {
  this->snapshot_mor_ref = val;
__isset.snapshot_mor_ref = true;
}

void vmdk_to_other_image_req_args::__set_checksum_file_path(const std::string& val) {
  this->checksum_file_path = val;
__isset.checksum_file_path = true;
}

void vmdk_to_other_image_req_args::__set_readonly(const bool val) {
  this->readonly = val;
__isset.readonly = true;
}

void vmdk_to_other_image_req_args::__set_disk_size_bytes(const int64_t val) {
  this->disk_size_bytes = val;
__isset.disk_size_bytes = true;
}

void vmdk_to_other_image_req_args::__set_next_byte_to_read(const int64_t val) {
  this->next_byte_to_read = val;
__isset.next_byte_to_read = true;
}

void vmdk_to_other_image_req_args::__set_next_byte_to_write(const int64_t val) {
  this->next_byte_to_write = val;
__isset.next_byte_to_write = true;
}

void vmdk_to_other_image_req_args::__set_completed_written_bytes(const int64_t val) {
  this->completed_written_bytes = val;
__isset.completed_written_bytes = true;
}

void vmdk_to_other_image_req_args::__set_clean_vss_sectors(const bool val) {
  this->clean_vss_sectors = val;
__isset.clean_vss_sectors = true;
}

void vmdk_to_other_image_req_args::__set_changed_blocks(const std::vector<data_chunks> & val) {
  this->changed_blocks = val;
__isset.changed_blocks = true;
}

uint32_t vmdk_to_other_image_req_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->vmxspec);
          this->__isset.vmxspec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->thumbprint);
          this->__isset.thumbprint = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->source_image_path);
          this->__isset.source_image_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->output_file_path);
          this->__isset.output_file_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->parent_file);
          this->__isset.parent_file = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->snapshot_mor_ref);
          this->__isset.snapshot_mor_ref = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->checksum_file_path);
          this->__isset.checksum_file_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->readonly);
          this->__isset.readonly = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->disk_size_bytes);
          this->__isset.disk_size_bytes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->next_byte_to_read);
          this->__isset.next_byte_to_read = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->next_byte_to_write);
          this->__isset.next_byte_to_write = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->completed_written_bytes);
          this->__isset.completed_written_bytes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->clean_vss_sectors);
          this->__isset.clean_vss_sectors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->changed_blocks.clear();
            uint32_t _size6;
            ::apache::thrift::protocol::TType _etype9;
            xfer += iprot->readListBegin(_etype9, _size6);
            this->changed_blocks.resize(_size6);
            uint32_t _i10;
            for (_i10 = 0; _i10 < _size6; ++_i10)
            {
              xfer += this->changed_blocks[_i10].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.changed_blocks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t vmdk_to_other_image_req_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("vmdk_to_other_image_req_args");

  if (this->__isset.vmxspec) {
    xfer += oprot->writeFieldBegin("vmxspec", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->vmxspec);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.thumbprint) {
    xfer += oprot->writeFieldBegin("thumbprint", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->thumbprint);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.source_image_path) {
    xfer += oprot->writeFieldBegin("source_image_path", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->source_image_path);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.output_file_path) {
    xfer += oprot->writeFieldBegin("output_file_path", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->output_file_path);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.parent_file) {
    xfer += oprot->writeFieldBegin("parent_file", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->parent_file);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.snapshot_mor_ref) {
    xfer += oprot->writeFieldBegin("snapshot_mor_ref", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->snapshot_mor_ref);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.checksum_file_path) {
    xfer += oprot->writeFieldBegin("checksum_file_path", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->checksum_file_path);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.readonly) {
    xfer += oprot->writeFieldBegin("readonly", ::apache::thrift::protocol::T_BOOL, 8);
    xfer += oprot->writeBool(this->readonly);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.disk_size_bytes) {
    xfer += oprot->writeFieldBegin("disk_size_bytes", ::apache::thrift::protocol::T_I64, 9);
    xfer += oprot->writeI64(this->disk_size_bytes);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.next_byte_to_read) {
    xfer += oprot->writeFieldBegin("next_byte_to_read", ::apache::thrift::protocol::T_I64, 10);
    xfer += oprot->writeI64(this->next_byte_to_read);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.next_byte_to_write) {
    xfer += oprot->writeFieldBegin("next_byte_to_write", ::apache::thrift::protocol::T_I64, 11);
    xfer += oprot->writeI64(this->next_byte_to_write);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.completed_written_bytes) {
    xfer += oprot->writeFieldBegin("completed_written_bytes", ::apache::thrift::protocol::T_I64, 12);
    xfer += oprot->writeI64(this->completed_written_bytes);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.clean_vss_sectors) {
    xfer += oprot->writeFieldBegin("clean_vss_sectors", ::apache::thrift::protocol::T_BOOL, 13);
    xfer += oprot->writeBool(this->clean_vss_sectors);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.changed_blocks) {
    xfer += oprot->writeFieldBegin("changed_blocks", ::apache::thrift::protocol::T_LIST, 14);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->changed_blocks.size()));
      std::vector<data_chunks> ::const_iterator _iter11;
      for (_iter11 = this->changed_blocks.begin(); _iter11 != this->changed_blocks.end(); ++_iter11)
      {
        xfer += (*_iter11).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(vmdk_to_other_image_req_args &a, vmdk_to_other_image_req_args &b) {
  using ::std::swap;
  swap(a.vmxspec, b.vmxspec);
  swap(a.thumbprint, b.thumbprint);
  swap(a.source_image_path, b.source_image_path);
  swap(a.output_file_path, b.output_file_path);
  swap(a.parent_file, b.parent_file);
  swap(a.snapshot_mor_ref, b.snapshot_mor_ref);
  swap(a.checksum_file_path, b.checksum_file_path);
  swap(a.readonly, b.readonly);
  swap(a.disk_size_bytes, b.disk_size_bytes);
  swap(a.next_byte_to_read, b.next_byte_to_read);
  swap(a.next_byte_to_write, b.next_byte_to_write);
  swap(a.completed_written_bytes, b.completed_written_bytes);
  swap(a.clean_vss_sectors, b.clean_vss_sectors);
  swap(a.changed_blocks, b.changed_blocks);
  swap(a.__isset, b.__isset);
}

vmdk_to_other_image_req_args::vmdk_to_other_image_req_args(const vmdk_to_other_image_req_args& other12) {
  vmxspec = other12.vmxspec;
  thumbprint = other12.thumbprint;
  source_image_path = other12.source_image_path;
  output_file_path = other12.output_file_path;
  parent_file = other12.parent_file;
  snapshot_mor_ref = other12.snapshot_mor_ref;
  checksum_file_path = other12.checksum_file_path;
  readonly = other12.readonly;
  disk_size_bytes = other12.disk_size_bytes;
  next_byte_to_read = other12.next_byte_to_read;
  next_byte_to_write = other12.next_byte_to_write;
  completed_written_bytes = other12.completed_written_bytes;
  clean_vss_sectors = other12.clean_vss_sectors;
  changed_blocks = other12.changed_blocks;
  __isset = other12.__isset;
}
vmdk_to_other_image_req_args& vmdk_to_other_image_req_args::operator=(const vmdk_to_other_image_req_args& other13) {
  vmxspec = other13.vmxspec;
  thumbprint = other13.thumbprint;
  source_image_path = other13.source_image_path;
  output_file_path = other13.output_file_path;
  parent_file = other13.parent_file;
  snapshot_mor_ref = other13.snapshot_mor_ref;
  checksum_file_path = other13.checksum_file_path;
  readonly = other13.readonly;
  disk_size_bytes = other13.disk_size_bytes;
  next_byte_to_read = other13.next_byte_to_read;
  next_byte_to_write = other13.next_byte_to_write;
  completed_written_bytes = other13.completed_written_bytes;
  clean_vss_sectors = other13.clean_vss_sectors;
  changed_blocks = other13.changed_blocks;
  __isset = other13.__isset;
  return *this;
}
void vmdk_to_other_image_req_args::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "vmdk_to_other_image_req_args(";
  out << "vmxspec="; (__isset.vmxspec ? (out << to_string(vmxspec)) : (out << "<null>"));
  out << ", " << "thumbprint="; (__isset.thumbprint ? (out << to_string(thumbprint)) : (out << "<null>"));
  out << ", " << "source_image_path="; (__isset.source_image_path ? (out << to_string(source_image_path)) : (out << "<null>"));
  out << ", " << "output_file_path="; (__isset.output_file_path ? (out << to_string(output_file_path)) : (out << "<null>"));
  out << ", " << "parent_file="; (__isset.parent_file ? (out << to_string(parent_file)) : (out << "<null>"));
  out << ", " << "snapshot_mor_ref="; (__isset.snapshot_mor_ref ? (out << to_string(snapshot_mor_ref)) : (out << "<null>"));
  out << ", " << "checksum_file_path="; (__isset.checksum_file_path ? (out << to_string(checksum_file_path)) : (out << "<null>"));
  out << ", " << "readonly="; (__isset.readonly ? (out << to_string(readonly)) : (out << "<null>"));
  out << ", " << "disk_size_bytes="; (__isset.disk_size_bytes ? (out << to_string(disk_size_bytes)) : (out << "<null>"));
  out << ", " << "next_byte_to_read="; (__isset.next_byte_to_read ? (out << to_string(next_byte_to_read)) : (out << "<null>"));
  out << ", " << "next_byte_to_write="; (__isset.next_byte_to_write ? (out << to_string(next_byte_to_write)) : (out << "<null>"));
  out << ", " << "completed_written_bytes="; (__isset.completed_written_bytes ? (out << to_string(completed_written_bytes)) : (out << "<null>"));
  out << ", " << "clean_vss_sectors="; (__isset.clean_vss_sectors ? (out << to_string(clean_vss_sectors)) : (out << "<null>"));
  out << ", " << "changed_blocks="; (__isset.changed_blocks ? (out << to_string(changed_blocks)) : (out << "<null>"));
  out << ")";
}

}}} // namespace
