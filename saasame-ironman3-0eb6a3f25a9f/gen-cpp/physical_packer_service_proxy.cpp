/**
 * Autogenerated by Thrift Compiler (0.12.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "physical_packer_service_proxy.h"
#include "thrift/async/TAsyncChannel.h"

namespace saasame { namespace transport {


physical_packer_service_proxy_packer_ping_p_args::~physical_packer_service_proxy_packer_ping_p_args() throw() {
}


uint32_t physical_packer_service_proxy_packer_ping_p_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->addr);
          this->__isset.addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_packer_ping_p_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_packer_ping_p_args");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->addr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_packer_ping_p_pargs::~physical_packer_service_proxy_packer_ping_p_pargs() throw() {
}


uint32_t physical_packer_service_proxy_packer_ping_p_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_packer_ping_p_pargs");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->session_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->addr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_packer_ping_p_result::~physical_packer_service_proxy_packer_ping_p_result() throw() {
}


uint32_t physical_packer_service_proxy_packer_ping_p_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_packer_ping_p_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("physical_packer_service_proxy_packer_ping_p_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_packer_ping_p_presult::~physical_packer_service_proxy_packer_ping_p_presult() throw() {
}


uint32_t physical_packer_service_proxy_packer_ping_p_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_packer_ping_p_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_packer_ping_p_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
  xfer += (*(this->success)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_take_snapshots_p_args::~physical_packer_service_proxy_take_snapshots_p_args() throw() {
}


uint32_t physical_packer_service_proxy_take_snapshots_p_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->addr);
          this->__isset.addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->disks.clear();
            uint32_t _size1488;
            ::apache::thrift::protocol::TType _etype1491;
            xfer += iprot->readSetBegin(_etype1491, _size1488);
            uint32_t _i1492;
            for (_i1492 = 0; _i1492 < _size1488; ++_i1492)
            {
              std::string _elem1493;
              xfer += iprot->readString(_elem1493);
              this->disks.insert(_elem1493);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.disks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_take_snapshots_p_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_take_snapshots_p_args");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->addr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("disks", ::apache::thrift::protocol::T_SET, 3);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->disks.size()));
    std::set<std::string> ::const_iterator _iter1494;
    for (_iter1494 = this->disks.begin(); _iter1494 != this->disks.end(); ++_iter1494)
    {
      xfer += oprot->writeString((*_iter1494));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_take_snapshots_p_pargs::~physical_packer_service_proxy_take_snapshots_p_pargs() throw() {
}


uint32_t physical_packer_service_proxy_take_snapshots_p_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_take_snapshots_p_pargs");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->session_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->addr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("disks", ::apache::thrift::protocol::T_SET, 3);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->disks)).size()));
    std::set<std::string> ::const_iterator _iter1495;
    for (_iter1495 = (*(this->disks)).begin(); _iter1495 != (*(this->disks)).end(); ++_iter1495)
    {
      xfer += oprot->writeString((*_iter1495));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_take_snapshots_p_result::~physical_packer_service_proxy_take_snapshots_p_result() throw() {
}


uint32_t physical_packer_service_proxy_take_snapshots_p_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size1496;
            ::apache::thrift::protocol::TType _etype1499;
            xfer += iprot->readListBegin(_etype1499, _size1496);
            this->success.resize(_size1496);
            uint32_t _i1500;
            for (_i1500 = 0; _i1500 < _size1496; ++_i1500)
            {
              xfer += this->success[_i1500].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_take_snapshots_p_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("physical_packer_service_proxy_take_snapshots_p_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector<snapshot> ::const_iterator _iter1501;
      for (_iter1501 = this->success.begin(); _iter1501 != this->success.end(); ++_iter1501)
      {
        xfer += (*_iter1501).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_take_snapshots_p_presult::~physical_packer_service_proxy_take_snapshots_p_presult() throw() {
}


uint32_t physical_packer_service_proxy_take_snapshots_p_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size1502;
            ::apache::thrift::protocol::TType _etype1505;
            xfer += iprot->readListBegin(_etype1505, _size1502);
            (*(this->success)).resize(_size1502);
            uint32_t _i1506;
            for (_i1506 = 0; _i1506 < _size1502; ++_i1506)
            {
              xfer += (*(this->success))[_i1506].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_take_snapshots_p_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_take_snapshots_p_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->success)).size()));
    std::vector<snapshot> ::const_iterator _iter1507;
    for (_iter1507 = (*(this->success)).begin(); _iter1507 != (*(this->success)).end(); ++_iter1507)
    {
      xfer += (*_iter1507).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_take_snapshots_ex_p_args::~physical_packer_service_proxy_take_snapshots_ex_p_args() throw() {
}


uint32_t physical_packer_service_proxy_take_snapshots_ex_p_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->addr);
          this->__isset.addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->disks.clear();
            uint32_t _size1508;
            ::apache::thrift::protocol::TType _etype1511;
            xfer += iprot->readSetBegin(_etype1511, _size1508);
            uint32_t _i1512;
            for (_i1512 = 0; _i1512 < _size1508; ++_i1512)
            {
              std::string _elem1513;
              xfer += iprot->readString(_elem1513);
              this->disks.insert(_elem1513);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.disks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pre_script);
          this->__isset.pre_script = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->post_script);
          this->__isset.post_script = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_take_snapshots_ex_p_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_take_snapshots_ex_p_args");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->addr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("disks", ::apache::thrift::protocol::T_SET, 3);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->disks.size()));
    std::set<std::string> ::const_iterator _iter1514;
    for (_iter1514 = this->disks.begin(); _iter1514 != this->disks.end(); ++_iter1514)
    {
      xfer += oprot->writeString((*_iter1514));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pre_script", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->pre_script);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("post_script", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->post_script);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_take_snapshots_ex_p_pargs::~physical_packer_service_proxy_take_snapshots_ex_p_pargs() throw() {
}


uint32_t physical_packer_service_proxy_take_snapshots_ex_p_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_take_snapshots_ex_p_pargs");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->session_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->addr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("disks", ::apache::thrift::protocol::T_SET, 3);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->disks)).size()));
    std::set<std::string> ::const_iterator _iter1515;
    for (_iter1515 = (*(this->disks)).begin(); _iter1515 != (*(this->disks)).end(); ++_iter1515)
    {
      xfer += oprot->writeString((*_iter1515));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pre_script", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->pre_script)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("post_script", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString((*(this->post_script)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_take_snapshots_ex_p_result::~physical_packer_service_proxy_take_snapshots_ex_p_result() throw() {
}


uint32_t physical_packer_service_proxy_take_snapshots_ex_p_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size1516;
            ::apache::thrift::protocol::TType _etype1519;
            xfer += iprot->readListBegin(_etype1519, _size1516);
            this->success.resize(_size1516);
            uint32_t _i1520;
            for (_i1520 = 0; _i1520 < _size1516; ++_i1520)
            {
              xfer += this->success[_i1520].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_take_snapshots_ex_p_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("physical_packer_service_proxy_take_snapshots_ex_p_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector<snapshot> ::const_iterator _iter1521;
      for (_iter1521 = this->success.begin(); _iter1521 != this->success.end(); ++_iter1521)
      {
        xfer += (*_iter1521).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_take_snapshots_ex_p_presult::~physical_packer_service_proxy_take_snapshots_ex_p_presult() throw() {
}


uint32_t physical_packer_service_proxy_take_snapshots_ex_p_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size1522;
            ::apache::thrift::protocol::TType _etype1525;
            xfer += iprot->readListBegin(_etype1525, _size1522);
            (*(this->success)).resize(_size1522);
            uint32_t _i1526;
            for (_i1526 = 0; _i1526 < _size1522; ++_i1526)
            {
              xfer += (*(this->success))[_i1526].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_take_snapshots_ex_p_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_take_snapshots_ex_p_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->success)).size()));
    std::vector<snapshot> ::const_iterator _iter1527;
    for (_iter1527 = (*(this->success)).begin(); _iter1527 != (*(this->success)).end(); ++_iter1527)
    {
      xfer += (*_iter1527).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_take_snapshots2_p_args::~physical_packer_service_proxy_take_snapshots2_p_args() throw() {
}


uint32_t physical_packer_service_proxy_take_snapshots2_p_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->addr);
          this->__isset.addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->parameters.read(iprot);
          this->__isset.parameters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_take_snapshots2_p_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_take_snapshots2_p_args");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->addr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parameters", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->parameters.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_take_snapshots2_p_pargs::~physical_packer_service_proxy_take_snapshots2_p_pargs() throw() {
}


uint32_t physical_packer_service_proxy_take_snapshots2_p_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_take_snapshots2_p_pargs");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->session_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->addr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parameters", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->parameters)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_take_snapshots2_p_result::~physical_packer_service_proxy_take_snapshots2_p_result() throw() {
}


uint32_t physical_packer_service_proxy_take_snapshots2_p_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size1528;
            ::apache::thrift::protocol::TType _etype1531;
            xfer += iprot->readListBegin(_etype1531, _size1528);
            this->success.resize(_size1528);
            uint32_t _i1532;
            for (_i1532 = 0; _i1532 < _size1528; ++_i1532)
            {
              xfer += this->success[_i1532].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_take_snapshots2_p_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("physical_packer_service_proxy_take_snapshots2_p_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector<snapshot> ::const_iterator _iter1533;
      for (_iter1533 = this->success.begin(); _iter1533 != this->success.end(); ++_iter1533)
      {
        xfer += (*_iter1533).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_take_snapshots2_p_presult::~physical_packer_service_proxy_take_snapshots2_p_presult() throw() {
}


uint32_t physical_packer_service_proxy_take_snapshots2_p_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size1534;
            ::apache::thrift::protocol::TType _etype1537;
            xfer += iprot->readListBegin(_etype1537, _size1534);
            (*(this->success)).resize(_size1534);
            uint32_t _i1538;
            for (_i1538 = 0; _i1538 < _size1534; ++_i1538)
            {
              xfer += (*(this->success))[_i1538].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_take_snapshots2_p_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_take_snapshots2_p_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->success)).size()));
    std::vector<snapshot> ::const_iterator _iter1539;
    for (_iter1539 = (*(this->success)).begin(); _iter1539 != (*(this->success)).end(); ++_iter1539)
    {
      xfer += (*_iter1539).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_delete_snapshot_p_args::~physical_packer_service_proxy_delete_snapshot_p_args() throw() {
}


uint32_t physical_packer_service_proxy_delete_snapshot_p_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->addr);
          this->__isset.addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->snapshot_id);
          this->__isset.snapshot_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_delete_snapshot_p_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_delete_snapshot_p_args");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->addr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("snapshot_id", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->snapshot_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_delete_snapshot_p_pargs::~physical_packer_service_proxy_delete_snapshot_p_pargs() throw() {
}


uint32_t physical_packer_service_proxy_delete_snapshot_p_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_delete_snapshot_p_pargs");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->session_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->addr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("snapshot_id", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->snapshot_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_delete_snapshot_p_result::~physical_packer_service_proxy_delete_snapshot_p_result() throw() {
}


uint32_t physical_packer_service_proxy_delete_snapshot_p_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_delete_snapshot_p_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("physical_packer_service_proxy_delete_snapshot_p_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_delete_snapshot_p_presult::~physical_packer_service_proxy_delete_snapshot_p_presult() throw() {
}


uint32_t physical_packer_service_proxy_delete_snapshot_p_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_delete_snapshot_p_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_delete_snapshot_p_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
  xfer += (*(this->success)).write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_delete_snapshot_set_p_args::~physical_packer_service_proxy_delete_snapshot_set_p_args() throw() {
}


uint32_t physical_packer_service_proxy_delete_snapshot_set_p_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->addr);
          this->__isset.addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->snapshot_set_id);
          this->__isset.snapshot_set_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_delete_snapshot_set_p_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_delete_snapshot_set_p_args");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->addr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("snapshot_set_id", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->snapshot_set_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_delete_snapshot_set_p_pargs::~physical_packer_service_proxy_delete_snapshot_set_p_pargs() throw() {
}


uint32_t physical_packer_service_proxy_delete_snapshot_set_p_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_delete_snapshot_set_p_pargs");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->session_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->addr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("snapshot_set_id", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->snapshot_set_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_delete_snapshot_set_p_result::~physical_packer_service_proxy_delete_snapshot_set_p_result() throw() {
}


uint32_t physical_packer_service_proxy_delete_snapshot_set_p_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_delete_snapshot_set_p_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("physical_packer_service_proxy_delete_snapshot_set_p_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_delete_snapshot_set_p_presult::~physical_packer_service_proxy_delete_snapshot_set_p_presult() throw() {
}


uint32_t physical_packer_service_proxy_delete_snapshot_set_p_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_delete_snapshot_set_p_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_delete_snapshot_set_p_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
  xfer += (*(this->success)).write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_get_all_snapshots_p_args::~physical_packer_service_proxy_get_all_snapshots_p_args() throw() {
}


uint32_t physical_packer_service_proxy_get_all_snapshots_p_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->addr);
          this->__isset.addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_get_all_snapshots_p_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_get_all_snapshots_p_args");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->addr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_get_all_snapshots_p_pargs::~physical_packer_service_proxy_get_all_snapshots_p_pargs() throw() {
}


uint32_t physical_packer_service_proxy_get_all_snapshots_p_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_get_all_snapshots_p_pargs");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->session_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->addr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_get_all_snapshots_p_result::~physical_packer_service_proxy_get_all_snapshots_p_result() throw() {
}


uint32_t physical_packer_service_proxy_get_all_snapshots_p_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->success.clear();
            uint32_t _size1540;
            ::apache::thrift::protocol::TType _ktype1541;
            ::apache::thrift::protocol::TType _vtype1542;
            xfer += iprot->readMapBegin(_ktype1541, _vtype1542, _size1540);
            uint32_t _i1544;
            for (_i1544 = 0; _i1544 < _size1540; ++_i1544)
            {
              std::string _key1545;
              xfer += iprot->readString(_key1545);
              std::vector<snapshot> & _val1546 = this->success[_key1545];
              {
                _val1546.clear();
                uint32_t _size1547;
                ::apache::thrift::protocol::TType _etype1550;
                xfer += iprot->readListBegin(_etype1550, _size1547);
                _val1546.resize(_size1547);
                uint32_t _i1551;
                for (_i1551 = 0; _i1551 < _size1547; ++_i1551)
                {
                  xfer += _val1546[_i1551].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_get_all_snapshots_p_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("physical_packer_service_proxy_get_all_snapshots_p_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->success.size()));
      std::map<std::string, std::vector<snapshot> > ::const_iterator _iter1552;
      for (_iter1552 = this->success.begin(); _iter1552 != this->success.end(); ++_iter1552)
      {
        xfer += oprot->writeString(_iter1552->first);
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter1552->second.size()));
          std::vector<snapshot> ::const_iterator _iter1553;
          for (_iter1553 = _iter1552->second.begin(); _iter1553 != _iter1552->second.end(); ++_iter1553)
          {
            xfer += (*_iter1553).write(oprot);
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_get_all_snapshots_p_presult::~physical_packer_service_proxy_get_all_snapshots_p_presult() throw() {
}


uint32_t physical_packer_service_proxy_get_all_snapshots_p_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            (*(this->success)).clear();
            uint32_t _size1554;
            ::apache::thrift::protocol::TType _ktype1555;
            ::apache::thrift::protocol::TType _vtype1556;
            xfer += iprot->readMapBegin(_ktype1555, _vtype1556, _size1554);
            uint32_t _i1558;
            for (_i1558 = 0; _i1558 < _size1554; ++_i1558)
            {
              std::string _key1559;
              xfer += iprot->readString(_key1559);
              std::vector<snapshot> & _val1560 = (*(this->success))[_key1559];
              {
                _val1560.clear();
                uint32_t _size1561;
                ::apache::thrift::protocol::TType _etype1564;
                xfer += iprot->readListBegin(_etype1564, _size1561);
                _val1560.resize(_size1561);
                uint32_t _i1565;
                for (_i1565 = 0; _i1565 < _size1561; ++_i1565)
                {
                  xfer += _val1560[_i1565].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_get_all_snapshots_p_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_get_all_snapshots_p_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>((*(this->success)).size()));
    std::map<std::string, std::vector<snapshot> > ::const_iterator _iter1566;
    for (_iter1566 = (*(this->success)).begin(); _iter1566 != (*(this->success)).end(); ++_iter1566)
    {
      xfer += oprot->writeString(_iter1566->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter1566->second.size()));
        std::vector<snapshot> ::const_iterator _iter1567;
        for (_iter1567 = _iter1566->second.begin(); _iter1567 != _iter1566->second.end(); ++_iter1567)
        {
          xfer += (*_iter1567).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_create_packer_job_ex_p_args::~physical_packer_service_proxy_create_packer_job_ex_p_args() throw() {
}


uint32_t physical_packer_service_proxy_create_packer_job_ex_p_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->addr);
          this->__isset.addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->job_id);
          this->__isset.job_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->create_job.read(iprot);
          this->__isset.create_job = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_create_packer_job_ex_p_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_create_packer_job_ex_p_args");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->addr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("job_id", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->job_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("create_job", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->create_job.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_create_packer_job_ex_p_pargs::~physical_packer_service_proxy_create_packer_job_ex_p_pargs() throw() {
}


uint32_t physical_packer_service_proxy_create_packer_job_ex_p_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_create_packer_job_ex_p_pargs");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->session_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->addr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("job_id", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->job_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("create_job", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += (*(this->create_job)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_create_packer_job_ex_p_result::~physical_packer_service_proxy_create_packer_job_ex_p_result() throw() {
}


uint32_t physical_packer_service_proxy_create_packer_job_ex_p_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_create_packer_job_ex_p_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("physical_packer_service_proxy_create_packer_job_ex_p_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_create_packer_job_ex_p_presult::~physical_packer_service_proxy_create_packer_job_ex_p_presult() throw() {
}


uint32_t physical_packer_service_proxy_create_packer_job_ex_p_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_create_packer_job_ex_p_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_create_packer_job_ex_p_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
  xfer += (*(this->success)).write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_get_packer_job_p_args::~physical_packer_service_proxy_get_packer_job_p_args() throw() {
}


uint32_t physical_packer_service_proxy_get_packer_job_p_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->addr);
          this->__isset.addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->job_id);
          this->__isset.job_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->previous_updated_time);
          this->__isset.previous_updated_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_get_packer_job_p_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_get_packer_job_p_args");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->addr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("job_id", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->job_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("previous_updated_time", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->previous_updated_time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_get_packer_job_p_pargs::~physical_packer_service_proxy_get_packer_job_p_pargs() throw() {
}


uint32_t physical_packer_service_proxy_get_packer_job_p_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_get_packer_job_p_pargs");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->session_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->addr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("job_id", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->job_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("previous_updated_time", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->previous_updated_time)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_get_packer_job_p_result::~physical_packer_service_proxy_get_packer_job_p_result() throw() {
}


uint32_t physical_packer_service_proxy_get_packer_job_p_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_get_packer_job_p_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("physical_packer_service_proxy_get_packer_job_p_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_get_packer_job_p_presult::~physical_packer_service_proxy_get_packer_job_p_presult() throw() {
}


uint32_t physical_packer_service_proxy_get_packer_job_p_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_get_packer_job_p_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_get_packer_job_p_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
  xfer += (*(this->success)).write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_interrupt_packer_job_p_args::~physical_packer_service_proxy_interrupt_packer_job_p_args() throw() {
}


uint32_t physical_packer_service_proxy_interrupt_packer_job_p_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->addr);
          this->__isset.addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->job_id);
          this->__isset.job_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_interrupt_packer_job_p_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_interrupt_packer_job_p_args");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->addr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("job_id", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->job_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_interrupt_packer_job_p_pargs::~physical_packer_service_proxy_interrupt_packer_job_p_pargs() throw() {
}


uint32_t physical_packer_service_proxy_interrupt_packer_job_p_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_interrupt_packer_job_p_pargs");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->session_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->addr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("job_id", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->job_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_interrupt_packer_job_p_result::~physical_packer_service_proxy_interrupt_packer_job_p_result() throw() {
}


uint32_t physical_packer_service_proxy_interrupt_packer_job_p_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_interrupt_packer_job_p_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("physical_packer_service_proxy_interrupt_packer_job_p_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_interrupt_packer_job_p_presult::~physical_packer_service_proxy_interrupt_packer_job_p_presult() throw() {
}


uint32_t physical_packer_service_proxy_interrupt_packer_job_p_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_interrupt_packer_job_p_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_interrupt_packer_job_p_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
  xfer += oprot->writeBool((*(this->success)));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_resume_packer_job_p_args::~physical_packer_service_proxy_resume_packer_job_p_args() throw() {
}


uint32_t physical_packer_service_proxy_resume_packer_job_p_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->addr);
          this->__isset.addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->job_id);
          this->__isset.job_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_resume_packer_job_p_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_resume_packer_job_p_args");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->addr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("job_id", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->job_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_resume_packer_job_p_pargs::~physical_packer_service_proxy_resume_packer_job_p_pargs() throw() {
}


uint32_t physical_packer_service_proxy_resume_packer_job_p_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_resume_packer_job_p_pargs");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->session_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->addr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("job_id", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->job_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_resume_packer_job_p_result::~physical_packer_service_proxy_resume_packer_job_p_result() throw() {
}


uint32_t physical_packer_service_proxy_resume_packer_job_p_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_resume_packer_job_p_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("physical_packer_service_proxy_resume_packer_job_p_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_resume_packer_job_p_presult::~physical_packer_service_proxy_resume_packer_job_p_presult() throw() {
}


uint32_t physical_packer_service_proxy_resume_packer_job_p_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_resume_packer_job_p_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_resume_packer_job_p_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
  xfer += oprot->writeBool((*(this->success)));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_remove_packer_job_p_args::~physical_packer_service_proxy_remove_packer_job_p_args() throw() {
}


uint32_t physical_packer_service_proxy_remove_packer_job_p_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->addr);
          this->__isset.addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->job_id);
          this->__isset.job_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_remove_packer_job_p_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_remove_packer_job_p_args");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->addr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("job_id", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->job_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_remove_packer_job_p_pargs::~physical_packer_service_proxy_remove_packer_job_p_pargs() throw() {
}


uint32_t physical_packer_service_proxy_remove_packer_job_p_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_remove_packer_job_p_pargs");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->session_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->addr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("job_id", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->job_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_remove_packer_job_p_result::~physical_packer_service_proxy_remove_packer_job_p_result() throw() {
}


uint32_t physical_packer_service_proxy_remove_packer_job_p_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_remove_packer_job_p_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("physical_packer_service_proxy_remove_packer_job_p_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_remove_packer_job_p_presult::~physical_packer_service_proxy_remove_packer_job_p_presult() throw() {
}


uint32_t physical_packer_service_proxy_remove_packer_job_p_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_remove_packer_job_p_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_remove_packer_job_p_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
  xfer += oprot->writeBool((*(this->success)));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_running_packer_job_p_args::~physical_packer_service_proxy_running_packer_job_p_args() throw() {
}


uint32_t physical_packer_service_proxy_running_packer_job_p_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->addr);
          this->__isset.addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->job_id);
          this->__isset.job_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_running_packer_job_p_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_running_packer_job_p_args");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->addr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("job_id", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->job_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_running_packer_job_p_pargs::~physical_packer_service_proxy_running_packer_job_p_pargs() throw() {
}


uint32_t physical_packer_service_proxy_running_packer_job_p_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_running_packer_job_p_pargs");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->session_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->addr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("job_id", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->job_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_running_packer_job_p_result::~physical_packer_service_proxy_running_packer_job_p_result() throw() {
}


uint32_t physical_packer_service_proxy_running_packer_job_p_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_running_packer_job_p_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("physical_packer_service_proxy_running_packer_job_p_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_running_packer_job_p_presult::~physical_packer_service_proxy_running_packer_job_p_presult() throw() {
}


uint32_t physical_packer_service_proxy_running_packer_job_p_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_running_packer_job_p_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_running_packer_job_p_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
  xfer += oprot->writeBool((*(this->success)));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_enumerate_packer_disks_p_args::~physical_packer_service_proxy_enumerate_packer_disks_p_args() throw() {
}


uint32_t physical_packer_service_proxy_enumerate_packer_disks_p_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->addr);
          this->__isset.addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1568;
          xfer += iprot->readI32(ecast1568);
          this->filter = (enumerate_disk_filter_style::type)ecast1568;
          this->__isset.filter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_enumerate_packer_disks_p_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_enumerate_packer_disks_p_args");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->addr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("filter", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->filter);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_enumerate_packer_disks_p_pargs::~physical_packer_service_proxy_enumerate_packer_disks_p_pargs() throw() {
}


uint32_t physical_packer_service_proxy_enumerate_packer_disks_p_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_enumerate_packer_disks_p_pargs");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->session_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->addr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("filter", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)(*(this->filter)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_enumerate_packer_disks_p_result::~physical_packer_service_proxy_enumerate_packer_disks_p_result() throw() {
}


uint32_t physical_packer_service_proxy_enumerate_packer_disks_p_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->success.clear();
            uint32_t _size1569;
            ::apache::thrift::protocol::TType _etype1572;
            xfer += iprot->readSetBegin(_etype1572, _size1569);
            uint32_t _i1573;
            for (_i1573 = 0; _i1573 < _size1569; ++_i1573)
            {
              disk_info _elem1574;
              xfer += _elem1574.read(iprot);
              this->success.insert(_elem1574);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_enumerate_packer_disks_p_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("physical_packer_service_proxy_enumerate_packer_disks_p_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_SET, 0);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::set<disk_info> ::const_iterator _iter1575;
      for (_iter1575 = this->success.begin(); _iter1575 != this->success.end(); ++_iter1575)
      {
        xfer += (*_iter1575).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_enumerate_packer_disks_p_presult::~physical_packer_service_proxy_enumerate_packer_disks_p_presult() throw() {
}


uint32_t physical_packer_service_proxy_enumerate_packer_disks_p_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            (*(this->success)).clear();
            uint32_t _size1576;
            ::apache::thrift::protocol::TType _etype1579;
            xfer += iprot->readSetBegin(_etype1579, _size1576);
            uint32_t _i1580;
            for (_i1580 = 0; _i1580 < _size1576; ++_i1580)
            {
              disk_info _elem1581;
              xfer += _elem1581.read(iprot);
              (*(this->success)).insert(_elem1581);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_enumerate_packer_disks_p_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_enumerate_packer_disks_p_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_SET, 0);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->success)).size()));
    std::set<disk_info> ::const_iterator _iter1582;
    for (_iter1582 = (*(this->success)).begin(); _iter1582 != (*(this->success)).end(); ++_iter1582)
    {
      xfer += (*_iter1582).write(oprot);
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_verify_packer_carrier_p_args::~physical_packer_service_proxy_verify_packer_carrier_p_args() throw() {
}


uint32_t physical_packer_service_proxy_verify_packer_carrier_p_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->addr);
          this->__isset.addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->carrier);
          this->__isset.carrier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_ssl);
          this->__isset.is_ssl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_verify_packer_carrier_p_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_verify_packer_carrier_p_args");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->addr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("carrier", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->carrier);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_ssl", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->is_ssl);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_verify_packer_carrier_p_pargs::~physical_packer_service_proxy_verify_packer_carrier_p_pargs() throw() {
}


uint32_t physical_packer_service_proxy_verify_packer_carrier_p_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_verify_packer_carrier_p_pargs");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->session_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->addr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("carrier", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->carrier)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_ssl", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool((*(this->is_ssl)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_verify_packer_carrier_p_result::~physical_packer_service_proxy_verify_packer_carrier_p_result() throw() {
}


uint32_t physical_packer_service_proxy_verify_packer_carrier_p_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_verify_packer_carrier_p_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("physical_packer_service_proxy_verify_packer_carrier_p_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_verify_packer_carrier_p_presult::~physical_packer_service_proxy_verify_packer_carrier_p_presult() throw() {
}


uint32_t physical_packer_service_proxy_verify_packer_carrier_p_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_verify_packer_carrier_p_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_verify_packer_carrier_p_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
  xfer += oprot->writeBool((*(this->success)));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_get_packer_host_detail_p_args::~physical_packer_service_proxy_get_packer_host_detail_p_args() throw() {
}


uint32_t physical_packer_service_proxy_get_packer_host_detail_p_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->addr);
          this->__isset.addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1583;
          xfer += iprot->readI32(ecast1583);
          this->filter = (machine_detail_filter::type)ecast1583;
          this->__isset.filter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_get_packer_host_detail_p_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_get_packer_host_detail_p_args");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->addr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("filter", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->filter);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_get_packer_host_detail_p_pargs::~physical_packer_service_proxy_get_packer_host_detail_p_pargs() throw() {
}


uint32_t physical_packer_service_proxy_get_packer_host_detail_p_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_get_packer_host_detail_p_pargs");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->session_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->addr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("filter", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)(*(this->filter)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_get_packer_host_detail_p_result::~physical_packer_service_proxy_get_packer_host_detail_p_result() throw() {
}


uint32_t physical_packer_service_proxy_get_packer_host_detail_p_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_get_packer_host_detail_p_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("physical_packer_service_proxy_get_packer_host_detail_p_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


physical_packer_service_proxy_get_packer_host_detail_p_presult::~physical_packer_service_proxy_get_packer_host_detail_p_presult() throw() {
}


uint32_t physical_packer_service_proxy_get_packer_host_detail_p_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ouch.read(iprot);
          this->__isset.ouch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_packer_service_proxy_get_packer_host_detail_p_presult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_packer_service_proxy_get_packer_host_detail_p_presult");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
  xfer += (*(this->success)).write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ouch) {
    xfer += oprot->writeFieldBegin("ouch", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->ouch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void physical_packer_service_proxyClient::packer_ping_p(service_info& _return, const std::string& session_id, const std::string& addr)
{
  send_packer_ping_p(session_id, addr);
  recv_packer_ping_p(_return);
}

void physical_packer_service_proxyClient::send_packer_ping_p(const std::string& session_id, const std::string& addr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("packer_ping_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_packer_ping_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyClient::recv_packer_ping_p(service_info& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("packer_ping_p") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  physical_packer_service_proxy_packer_ping_p_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "packer_ping_p failed: unknown result");
}

void physical_packer_service_proxyClient::take_snapshots_p(std::vector<snapshot> & _return, const std::string& session_id, const std::string& addr, const std::set<std::string> & disks)
{
  send_take_snapshots_p(session_id, addr, disks);
  recv_take_snapshots_p(_return);
}

void physical_packer_service_proxyClient::send_take_snapshots_p(const std::string& session_id, const std::string& addr, const std::set<std::string> & disks)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("take_snapshots_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_take_snapshots_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.disks = &disks;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyClient::recv_take_snapshots_p(std::vector<snapshot> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("take_snapshots_p") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  physical_packer_service_proxy_take_snapshots_p_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.ouch) {
    throw result.ouch;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "take_snapshots_p failed: unknown result");
}

void physical_packer_service_proxyClient::take_snapshots_ex_p(std::vector<snapshot> & _return, const std::string& session_id, const std::string& addr, const std::set<std::string> & disks, const std::string& pre_script, const std::string& post_script)
{
  send_take_snapshots_ex_p(session_id, addr, disks, pre_script, post_script);
  recv_take_snapshots_ex_p(_return);
}

void physical_packer_service_proxyClient::send_take_snapshots_ex_p(const std::string& session_id, const std::string& addr, const std::set<std::string> & disks, const std::string& pre_script, const std::string& post_script)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("take_snapshots_ex_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_take_snapshots_ex_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.disks = &disks;
  args.pre_script = &pre_script;
  args.post_script = &post_script;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyClient::recv_take_snapshots_ex_p(std::vector<snapshot> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("take_snapshots_ex_p") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  physical_packer_service_proxy_take_snapshots_ex_p_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.ouch) {
    throw result.ouch;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "take_snapshots_ex_p failed: unknown result");
}

void physical_packer_service_proxyClient::take_snapshots2_p(std::vector<snapshot> & _return, const std::string& session_id, const std::string& addr, const take_snapshots_parameters& parameters)
{
  send_take_snapshots2_p(session_id, addr, parameters);
  recv_take_snapshots2_p(_return);
}

void physical_packer_service_proxyClient::send_take_snapshots2_p(const std::string& session_id, const std::string& addr, const take_snapshots_parameters& parameters)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("take_snapshots2_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_take_snapshots2_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.parameters = &parameters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyClient::recv_take_snapshots2_p(std::vector<snapshot> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("take_snapshots2_p") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  physical_packer_service_proxy_take_snapshots2_p_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.ouch) {
    throw result.ouch;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "take_snapshots2_p failed: unknown result");
}

void physical_packer_service_proxyClient::delete_snapshot_p(delete_snapshot_result& _return, const std::string& session_id, const std::string& addr, const std::string& snapshot_id)
{
  send_delete_snapshot_p(session_id, addr, snapshot_id);
  recv_delete_snapshot_p(_return);
}

void physical_packer_service_proxyClient::send_delete_snapshot_p(const std::string& session_id, const std::string& addr, const std::string& snapshot_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("delete_snapshot_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_delete_snapshot_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.snapshot_id = &snapshot_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyClient::recv_delete_snapshot_p(delete_snapshot_result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("delete_snapshot_p") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  physical_packer_service_proxy_delete_snapshot_p_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.ouch) {
    throw result.ouch;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "delete_snapshot_p failed: unknown result");
}

void physical_packer_service_proxyClient::delete_snapshot_set_p(delete_snapshot_result& _return, const std::string& session_id, const std::string& addr, const std::string& snapshot_set_id)
{
  send_delete_snapshot_set_p(session_id, addr, snapshot_set_id);
  recv_delete_snapshot_set_p(_return);
}

void physical_packer_service_proxyClient::send_delete_snapshot_set_p(const std::string& session_id, const std::string& addr, const std::string& snapshot_set_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("delete_snapshot_set_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_delete_snapshot_set_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.snapshot_set_id = &snapshot_set_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyClient::recv_delete_snapshot_set_p(delete_snapshot_result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("delete_snapshot_set_p") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  physical_packer_service_proxy_delete_snapshot_set_p_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.ouch) {
    throw result.ouch;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "delete_snapshot_set_p failed: unknown result");
}

void physical_packer_service_proxyClient::get_all_snapshots_p(std::map<std::string, std::vector<snapshot> > & _return, const std::string& session_id, const std::string& addr)
{
  send_get_all_snapshots_p(session_id, addr);
  recv_get_all_snapshots_p(_return);
}

void physical_packer_service_proxyClient::send_get_all_snapshots_p(const std::string& session_id, const std::string& addr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("get_all_snapshots_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_get_all_snapshots_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyClient::recv_get_all_snapshots_p(std::map<std::string, std::vector<snapshot> > & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("get_all_snapshots_p") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  physical_packer_service_proxy_get_all_snapshots_p_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.ouch) {
    throw result.ouch;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_all_snapshots_p failed: unknown result");
}

void physical_packer_service_proxyClient::create_packer_job_ex_p(packer_job_detail& _return, const std::string& session_id, const std::string& addr, const std::string& job_id, const create_packer_job_detail& create_job)
{
  send_create_packer_job_ex_p(session_id, addr, job_id, create_job);
  recv_create_packer_job_ex_p(_return);
}

void physical_packer_service_proxyClient::send_create_packer_job_ex_p(const std::string& session_id, const std::string& addr, const std::string& job_id, const create_packer_job_detail& create_job)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("create_packer_job_ex_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_create_packer_job_ex_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.job_id = &job_id;
  args.create_job = &create_job;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyClient::recv_create_packer_job_ex_p(packer_job_detail& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("create_packer_job_ex_p") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  physical_packer_service_proxy_create_packer_job_ex_p_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.ouch) {
    throw result.ouch;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "create_packer_job_ex_p failed: unknown result");
}

void physical_packer_service_proxyClient::get_packer_job_p(packer_job_detail& _return, const std::string& session_id, const std::string& addr, const std::string& job_id, const std::string& previous_updated_time)
{
  send_get_packer_job_p(session_id, addr, job_id, previous_updated_time);
  recv_get_packer_job_p(_return);
}

void physical_packer_service_proxyClient::send_get_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id, const std::string& previous_updated_time)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("get_packer_job_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_get_packer_job_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.job_id = &job_id;
  args.previous_updated_time = &previous_updated_time;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyClient::recv_get_packer_job_p(packer_job_detail& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("get_packer_job_p") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  physical_packer_service_proxy_get_packer_job_p_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.ouch) {
    throw result.ouch;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_packer_job_p failed: unknown result");
}

bool physical_packer_service_proxyClient::interrupt_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  send_interrupt_packer_job_p(session_id, addr, job_id);
  return recv_interrupt_packer_job_p();
}

void physical_packer_service_proxyClient::send_interrupt_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("interrupt_packer_job_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_interrupt_packer_job_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.job_id = &job_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool physical_packer_service_proxyClient::recv_interrupt_packer_job_p()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("interrupt_packer_job_p") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  physical_packer_service_proxy_interrupt_packer_job_p_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.ouch) {
    throw result.ouch;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "interrupt_packer_job_p failed: unknown result");
}

bool physical_packer_service_proxyClient::resume_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  send_resume_packer_job_p(session_id, addr, job_id);
  return recv_resume_packer_job_p();
}

void physical_packer_service_proxyClient::send_resume_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("resume_packer_job_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_resume_packer_job_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.job_id = &job_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool physical_packer_service_proxyClient::recv_resume_packer_job_p()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("resume_packer_job_p") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  physical_packer_service_proxy_resume_packer_job_p_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.ouch) {
    throw result.ouch;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "resume_packer_job_p failed: unknown result");
}

bool physical_packer_service_proxyClient::remove_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  send_remove_packer_job_p(session_id, addr, job_id);
  return recv_remove_packer_job_p();
}

void physical_packer_service_proxyClient::send_remove_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("remove_packer_job_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_remove_packer_job_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.job_id = &job_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool physical_packer_service_proxyClient::recv_remove_packer_job_p()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("remove_packer_job_p") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  physical_packer_service_proxy_remove_packer_job_p_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.ouch) {
    throw result.ouch;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "remove_packer_job_p failed: unknown result");
}

bool physical_packer_service_proxyClient::running_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  send_running_packer_job_p(session_id, addr, job_id);
  return recv_running_packer_job_p();
}

void physical_packer_service_proxyClient::send_running_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("running_packer_job_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_running_packer_job_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.job_id = &job_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool physical_packer_service_proxyClient::recv_running_packer_job_p()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("running_packer_job_p") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  physical_packer_service_proxy_running_packer_job_p_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.ouch) {
    throw result.ouch;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "running_packer_job_p failed: unknown result");
}

void physical_packer_service_proxyClient::enumerate_packer_disks_p(std::set<disk_info> & _return, const std::string& session_id, const std::string& addr, const enumerate_disk_filter_style::type filter)
{
  send_enumerate_packer_disks_p(session_id, addr, filter);
  recv_enumerate_packer_disks_p(_return);
}

void physical_packer_service_proxyClient::send_enumerate_packer_disks_p(const std::string& session_id, const std::string& addr, const enumerate_disk_filter_style::type filter)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("enumerate_packer_disks_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_enumerate_packer_disks_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.filter = &filter;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyClient::recv_enumerate_packer_disks_p(std::set<disk_info> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("enumerate_packer_disks_p") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  physical_packer_service_proxy_enumerate_packer_disks_p_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.ouch) {
    throw result.ouch;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "enumerate_packer_disks_p failed: unknown result");
}

bool physical_packer_service_proxyClient::verify_packer_carrier_p(const std::string& session_id, const std::string& addr, const std::string& carrier, const bool is_ssl)
{
  send_verify_packer_carrier_p(session_id, addr, carrier, is_ssl);
  return recv_verify_packer_carrier_p();
}

void physical_packer_service_proxyClient::send_verify_packer_carrier_p(const std::string& session_id, const std::string& addr, const std::string& carrier, const bool is_ssl)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("verify_packer_carrier_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_verify_packer_carrier_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.carrier = &carrier;
  args.is_ssl = &is_ssl;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool physical_packer_service_proxyClient::recv_verify_packer_carrier_p()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("verify_packer_carrier_p") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  physical_packer_service_proxy_verify_packer_carrier_p_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.ouch) {
    throw result.ouch;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "verify_packer_carrier_p failed: unknown result");
}

void physical_packer_service_proxyClient::get_packer_host_detail_p(physical_machine_info& _return, const std::string& session_id, const std::string& addr, const machine_detail_filter::type filter)
{
  send_get_packer_host_detail_p(session_id, addr, filter);
  recv_get_packer_host_detail_p(_return);
}

void physical_packer_service_proxyClient::send_get_packer_host_detail_p(const std::string& session_id, const std::string& addr, const machine_detail_filter::type filter)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("get_packer_host_detail_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_get_packer_host_detail_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.filter = &filter;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyClient::recv_get_packer_host_detail_p(physical_machine_info& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("get_packer_host_detail_p") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  physical_packer_service_proxy_get_packer_host_detail_p_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.ouch) {
    throw result.ouch;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_packer_host_detail_p failed: unknown result");
}

bool physical_packer_service_proxyProcessor::dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext) {
  ProcessMap::iterator pfn;
  pfn = processMap_.find(fname);
  if (pfn == processMap_.end()) {
    return common_serviceProcessor::dispatchCall(iprot, oprot, fname, seqid, callContext);
  }
  (this->*(pfn->second))(seqid, iprot, oprot, callContext);
  return true;
}

void physical_packer_service_proxyProcessor::process_packer_ping_p(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.packer_ping_p", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.packer_ping_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.packer_ping_p");
  }

  physical_packer_service_proxy_packer_ping_p_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.packer_ping_p", bytes);
  }

  physical_packer_service_proxy_packer_ping_p_result result;
  try {
    iface_->packer_ping_p(result.success, args.session_id, args.addr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.packer_ping_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("packer_ping_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.packer_ping_p");
  }

  oprot->writeMessageBegin("packer_ping_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.packer_ping_p", bytes);
  }
}

void physical_packer_service_proxyProcessor::process_take_snapshots_p(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.take_snapshots_p", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.take_snapshots_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.take_snapshots_p");
  }

  physical_packer_service_proxy_take_snapshots_p_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.take_snapshots_p", bytes);
  }

  physical_packer_service_proxy_take_snapshots_p_result result;
  try {
    iface_->take_snapshots_p(result.success, args.session_id, args.addr, args.disks);
    result.__isset.success = true;
  } catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.take_snapshots_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("take_snapshots_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.take_snapshots_p");
  }

  oprot->writeMessageBegin("take_snapshots_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.take_snapshots_p", bytes);
  }
}

void physical_packer_service_proxyProcessor::process_take_snapshots_ex_p(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.take_snapshots_ex_p", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.take_snapshots_ex_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.take_snapshots_ex_p");
  }

  physical_packer_service_proxy_take_snapshots_ex_p_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.take_snapshots_ex_p", bytes);
  }

  physical_packer_service_proxy_take_snapshots_ex_p_result result;
  try {
    iface_->take_snapshots_ex_p(result.success, args.session_id, args.addr, args.disks, args.pre_script, args.post_script);
    result.__isset.success = true;
  } catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.take_snapshots_ex_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("take_snapshots_ex_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.take_snapshots_ex_p");
  }

  oprot->writeMessageBegin("take_snapshots_ex_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.take_snapshots_ex_p", bytes);
  }
}

void physical_packer_service_proxyProcessor::process_take_snapshots2_p(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.take_snapshots2_p", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.take_snapshots2_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.take_snapshots2_p");
  }

  physical_packer_service_proxy_take_snapshots2_p_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.take_snapshots2_p", bytes);
  }

  physical_packer_service_proxy_take_snapshots2_p_result result;
  try {
    iface_->take_snapshots2_p(result.success, args.session_id, args.addr, args.parameters);
    result.__isset.success = true;
  } catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.take_snapshots2_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("take_snapshots2_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.take_snapshots2_p");
  }

  oprot->writeMessageBegin("take_snapshots2_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.take_snapshots2_p", bytes);
  }
}

void physical_packer_service_proxyProcessor::process_delete_snapshot_p(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.delete_snapshot_p", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.delete_snapshot_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.delete_snapshot_p");
  }

  physical_packer_service_proxy_delete_snapshot_p_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.delete_snapshot_p", bytes);
  }

  physical_packer_service_proxy_delete_snapshot_p_result result;
  try {
    iface_->delete_snapshot_p(result.success, args.session_id, args.addr, args.snapshot_id);
    result.__isset.success = true;
  } catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.delete_snapshot_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("delete_snapshot_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.delete_snapshot_p");
  }

  oprot->writeMessageBegin("delete_snapshot_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.delete_snapshot_p", bytes);
  }
}

void physical_packer_service_proxyProcessor::process_delete_snapshot_set_p(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.delete_snapshot_set_p", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.delete_snapshot_set_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.delete_snapshot_set_p");
  }

  physical_packer_service_proxy_delete_snapshot_set_p_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.delete_snapshot_set_p", bytes);
  }

  physical_packer_service_proxy_delete_snapshot_set_p_result result;
  try {
    iface_->delete_snapshot_set_p(result.success, args.session_id, args.addr, args.snapshot_set_id);
    result.__isset.success = true;
  } catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.delete_snapshot_set_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("delete_snapshot_set_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.delete_snapshot_set_p");
  }

  oprot->writeMessageBegin("delete_snapshot_set_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.delete_snapshot_set_p", bytes);
  }
}

void physical_packer_service_proxyProcessor::process_get_all_snapshots_p(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.get_all_snapshots_p", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.get_all_snapshots_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.get_all_snapshots_p");
  }

  physical_packer_service_proxy_get_all_snapshots_p_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.get_all_snapshots_p", bytes);
  }

  physical_packer_service_proxy_get_all_snapshots_p_result result;
  try {
    iface_->get_all_snapshots_p(result.success, args.session_id, args.addr);
    result.__isset.success = true;
  } catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.get_all_snapshots_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("get_all_snapshots_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.get_all_snapshots_p");
  }

  oprot->writeMessageBegin("get_all_snapshots_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.get_all_snapshots_p", bytes);
  }
}

void physical_packer_service_proxyProcessor::process_create_packer_job_ex_p(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.create_packer_job_ex_p", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.create_packer_job_ex_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.create_packer_job_ex_p");
  }

  physical_packer_service_proxy_create_packer_job_ex_p_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.create_packer_job_ex_p", bytes);
  }

  physical_packer_service_proxy_create_packer_job_ex_p_result result;
  try {
    iface_->create_packer_job_ex_p(result.success, args.session_id, args.addr, args.job_id, args.create_job);
    result.__isset.success = true;
  } catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.create_packer_job_ex_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("create_packer_job_ex_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.create_packer_job_ex_p");
  }

  oprot->writeMessageBegin("create_packer_job_ex_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.create_packer_job_ex_p", bytes);
  }
}

void physical_packer_service_proxyProcessor::process_get_packer_job_p(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.get_packer_job_p", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.get_packer_job_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.get_packer_job_p");
  }

  physical_packer_service_proxy_get_packer_job_p_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.get_packer_job_p", bytes);
  }

  physical_packer_service_proxy_get_packer_job_p_result result;
  try {
    iface_->get_packer_job_p(result.success, args.session_id, args.addr, args.job_id, args.previous_updated_time);
    result.__isset.success = true;
  } catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.get_packer_job_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("get_packer_job_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.get_packer_job_p");
  }

  oprot->writeMessageBegin("get_packer_job_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.get_packer_job_p", bytes);
  }
}

void physical_packer_service_proxyProcessor::process_interrupt_packer_job_p(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.interrupt_packer_job_p", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.interrupt_packer_job_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.interrupt_packer_job_p");
  }

  physical_packer_service_proxy_interrupt_packer_job_p_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.interrupt_packer_job_p", bytes);
  }

  physical_packer_service_proxy_interrupt_packer_job_p_result result;
  try {
    result.success = iface_->interrupt_packer_job_p(args.session_id, args.addr, args.job_id);
    result.__isset.success = true;
  } catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.interrupt_packer_job_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("interrupt_packer_job_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.interrupt_packer_job_p");
  }

  oprot->writeMessageBegin("interrupt_packer_job_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.interrupt_packer_job_p", bytes);
  }
}

void physical_packer_service_proxyProcessor::process_resume_packer_job_p(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.resume_packer_job_p", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.resume_packer_job_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.resume_packer_job_p");
  }

  physical_packer_service_proxy_resume_packer_job_p_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.resume_packer_job_p", bytes);
  }

  physical_packer_service_proxy_resume_packer_job_p_result result;
  try {
    result.success = iface_->resume_packer_job_p(args.session_id, args.addr, args.job_id);
    result.__isset.success = true;
  } catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.resume_packer_job_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("resume_packer_job_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.resume_packer_job_p");
  }

  oprot->writeMessageBegin("resume_packer_job_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.resume_packer_job_p", bytes);
  }
}

void physical_packer_service_proxyProcessor::process_remove_packer_job_p(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.remove_packer_job_p", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.remove_packer_job_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.remove_packer_job_p");
  }

  physical_packer_service_proxy_remove_packer_job_p_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.remove_packer_job_p", bytes);
  }

  physical_packer_service_proxy_remove_packer_job_p_result result;
  try {
    result.success = iface_->remove_packer_job_p(args.session_id, args.addr, args.job_id);
    result.__isset.success = true;
  } catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.remove_packer_job_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("remove_packer_job_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.remove_packer_job_p");
  }

  oprot->writeMessageBegin("remove_packer_job_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.remove_packer_job_p", bytes);
  }
}

void physical_packer_service_proxyProcessor::process_running_packer_job_p(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.running_packer_job_p", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.running_packer_job_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.running_packer_job_p");
  }

  physical_packer_service_proxy_running_packer_job_p_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.running_packer_job_p", bytes);
  }

  physical_packer_service_proxy_running_packer_job_p_result result;
  try {
    result.success = iface_->running_packer_job_p(args.session_id, args.addr, args.job_id);
    result.__isset.success = true;
  } catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.running_packer_job_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("running_packer_job_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.running_packer_job_p");
  }

  oprot->writeMessageBegin("running_packer_job_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.running_packer_job_p", bytes);
  }
}

void physical_packer_service_proxyProcessor::process_enumerate_packer_disks_p(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.enumerate_packer_disks_p", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.enumerate_packer_disks_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.enumerate_packer_disks_p");
  }

  physical_packer_service_proxy_enumerate_packer_disks_p_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.enumerate_packer_disks_p", bytes);
  }

  physical_packer_service_proxy_enumerate_packer_disks_p_result result;
  try {
    iface_->enumerate_packer_disks_p(result.success, args.session_id, args.addr, args.filter);
    result.__isset.success = true;
  } catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.enumerate_packer_disks_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("enumerate_packer_disks_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.enumerate_packer_disks_p");
  }

  oprot->writeMessageBegin("enumerate_packer_disks_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.enumerate_packer_disks_p", bytes);
  }
}

void physical_packer_service_proxyProcessor::process_verify_packer_carrier_p(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.verify_packer_carrier_p", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.verify_packer_carrier_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.verify_packer_carrier_p");
  }

  physical_packer_service_proxy_verify_packer_carrier_p_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.verify_packer_carrier_p", bytes);
  }

  physical_packer_service_proxy_verify_packer_carrier_p_result result;
  try {
    result.success = iface_->verify_packer_carrier_p(args.session_id, args.addr, args.carrier, args.is_ssl);
    result.__isset.success = true;
  } catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.verify_packer_carrier_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("verify_packer_carrier_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.verify_packer_carrier_p");
  }

  oprot->writeMessageBegin("verify_packer_carrier_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.verify_packer_carrier_p", bytes);
  }
}

void physical_packer_service_proxyProcessor::process_get_packer_host_detail_p(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.get_packer_host_detail_p", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.get_packer_host_detail_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.get_packer_host_detail_p");
  }

  physical_packer_service_proxy_get_packer_host_detail_p_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.get_packer_host_detail_p", bytes);
  }

  physical_packer_service_proxy_get_packer_host_detail_p_result result;
  try {
    iface_->get_packer_host_detail_p(result.success, args.session_id, args.addr, args.filter);
    result.__isset.success = true;
  } catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.get_packer_host_detail_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("get_packer_host_detail_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.get_packer_host_detail_p");
  }

  oprot->writeMessageBegin("get_packer_host_detail_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.get_packer_host_detail_p", bytes);
  }
}

::apache::thrift::stdcxx::shared_ptr< ::apache::thrift::TProcessor > physical_packer_service_proxyProcessorFactory::getProcessor(const ::apache::thrift::TConnectionInfo& connInfo) {
  ::apache::thrift::ReleaseHandler< physical_packer_service_proxyIfFactory > cleanup(handlerFactory_);
  ::apache::thrift::stdcxx::shared_ptr< physical_packer_service_proxyIf > handler(handlerFactory_->getHandler(connInfo), cleanup);
  ::apache::thrift::stdcxx::shared_ptr< ::apache::thrift::TProcessor > processor(new physical_packer_service_proxyProcessor(handler));
  return processor;
}

void physical_packer_service_proxyConcurrentClient::packer_ping_p(service_info& _return, const std::string& session_id, const std::string& addr)
{
  int32_t seqid = send_packer_ping_p(session_id, addr);
  recv_packer_ping_p(_return, seqid);
}

int32_t physical_packer_service_proxyConcurrentClient::send_packer_ping_p(const std::string& session_id, const std::string& addr)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("packer_ping_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_packer_ping_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void physical_packer_service_proxyConcurrentClient::recv_packer_ping_p(service_info& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("packer_ping_p") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      physical_packer_service_proxy_packer_ping_p_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "packer_ping_p failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void physical_packer_service_proxyConcurrentClient::take_snapshots_p(std::vector<snapshot> & _return, const std::string& session_id, const std::string& addr, const std::set<std::string> & disks)
{
  int32_t seqid = send_take_snapshots_p(session_id, addr, disks);
  recv_take_snapshots_p(_return, seqid);
}

int32_t physical_packer_service_proxyConcurrentClient::send_take_snapshots_p(const std::string& session_id, const std::string& addr, const std::set<std::string> & disks)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("take_snapshots_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_take_snapshots_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.disks = &disks;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void physical_packer_service_proxyConcurrentClient::recv_take_snapshots_p(std::vector<snapshot> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("take_snapshots_p") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      physical_packer_service_proxy_take_snapshots_p_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.ouch) {
        sentry.commit();
        throw result.ouch;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "take_snapshots_p failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void physical_packer_service_proxyConcurrentClient::take_snapshots_ex_p(std::vector<snapshot> & _return, const std::string& session_id, const std::string& addr, const std::set<std::string> & disks, const std::string& pre_script, const std::string& post_script)
{
  int32_t seqid = send_take_snapshots_ex_p(session_id, addr, disks, pre_script, post_script);
  recv_take_snapshots_ex_p(_return, seqid);
}

int32_t physical_packer_service_proxyConcurrentClient::send_take_snapshots_ex_p(const std::string& session_id, const std::string& addr, const std::set<std::string> & disks, const std::string& pre_script, const std::string& post_script)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("take_snapshots_ex_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_take_snapshots_ex_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.disks = &disks;
  args.pre_script = &pre_script;
  args.post_script = &post_script;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void physical_packer_service_proxyConcurrentClient::recv_take_snapshots_ex_p(std::vector<snapshot> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("take_snapshots_ex_p") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      physical_packer_service_proxy_take_snapshots_ex_p_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.ouch) {
        sentry.commit();
        throw result.ouch;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "take_snapshots_ex_p failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void physical_packer_service_proxyConcurrentClient::take_snapshots2_p(std::vector<snapshot> & _return, const std::string& session_id, const std::string& addr, const take_snapshots_parameters& parameters)
{
  int32_t seqid = send_take_snapshots2_p(session_id, addr, parameters);
  recv_take_snapshots2_p(_return, seqid);
}

int32_t physical_packer_service_proxyConcurrentClient::send_take_snapshots2_p(const std::string& session_id, const std::string& addr, const take_snapshots_parameters& parameters)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("take_snapshots2_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_take_snapshots2_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.parameters = &parameters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void physical_packer_service_proxyConcurrentClient::recv_take_snapshots2_p(std::vector<snapshot> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("take_snapshots2_p") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      physical_packer_service_proxy_take_snapshots2_p_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.ouch) {
        sentry.commit();
        throw result.ouch;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "take_snapshots2_p failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void physical_packer_service_proxyConcurrentClient::delete_snapshot_p(delete_snapshot_result& _return, const std::string& session_id, const std::string& addr, const std::string& snapshot_id)
{
  int32_t seqid = send_delete_snapshot_p(session_id, addr, snapshot_id);
  recv_delete_snapshot_p(_return, seqid);
}

int32_t physical_packer_service_proxyConcurrentClient::send_delete_snapshot_p(const std::string& session_id, const std::string& addr, const std::string& snapshot_id)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("delete_snapshot_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_delete_snapshot_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.snapshot_id = &snapshot_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void physical_packer_service_proxyConcurrentClient::recv_delete_snapshot_p(delete_snapshot_result& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("delete_snapshot_p") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      physical_packer_service_proxy_delete_snapshot_p_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.ouch) {
        sentry.commit();
        throw result.ouch;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "delete_snapshot_p failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void physical_packer_service_proxyConcurrentClient::delete_snapshot_set_p(delete_snapshot_result& _return, const std::string& session_id, const std::string& addr, const std::string& snapshot_set_id)
{
  int32_t seqid = send_delete_snapshot_set_p(session_id, addr, snapshot_set_id);
  recv_delete_snapshot_set_p(_return, seqid);
}

int32_t physical_packer_service_proxyConcurrentClient::send_delete_snapshot_set_p(const std::string& session_id, const std::string& addr, const std::string& snapshot_set_id)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("delete_snapshot_set_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_delete_snapshot_set_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.snapshot_set_id = &snapshot_set_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void physical_packer_service_proxyConcurrentClient::recv_delete_snapshot_set_p(delete_snapshot_result& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("delete_snapshot_set_p") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      physical_packer_service_proxy_delete_snapshot_set_p_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.ouch) {
        sentry.commit();
        throw result.ouch;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "delete_snapshot_set_p failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void physical_packer_service_proxyConcurrentClient::get_all_snapshots_p(std::map<std::string, std::vector<snapshot> > & _return, const std::string& session_id, const std::string& addr)
{
  int32_t seqid = send_get_all_snapshots_p(session_id, addr);
  recv_get_all_snapshots_p(_return, seqid);
}

int32_t physical_packer_service_proxyConcurrentClient::send_get_all_snapshots_p(const std::string& session_id, const std::string& addr)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("get_all_snapshots_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_get_all_snapshots_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void physical_packer_service_proxyConcurrentClient::recv_get_all_snapshots_p(std::map<std::string, std::vector<snapshot> > & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("get_all_snapshots_p") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      physical_packer_service_proxy_get_all_snapshots_p_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.ouch) {
        sentry.commit();
        throw result.ouch;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_all_snapshots_p failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void physical_packer_service_proxyConcurrentClient::create_packer_job_ex_p(packer_job_detail& _return, const std::string& session_id, const std::string& addr, const std::string& job_id, const create_packer_job_detail& create_job)
{
  int32_t seqid = send_create_packer_job_ex_p(session_id, addr, job_id, create_job);
  recv_create_packer_job_ex_p(_return, seqid);
}

int32_t physical_packer_service_proxyConcurrentClient::send_create_packer_job_ex_p(const std::string& session_id, const std::string& addr, const std::string& job_id, const create_packer_job_detail& create_job)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("create_packer_job_ex_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_create_packer_job_ex_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.job_id = &job_id;
  args.create_job = &create_job;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void physical_packer_service_proxyConcurrentClient::recv_create_packer_job_ex_p(packer_job_detail& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("create_packer_job_ex_p") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      physical_packer_service_proxy_create_packer_job_ex_p_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.ouch) {
        sentry.commit();
        throw result.ouch;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "create_packer_job_ex_p failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void physical_packer_service_proxyConcurrentClient::get_packer_job_p(packer_job_detail& _return, const std::string& session_id, const std::string& addr, const std::string& job_id, const std::string& previous_updated_time)
{
  int32_t seqid = send_get_packer_job_p(session_id, addr, job_id, previous_updated_time);
  recv_get_packer_job_p(_return, seqid);
}

int32_t physical_packer_service_proxyConcurrentClient::send_get_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id, const std::string& previous_updated_time)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("get_packer_job_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_get_packer_job_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.job_id = &job_id;
  args.previous_updated_time = &previous_updated_time;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void physical_packer_service_proxyConcurrentClient::recv_get_packer_job_p(packer_job_detail& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("get_packer_job_p") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      physical_packer_service_proxy_get_packer_job_p_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.ouch) {
        sentry.commit();
        throw result.ouch;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_packer_job_p failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

bool physical_packer_service_proxyConcurrentClient::interrupt_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  int32_t seqid = send_interrupt_packer_job_p(session_id, addr, job_id);
  return recv_interrupt_packer_job_p(seqid);
}

int32_t physical_packer_service_proxyConcurrentClient::send_interrupt_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("interrupt_packer_job_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_interrupt_packer_job_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.job_id = &job_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool physical_packer_service_proxyConcurrentClient::recv_interrupt_packer_job_p(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("interrupt_packer_job_p") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      physical_packer_service_proxy_interrupt_packer_job_p_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      if (result.__isset.ouch) {
        sentry.commit();
        throw result.ouch;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "interrupt_packer_job_p failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

bool physical_packer_service_proxyConcurrentClient::resume_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  int32_t seqid = send_resume_packer_job_p(session_id, addr, job_id);
  return recv_resume_packer_job_p(seqid);
}

int32_t physical_packer_service_proxyConcurrentClient::send_resume_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("resume_packer_job_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_resume_packer_job_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.job_id = &job_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool physical_packer_service_proxyConcurrentClient::recv_resume_packer_job_p(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("resume_packer_job_p") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      physical_packer_service_proxy_resume_packer_job_p_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      if (result.__isset.ouch) {
        sentry.commit();
        throw result.ouch;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "resume_packer_job_p failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

bool physical_packer_service_proxyConcurrentClient::remove_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  int32_t seqid = send_remove_packer_job_p(session_id, addr, job_id);
  return recv_remove_packer_job_p(seqid);
}

int32_t physical_packer_service_proxyConcurrentClient::send_remove_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("remove_packer_job_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_remove_packer_job_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.job_id = &job_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool physical_packer_service_proxyConcurrentClient::recv_remove_packer_job_p(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("remove_packer_job_p") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      physical_packer_service_proxy_remove_packer_job_p_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      if (result.__isset.ouch) {
        sentry.commit();
        throw result.ouch;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "remove_packer_job_p failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

bool physical_packer_service_proxyConcurrentClient::running_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  int32_t seqid = send_running_packer_job_p(session_id, addr, job_id);
  return recv_running_packer_job_p(seqid);
}

int32_t physical_packer_service_proxyConcurrentClient::send_running_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("running_packer_job_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_running_packer_job_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.job_id = &job_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool physical_packer_service_proxyConcurrentClient::recv_running_packer_job_p(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("running_packer_job_p") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      physical_packer_service_proxy_running_packer_job_p_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      if (result.__isset.ouch) {
        sentry.commit();
        throw result.ouch;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "running_packer_job_p failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void physical_packer_service_proxyConcurrentClient::enumerate_packer_disks_p(std::set<disk_info> & _return, const std::string& session_id, const std::string& addr, const enumerate_disk_filter_style::type filter)
{
  int32_t seqid = send_enumerate_packer_disks_p(session_id, addr, filter);
  recv_enumerate_packer_disks_p(_return, seqid);
}

int32_t physical_packer_service_proxyConcurrentClient::send_enumerate_packer_disks_p(const std::string& session_id, const std::string& addr, const enumerate_disk_filter_style::type filter)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("enumerate_packer_disks_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_enumerate_packer_disks_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.filter = &filter;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void physical_packer_service_proxyConcurrentClient::recv_enumerate_packer_disks_p(std::set<disk_info> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("enumerate_packer_disks_p") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      physical_packer_service_proxy_enumerate_packer_disks_p_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.ouch) {
        sentry.commit();
        throw result.ouch;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "enumerate_packer_disks_p failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

bool physical_packer_service_proxyConcurrentClient::verify_packer_carrier_p(const std::string& session_id, const std::string& addr, const std::string& carrier, const bool is_ssl)
{
  int32_t seqid = send_verify_packer_carrier_p(session_id, addr, carrier, is_ssl);
  return recv_verify_packer_carrier_p(seqid);
}

int32_t physical_packer_service_proxyConcurrentClient::send_verify_packer_carrier_p(const std::string& session_id, const std::string& addr, const std::string& carrier, const bool is_ssl)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("verify_packer_carrier_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_verify_packer_carrier_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.carrier = &carrier;
  args.is_ssl = &is_ssl;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool physical_packer_service_proxyConcurrentClient::recv_verify_packer_carrier_p(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("verify_packer_carrier_p") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      physical_packer_service_proxy_verify_packer_carrier_p_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      if (result.__isset.ouch) {
        sentry.commit();
        throw result.ouch;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "verify_packer_carrier_p failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void physical_packer_service_proxyConcurrentClient::get_packer_host_detail_p(physical_machine_info& _return, const std::string& session_id, const std::string& addr, const machine_detail_filter::type filter)
{
  int32_t seqid = send_get_packer_host_detail_p(session_id, addr, filter);
  recv_get_packer_host_detail_p(_return, seqid);
}

int32_t physical_packer_service_proxyConcurrentClient::send_get_packer_host_detail_p(const std::string& session_id, const std::string& addr, const machine_detail_filter::type filter)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("get_packer_host_detail_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_get_packer_host_detail_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.filter = &filter;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void physical_packer_service_proxyConcurrentClient::recv_get_packer_host_detail_p(physical_machine_info& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("get_packer_host_detail_p") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      physical_packer_service_proxy_get_packer_host_detail_p_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      if (result.__isset.ouch) {
        sentry.commit();
        throw result.ouch;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_packer_host_detail_p failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void physical_packer_service_proxyCobClient::packer_ping_p(::apache::thrift::stdcxx::function<void(physical_packer_service_proxyCobClient* client)> cob, const std::string& session_id, const std::string& addr)
{
  send_packer_ping_p(session_id, addr);
  channel_->sendAndRecvMessage(::apache::thrift::stdcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void physical_packer_service_proxyCobClient::send_packer_ping_p(const std::string& session_id, const std::string& addr)
{
  int32_t cseqid = 0;
  otrans_->resetBuffer();
  oprot_->writeMessageBegin("packer_ping_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_packer_ping_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyCobClient::recv_packer_ping_p(service_info& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("packer_ping_p") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    physical_packer_service_proxy_packer_ping_p_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "packer_ping_p failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void physical_packer_service_proxyCobClient::take_snapshots_p(::apache::thrift::stdcxx::function<void(physical_packer_service_proxyCobClient* client)> cob, const std::string& session_id, const std::string& addr, const std::set<std::string> & disks)
{
  send_take_snapshots_p(session_id, addr, disks);
  channel_->sendAndRecvMessage(::apache::thrift::stdcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void physical_packer_service_proxyCobClient::send_take_snapshots_p(const std::string& session_id, const std::string& addr, const std::set<std::string> & disks)
{
  int32_t cseqid = 0;
  otrans_->resetBuffer();
  oprot_->writeMessageBegin("take_snapshots_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_take_snapshots_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.disks = &disks;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyCobClient::recv_take_snapshots_p(std::vector<snapshot> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("take_snapshots_p") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    physical_packer_service_proxy_take_snapshots_p_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    if (result.__isset.ouch) {
      completed = true;
      completed__(true);
      throw result.ouch;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "take_snapshots_p failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void physical_packer_service_proxyCobClient::take_snapshots_ex_p(::apache::thrift::stdcxx::function<void(physical_packer_service_proxyCobClient* client)> cob, const std::string& session_id, const std::string& addr, const std::set<std::string> & disks, const std::string& pre_script, const std::string& post_script)
{
  send_take_snapshots_ex_p(session_id, addr, disks, pre_script, post_script);
  channel_->sendAndRecvMessage(::apache::thrift::stdcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void physical_packer_service_proxyCobClient::send_take_snapshots_ex_p(const std::string& session_id, const std::string& addr, const std::set<std::string> & disks, const std::string& pre_script, const std::string& post_script)
{
  int32_t cseqid = 0;
  otrans_->resetBuffer();
  oprot_->writeMessageBegin("take_snapshots_ex_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_take_snapshots_ex_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.disks = &disks;
  args.pre_script = &pre_script;
  args.post_script = &post_script;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyCobClient::recv_take_snapshots_ex_p(std::vector<snapshot> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("take_snapshots_ex_p") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    physical_packer_service_proxy_take_snapshots_ex_p_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    if (result.__isset.ouch) {
      completed = true;
      completed__(true);
      throw result.ouch;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "take_snapshots_ex_p failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void physical_packer_service_proxyCobClient::take_snapshots2_p(::apache::thrift::stdcxx::function<void(physical_packer_service_proxyCobClient* client)> cob, const std::string& session_id, const std::string& addr, const take_snapshots_parameters& parameters)
{
  send_take_snapshots2_p(session_id, addr, parameters);
  channel_->sendAndRecvMessage(::apache::thrift::stdcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void physical_packer_service_proxyCobClient::send_take_snapshots2_p(const std::string& session_id, const std::string& addr, const take_snapshots_parameters& parameters)
{
  int32_t cseqid = 0;
  otrans_->resetBuffer();
  oprot_->writeMessageBegin("take_snapshots2_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_take_snapshots2_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.parameters = &parameters;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyCobClient::recv_take_snapshots2_p(std::vector<snapshot> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("take_snapshots2_p") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    physical_packer_service_proxy_take_snapshots2_p_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    if (result.__isset.ouch) {
      completed = true;
      completed__(true);
      throw result.ouch;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "take_snapshots2_p failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void physical_packer_service_proxyCobClient::delete_snapshot_p(::apache::thrift::stdcxx::function<void(physical_packer_service_proxyCobClient* client)> cob, const std::string& session_id, const std::string& addr, const std::string& snapshot_id)
{
  send_delete_snapshot_p(session_id, addr, snapshot_id);
  channel_->sendAndRecvMessage(::apache::thrift::stdcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void physical_packer_service_proxyCobClient::send_delete_snapshot_p(const std::string& session_id, const std::string& addr, const std::string& snapshot_id)
{
  int32_t cseqid = 0;
  otrans_->resetBuffer();
  oprot_->writeMessageBegin("delete_snapshot_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_delete_snapshot_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.snapshot_id = &snapshot_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyCobClient::recv_delete_snapshot_p(delete_snapshot_result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("delete_snapshot_p") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    physical_packer_service_proxy_delete_snapshot_p_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    if (result.__isset.ouch) {
      completed = true;
      completed__(true);
      throw result.ouch;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "delete_snapshot_p failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void physical_packer_service_proxyCobClient::delete_snapshot_set_p(::apache::thrift::stdcxx::function<void(physical_packer_service_proxyCobClient* client)> cob, const std::string& session_id, const std::string& addr, const std::string& snapshot_set_id)
{
  send_delete_snapshot_set_p(session_id, addr, snapshot_set_id);
  channel_->sendAndRecvMessage(::apache::thrift::stdcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void physical_packer_service_proxyCobClient::send_delete_snapshot_set_p(const std::string& session_id, const std::string& addr, const std::string& snapshot_set_id)
{
  int32_t cseqid = 0;
  otrans_->resetBuffer();
  oprot_->writeMessageBegin("delete_snapshot_set_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_delete_snapshot_set_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.snapshot_set_id = &snapshot_set_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyCobClient::recv_delete_snapshot_set_p(delete_snapshot_result& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("delete_snapshot_set_p") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    physical_packer_service_proxy_delete_snapshot_set_p_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    if (result.__isset.ouch) {
      completed = true;
      completed__(true);
      throw result.ouch;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "delete_snapshot_set_p failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void physical_packer_service_proxyCobClient::get_all_snapshots_p(::apache::thrift::stdcxx::function<void(physical_packer_service_proxyCobClient* client)> cob, const std::string& session_id, const std::string& addr)
{
  send_get_all_snapshots_p(session_id, addr);
  channel_->sendAndRecvMessage(::apache::thrift::stdcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void physical_packer_service_proxyCobClient::send_get_all_snapshots_p(const std::string& session_id, const std::string& addr)
{
  int32_t cseqid = 0;
  otrans_->resetBuffer();
  oprot_->writeMessageBegin("get_all_snapshots_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_get_all_snapshots_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyCobClient::recv_get_all_snapshots_p(std::map<std::string, std::vector<snapshot> > & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("get_all_snapshots_p") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    physical_packer_service_proxy_get_all_snapshots_p_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    if (result.__isset.ouch) {
      completed = true;
      completed__(true);
      throw result.ouch;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_all_snapshots_p failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void physical_packer_service_proxyCobClient::create_packer_job_ex_p(::apache::thrift::stdcxx::function<void(physical_packer_service_proxyCobClient* client)> cob, const std::string& session_id, const std::string& addr, const std::string& job_id, const create_packer_job_detail& create_job)
{
  send_create_packer_job_ex_p(session_id, addr, job_id, create_job);
  channel_->sendAndRecvMessage(::apache::thrift::stdcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void physical_packer_service_proxyCobClient::send_create_packer_job_ex_p(const std::string& session_id, const std::string& addr, const std::string& job_id, const create_packer_job_detail& create_job)
{
  int32_t cseqid = 0;
  otrans_->resetBuffer();
  oprot_->writeMessageBegin("create_packer_job_ex_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_create_packer_job_ex_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.job_id = &job_id;
  args.create_job = &create_job;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyCobClient::recv_create_packer_job_ex_p(packer_job_detail& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("create_packer_job_ex_p") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    physical_packer_service_proxy_create_packer_job_ex_p_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    if (result.__isset.ouch) {
      completed = true;
      completed__(true);
      throw result.ouch;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "create_packer_job_ex_p failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void physical_packer_service_proxyCobClient::get_packer_job_p(::apache::thrift::stdcxx::function<void(physical_packer_service_proxyCobClient* client)> cob, const std::string& session_id, const std::string& addr, const std::string& job_id, const std::string& previous_updated_time)
{
  send_get_packer_job_p(session_id, addr, job_id, previous_updated_time);
  channel_->sendAndRecvMessage(::apache::thrift::stdcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void physical_packer_service_proxyCobClient::send_get_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id, const std::string& previous_updated_time)
{
  int32_t cseqid = 0;
  otrans_->resetBuffer();
  oprot_->writeMessageBegin("get_packer_job_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_get_packer_job_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.job_id = &job_id;
  args.previous_updated_time = &previous_updated_time;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyCobClient::recv_get_packer_job_p(packer_job_detail& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("get_packer_job_p") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    physical_packer_service_proxy_get_packer_job_p_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    if (result.__isset.ouch) {
      completed = true;
      completed__(true);
      throw result.ouch;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_packer_job_p failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void physical_packer_service_proxyCobClient::interrupt_packer_job_p(::apache::thrift::stdcxx::function<void(physical_packer_service_proxyCobClient* client)> cob, const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  send_interrupt_packer_job_p(session_id, addr, job_id);
  channel_->sendAndRecvMessage(::apache::thrift::stdcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void physical_packer_service_proxyCobClient::send_interrupt_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  int32_t cseqid = 0;
  otrans_->resetBuffer();
  oprot_->writeMessageBegin("interrupt_packer_job_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_interrupt_packer_job_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.job_id = &job_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool physical_packer_service_proxyCobClient::recv_interrupt_packer_job_p()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("interrupt_packer_job_p") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    bool _return;
    physical_packer_service_proxy_interrupt_packer_job_p_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      completed = true;
      completed__(true);
      return _return;
    }
    if (result.__isset.ouch) {
      completed = true;
      completed__(true);
      throw result.ouch;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "interrupt_packer_job_p failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void physical_packer_service_proxyCobClient::resume_packer_job_p(::apache::thrift::stdcxx::function<void(physical_packer_service_proxyCobClient* client)> cob, const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  send_resume_packer_job_p(session_id, addr, job_id);
  channel_->sendAndRecvMessage(::apache::thrift::stdcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void physical_packer_service_proxyCobClient::send_resume_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  int32_t cseqid = 0;
  otrans_->resetBuffer();
  oprot_->writeMessageBegin("resume_packer_job_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_resume_packer_job_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.job_id = &job_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool physical_packer_service_proxyCobClient::recv_resume_packer_job_p()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("resume_packer_job_p") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    bool _return;
    physical_packer_service_proxy_resume_packer_job_p_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      completed = true;
      completed__(true);
      return _return;
    }
    if (result.__isset.ouch) {
      completed = true;
      completed__(true);
      throw result.ouch;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "resume_packer_job_p failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void physical_packer_service_proxyCobClient::remove_packer_job_p(::apache::thrift::stdcxx::function<void(physical_packer_service_proxyCobClient* client)> cob, const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  send_remove_packer_job_p(session_id, addr, job_id);
  channel_->sendAndRecvMessage(::apache::thrift::stdcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void physical_packer_service_proxyCobClient::send_remove_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  int32_t cseqid = 0;
  otrans_->resetBuffer();
  oprot_->writeMessageBegin("remove_packer_job_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_remove_packer_job_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.job_id = &job_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool physical_packer_service_proxyCobClient::recv_remove_packer_job_p()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("remove_packer_job_p") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    bool _return;
    physical_packer_service_proxy_remove_packer_job_p_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      completed = true;
      completed__(true);
      return _return;
    }
    if (result.__isset.ouch) {
      completed = true;
      completed__(true);
      throw result.ouch;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "remove_packer_job_p failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void physical_packer_service_proxyCobClient::running_packer_job_p(::apache::thrift::stdcxx::function<void(physical_packer_service_proxyCobClient* client)> cob, const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  send_running_packer_job_p(session_id, addr, job_id);
  channel_->sendAndRecvMessage(::apache::thrift::stdcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void physical_packer_service_proxyCobClient::send_running_packer_job_p(const std::string& session_id, const std::string& addr, const std::string& job_id)
{
  int32_t cseqid = 0;
  otrans_->resetBuffer();
  oprot_->writeMessageBegin("running_packer_job_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_running_packer_job_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.job_id = &job_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool physical_packer_service_proxyCobClient::recv_running_packer_job_p()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("running_packer_job_p") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    bool _return;
    physical_packer_service_proxy_running_packer_job_p_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      completed = true;
      completed__(true);
      return _return;
    }
    if (result.__isset.ouch) {
      completed = true;
      completed__(true);
      throw result.ouch;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "running_packer_job_p failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void physical_packer_service_proxyCobClient::enumerate_packer_disks_p(::apache::thrift::stdcxx::function<void(physical_packer_service_proxyCobClient* client)> cob, const std::string& session_id, const std::string& addr, const enumerate_disk_filter_style::type filter)
{
  send_enumerate_packer_disks_p(session_id, addr, filter);
  channel_->sendAndRecvMessage(::apache::thrift::stdcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void physical_packer_service_proxyCobClient::send_enumerate_packer_disks_p(const std::string& session_id, const std::string& addr, const enumerate_disk_filter_style::type filter)
{
  int32_t cseqid = 0;
  otrans_->resetBuffer();
  oprot_->writeMessageBegin("enumerate_packer_disks_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_enumerate_packer_disks_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.filter = &filter;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyCobClient::recv_enumerate_packer_disks_p(std::set<disk_info> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("enumerate_packer_disks_p") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    physical_packer_service_proxy_enumerate_packer_disks_p_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    if (result.__isset.ouch) {
      completed = true;
      completed__(true);
      throw result.ouch;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "enumerate_packer_disks_p failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void physical_packer_service_proxyCobClient::verify_packer_carrier_p(::apache::thrift::stdcxx::function<void(physical_packer_service_proxyCobClient* client)> cob, const std::string& session_id, const std::string& addr, const std::string& carrier, const bool is_ssl)
{
  send_verify_packer_carrier_p(session_id, addr, carrier, is_ssl);
  channel_->sendAndRecvMessage(::apache::thrift::stdcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void physical_packer_service_proxyCobClient::send_verify_packer_carrier_p(const std::string& session_id, const std::string& addr, const std::string& carrier, const bool is_ssl)
{
  int32_t cseqid = 0;
  otrans_->resetBuffer();
  oprot_->writeMessageBegin("verify_packer_carrier_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_verify_packer_carrier_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.carrier = &carrier;
  args.is_ssl = &is_ssl;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool physical_packer_service_proxyCobClient::recv_verify_packer_carrier_p()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("verify_packer_carrier_p") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    bool _return;
    physical_packer_service_proxy_verify_packer_carrier_p_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      completed = true;
      completed__(true);
      return _return;
    }
    if (result.__isset.ouch) {
      completed = true;
      completed__(true);
      throw result.ouch;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "verify_packer_carrier_p failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void physical_packer_service_proxyCobClient::get_packer_host_detail_p(::apache::thrift::stdcxx::function<void(physical_packer_service_proxyCobClient* client)> cob, const std::string& session_id, const std::string& addr, const machine_detail_filter::type filter)
{
  send_get_packer_host_detail_p(session_id, addr, filter);
  channel_->sendAndRecvMessage(::apache::thrift::stdcxx::bind(cob, this), otrans_.get(), itrans_.get());
}

void physical_packer_service_proxyCobClient::send_get_packer_host_detail_p(const std::string& session_id, const std::string& addr, const machine_detail_filter::type filter)
{
  int32_t cseqid = 0;
  otrans_->resetBuffer();
  oprot_->writeMessageBegin("get_packer_host_detail_p", ::apache::thrift::protocol::T_CALL, cseqid);

  physical_packer_service_proxy_get_packer_host_detail_p_pargs args;
  args.session_id = &session_id;
  args.addr = &addr;
  args.filter = &filter;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void physical_packer_service_proxyCobClient::recv_get_packer_host_detail_p(physical_machine_info& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;
  bool completed = false;

  try {
    iprot_->readMessageBegin(fname, mtype, rseqid);
    if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
      ::apache::thrift::TApplicationException x;
      x.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(true);
      throw x;
    }
    if (mtype != ::apache::thrift::protocol::T_REPLY) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    if (fname.compare("get_packer_host_detail_p") != 0) {
      iprot_->skip(::apache::thrift::protocol::T_STRUCT);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();
      completed = true;
      completed__(false);
    }
    physical_packer_service_proxy_get_packer_host_detail_p_presult result;
    result.success = &_return;
    result.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();

    if (result.__isset.success) {
      // _return pointer has now been filled
      completed = true;
      completed__(true);
      return;
    }
    if (result.__isset.ouch) {
      completed = true;
      completed__(true);
      throw result.ouch;
    }
    completed = true;
    completed__(true);
    throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "get_packer_host_detail_p failed: unknown result");
  } catch (...) {
    if (!completed) {
      completed__(false);
    }
    throw;
  }
}

void physical_packer_service_proxyAsyncProcessor::dispatchCall(::apache::thrift::stdcxx::function<void(bool ok)> cob, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid) {
  ProcessMap::iterator pfn;
  pfn = processMap_.find(fname);
  if (pfn == processMap_.end()) {
    return common_serviceAsyncProcessor::dispatchCall(cob, iprot, oprot, fname, seqid);
  }
  (this->*(pfn->second))(cob, seqid, iprot, oprot);
  return;
}

void physical_packer_service_proxyAsyncProcessor::process_packer_ping_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  physical_packer_service_proxy_packer_ping_p_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.packer_ping_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.packer_ping_p");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.packer_ping_p");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.packer_ping_p", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.packer_ping_p");
    }
    return cob(false);
  }
  freer.unregister();
  void (physical_packer_service_proxyAsyncProcessor::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const service_info& _return) =
    &physical_packer_service_proxyAsyncProcessor::return_packer_ping_p;
  iface_->packer_ping_p(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.session_id,
      args.addr);
}

void physical_packer_service_proxyAsyncProcessor::return_packer_ping_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const service_info& _return)
{
  physical_packer_service_proxy_packer_ping_p_presult result;
  result.success = const_cast<service_info*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.packer_ping_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.packer_ping_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.packer_ping_p");
  }

  oprot->writeMessageBegin("packer_ping_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.packer_ping_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::process_take_snapshots_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  physical_packer_service_proxy_take_snapshots_p_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.take_snapshots_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.take_snapshots_p");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.take_snapshots_p");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.take_snapshots_p", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.take_snapshots_p");
    }
    return cob(false);
  }
  freer.unregister();
  void (physical_packer_service_proxyAsyncProcessor::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::vector<snapshot> & _return) =
    &physical_packer_service_proxyAsyncProcessor::return_take_snapshots_p;
  void (physical_packer_service_proxyAsyncProcessor::*throw_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &physical_packer_service_proxyAsyncProcessor::throw_take_snapshots_p;
  iface_->take_snapshots_p(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      ::apache::thrift::stdcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.session_id,
      args.addr,
      args.disks);
}

void physical_packer_service_proxyAsyncProcessor::return_take_snapshots_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::vector<snapshot> & _return)
{
  physical_packer_service_proxy_take_snapshots_p_presult result;
  result.success = const_cast<std::vector<snapshot> *>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.take_snapshots_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.take_snapshots_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.take_snapshots_p");
  }

  oprot->writeMessageBegin("take_snapshots_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.take_snapshots_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::throw_take_snapshots_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.take_snapshots_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.take_snapshots_p");

  physical_packer_service_proxy_take_snapshots_p_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.take_snapshots_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("take_snapshots_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.take_snapshots_p");
  }

  oprot->writeMessageBegin("take_snapshots_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.take_snapshots_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::process_take_snapshots_ex_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  physical_packer_service_proxy_take_snapshots_ex_p_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.take_snapshots_ex_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.take_snapshots_ex_p");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.take_snapshots_ex_p");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.take_snapshots_ex_p", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.take_snapshots_ex_p");
    }
    return cob(false);
  }
  freer.unregister();
  void (physical_packer_service_proxyAsyncProcessor::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::vector<snapshot> & _return) =
    &physical_packer_service_proxyAsyncProcessor::return_take_snapshots_ex_p;
  void (physical_packer_service_proxyAsyncProcessor::*throw_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &physical_packer_service_proxyAsyncProcessor::throw_take_snapshots_ex_p;
  iface_->take_snapshots_ex_p(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      ::apache::thrift::stdcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.session_id,
      args.addr,
      args.disks,
      args.pre_script,
      args.post_script);
}

void physical_packer_service_proxyAsyncProcessor::return_take_snapshots_ex_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::vector<snapshot> & _return)
{
  physical_packer_service_proxy_take_snapshots_ex_p_presult result;
  result.success = const_cast<std::vector<snapshot> *>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.take_snapshots_ex_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.take_snapshots_ex_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.take_snapshots_ex_p");
  }

  oprot->writeMessageBegin("take_snapshots_ex_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.take_snapshots_ex_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::throw_take_snapshots_ex_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.take_snapshots_ex_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.take_snapshots_ex_p");

  physical_packer_service_proxy_take_snapshots_ex_p_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.take_snapshots_ex_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("take_snapshots_ex_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.take_snapshots_ex_p");
  }

  oprot->writeMessageBegin("take_snapshots_ex_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.take_snapshots_ex_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::process_take_snapshots2_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  physical_packer_service_proxy_take_snapshots2_p_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.take_snapshots2_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.take_snapshots2_p");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.take_snapshots2_p");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.take_snapshots2_p", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.take_snapshots2_p");
    }
    return cob(false);
  }
  freer.unregister();
  void (physical_packer_service_proxyAsyncProcessor::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::vector<snapshot> & _return) =
    &physical_packer_service_proxyAsyncProcessor::return_take_snapshots2_p;
  void (physical_packer_service_proxyAsyncProcessor::*throw_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &physical_packer_service_proxyAsyncProcessor::throw_take_snapshots2_p;
  iface_->take_snapshots2_p(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      ::apache::thrift::stdcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.session_id,
      args.addr,
      args.parameters);
}

void physical_packer_service_proxyAsyncProcessor::return_take_snapshots2_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::vector<snapshot> & _return)
{
  physical_packer_service_proxy_take_snapshots2_p_presult result;
  result.success = const_cast<std::vector<snapshot> *>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.take_snapshots2_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.take_snapshots2_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.take_snapshots2_p");
  }

  oprot->writeMessageBegin("take_snapshots2_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.take_snapshots2_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::throw_take_snapshots2_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.take_snapshots2_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.take_snapshots2_p");

  physical_packer_service_proxy_take_snapshots2_p_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.take_snapshots2_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("take_snapshots2_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.take_snapshots2_p");
  }

  oprot->writeMessageBegin("take_snapshots2_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.take_snapshots2_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::process_delete_snapshot_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  physical_packer_service_proxy_delete_snapshot_p_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.delete_snapshot_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.delete_snapshot_p");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.delete_snapshot_p");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.delete_snapshot_p", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.delete_snapshot_p");
    }
    return cob(false);
  }
  freer.unregister();
  void (physical_packer_service_proxyAsyncProcessor::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const delete_snapshot_result& _return) =
    &physical_packer_service_proxyAsyncProcessor::return_delete_snapshot_p;
  void (physical_packer_service_proxyAsyncProcessor::*throw_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &physical_packer_service_proxyAsyncProcessor::throw_delete_snapshot_p;
  iface_->delete_snapshot_p(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      ::apache::thrift::stdcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.session_id,
      args.addr,
      args.snapshot_id);
}

void physical_packer_service_proxyAsyncProcessor::return_delete_snapshot_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const delete_snapshot_result& _return)
{
  physical_packer_service_proxy_delete_snapshot_p_presult result;
  result.success = const_cast<delete_snapshot_result*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.delete_snapshot_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.delete_snapshot_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.delete_snapshot_p");
  }

  oprot->writeMessageBegin("delete_snapshot_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.delete_snapshot_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::throw_delete_snapshot_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.delete_snapshot_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.delete_snapshot_p");

  physical_packer_service_proxy_delete_snapshot_p_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.delete_snapshot_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("delete_snapshot_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.delete_snapshot_p");
  }

  oprot->writeMessageBegin("delete_snapshot_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.delete_snapshot_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::process_delete_snapshot_set_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  physical_packer_service_proxy_delete_snapshot_set_p_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.delete_snapshot_set_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.delete_snapshot_set_p");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.delete_snapshot_set_p");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.delete_snapshot_set_p", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.delete_snapshot_set_p");
    }
    return cob(false);
  }
  freer.unregister();
  void (physical_packer_service_proxyAsyncProcessor::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const delete_snapshot_result& _return) =
    &physical_packer_service_proxyAsyncProcessor::return_delete_snapshot_set_p;
  void (physical_packer_service_proxyAsyncProcessor::*throw_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &physical_packer_service_proxyAsyncProcessor::throw_delete_snapshot_set_p;
  iface_->delete_snapshot_set_p(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      ::apache::thrift::stdcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.session_id,
      args.addr,
      args.snapshot_set_id);
}

void physical_packer_service_proxyAsyncProcessor::return_delete_snapshot_set_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const delete_snapshot_result& _return)
{
  physical_packer_service_proxy_delete_snapshot_set_p_presult result;
  result.success = const_cast<delete_snapshot_result*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.delete_snapshot_set_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.delete_snapshot_set_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.delete_snapshot_set_p");
  }

  oprot->writeMessageBegin("delete_snapshot_set_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.delete_snapshot_set_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::throw_delete_snapshot_set_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.delete_snapshot_set_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.delete_snapshot_set_p");

  physical_packer_service_proxy_delete_snapshot_set_p_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.delete_snapshot_set_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("delete_snapshot_set_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.delete_snapshot_set_p");
  }

  oprot->writeMessageBegin("delete_snapshot_set_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.delete_snapshot_set_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::process_get_all_snapshots_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  physical_packer_service_proxy_get_all_snapshots_p_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.get_all_snapshots_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.get_all_snapshots_p");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.get_all_snapshots_p");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.get_all_snapshots_p", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.get_all_snapshots_p");
    }
    return cob(false);
  }
  freer.unregister();
  void (physical_packer_service_proxyAsyncProcessor::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::map<std::string, std::vector<snapshot> > & _return) =
    &physical_packer_service_proxyAsyncProcessor::return_get_all_snapshots_p;
  void (physical_packer_service_proxyAsyncProcessor::*throw_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &physical_packer_service_proxyAsyncProcessor::throw_get_all_snapshots_p;
  iface_->get_all_snapshots_p(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      ::apache::thrift::stdcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.session_id,
      args.addr);
}

void physical_packer_service_proxyAsyncProcessor::return_get_all_snapshots_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::map<std::string, std::vector<snapshot> > & _return)
{
  physical_packer_service_proxy_get_all_snapshots_p_presult result;
  result.success = const_cast<std::map<std::string, std::vector<snapshot> > *>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.get_all_snapshots_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.get_all_snapshots_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.get_all_snapshots_p");
  }

  oprot->writeMessageBegin("get_all_snapshots_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.get_all_snapshots_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::throw_get_all_snapshots_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.get_all_snapshots_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.get_all_snapshots_p");

  physical_packer_service_proxy_get_all_snapshots_p_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.get_all_snapshots_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("get_all_snapshots_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.get_all_snapshots_p");
  }

  oprot->writeMessageBegin("get_all_snapshots_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.get_all_snapshots_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::process_create_packer_job_ex_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  physical_packer_service_proxy_create_packer_job_ex_p_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.create_packer_job_ex_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.create_packer_job_ex_p");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.create_packer_job_ex_p");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.create_packer_job_ex_p", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.create_packer_job_ex_p");
    }
    return cob(false);
  }
  freer.unregister();
  void (physical_packer_service_proxyAsyncProcessor::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const packer_job_detail& _return) =
    &physical_packer_service_proxyAsyncProcessor::return_create_packer_job_ex_p;
  void (physical_packer_service_proxyAsyncProcessor::*throw_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &physical_packer_service_proxyAsyncProcessor::throw_create_packer_job_ex_p;
  iface_->create_packer_job_ex_p(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      ::apache::thrift::stdcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.session_id,
      args.addr,
      args.job_id,
      args.create_job);
}

void physical_packer_service_proxyAsyncProcessor::return_create_packer_job_ex_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const packer_job_detail& _return)
{
  physical_packer_service_proxy_create_packer_job_ex_p_presult result;
  result.success = const_cast<packer_job_detail*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.create_packer_job_ex_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.create_packer_job_ex_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.create_packer_job_ex_p");
  }

  oprot->writeMessageBegin("create_packer_job_ex_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.create_packer_job_ex_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::throw_create_packer_job_ex_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.create_packer_job_ex_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.create_packer_job_ex_p");

  physical_packer_service_proxy_create_packer_job_ex_p_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.create_packer_job_ex_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("create_packer_job_ex_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.create_packer_job_ex_p");
  }

  oprot->writeMessageBegin("create_packer_job_ex_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.create_packer_job_ex_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::process_get_packer_job_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  physical_packer_service_proxy_get_packer_job_p_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.get_packer_job_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.get_packer_job_p");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.get_packer_job_p");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.get_packer_job_p", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.get_packer_job_p");
    }
    return cob(false);
  }
  freer.unregister();
  void (physical_packer_service_proxyAsyncProcessor::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const packer_job_detail& _return) =
    &physical_packer_service_proxyAsyncProcessor::return_get_packer_job_p;
  void (physical_packer_service_proxyAsyncProcessor::*throw_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &physical_packer_service_proxyAsyncProcessor::throw_get_packer_job_p;
  iface_->get_packer_job_p(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      ::apache::thrift::stdcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.session_id,
      args.addr,
      args.job_id,
      args.previous_updated_time);
}

void physical_packer_service_proxyAsyncProcessor::return_get_packer_job_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const packer_job_detail& _return)
{
  physical_packer_service_proxy_get_packer_job_p_presult result;
  result.success = const_cast<packer_job_detail*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.get_packer_job_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.get_packer_job_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.get_packer_job_p");
  }

  oprot->writeMessageBegin("get_packer_job_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.get_packer_job_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::throw_get_packer_job_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.get_packer_job_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.get_packer_job_p");

  physical_packer_service_proxy_get_packer_job_p_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.get_packer_job_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("get_packer_job_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.get_packer_job_p");
  }

  oprot->writeMessageBegin("get_packer_job_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.get_packer_job_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::process_interrupt_packer_job_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  physical_packer_service_proxy_interrupt_packer_job_p_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.interrupt_packer_job_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.interrupt_packer_job_p");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.interrupt_packer_job_p");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.interrupt_packer_job_p", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.interrupt_packer_job_p");
    }
    return cob(false);
  }
  freer.unregister();
  void (physical_packer_service_proxyAsyncProcessor::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const bool& _return) =
    &physical_packer_service_proxyAsyncProcessor::return_interrupt_packer_job_p;
  void (physical_packer_service_proxyAsyncProcessor::*throw_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &physical_packer_service_proxyAsyncProcessor::throw_interrupt_packer_job_p;
  iface_->interrupt_packer_job_p(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      ::apache::thrift::stdcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.session_id,
      args.addr,
      args.job_id);
}

void physical_packer_service_proxyAsyncProcessor::return_interrupt_packer_job_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const bool& _return)
{
  physical_packer_service_proxy_interrupt_packer_job_p_presult result;
  result.success = const_cast<bool*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.interrupt_packer_job_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.interrupt_packer_job_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.interrupt_packer_job_p");
  }

  oprot->writeMessageBegin("interrupt_packer_job_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.interrupt_packer_job_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::throw_interrupt_packer_job_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.interrupt_packer_job_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.interrupt_packer_job_p");

  physical_packer_service_proxy_interrupt_packer_job_p_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.interrupt_packer_job_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("interrupt_packer_job_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.interrupt_packer_job_p");
  }

  oprot->writeMessageBegin("interrupt_packer_job_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.interrupt_packer_job_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::process_resume_packer_job_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  physical_packer_service_proxy_resume_packer_job_p_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.resume_packer_job_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.resume_packer_job_p");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.resume_packer_job_p");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.resume_packer_job_p", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.resume_packer_job_p");
    }
    return cob(false);
  }
  freer.unregister();
  void (physical_packer_service_proxyAsyncProcessor::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const bool& _return) =
    &physical_packer_service_proxyAsyncProcessor::return_resume_packer_job_p;
  void (physical_packer_service_proxyAsyncProcessor::*throw_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &physical_packer_service_proxyAsyncProcessor::throw_resume_packer_job_p;
  iface_->resume_packer_job_p(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      ::apache::thrift::stdcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.session_id,
      args.addr,
      args.job_id);
}

void physical_packer_service_proxyAsyncProcessor::return_resume_packer_job_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const bool& _return)
{
  physical_packer_service_proxy_resume_packer_job_p_presult result;
  result.success = const_cast<bool*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.resume_packer_job_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.resume_packer_job_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.resume_packer_job_p");
  }

  oprot->writeMessageBegin("resume_packer_job_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.resume_packer_job_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::throw_resume_packer_job_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.resume_packer_job_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.resume_packer_job_p");

  physical_packer_service_proxy_resume_packer_job_p_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.resume_packer_job_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("resume_packer_job_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.resume_packer_job_p");
  }

  oprot->writeMessageBegin("resume_packer_job_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.resume_packer_job_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::process_remove_packer_job_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  physical_packer_service_proxy_remove_packer_job_p_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.remove_packer_job_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.remove_packer_job_p");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.remove_packer_job_p");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.remove_packer_job_p", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.remove_packer_job_p");
    }
    return cob(false);
  }
  freer.unregister();
  void (physical_packer_service_proxyAsyncProcessor::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const bool& _return) =
    &physical_packer_service_proxyAsyncProcessor::return_remove_packer_job_p;
  void (physical_packer_service_proxyAsyncProcessor::*throw_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &physical_packer_service_proxyAsyncProcessor::throw_remove_packer_job_p;
  iface_->remove_packer_job_p(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      ::apache::thrift::stdcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.session_id,
      args.addr,
      args.job_id);
}

void physical_packer_service_proxyAsyncProcessor::return_remove_packer_job_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const bool& _return)
{
  physical_packer_service_proxy_remove_packer_job_p_presult result;
  result.success = const_cast<bool*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.remove_packer_job_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.remove_packer_job_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.remove_packer_job_p");
  }

  oprot->writeMessageBegin("remove_packer_job_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.remove_packer_job_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::throw_remove_packer_job_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.remove_packer_job_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.remove_packer_job_p");

  physical_packer_service_proxy_remove_packer_job_p_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.remove_packer_job_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("remove_packer_job_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.remove_packer_job_p");
  }

  oprot->writeMessageBegin("remove_packer_job_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.remove_packer_job_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::process_running_packer_job_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  physical_packer_service_proxy_running_packer_job_p_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.running_packer_job_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.running_packer_job_p");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.running_packer_job_p");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.running_packer_job_p", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.running_packer_job_p");
    }
    return cob(false);
  }
  freer.unregister();
  void (physical_packer_service_proxyAsyncProcessor::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const bool& _return) =
    &physical_packer_service_proxyAsyncProcessor::return_running_packer_job_p;
  void (physical_packer_service_proxyAsyncProcessor::*throw_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &physical_packer_service_proxyAsyncProcessor::throw_running_packer_job_p;
  iface_->running_packer_job_p(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      ::apache::thrift::stdcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.session_id,
      args.addr,
      args.job_id);
}

void physical_packer_service_proxyAsyncProcessor::return_running_packer_job_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const bool& _return)
{
  physical_packer_service_proxy_running_packer_job_p_presult result;
  result.success = const_cast<bool*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.running_packer_job_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.running_packer_job_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.running_packer_job_p");
  }

  oprot->writeMessageBegin("running_packer_job_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.running_packer_job_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::throw_running_packer_job_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.running_packer_job_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.running_packer_job_p");

  physical_packer_service_proxy_running_packer_job_p_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.running_packer_job_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("running_packer_job_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.running_packer_job_p");
  }

  oprot->writeMessageBegin("running_packer_job_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.running_packer_job_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::process_enumerate_packer_disks_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  physical_packer_service_proxy_enumerate_packer_disks_p_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.enumerate_packer_disks_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.enumerate_packer_disks_p");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.enumerate_packer_disks_p");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.enumerate_packer_disks_p", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.enumerate_packer_disks_p");
    }
    return cob(false);
  }
  freer.unregister();
  void (physical_packer_service_proxyAsyncProcessor::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::set<disk_info> & _return) =
    &physical_packer_service_proxyAsyncProcessor::return_enumerate_packer_disks_p;
  void (physical_packer_service_proxyAsyncProcessor::*throw_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &physical_packer_service_proxyAsyncProcessor::throw_enumerate_packer_disks_p;
  iface_->enumerate_packer_disks_p(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      ::apache::thrift::stdcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.session_id,
      args.addr,
      args.filter);
}

void physical_packer_service_proxyAsyncProcessor::return_enumerate_packer_disks_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const std::set<disk_info> & _return)
{
  physical_packer_service_proxy_enumerate_packer_disks_p_presult result;
  result.success = const_cast<std::set<disk_info> *>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.enumerate_packer_disks_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.enumerate_packer_disks_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.enumerate_packer_disks_p");
  }

  oprot->writeMessageBegin("enumerate_packer_disks_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.enumerate_packer_disks_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::throw_enumerate_packer_disks_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.enumerate_packer_disks_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.enumerate_packer_disks_p");

  physical_packer_service_proxy_enumerate_packer_disks_p_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.enumerate_packer_disks_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("enumerate_packer_disks_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.enumerate_packer_disks_p");
  }

  oprot->writeMessageBegin("enumerate_packer_disks_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.enumerate_packer_disks_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::process_verify_packer_carrier_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  physical_packer_service_proxy_verify_packer_carrier_p_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.verify_packer_carrier_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.verify_packer_carrier_p");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.verify_packer_carrier_p");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.verify_packer_carrier_p", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.verify_packer_carrier_p");
    }
    return cob(false);
  }
  freer.unregister();
  void (physical_packer_service_proxyAsyncProcessor::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const bool& _return) =
    &physical_packer_service_proxyAsyncProcessor::return_verify_packer_carrier_p;
  void (physical_packer_service_proxyAsyncProcessor::*throw_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &physical_packer_service_proxyAsyncProcessor::throw_verify_packer_carrier_p;
  iface_->verify_packer_carrier_p(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      ::apache::thrift::stdcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.session_id,
      args.addr,
      args.carrier,
      args.is_ssl);
}

void physical_packer_service_proxyAsyncProcessor::return_verify_packer_carrier_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const bool& _return)
{
  physical_packer_service_proxy_verify_packer_carrier_p_presult result;
  result.success = const_cast<bool*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.verify_packer_carrier_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.verify_packer_carrier_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.verify_packer_carrier_p");
  }

  oprot->writeMessageBegin("verify_packer_carrier_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.verify_packer_carrier_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::throw_verify_packer_carrier_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.verify_packer_carrier_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.verify_packer_carrier_p");

  physical_packer_service_proxy_verify_packer_carrier_p_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.verify_packer_carrier_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("verify_packer_carrier_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.verify_packer_carrier_p");
  }

  oprot->writeMessageBegin("verify_packer_carrier_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.verify_packer_carrier_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::process_get_packer_host_detail_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot)
{
  physical_packer_service_proxy_get_packer_host_detail_p_args args;
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.get_packer_host_detail_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.get_packer_host_detail_p");

  try {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->preRead(ctx, "physical_packer_service_proxy.get_packer_host_detail_p");
    }
    args.read(iprot);
    iprot->readMessageEnd();
    uint32_t bytes = iprot->getTransport()->readEnd();
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->postRead(ctx, "physical_packer_service_proxy.get_packer_host_detail_p", bytes);
    }
  }
  catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.get_packer_host_detail_p");
    }
    return cob(false);
  }
  freer.unregister();
  void (physical_packer_service_proxyAsyncProcessor::*return_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const physical_machine_info& _return) =
    &physical_packer_service_proxyAsyncProcessor::return_get_packer_host_detail_p;
  void (physical_packer_service_proxyAsyncProcessor::*throw_fn)(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw) =
    &physical_packer_service_proxyAsyncProcessor::throw_get_packer_host_detail_p;
  iface_->get_packer_host_detail_p(
      ::apache::thrift::stdcxx::bind(return_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      ::apache::thrift::stdcxx::bind(throw_fn, this, cob, seqid, oprot, ctx, ::apache::thrift::stdcxx::placeholders::_1),
      args.session_id,
      args.addr,
      args.filter);
}

void physical_packer_service_proxyAsyncProcessor::return_get_packer_host_detail_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, const physical_machine_info& _return)
{
  physical_packer_service_proxy_get_packer_host_detail_p_presult result;
  result.success = const_cast<physical_machine_info*>(&_return);
  result.__isset.success = true;

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.get_packer_host_detail_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.get_packer_host_detail_p");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.get_packer_host_detail_p");
  }

  oprot->writeMessageBegin("get_packer_host_detail_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.get_packer_host_detail_p", bytes);
  }
  return cob(true);
}

void physical_packer_service_proxyAsyncProcessor::throw_get_packer_host_detail_p(::apache::thrift::stdcxx::function<void(bool ok)> cob, int32_t seqid, ::apache::thrift::protocol::TProtocol* oprot, void* ctx, ::apache::thrift::TDelayedException* _throw)
{

  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("physical_packer_service_proxy.get_packer_host_detail_p", NULL);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "physical_packer_service_proxy.get_packer_host_detail_p");

  physical_packer_service_proxy_get_packer_host_detail_p_result result;

  try {
    _throw->throw_it();
    return cob(false);
  }  catch (invalid_operation &ouch) {
    result.ouch = ouch;
    result.__isset.ouch = true;
  }
 catch (std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "physical_packer_service_proxy.get_packer_host_detail_p");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("get_packer_host_detail_p", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return cob(true);
  }
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "physical_packer_service_proxy.get_packer_host_detail_p");
  }

  oprot->writeMessageBegin("get_packer_host_detail_p", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  uint32_t bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();
  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "physical_packer_service_proxy.get_packer_host_detail_p", bytes);
  }
  return cob(true);
}

::apache::thrift::stdcxx::shared_ptr< ::apache::thrift::async::TAsyncProcessor > physical_packer_service_proxyAsyncProcessorFactory::getProcessor(const ::apache::thrift::TConnectionInfo& connInfo) {
  ::apache::thrift::ReleaseHandler< physical_packer_service_proxyCobSvIfFactory > cleanup(handlerFactory_);
  ::apache::thrift::stdcxx::shared_ptr< physical_packer_service_proxyCobSvIf > handler(handlerFactory_->getHandler(connInfo), cleanup);
  ::apache::thrift::stdcxx::shared_ptr< ::apache::thrift::async::TAsyncProcessor > processor(new physical_packer_service_proxyAsyncProcessor(handler));
  return processor;
}

}} // namespace

