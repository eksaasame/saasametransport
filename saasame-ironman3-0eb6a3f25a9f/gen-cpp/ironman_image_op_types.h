/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef ironman_image_op_TYPES_H
#define ironman_image_op_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace mwdc { namespace ironman { namespace image_op {

class invalid_operation;

class op_status;

class data_chunks;

class vmdk_to_other_image_req_args;

typedef struct _invalid_operation__isset {
  _invalid_operation__isset() : what_op(false), why(false) {}
  bool what_op :1;
  bool why :1;
} _invalid_operation__isset;

class invalid_operation : public ::apache::thrift::TException {
 public:

  invalid_operation(const invalid_operation&);
  invalid_operation& operator=(const invalid_operation&);
  invalid_operation() : what_op(0), why() {
  }

  virtual ~invalid_operation() throw();
  int32_t what_op;
  std::string why;

  _invalid_operation__isset __isset;

  void __set_what_op(const int32_t val);

  void __set_why(const std::string& val);

  bool operator == (const invalid_operation & rhs) const
  {
    if (!(what_op == rhs.what_op))
      return false;
    if (!(why == rhs.why))
      return false;
    return true;
  }
  bool operator != (const invalid_operation &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const invalid_operation & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(invalid_operation &a, invalid_operation &b);

inline std::ostream& operator<<(std::ostream& out, const invalid_operation& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _op_status__isset {
  _op_status__isset() : vmxspec(true), image_name(true), snapshot_mor_ref(true), output_file_path(true), disk_size_bytes(true), last_read_pos_bytes(true), last_write_pos_bytes(true), completed_written_bytes(true), error_what(true), error_why(true), is_windows(true) {}
  bool vmxspec :1;
  bool image_name :1;
  bool snapshot_mor_ref :1;
  bool output_file_path :1;
  bool disk_size_bytes :1;
  bool last_read_pos_bytes :1;
  bool last_write_pos_bytes :1;
  bool completed_written_bytes :1;
  bool error_what :1;
  bool error_why :1;
  bool is_windows :1;
} _op_status__isset;

class op_status {
 public:

  op_status(const op_status&);
  op_status& operator=(const op_status&);
  op_status() : vmxspec(""), image_name(""), snapshot_mor_ref(""), output_file_path(""), disk_size_bytes(0LL), last_read_pos_bytes(0LL), last_write_pos_bytes(0LL), completed_written_bytes(0LL), error_what(0LL), error_why(""), is_windows(false) {
  }

  virtual ~op_status() throw();
  std::string vmxspec;
  std::string image_name;
  std::string snapshot_mor_ref;
  std::string output_file_path;
  int64_t disk_size_bytes;
  int64_t last_read_pos_bytes;
  int64_t last_write_pos_bytes;
  int64_t completed_written_bytes;
  int64_t error_what;
  std::string error_why;
  bool is_windows;

  _op_status__isset __isset;

  void __set_vmxspec(const std::string& val);

  void __set_image_name(const std::string& val);

  void __set_snapshot_mor_ref(const std::string& val);

  void __set_output_file_path(const std::string& val);

  void __set_disk_size_bytes(const int64_t val);

  void __set_last_read_pos_bytes(const int64_t val);

  void __set_last_write_pos_bytes(const int64_t val);

  void __set_completed_written_bytes(const int64_t val);

  void __set_error_what(const int64_t val);

  void __set_error_why(const std::string& val);

  void __set_is_windows(const bool val);

  bool operator == (const op_status & rhs) const
  {
    if (__isset.vmxspec != rhs.__isset.vmxspec)
      return false;
    else if (__isset.vmxspec && !(vmxspec == rhs.vmxspec))
      return false;
    if (__isset.image_name != rhs.__isset.image_name)
      return false;
    else if (__isset.image_name && !(image_name == rhs.image_name))
      return false;
    if (__isset.snapshot_mor_ref != rhs.__isset.snapshot_mor_ref)
      return false;
    else if (__isset.snapshot_mor_ref && !(snapshot_mor_ref == rhs.snapshot_mor_ref))
      return false;
    if (__isset.output_file_path != rhs.__isset.output_file_path)
      return false;
    else if (__isset.output_file_path && !(output_file_path == rhs.output_file_path))
      return false;
    if (__isset.disk_size_bytes != rhs.__isset.disk_size_bytes)
      return false;
    else if (__isset.disk_size_bytes && !(disk_size_bytes == rhs.disk_size_bytes))
      return false;
    if (__isset.last_read_pos_bytes != rhs.__isset.last_read_pos_bytes)
      return false;
    else if (__isset.last_read_pos_bytes && !(last_read_pos_bytes == rhs.last_read_pos_bytes))
      return false;
    if (__isset.last_write_pos_bytes != rhs.__isset.last_write_pos_bytes)
      return false;
    else if (__isset.last_write_pos_bytes && !(last_write_pos_bytes == rhs.last_write_pos_bytes))
      return false;
    if (__isset.completed_written_bytes != rhs.__isset.completed_written_bytes)
      return false;
    else if (__isset.completed_written_bytes && !(completed_written_bytes == rhs.completed_written_bytes))
      return false;
    if (__isset.error_what != rhs.__isset.error_what)
      return false;
    else if (__isset.error_what && !(error_what == rhs.error_what))
      return false;
    if (__isset.error_why != rhs.__isset.error_why)
      return false;
    else if (__isset.error_why && !(error_why == rhs.error_why))
      return false;
    if (__isset.is_windows != rhs.__isset.is_windows)
      return false;
    else if (__isset.is_windows && !(is_windows == rhs.is_windows))
      return false;
    return true;
  }
  bool operator != (const op_status &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const op_status & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(op_status &a, op_status &b);

inline std::ostream& operator<<(std::ostream& out, const op_status& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _data_chunks__isset {
  _data_chunks__isset() : start(true), length(true) {}
  bool start :1;
  bool length :1;
} _data_chunks__isset;

class data_chunks {
 public:

  data_chunks(const data_chunks&);
  data_chunks& operator=(const data_chunks&);
  data_chunks() : start(0LL), length(0LL) {
  }

  virtual ~data_chunks() throw();
  int64_t start;
  int64_t length;

  _data_chunks__isset __isset;

  void __set_start(const int64_t val);

  void __set_length(const int64_t val);

  bool operator == (const data_chunks & rhs) const
  {
    if (__isset.start != rhs.__isset.start)
      return false;
    else if (__isset.start && !(start == rhs.start))
      return false;
    if (__isset.length != rhs.__isset.length)
      return false;
    else if (__isset.length && !(length == rhs.length))
      return false;
    return true;
  }
  bool operator != (const data_chunks &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const data_chunks & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(data_chunks &a, data_chunks &b);

inline std::ostream& operator<<(std::ostream& out, const data_chunks& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _vmdk_to_other_image_req_args__isset {
  _vmdk_to_other_image_req_args__isset() : vmxspec(true), thumbprint(true), source_image_path(true), output_file_path(true), parent_file(true), snapshot_mor_ref(true), checksum_file_path(true), readonly(true), disk_size_bytes(true), next_byte_to_read(true), next_byte_to_write(true), completed_written_bytes(true), clean_vss_sectors(true), changed_blocks(false) {}
  bool vmxspec :1;
  bool thumbprint :1;
  bool source_image_path :1;
  bool output_file_path :1;
  bool parent_file :1;
  bool snapshot_mor_ref :1;
  bool checksum_file_path :1;
  bool readonly :1;
  bool disk_size_bytes :1;
  bool next_byte_to_read :1;
  bool next_byte_to_write :1;
  bool completed_written_bytes :1;
  bool clean_vss_sectors :1;
  bool changed_blocks :1;
} _vmdk_to_other_image_req_args__isset;

class vmdk_to_other_image_req_args {
 public:

  vmdk_to_other_image_req_args(const vmdk_to_other_image_req_args&);
  vmdk_to_other_image_req_args& operator=(const vmdk_to_other_image_req_args&);
  vmdk_to_other_image_req_args() : vmxspec(""), thumbprint(""), source_image_path(""), output_file_path(""), parent_file(""), snapshot_mor_ref(""), checksum_file_path(""), readonly(true), disk_size_bytes(0LL), next_byte_to_read(0LL), next_byte_to_write(0LL), completed_written_bytes(0LL), clean_vss_sectors(false) {
  }

  virtual ~vmdk_to_other_image_req_args() throw();
  std::string vmxspec;
  std::string thumbprint;
  std::string source_image_path;
  std::string output_file_path;
  std::string parent_file;
  std::string snapshot_mor_ref;
  std::string checksum_file_path;
  bool readonly;
  int64_t disk_size_bytes;
  int64_t next_byte_to_read;
  int64_t next_byte_to_write;
  int64_t completed_written_bytes;
  bool clean_vss_sectors;
  std::vector<data_chunks>  changed_blocks;

  _vmdk_to_other_image_req_args__isset __isset;

  void __set_vmxspec(const std::string& val);

  void __set_thumbprint(const std::string& val);

  void __set_source_image_path(const std::string& val);

  void __set_output_file_path(const std::string& val);

  void __set_parent_file(const std::string& val);

  void __set_snapshot_mor_ref(const std::string& val);

  void __set_checksum_file_path(const std::string& val);

  void __set_readonly(const bool val);

  void __set_disk_size_bytes(const int64_t val);

  void __set_next_byte_to_read(const int64_t val);

  void __set_next_byte_to_write(const int64_t val);

  void __set_completed_written_bytes(const int64_t val);

  void __set_clean_vss_sectors(const bool val);

  void __set_changed_blocks(const std::vector<data_chunks> & val);

  bool operator == (const vmdk_to_other_image_req_args & rhs) const
  {
    if (__isset.vmxspec != rhs.__isset.vmxspec)
      return false;
    else if (__isset.vmxspec && !(vmxspec == rhs.vmxspec))
      return false;
    if (__isset.thumbprint != rhs.__isset.thumbprint)
      return false;
    else if (__isset.thumbprint && !(thumbprint == rhs.thumbprint))
      return false;
    if (__isset.source_image_path != rhs.__isset.source_image_path)
      return false;
    else if (__isset.source_image_path && !(source_image_path == rhs.source_image_path))
      return false;
    if (__isset.output_file_path != rhs.__isset.output_file_path)
      return false;
    else if (__isset.output_file_path && !(output_file_path == rhs.output_file_path))
      return false;
    if (__isset.parent_file != rhs.__isset.parent_file)
      return false;
    else if (__isset.parent_file && !(parent_file == rhs.parent_file))
      return false;
    if (__isset.snapshot_mor_ref != rhs.__isset.snapshot_mor_ref)
      return false;
    else if (__isset.snapshot_mor_ref && !(snapshot_mor_ref == rhs.snapshot_mor_ref))
      return false;
    if (__isset.checksum_file_path != rhs.__isset.checksum_file_path)
      return false;
    else if (__isset.checksum_file_path && !(checksum_file_path == rhs.checksum_file_path))
      return false;
    if (__isset.readonly != rhs.__isset.readonly)
      return false;
    else if (__isset.readonly && !(readonly == rhs.readonly))
      return false;
    if (__isset.disk_size_bytes != rhs.__isset.disk_size_bytes)
      return false;
    else if (__isset.disk_size_bytes && !(disk_size_bytes == rhs.disk_size_bytes))
      return false;
    if (__isset.next_byte_to_read != rhs.__isset.next_byte_to_read)
      return false;
    else if (__isset.next_byte_to_read && !(next_byte_to_read == rhs.next_byte_to_read))
      return false;
    if (__isset.next_byte_to_write != rhs.__isset.next_byte_to_write)
      return false;
    else if (__isset.next_byte_to_write && !(next_byte_to_write == rhs.next_byte_to_write))
      return false;
    if (__isset.completed_written_bytes != rhs.__isset.completed_written_bytes)
      return false;
    else if (__isset.completed_written_bytes && !(completed_written_bytes == rhs.completed_written_bytes))
      return false;
    if (__isset.clean_vss_sectors != rhs.__isset.clean_vss_sectors)
      return false;
    else if (__isset.clean_vss_sectors && !(clean_vss_sectors == rhs.clean_vss_sectors))
      return false;
    if (__isset.changed_blocks != rhs.__isset.changed_blocks)
      return false;
    else if (__isset.changed_blocks && !(changed_blocks == rhs.changed_blocks))
      return false;
    return true;
  }
  bool operator != (const vmdk_to_other_image_req_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const vmdk_to_other_image_req_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(vmdk_to_other_image_req_args &a, vmdk_to_other_image_req_args &b);

inline std::ostream& operator<<(std::ostream& out, const vmdk_to_other_image_req_args& obj)
{
  obj.printTo(out);
  return out;
}

}}} // namespace

#endif
