/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef saasame_mgmt_TYPES_H
#define saasame_mgmt_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace saasame { namespace mgmt {

struct partition_style {
  enum type {
    PARTITION_UNKNOWN = 0,
    PARTITION_MBR = 1,
    PARTITION_GPT = 2
  };
};

extern const std::map<int, const char*> _partition_style_VALUES_TO_NAMES;

struct drive_type {
  enum type {
    DT_UNKNOWN = 0,
    DT_NO_ROOT_PATH = 1,
    DT_REMOVABLE = 2,
    DT_FIXED = 3,
    DT_REMOTE = 4,
    DT_CDROM = 5,
    DT_RAMDISK = 6
  };
};

extern const std::map<int, const char*> _drive_type_VALUES_TO_NAMES;

struct bus_type {
  enum type {
    Unknown = 0,
    SCSI = 1,
    ATAPI = 2,
    ATA = 3,
    IEEE_1394 = 4,
    SSA = 5,
    Fibre_Channel = 6,
    USB = 7,
    RAID = 8,
    iSCSI = 9,
    SAS = 10,
    SATA = 11,
    SD = 12,
    MMC = 13,
    Virtual = 14,
    File_Backed_Virtual = 15,
    Storage_Spaces = 16,
    NVMe = 17
  };
};

extern const std::map<int, const char*> _bus_type_VALUES_TO_NAMES;

struct hv_vm_tools_status {
  enum type {
    HV_VMTOOLS_UNKNOWN = 0,
    HV_VMTOOLS_OK = 1,
    HV_VMTOOLS_NOTINSTALLED = 2,
    HV_VMTOOLS_OLD = 3,
    HV_VMTOOLS_NOTRUNNING = 4
  };
};

extern const std::map<int, const char*> _hv_vm_tools_status_VALUES_TO_NAMES;

struct hv_vm_power_state {
  enum type {
    HV_VMPOWER_UNKNOWN = 0,
    HV_VMPOWER_ON = 1,
    HV_VMPOWER_OFF = 2,
    HV_VMPOWER_SUSPENDED = 3
  };
};

extern const std::map<int, const char*> _hv_vm_power_state_VALUES_TO_NAMES;

struct hv_vm_connection_state {
  enum type {
    HV_VMCONNECT_UNKNOWN = 0,
    HV_VMCONNECT_CONNECTED = 1,
    HV_VMCONNECT_DISCONNECTED = 2,
    HV_VMCONNECT_INACCESSIBLE = 3,
    HV_VMCONNECT_INVALID = 4,
    HV_VMCONNECT_ORPHANED = 5
  };
};

extern const std::map<int, const char*> _hv_vm_connection_state_VALUES_TO_NAMES;

struct hv_host_power_state {
  enum type {
    HV_HOSTPOWER_UNKNOWN = 0,
    HV_HOSTPOWER_ON = 1,
    HV_HOSTPOWER_OFF = 2,
    HV_HOSTPOWER_STANDBY = 3
  };
};

extern const std::map<int, const char*> _hv_host_power_state_VALUES_TO_NAMES;

struct hv_guest_os_type {
  enum type {
    HV_OS_UNKNOWN = 0,
    HV_OS_WINDOWS = 1,
    HV_OS_LINUX = 2
  };
};

extern const std::map<int, const char*> _hv_guest_os_type_VALUES_TO_NAMES;

struct hv_vm_firmware {
  enum type {
    HV_VM_FIRMWARE_BIOS = 0,
    HV_VM_FIRMWARE_EFI = 1
  };
};

extern const std::map<int, const char*> _hv_vm_firmware_VALUES_TO_NAMES;

struct job_type {
  enum type {
    physical_migration_type = 1,
    virtual_migration_type = 2,
    physical_transport_type = 3,
    virtual_transport_type = 4
  };
};

extern const std::map<int, const char*> _job_type_VALUES_TO_NAMES;

struct job_state {
  enum type {
    job_state_none = 1,
    job_state_initialed = 2,
    job_state_replicating = 4,
    job_state_replicated = 8,
    job_state_converting = 16,
    job_state_finished = 32,
    job_state_sche_completed = 64
  };
};

extern const std::map<int, const char*> _job_state_VALUES_TO_NAMES;

struct error_codes {
  enum type {
    IRONMAN_S_OK = 0,
    IRONMAN_NOERROR = 0,
    IRONMAN_E_FAIL = 4096,
    IRONMAN_E_INITIAL_FAIL = 4097,
    IRONMAN_E_DISK_FULL = 4098,
    IRONMAN_E_INVALID_ARG = 4099,
    IRONMAN_E_INVALID_AUTHENTICATION = 4100,
    IRONMAN_E_INTERNAL_FAIL = 4101,
    IRONMAN_E_CANNOT_CONNECT_TO_HOST = 4102,
    IRONMAN_E_JOB_CREATE_FAIL = 12288,
    IRONMAN_E_JOB_REMOVE_FAIL = 12289,
    IRONMAN_E_JOB_NOTFOUND = 12290,
    IRONMAN_E_JOB_CONFIG_NOTFOUND = 12291,
    IRONMAN_E_JOB_STATUS_NOTFOUND = 12292,
    IRONMAN_E_JOB_CANCELLED = 12293,
    IRONMAN_E_JOB_CONVERT_FAIL = 12294,
    IRONMAN_E_JOB_REPLICATE_FAIL = 12295,
    IRONMAN_E_JOB_ID_DUPLICATED = 12296,
    IRONMAN_E_JOB_INTERRUPTED = 12297,
    IRONMAN_E_PHYSICAL_CONFIG_FAILED = 16384,
    IRONMAN_E_VIRTUAL_VM_NOTFOUND = 20480,
    IRONMAN_E_IMAGE_NOTFOUND = 24576,
    IRONMAN_E_IMAGE_CREATE_FAIL = 24577,
    IRONMAN_E_IMAGE_OPEN_FAIL = 24578,
    IRONMAN_E_IMAGE_READ = 24579,
    IRONMAN_E_IMAGE_WRITE = 24580,
    IRONMAN_E_IMAGE_OUTOFRANGE = 24581,
    IRONMAN_E_IMAGE_ATTACH_FAIL = 24582,
    IRONMAN_E_IMAGE_DETACH_FAIL = 24583,
    IRONMAN_E_IMAGE_PROPERTY_FAIL = 24584,
    IRONMAN_E_SNAPSHOT_CREATE_FAIL = 28672,
    IRONMAN_E_SNAPSHOT_REMOVE_FAIL = 28673,
    IRONMAN_E_SNAPSHOT_NOTFOUND = 28674,
    IRONMAN_E_SNAPSHOT_INVALID = 28675
  };
};

extern const std::map<int, const char*> _error_codes_VALUES_TO_NAMES;

class disk_info;

class partition_info;

class volume_info;

class network_info;

class os_version_info;

class physical_client_info;

class virtual_host;

class virtual_network_adapter;

class virtual_machine_snapshots;

class virtual_disk_info;

class virtual_machine;

class invalid_operation;

class job_trigger;

class output_folder;

class create_job_detail;

class job_history;

class job_detail;

typedef struct _disk_info__isset {
  _disk_info__isset() : boot_from_disk(true), bus_type(true), cluster_owner(true), cylinders(true), friend_name(true), guid(true), tracks_per_cylinder(true), is_boot(true), is_clustered(true), is_offline(true), is_readonly(true), is_snapshot(true), is_system(true), location(true), logical_sector_size(true), manufacturer(true), model(true), number(true), number_of_partitions(true), offline_reason(true), partition_style(true), path(true), physical_sector_size(true), sectors_per_track(true), serial_number(true), signature(true), size(true), uri(true), scsi_bus(true), scsi_logical_unit(true), scsi_port(true), scsi_target_id(true) {}
  bool boot_from_disk :1;
  bool bus_type :1;
  bool cluster_owner :1;
  bool cylinders :1;
  bool friend_name :1;
  bool guid :1;
  bool tracks_per_cylinder :1;
  bool is_boot :1;
  bool is_clustered :1;
  bool is_offline :1;
  bool is_readonly :1;
  bool is_snapshot :1;
  bool is_system :1;
  bool location :1;
  bool logical_sector_size :1;
  bool manufacturer :1;
  bool model :1;
  bool number :1;
  bool number_of_partitions :1;
  bool offline_reason :1;
  bool partition_style :1;
  bool path :1;
  bool physical_sector_size :1;
  bool sectors_per_track :1;
  bool serial_number :1;
  bool signature :1;
  bool size :1;
  bool uri :1;
  bool scsi_bus :1;
  bool scsi_logical_unit :1;
  bool scsi_port :1;
  bool scsi_target_id :1;
} _disk_info__isset;

class disk_info {
 public:

  disk_info(const disk_info&);
  disk_info& operator=(const disk_info&);
  disk_info() : boot_from_disk(false), bus_type((bus_type::type)0), cluster_owner(""), cylinders(0LL), friend_name(""), guid(""), tracks_per_cylinder(0), is_boot(false), is_clustered(false), is_offline(false), is_readonly(false), is_snapshot(false), is_system(false), location(""), logical_sector_size(0), manufacturer(""), model(""), number(-1), number_of_partitions(-1), offline_reason(0), partition_style((partition_style::type)0), path(""), physical_sector_size(0), sectors_per_track(0), serial_number(""), signature(0), size(0LL), uri(""), scsi_bus(0), scsi_logical_unit(0), scsi_port(0), scsi_target_id(0) {
    bus_type = (bus_type::type)0;

    partition_style = (partition_style::type)0;

  }

  virtual ~disk_info() throw();
  bool boot_from_disk;
  bus_type::type bus_type;
  std::string cluster_owner;
  int64_t cylinders;
  std::string friend_name;
  std::string guid;
  int32_t tracks_per_cylinder;
  bool is_boot;
  bool is_clustered;
  bool is_offline;
  bool is_readonly;
  bool is_snapshot;
  bool is_system;
  std::string location;
  int32_t logical_sector_size;
  std::string manufacturer;
  std::string model;
  int32_t number;
  int32_t number_of_partitions;
  int16_t offline_reason;
  partition_style::type partition_style;
  std::string path;
  int32_t physical_sector_size;
  int32_t sectors_per_track;
  std::string serial_number;
  int32_t signature;
  int64_t size;
  std::string uri;
  int32_t scsi_bus;
  int16_t scsi_logical_unit;
  int16_t scsi_port;
  int16_t scsi_target_id;

  _disk_info__isset __isset;

  void __set_boot_from_disk(const bool val);

  void __set_bus_type(const bus_type::type val);

  void __set_cluster_owner(const std::string& val);

  void __set_cylinders(const int64_t val);

  void __set_friend_name(const std::string& val);

  void __set_guid(const std::string& val);

  void __set_tracks_per_cylinder(const int32_t val);

  void __set_is_boot(const bool val);

  void __set_is_clustered(const bool val);

  void __set_is_offline(const bool val);

  void __set_is_readonly(const bool val);

  void __set_is_snapshot(const bool val);

  void __set_is_system(const bool val);

  void __set_location(const std::string& val);

  void __set_logical_sector_size(const int32_t val);

  void __set_manufacturer(const std::string& val);

  void __set_model(const std::string& val);

  void __set_number(const int32_t val);

  void __set_number_of_partitions(const int32_t val);

  void __set_offline_reason(const int16_t val);

  void __set_partition_style(const partition_style::type val);

  void __set_path(const std::string& val);

  void __set_physical_sector_size(const int32_t val);

  void __set_sectors_per_track(const int32_t val);

  void __set_serial_number(const std::string& val);

  void __set_signature(const int32_t val);

  void __set_size(const int64_t val);

  void __set_uri(const std::string& val);

  void __set_scsi_bus(const int32_t val);

  void __set_scsi_logical_unit(const int16_t val);

  void __set_scsi_port(const int16_t val);

  void __set_scsi_target_id(const int16_t val);

  bool operator == (const disk_info & rhs) const
  {
    if (__isset.boot_from_disk != rhs.__isset.boot_from_disk)
      return false;
    else if (__isset.boot_from_disk && !(boot_from_disk == rhs.boot_from_disk))
      return false;
    if (__isset.bus_type != rhs.__isset.bus_type)
      return false;
    else if (__isset.bus_type && !(bus_type == rhs.bus_type))
      return false;
    if (__isset.cluster_owner != rhs.__isset.cluster_owner)
      return false;
    else if (__isset.cluster_owner && !(cluster_owner == rhs.cluster_owner))
      return false;
    if (__isset.cylinders != rhs.__isset.cylinders)
      return false;
    else if (__isset.cylinders && !(cylinders == rhs.cylinders))
      return false;
    if (__isset.friend_name != rhs.__isset.friend_name)
      return false;
    else if (__isset.friend_name && !(friend_name == rhs.friend_name))
      return false;
    if (__isset.guid != rhs.__isset.guid)
      return false;
    else if (__isset.guid && !(guid == rhs.guid))
      return false;
    if (__isset.tracks_per_cylinder != rhs.__isset.tracks_per_cylinder)
      return false;
    else if (__isset.tracks_per_cylinder && !(tracks_per_cylinder == rhs.tracks_per_cylinder))
      return false;
    if (__isset.is_boot != rhs.__isset.is_boot)
      return false;
    else if (__isset.is_boot && !(is_boot == rhs.is_boot))
      return false;
    if (__isset.is_clustered != rhs.__isset.is_clustered)
      return false;
    else if (__isset.is_clustered && !(is_clustered == rhs.is_clustered))
      return false;
    if (__isset.is_offline != rhs.__isset.is_offline)
      return false;
    else if (__isset.is_offline && !(is_offline == rhs.is_offline))
      return false;
    if (__isset.is_readonly != rhs.__isset.is_readonly)
      return false;
    else if (__isset.is_readonly && !(is_readonly == rhs.is_readonly))
      return false;
    if (__isset.is_snapshot != rhs.__isset.is_snapshot)
      return false;
    else if (__isset.is_snapshot && !(is_snapshot == rhs.is_snapshot))
      return false;
    if (__isset.is_system != rhs.__isset.is_system)
      return false;
    else if (__isset.is_system && !(is_system == rhs.is_system))
      return false;
    if (__isset.location != rhs.__isset.location)
      return false;
    else if (__isset.location && !(location == rhs.location))
      return false;
    if (__isset.logical_sector_size != rhs.__isset.logical_sector_size)
      return false;
    else if (__isset.logical_sector_size && !(logical_sector_size == rhs.logical_sector_size))
      return false;
    if (__isset.manufacturer != rhs.__isset.manufacturer)
      return false;
    else if (__isset.manufacturer && !(manufacturer == rhs.manufacturer))
      return false;
    if (__isset.model != rhs.__isset.model)
      return false;
    else if (__isset.model && !(model == rhs.model))
      return false;
    if (__isset.number != rhs.__isset.number)
      return false;
    else if (__isset.number && !(number == rhs.number))
      return false;
    if (__isset.number_of_partitions != rhs.__isset.number_of_partitions)
      return false;
    else if (__isset.number_of_partitions && !(number_of_partitions == rhs.number_of_partitions))
      return false;
    if (__isset.offline_reason != rhs.__isset.offline_reason)
      return false;
    else if (__isset.offline_reason && !(offline_reason == rhs.offline_reason))
      return false;
    if (__isset.partition_style != rhs.__isset.partition_style)
      return false;
    else if (__isset.partition_style && !(partition_style == rhs.partition_style))
      return false;
    if (__isset.path != rhs.__isset.path)
      return false;
    else if (__isset.path && !(path == rhs.path))
      return false;
    if (__isset.physical_sector_size != rhs.__isset.physical_sector_size)
      return false;
    else if (__isset.physical_sector_size && !(physical_sector_size == rhs.physical_sector_size))
      return false;
    if (__isset.sectors_per_track != rhs.__isset.sectors_per_track)
      return false;
    else if (__isset.sectors_per_track && !(sectors_per_track == rhs.sectors_per_track))
      return false;
    if (__isset.serial_number != rhs.__isset.serial_number)
      return false;
    else if (__isset.serial_number && !(serial_number == rhs.serial_number))
      return false;
    if (__isset.signature != rhs.__isset.signature)
      return false;
    else if (__isset.signature && !(signature == rhs.signature))
      return false;
    if (__isset.size != rhs.__isset.size)
      return false;
    else if (__isset.size && !(size == rhs.size))
      return false;
    if (__isset.uri != rhs.__isset.uri)
      return false;
    else if (__isset.uri && !(uri == rhs.uri))
      return false;
    if (__isset.scsi_bus != rhs.__isset.scsi_bus)
      return false;
    else if (__isset.scsi_bus && !(scsi_bus == rhs.scsi_bus))
      return false;
    if (__isset.scsi_logical_unit != rhs.__isset.scsi_logical_unit)
      return false;
    else if (__isset.scsi_logical_unit && !(scsi_logical_unit == rhs.scsi_logical_unit))
      return false;
    if (__isset.scsi_port != rhs.__isset.scsi_port)
      return false;
    else if (__isset.scsi_port && !(scsi_port == rhs.scsi_port))
      return false;
    if (__isset.scsi_target_id != rhs.__isset.scsi_target_id)
      return false;
    else if (__isset.scsi_target_id && !(scsi_target_id == rhs.scsi_target_id))
      return false;
    return true;
  }
  bool operator != (const disk_info &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const disk_info & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(disk_info &a, disk_info &b);

inline std::ostream& operator<<(std::ostream& out, const disk_info& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _partition_info__isset {
  _partition_info__isset() : access_paths(false), disk_number(true), drive_letter(true), gpt_type(true), guid(true), is_active(true), is_boot(true), is_hidden(true), is_offline(true), is_readonly(true), is_shadowcopy(true), is_system(true), mbr_type(true), offset(true), partition_number(true), size(true) {}
  bool access_paths :1;
  bool disk_number :1;
  bool drive_letter :1;
  bool gpt_type :1;
  bool guid :1;
  bool is_active :1;
  bool is_boot :1;
  bool is_hidden :1;
  bool is_offline :1;
  bool is_readonly :1;
  bool is_shadowcopy :1;
  bool is_system :1;
  bool mbr_type :1;
  bool offset :1;
  bool partition_number :1;
  bool size :1;
} _partition_info__isset;

class partition_info {
 public:

  partition_info(const partition_info&);
  partition_info& operator=(const partition_info&);
  partition_info() : disk_number(-1), drive_letter(""), gpt_type(""), guid(""), is_active(false), is_boot(false), is_hidden(false), is_offline(false), is_readonly(false), is_shadowcopy(false), is_system(false), mbr_type(0), offset(0LL), partition_number(-1), size(0LL) {
  }

  virtual ~partition_info() throw();
  std::set<std::string>  access_paths;
  int32_t disk_number;
  std::string drive_letter;
  std::string gpt_type;
  std::string guid;
  bool is_active;
  bool is_boot;
  bool is_hidden;
  bool is_offline;
  bool is_readonly;
  bool is_shadowcopy;
  bool is_system;
  int16_t mbr_type;
  int64_t offset;
  int32_t partition_number;
  int64_t size;

  _partition_info__isset __isset;

  void __set_access_paths(const std::set<std::string> & val);

  void __set_disk_number(const int32_t val);

  void __set_drive_letter(const std::string& val);

  void __set_gpt_type(const std::string& val);

  void __set_guid(const std::string& val);

  void __set_is_active(const bool val);

  void __set_is_boot(const bool val);

  void __set_is_hidden(const bool val);

  void __set_is_offline(const bool val);

  void __set_is_readonly(const bool val);

  void __set_is_shadowcopy(const bool val);

  void __set_is_system(const bool val);

  void __set_mbr_type(const int16_t val);

  void __set_offset(const int64_t val);

  void __set_partition_number(const int32_t val);

  void __set_size(const int64_t val);

  bool operator == (const partition_info & rhs) const
  {
    if (__isset.access_paths != rhs.__isset.access_paths)
      return false;
    else if (__isset.access_paths && !(access_paths == rhs.access_paths))
      return false;
    if (__isset.disk_number != rhs.__isset.disk_number)
      return false;
    else if (__isset.disk_number && !(disk_number == rhs.disk_number))
      return false;
    if (__isset.drive_letter != rhs.__isset.drive_letter)
      return false;
    else if (__isset.drive_letter && !(drive_letter == rhs.drive_letter))
      return false;
    if (__isset.gpt_type != rhs.__isset.gpt_type)
      return false;
    else if (__isset.gpt_type && !(gpt_type == rhs.gpt_type))
      return false;
    if (__isset.guid != rhs.__isset.guid)
      return false;
    else if (__isset.guid && !(guid == rhs.guid))
      return false;
    if (__isset.is_active != rhs.__isset.is_active)
      return false;
    else if (__isset.is_active && !(is_active == rhs.is_active))
      return false;
    if (__isset.is_boot != rhs.__isset.is_boot)
      return false;
    else if (__isset.is_boot && !(is_boot == rhs.is_boot))
      return false;
    if (__isset.is_hidden != rhs.__isset.is_hidden)
      return false;
    else if (__isset.is_hidden && !(is_hidden == rhs.is_hidden))
      return false;
    if (__isset.is_offline != rhs.__isset.is_offline)
      return false;
    else if (__isset.is_offline && !(is_offline == rhs.is_offline))
      return false;
    if (__isset.is_readonly != rhs.__isset.is_readonly)
      return false;
    else if (__isset.is_readonly && !(is_readonly == rhs.is_readonly))
      return false;
    if (__isset.is_shadowcopy != rhs.__isset.is_shadowcopy)
      return false;
    else if (__isset.is_shadowcopy && !(is_shadowcopy == rhs.is_shadowcopy))
      return false;
    if (__isset.is_system != rhs.__isset.is_system)
      return false;
    else if (__isset.is_system && !(is_system == rhs.is_system))
      return false;
    if (__isset.mbr_type != rhs.__isset.mbr_type)
      return false;
    else if (__isset.mbr_type && !(mbr_type == rhs.mbr_type))
      return false;
    if (__isset.offset != rhs.__isset.offset)
      return false;
    else if (__isset.offset && !(offset == rhs.offset))
      return false;
    if (__isset.partition_number != rhs.__isset.partition_number)
      return false;
    else if (__isset.partition_number && !(partition_number == rhs.partition_number))
      return false;
    if (__isset.size != rhs.__isset.size)
      return false;
    else if (__isset.size && !(size == rhs.size))
      return false;
    return true;
  }
  bool operator != (const partition_info &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const partition_info & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(partition_info &a, partition_info &b);

inline std::ostream& operator<<(std::ostream& out, const partition_info& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _volume_info__isset {
  _volume_info__isset() : access_paths(false), cluster_access_path(true), drive_letter(true), drive_type(true), file_system(true), file_system_catalogid(true), file_system_label(true), object_id(true), path(true), size(true), size_remaining(true) {}
  bool access_paths :1;
  bool cluster_access_path :1;
  bool drive_letter :1;
  bool drive_type :1;
  bool file_system :1;
  bool file_system_catalogid :1;
  bool file_system_label :1;
  bool object_id :1;
  bool path :1;
  bool size :1;
  bool size_remaining :1;
} _volume_info__isset;

class volume_info {
 public:

  volume_info(const volume_info&);
  volume_info& operator=(const volume_info&);
  volume_info() : cluster_access_path(""), drive_letter(""), drive_type((drive_type::type)0), file_system(""), file_system_catalogid(""), file_system_label(""), object_id(""), path(""), size(0LL), size_remaining(0LL) {
    drive_type = (drive_type::type)0;

  }

  virtual ~volume_info() throw();
  std::set<std::string>  access_paths;
  std::string cluster_access_path;
  std::string drive_letter;
  drive_type::type drive_type;
  std::string file_system;
  std::string file_system_catalogid;
  std::string file_system_label;
  std::string object_id;
  std::string path;
  int64_t size;
  int64_t size_remaining;

  _volume_info__isset __isset;

  void __set_access_paths(const std::set<std::string> & val);

  void __set_cluster_access_path(const std::string& val);

  void __set_drive_letter(const std::string& val);

  void __set_drive_type(const drive_type::type val);

  void __set_file_system(const std::string& val);

  void __set_file_system_catalogid(const std::string& val);

  void __set_file_system_label(const std::string& val);

  void __set_object_id(const std::string& val);

  void __set_path(const std::string& val);

  void __set_size(const int64_t val);

  void __set_size_remaining(const int64_t val);

  bool operator == (const volume_info & rhs) const
  {
    if (__isset.access_paths != rhs.__isset.access_paths)
      return false;
    else if (__isset.access_paths && !(access_paths == rhs.access_paths))
      return false;
    if (__isset.cluster_access_path != rhs.__isset.cluster_access_path)
      return false;
    else if (__isset.cluster_access_path && !(cluster_access_path == rhs.cluster_access_path))
      return false;
    if (__isset.drive_letter != rhs.__isset.drive_letter)
      return false;
    else if (__isset.drive_letter && !(drive_letter == rhs.drive_letter))
      return false;
    if (__isset.drive_type != rhs.__isset.drive_type)
      return false;
    else if (__isset.drive_type && !(drive_type == rhs.drive_type))
      return false;
    if (__isset.file_system != rhs.__isset.file_system)
      return false;
    else if (__isset.file_system && !(file_system == rhs.file_system))
      return false;
    if (__isset.file_system_catalogid != rhs.__isset.file_system_catalogid)
      return false;
    else if (__isset.file_system_catalogid && !(file_system_catalogid == rhs.file_system_catalogid))
      return false;
    if (__isset.file_system_label != rhs.__isset.file_system_label)
      return false;
    else if (__isset.file_system_label && !(file_system_label == rhs.file_system_label))
      return false;
    if (__isset.object_id != rhs.__isset.object_id)
      return false;
    else if (__isset.object_id && !(object_id == rhs.object_id))
      return false;
    if (__isset.path != rhs.__isset.path)
      return false;
    else if (__isset.path && !(path == rhs.path))
      return false;
    if (__isset.size != rhs.__isset.size)
      return false;
    else if (__isset.size && !(size == rhs.size))
      return false;
    if (__isset.size_remaining != rhs.__isset.size_remaining)
      return false;
    else if (__isset.size_remaining && !(size_remaining == rhs.size_remaining))
      return false;
    return true;
  }
  bool operator != (const volume_info &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const volume_info & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(volume_info &a, volume_info &b);

inline std::ostream& operator<<(std::ostream& out, const volume_info& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _network_info__isset {
  _network_info__isset() : adapter_name(true), description(true), dnss(false), gateways(false), ip_addresses(false), is_dhcp_v4(true), is_dhcp_v6(true), mac_address(true), subnet_masks(false) {}
  bool adapter_name :1;
  bool description :1;
  bool dnss :1;
  bool gateways :1;
  bool ip_addresses :1;
  bool is_dhcp_v4 :1;
  bool is_dhcp_v6 :1;
  bool mac_address :1;
  bool subnet_masks :1;
} _network_info__isset;

class network_info {
 public:

  network_info(const network_info&);
  network_info& operator=(const network_info&);
  network_info() : adapter_name(""), description(""), is_dhcp_v4(false), is_dhcp_v6(false), mac_address("") {
  }

  virtual ~network_info() throw();
  std::string adapter_name;
  std::string description;
  std::vector<std::string>  dnss;
  std::vector<std::string>  gateways;
  std::vector<std::string>  ip_addresses;
  bool is_dhcp_v4;
  bool is_dhcp_v6;
  std::string mac_address;
  std::vector<std::string>  subnet_masks;

  _network_info__isset __isset;

  void __set_adapter_name(const std::string& val);

  void __set_description(const std::string& val);

  void __set_dnss(const std::vector<std::string> & val);

  void __set_gateways(const std::vector<std::string> & val);

  void __set_ip_addresses(const std::vector<std::string> & val);

  void __set_is_dhcp_v4(const bool val);

  void __set_is_dhcp_v6(const bool val);

  void __set_mac_address(const std::string& val);

  void __set_subnet_masks(const std::vector<std::string> & val);

  bool operator == (const network_info & rhs) const
  {
    if (__isset.adapter_name != rhs.__isset.adapter_name)
      return false;
    else if (__isset.adapter_name && !(adapter_name == rhs.adapter_name))
      return false;
    if (__isset.description != rhs.__isset.description)
      return false;
    else if (__isset.description && !(description == rhs.description))
      return false;
    if (__isset.dnss != rhs.__isset.dnss)
      return false;
    else if (__isset.dnss && !(dnss == rhs.dnss))
      return false;
    if (__isset.gateways != rhs.__isset.gateways)
      return false;
    else if (__isset.gateways && !(gateways == rhs.gateways))
      return false;
    if (__isset.ip_addresses != rhs.__isset.ip_addresses)
      return false;
    else if (__isset.ip_addresses && !(ip_addresses == rhs.ip_addresses))
      return false;
    if (__isset.is_dhcp_v4 != rhs.__isset.is_dhcp_v4)
      return false;
    else if (__isset.is_dhcp_v4 && !(is_dhcp_v4 == rhs.is_dhcp_v4))
      return false;
    if (__isset.is_dhcp_v6 != rhs.__isset.is_dhcp_v6)
      return false;
    else if (__isset.is_dhcp_v6 && !(is_dhcp_v6 == rhs.is_dhcp_v6))
      return false;
    if (__isset.mac_address != rhs.__isset.mac_address)
      return false;
    else if (__isset.mac_address && !(mac_address == rhs.mac_address))
      return false;
    if (__isset.subnet_masks != rhs.__isset.subnet_masks)
      return false;
    else if (__isset.subnet_masks && !(subnet_masks == rhs.subnet_masks))
      return false;
    return true;
  }
  bool operator != (const network_info &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const network_info & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(network_info &a, network_info &b);

inline std::ostream& operator<<(std::ostream& out, const network_info& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _os_version_info__isset {
  _os_version_info__isset() : csd_version(true), build_number(true), major_version(true), minor_version(true), platform_id(true), product_type(true), servicepack_major(true), servicepack_minor(true), suite_mask(true) {}
  bool csd_version :1;
  bool build_number :1;
  bool major_version :1;
  bool minor_version :1;
  bool platform_id :1;
  bool product_type :1;
  bool servicepack_major :1;
  bool servicepack_minor :1;
  bool suite_mask :1;
} _os_version_info__isset;

class os_version_info {
 public:

  os_version_info(const os_version_info&);
  os_version_info& operator=(const os_version_info&);
  os_version_info() : csd_version(""), build_number(-1), major_version(-1), minor_version(-1), platform_id(-1), product_type(-1), servicepack_major(-1), servicepack_minor(-1), suite_mask(-1) {
  }

  virtual ~os_version_info() throw();
  std::string csd_version;
  int32_t build_number;
  int32_t major_version;
  int32_t minor_version;
  int32_t platform_id;
  int16_t product_type;
  int32_t servicepack_major;
  int32_t servicepack_minor;
  int32_t suite_mask;

  _os_version_info__isset __isset;

  void __set_csd_version(const std::string& val);

  void __set_build_number(const int32_t val);

  void __set_major_version(const int32_t val);

  void __set_minor_version(const int32_t val);

  void __set_platform_id(const int32_t val);

  void __set_product_type(const int16_t val);

  void __set_servicepack_major(const int32_t val);

  void __set_servicepack_minor(const int32_t val);

  void __set_suite_mask(const int32_t val);

  bool operator == (const os_version_info & rhs) const
  {
    if (__isset.csd_version != rhs.__isset.csd_version)
      return false;
    else if (__isset.csd_version && !(csd_version == rhs.csd_version))
      return false;
    if (__isset.build_number != rhs.__isset.build_number)
      return false;
    else if (__isset.build_number && !(build_number == rhs.build_number))
      return false;
    if (__isset.major_version != rhs.__isset.major_version)
      return false;
    else if (__isset.major_version && !(major_version == rhs.major_version))
      return false;
    if (__isset.minor_version != rhs.__isset.minor_version)
      return false;
    else if (__isset.minor_version && !(minor_version == rhs.minor_version))
      return false;
    if (__isset.platform_id != rhs.__isset.platform_id)
      return false;
    else if (__isset.platform_id && !(platform_id == rhs.platform_id))
      return false;
    if (__isset.product_type != rhs.__isset.product_type)
      return false;
    else if (__isset.product_type && !(product_type == rhs.product_type))
      return false;
    if (__isset.servicepack_major != rhs.__isset.servicepack_major)
      return false;
    else if (__isset.servicepack_major && !(servicepack_major == rhs.servicepack_major))
      return false;
    if (__isset.servicepack_minor != rhs.__isset.servicepack_minor)
      return false;
    else if (__isset.servicepack_minor && !(servicepack_minor == rhs.servicepack_minor))
      return false;
    if (__isset.suite_mask != rhs.__isset.suite_mask)
      return false;
    else if (__isset.suite_mask && !(suite_mask == rhs.suite_mask))
      return false;
    return true;
  }
  bool operator != (const os_version_info &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const os_version_info & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(os_version_info &a, os_version_info &b);

inline std::ostream& operator<<(std::ostream& out, const os_version_info& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _physical_client_info__isset {
  _physical_client_info__isset() : architecture(true), client_name(true), domain(true), hal(true), initiator_name(true), is_oem(true), logical_processors(true), manufacturer(true), os_name(true), os_type(true), os_system_info(false), physical_memory(true), processors(true), role(true), system_model(true), system_root(true), workgroup(true), os_version(false), disk_infos(false), partition_infos(false), volume_infos(false), network_infos(false), client_id(true), machine_id(true) {}
  bool architecture :1;
  bool client_name :1;
  bool domain :1;
  bool hal :1;
  bool initiator_name :1;
  bool is_oem :1;
  bool logical_processors :1;
  bool manufacturer :1;
  bool os_name :1;
  bool os_type :1;
  bool os_system_info :1;
  bool physical_memory :1;
  bool processors :1;
  bool role :1;
  bool system_model :1;
  bool system_root :1;
  bool workgroup :1;
  bool os_version :1;
  bool disk_infos :1;
  bool partition_infos :1;
  bool volume_infos :1;
  bool network_infos :1;
  bool client_id :1;
  bool machine_id :1;
} _physical_client_info__isset;

class physical_client_info {
 public:

  physical_client_info(const physical_client_info&);
  physical_client_info& operator=(const physical_client_info&);
  physical_client_info() : architecture(""), client_name(""), domain(""), hal(""), initiator_name(""), is_oem(false), logical_processors(0), manufacturer(""), os_name(""), os_type(0), os_system_info(), physical_memory(0LL), processors(0), role(0), system_model(""), system_root(""), workgroup(""), client_id(""), machine_id("") {
  }

  virtual ~physical_client_info() throw();
  std::string architecture;
  std::string client_name;
  std::string domain;
  std::string hal;
  std::string initiator_name;
  bool is_oem;
  int16_t logical_processors;
  std::string manufacturer;
  std::string os_name;
  int32_t os_type;
  std::string os_system_info;
  int64_t physical_memory;
  int16_t processors;
  int32_t role;
  std::string system_model;
  std::string system_root;
  std::string workgroup;
  os_version_info os_version;
  std::set<disk_info>  disk_infos;
  std::set<partition_info>  partition_infos;
  std::set<volume_info>  volume_infos;
  std::set<network_info>  network_infos;
  std::string client_id;
  std::string machine_id;

  _physical_client_info__isset __isset;

  void __set_architecture(const std::string& val);

  void __set_client_name(const std::string& val);

  void __set_domain(const std::string& val);

  void __set_hal(const std::string& val);

  void __set_initiator_name(const std::string& val);

  void __set_is_oem(const bool val);

  void __set_logical_processors(const int16_t val);

  void __set_manufacturer(const std::string& val);

  void __set_os_name(const std::string& val);

  void __set_os_type(const int32_t val);

  void __set_os_system_info(const std::string& val);

  void __set_physical_memory(const int64_t val);

  void __set_processors(const int16_t val);

  void __set_role(const int32_t val);

  void __set_system_model(const std::string& val);

  void __set_system_root(const std::string& val);

  void __set_workgroup(const std::string& val);

  void __set_os_version(const os_version_info& val);

  void __set_disk_infos(const std::set<disk_info> & val);

  void __set_partition_infos(const std::set<partition_info> & val);

  void __set_volume_infos(const std::set<volume_info> & val);

  void __set_network_infos(const std::set<network_info> & val);

  void __set_client_id(const std::string& val);

  void __set_machine_id(const std::string& val);

  bool operator == (const physical_client_info & rhs) const
  {
    if (__isset.architecture != rhs.__isset.architecture)
      return false;
    else if (__isset.architecture && !(architecture == rhs.architecture))
      return false;
    if (__isset.client_name != rhs.__isset.client_name)
      return false;
    else if (__isset.client_name && !(client_name == rhs.client_name))
      return false;
    if (__isset.domain != rhs.__isset.domain)
      return false;
    else if (__isset.domain && !(domain == rhs.domain))
      return false;
    if (__isset.hal != rhs.__isset.hal)
      return false;
    else if (__isset.hal && !(hal == rhs.hal))
      return false;
    if (__isset.initiator_name != rhs.__isset.initiator_name)
      return false;
    else if (__isset.initiator_name && !(initiator_name == rhs.initiator_name))
      return false;
    if (__isset.is_oem != rhs.__isset.is_oem)
      return false;
    else if (__isset.is_oem && !(is_oem == rhs.is_oem))
      return false;
    if (__isset.logical_processors != rhs.__isset.logical_processors)
      return false;
    else if (__isset.logical_processors && !(logical_processors == rhs.logical_processors))
      return false;
    if (__isset.manufacturer != rhs.__isset.manufacturer)
      return false;
    else if (__isset.manufacturer && !(manufacturer == rhs.manufacturer))
      return false;
    if (__isset.os_name != rhs.__isset.os_name)
      return false;
    else if (__isset.os_name && !(os_name == rhs.os_name))
      return false;
    if (__isset.os_type != rhs.__isset.os_type)
      return false;
    else if (__isset.os_type && !(os_type == rhs.os_type))
      return false;
    if (__isset.os_system_info != rhs.__isset.os_system_info)
      return false;
    else if (__isset.os_system_info && !(os_system_info == rhs.os_system_info))
      return false;
    if (__isset.physical_memory != rhs.__isset.physical_memory)
      return false;
    else if (__isset.physical_memory && !(physical_memory == rhs.physical_memory))
      return false;
    if (__isset.processors != rhs.__isset.processors)
      return false;
    else if (__isset.processors && !(processors == rhs.processors))
      return false;
    if (__isset.role != rhs.__isset.role)
      return false;
    else if (__isset.role && !(role == rhs.role))
      return false;
    if (__isset.system_model != rhs.__isset.system_model)
      return false;
    else if (__isset.system_model && !(system_model == rhs.system_model))
      return false;
    if (__isset.system_root != rhs.__isset.system_root)
      return false;
    else if (__isset.system_root && !(system_root == rhs.system_root))
      return false;
    if (__isset.workgroup != rhs.__isset.workgroup)
      return false;
    else if (__isset.workgroup && !(workgroup == rhs.workgroup))
      return false;
    if (__isset.os_version != rhs.__isset.os_version)
      return false;
    else if (__isset.os_version && !(os_version == rhs.os_version))
      return false;
    if (__isset.disk_infos != rhs.__isset.disk_infos)
      return false;
    else if (__isset.disk_infos && !(disk_infos == rhs.disk_infos))
      return false;
    if (__isset.partition_infos != rhs.__isset.partition_infos)
      return false;
    else if (__isset.partition_infos && !(partition_infos == rhs.partition_infos))
      return false;
    if (__isset.volume_infos != rhs.__isset.volume_infos)
      return false;
    else if (__isset.volume_infos && !(volume_infos == rhs.volume_infos))
      return false;
    if (__isset.network_infos != rhs.__isset.network_infos)
      return false;
    else if (__isset.network_infos && !(network_infos == rhs.network_infos))
      return false;
    if (__isset.client_id != rhs.__isset.client_id)
      return false;
    else if (__isset.client_id && !(client_id == rhs.client_id))
      return false;
    if (__isset.machine_id != rhs.__isset.machine_id)
      return false;
    else if (__isset.machine_id && !(machine_id == rhs.machine_id))
      return false;
    return true;
  }
  bool operator != (const physical_client_info &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const physical_client_info & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(physical_client_info &a, physical_client_info &b);

inline std::ostream& operator<<(std::ostream& out, const physical_client_info& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _virtual_host__isset {
  _virtual_host__isset() : name_ref(true), name(true), ip_addresses(true), ip_address(true), product_name(true), version(true), power_state(true), state(true), in_maintenance_mode(true), vms(false), datastores(false), networks(false), datacenter_name(true), domain_name(true), cluster_key(true), full_name(true) {}
  bool name_ref :1;
  bool name :1;
  bool ip_addresses :1;
  bool ip_address :1;
  bool product_name :1;
  bool version :1;
  bool power_state :1;
  bool state :1;
  bool in_maintenance_mode :1;
  bool vms :1;
  bool datastores :1;
  bool networks :1;
  bool datacenter_name :1;
  bool domain_name :1;
  bool cluster_key :1;
  bool full_name :1;
} _virtual_host__isset;

class virtual_host {
 public:

  virtual_host(const virtual_host&);
  virtual_host& operator=(const virtual_host&);
  virtual_host() : name_ref(""), name(""), ip_address(""), product_name(""), version(""), power_state((hv_host_power_state::type)0), state(""), in_maintenance_mode(false), datacenter_name(""), domain_name(""), cluster_key(""), full_name("") {

    power_state = (hv_host_power_state::type)0;

  }

  virtual ~virtual_host() throw();
  std::string name_ref;
  std::string name;
  std::vector<std::string>  ip_addresses;
  std::string ip_address;
  std::string product_name;
  std::string version;
  hv_host_power_state::type power_state;
  std::string state;
  bool in_maintenance_mode;
  std::map<std::string, std::string>  vms;
  std::map<std::string, std::string>  datastores;
  std::map<std::string, std::string>  networks;
  std::string datacenter_name;
  std::string domain_name;
  std::string cluster_key;
  std::string full_name;

  _virtual_host__isset __isset;

  void __set_name_ref(const std::string& val);

  void __set_name(const std::string& val);

  void __set_ip_addresses(const std::vector<std::string> & val);

  void __set_ip_address(const std::string& val);

  void __set_product_name(const std::string& val);

  void __set_version(const std::string& val);

  void __set_power_state(const hv_host_power_state::type val);

  void __set_state(const std::string& val);

  void __set_in_maintenance_mode(const bool val);

  void __set_vms(const std::map<std::string, std::string> & val);

  void __set_datastores(const std::map<std::string, std::string> & val);

  void __set_networks(const std::map<std::string, std::string> & val);

  void __set_datacenter_name(const std::string& val);

  void __set_domain_name(const std::string& val);

  void __set_cluster_key(const std::string& val);

  void __set_full_name(const std::string& val);

  bool operator == (const virtual_host & rhs) const
  {
    if (__isset.name_ref != rhs.__isset.name_ref)
      return false;
    else if (__isset.name_ref && !(name_ref == rhs.name_ref))
      return false;
    if (__isset.name != rhs.__isset.name)
      return false;
    else if (__isset.name && !(name == rhs.name))
      return false;
    if (__isset.ip_addresses != rhs.__isset.ip_addresses)
      return false;
    else if (__isset.ip_addresses && !(ip_addresses == rhs.ip_addresses))
      return false;
    if (__isset.ip_address != rhs.__isset.ip_address)
      return false;
    else if (__isset.ip_address && !(ip_address == rhs.ip_address))
      return false;
    if (__isset.product_name != rhs.__isset.product_name)
      return false;
    else if (__isset.product_name && !(product_name == rhs.product_name))
      return false;
    if (__isset.version != rhs.__isset.version)
      return false;
    else if (__isset.version && !(version == rhs.version))
      return false;
    if (__isset.power_state != rhs.__isset.power_state)
      return false;
    else if (__isset.power_state && !(power_state == rhs.power_state))
      return false;
    if (__isset.state != rhs.__isset.state)
      return false;
    else if (__isset.state && !(state == rhs.state))
      return false;
    if (__isset.in_maintenance_mode != rhs.__isset.in_maintenance_mode)
      return false;
    else if (__isset.in_maintenance_mode && !(in_maintenance_mode == rhs.in_maintenance_mode))
      return false;
    if (__isset.vms != rhs.__isset.vms)
      return false;
    else if (__isset.vms && !(vms == rhs.vms))
      return false;
    if (__isset.datastores != rhs.__isset.datastores)
      return false;
    else if (__isset.datastores && !(datastores == rhs.datastores))
      return false;
    if (__isset.networks != rhs.__isset.networks)
      return false;
    else if (__isset.networks && !(networks == rhs.networks))
      return false;
    if (__isset.datacenter_name != rhs.__isset.datacenter_name)
      return false;
    else if (__isset.datacenter_name && !(datacenter_name == rhs.datacenter_name))
      return false;
    if (__isset.domain_name != rhs.__isset.domain_name)
      return false;
    else if (__isset.domain_name && !(domain_name == rhs.domain_name))
      return false;
    if (__isset.cluster_key != rhs.__isset.cluster_key)
      return false;
    else if (__isset.cluster_key && !(cluster_key == rhs.cluster_key))
      return false;
    if (__isset.full_name != rhs.__isset.full_name)
      return false;
    else if (__isset.full_name && !(full_name == rhs.full_name))
      return false;
    return true;
  }
  bool operator != (const virtual_host &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const virtual_host & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(virtual_host &a, virtual_host &b);

inline std::ostream& operator<<(std::ostream& out, const virtual_host& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _virtual_network_adapter__isset {
  _virtual_network_adapter__isset() : key(true), name(true), mac_address(true), network(true), port_group(true), type(true), is_connected(true), is_start_connected(true), is_allow_guest_control(true), address_type(true) {}
  bool key :1;
  bool name :1;
  bool mac_address :1;
  bool network :1;
  bool port_group :1;
  bool type :1;
  bool is_connected :1;
  bool is_start_connected :1;
  bool is_allow_guest_control :1;
  bool address_type :1;
} _virtual_network_adapter__isset;

class virtual_network_adapter {
 public:

  virtual_network_adapter(const virtual_network_adapter&);
  virtual_network_adapter& operator=(const virtual_network_adapter&);
  virtual_network_adapter() : key(0), name(""), mac_address(""), network(""), port_group(""), type(""), is_connected(false), is_start_connected(false), is_allow_guest_control(false), address_type("") {
  }

  virtual ~virtual_network_adapter() throw();
  int32_t key;
  std::string name;
  std::string mac_address;
  std::string network;
  std::string port_group;
  std::string type;
  bool is_connected;
  bool is_start_connected;
  bool is_allow_guest_control;
  std::string address_type;

  _virtual_network_adapter__isset __isset;

  void __set_key(const int32_t val);

  void __set_name(const std::string& val);

  void __set_mac_address(const std::string& val);

  void __set_network(const std::string& val);

  void __set_port_group(const std::string& val);

  void __set_type(const std::string& val);

  void __set_is_connected(const bool val);

  void __set_is_start_connected(const bool val);

  void __set_is_allow_guest_control(const bool val);

  void __set_address_type(const std::string& val);

  bool operator == (const virtual_network_adapter & rhs) const
  {
    if (__isset.key != rhs.__isset.key)
      return false;
    else if (__isset.key && !(key == rhs.key))
      return false;
    if (__isset.name != rhs.__isset.name)
      return false;
    else if (__isset.name && !(name == rhs.name))
      return false;
    if (__isset.mac_address != rhs.__isset.mac_address)
      return false;
    else if (__isset.mac_address && !(mac_address == rhs.mac_address))
      return false;
    if (__isset.network != rhs.__isset.network)
      return false;
    else if (__isset.network && !(network == rhs.network))
      return false;
    if (__isset.port_group != rhs.__isset.port_group)
      return false;
    else if (__isset.port_group && !(port_group == rhs.port_group))
      return false;
    if (__isset.type != rhs.__isset.type)
      return false;
    else if (__isset.type && !(type == rhs.type))
      return false;
    if (__isset.is_connected != rhs.__isset.is_connected)
      return false;
    else if (__isset.is_connected && !(is_connected == rhs.is_connected))
      return false;
    if (__isset.is_start_connected != rhs.__isset.is_start_connected)
      return false;
    else if (__isset.is_start_connected && !(is_start_connected == rhs.is_start_connected))
      return false;
    if (__isset.is_allow_guest_control != rhs.__isset.is_allow_guest_control)
      return false;
    else if (__isset.is_allow_guest_control && !(is_allow_guest_control == rhs.is_allow_guest_control))
      return false;
    if (__isset.address_type != rhs.__isset.address_type)
      return false;
    else if (__isset.address_type && !(address_type == rhs.address_type))
      return false;
    return true;
  }
  bool operator != (const virtual_network_adapter &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const virtual_network_adapter & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(virtual_network_adapter &a, virtual_network_adapter &b);

inline std::ostream& operator<<(std::ostream& out, const virtual_network_adapter& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _virtual_machine_snapshots__isset {
  _virtual_machine_snapshots__isset() : name(true), description(true), create_time(true), quiesced(true), id(true), backup_manifest(true), replay_supported(true), child_snapshot_list(false) {}
  bool name :1;
  bool description :1;
  bool create_time :1;
  bool quiesced :1;
  bool id :1;
  bool backup_manifest :1;
  bool replay_supported :1;
  bool child_snapshot_list :1;
} _virtual_machine_snapshots__isset;

class virtual_machine_snapshots {
 public:

  virtual_machine_snapshots(const virtual_machine_snapshots&);
  virtual_machine_snapshots& operator=(const virtual_machine_snapshots&);
  virtual_machine_snapshots() : name(""), description(""), create_time(""), quiesced(false), id(-1), backup_manifest(""), replay_supported(false) {
  }

  virtual ~virtual_machine_snapshots() throw();
  std::string name;
  std::string description;
  std::string create_time;
  bool quiesced;
  int32_t id;
  std::string backup_manifest;
  bool replay_supported;
  std::vector<virtual_machine_snapshots>  child_snapshot_list;

  _virtual_machine_snapshots__isset __isset;

  void __set_name(const std::string& val);

  void __set_description(const std::string& val);

  void __set_create_time(const std::string& val);

  void __set_quiesced(const bool val);

  void __set_id(const int32_t val);

  void __set_backup_manifest(const std::string& val);

  void __set_replay_supported(const bool val);

  void __set_child_snapshot_list(const std::vector<virtual_machine_snapshots> & val);

  bool operator == (const virtual_machine_snapshots & rhs) const
  {
    if (__isset.name != rhs.__isset.name)
      return false;
    else if (__isset.name && !(name == rhs.name))
      return false;
    if (__isset.description != rhs.__isset.description)
      return false;
    else if (__isset.description && !(description == rhs.description))
      return false;
    if (__isset.create_time != rhs.__isset.create_time)
      return false;
    else if (__isset.create_time && !(create_time == rhs.create_time))
      return false;
    if (__isset.quiesced != rhs.__isset.quiesced)
      return false;
    else if (__isset.quiesced && !(quiesced == rhs.quiesced))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.backup_manifest != rhs.__isset.backup_manifest)
      return false;
    else if (__isset.backup_manifest && !(backup_manifest == rhs.backup_manifest))
      return false;
    if (__isset.replay_supported != rhs.__isset.replay_supported)
      return false;
    else if (__isset.replay_supported && !(replay_supported == rhs.replay_supported))
      return false;
    if (__isset.child_snapshot_list != rhs.__isset.child_snapshot_list)
      return false;
    else if (__isset.child_snapshot_list && !(child_snapshot_list == rhs.child_snapshot_list))
      return false;
    return true;
  }
  bool operator != (const virtual_machine_snapshots &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const virtual_machine_snapshots & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(virtual_machine_snapshots &a, virtual_machine_snapshots &b);

inline std::ostream& operator<<(std::ostream& out, const virtual_machine_snapshots& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _virtual_disk_info__isset {
  _virtual_disk_info__isset() : key(true), name(true), size_kb(true) {}
  bool key :1;
  bool name :1;
  bool size_kb :1;
} _virtual_disk_info__isset;

class virtual_disk_info {
 public:

  virtual_disk_info(const virtual_disk_info&);
  virtual_disk_info& operator=(const virtual_disk_info&);
  virtual_disk_info() : key(""), name(""), size_kb(0LL) {
  }

  virtual ~virtual_disk_info() throw();
  std::string key;
  std::string name;
  int64_t size_kb;

  _virtual_disk_info__isset __isset;

  void __set_key(const std::string& val);

  void __set_name(const std::string& val);

  void __set_size_kb(const int64_t val);

  bool operator == (const virtual_disk_info & rhs) const
  {
    if (__isset.key != rhs.__isset.key)
      return false;
    else if (__isset.key && !(key == rhs.key))
      return false;
    if (__isset.name != rhs.__isset.name)
      return false;
    else if (__isset.name && !(name == rhs.name))
      return false;
    if (__isset.size_kb != rhs.__isset.size_kb)
      return false;
    else if (__isset.size_kb && !(size_kb == rhs.size_kb))
      return false;
    return true;
  }
  bool operator != (const virtual_disk_info &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const virtual_disk_info & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(virtual_disk_info &a, virtual_disk_info &b);

inline std::ostream& operator<<(std::ostream& out, const virtual_disk_info& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _virtual_machine__isset {
  _virtual_machine__isset() : uuid(true), name(true), host_key(true), host_ip(true), host_name(true), cluster_key(true), cluster_name(true), annotation(true), is_cpu_hot_add(true), is_cpu_hot_remove(true), memory_mb(true), number_of_cpu(true), is_template(true), config_path(true), config_path_file(true), version(true), power_state(true), connection_state(true), tools_status(true), firmware(true), guest_os_type(true), guest_id(true), guest_full_name(true), is_disk_uuid_enabled(true), folder_path(true), resource_pool_path(true), disks(false), networks(false), datacenter_name(true), network_adapters(false), root_snapshot_list(false) {}
  bool uuid :1;
  bool name :1;
  bool host_key :1;
  bool host_ip :1;
  bool host_name :1;
  bool cluster_key :1;
  bool cluster_name :1;
  bool annotation :1;
  bool is_cpu_hot_add :1;
  bool is_cpu_hot_remove :1;
  bool memory_mb :1;
  bool number_of_cpu :1;
  bool is_template :1;
  bool config_path :1;
  bool config_path_file :1;
  bool version :1;
  bool power_state :1;
  bool connection_state :1;
  bool tools_status :1;
  bool firmware :1;
  bool guest_os_type :1;
  bool guest_id :1;
  bool guest_full_name :1;
  bool is_disk_uuid_enabled :1;
  bool folder_path :1;
  bool resource_pool_path :1;
  bool disks :1;
  bool networks :1;
  bool datacenter_name :1;
  bool network_adapters :1;
  bool root_snapshot_list :1;
} _virtual_machine__isset;

class virtual_machine {
 public:

  virtual_machine(const virtual_machine&);
  virtual_machine& operator=(const virtual_machine&);
  virtual_machine() : uuid(""), name(""), host_key(""), host_ip(""), host_name(""), cluster_key(""), cluster_name(""), annotation(""), is_cpu_hot_add(false), is_cpu_hot_remove(false), memory_mb(0), number_of_cpu(0), is_template(false), config_path(""), config_path_file(""), version(0), power_state((hv_vm_power_state::type)0), connection_state((hv_vm_connection_state::type)0), tools_status((hv_vm_tools_status::type)0), firmware((hv_vm_firmware::type)0), guest_os_type((hv_guest_os_type::type)0), guest_id(""), guest_full_name(""), is_disk_uuid_enabled(false), folder_path(""), resource_pool_path(""), datacenter_name("") {
    power_state = (hv_vm_power_state::type)0;

    connection_state = (hv_vm_connection_state::type)0;

    tools_status = (hv_vm_tools_status::type)0;

    firmware = (hv_vm_firmware::type)0;

    guest_os_type = (hv_guest_os_type::type)0;

  }

  virtual ~virtual_machine() throw();
  std::string uuid;
  std::string name;
  std::string host_key;
  std::string host_ip;
  std::string host_name;
  std::string cluster_key;
  std::string cluster_name;
  std::string annotation;
  bool is_cpu_hot_add;
  bool is_cpu_hot_remove;
  int32_t memory_mb;
  int32_t number_of_cpu;
  bool is_template;
  std::string config_path;
  std::string config_path_file;
  int32_t version;
  hv_vm_power_state::type power_state;
  hv_vm_connection_state::type connection_state;
  hv_vm_tools_status::type tools_status;
  hv_vm_firmware::type firmware;
  hv_guest_os_type::type guest_os_type;
  std::string guest_id;
  std::string guest_full_name;
  bool is_disk_uuid_enabled;
  std::string folder_path;
  std::string resource_pool_path;
  std::vector<virtual_disk_info>  disks;
  std::map<std::string, std::string>  networks;
  std::string datacenter_name;
  std::vector<virtual_network_adapter>  network_adapters;
  std::vector<virtual_machine_snapshots>  root_snapshot_list;

  _virtual_machine__isset __isset;

  void __set_uuid(const std::string& val);

  void __set_name(const std::string& val);

  void __set_host_key(const std::string& val);

  void __set_host_ip(const std::string& val);

  void __set_host_name(const std::string& val);

  void __set_cluster_key(const std::string& val);

  void __set_cluster_name(const std::string& val);

  void __set_annotation(const std::string& val);

  void __set_is_cpu_hot_add(const bool val);

  void __set_is_cpu_hot_remove(const bool val);

  void __set_memory_mb(const int32_t val);

  void __set_number_of_cpu(const int32_t val);

  void __set_is_template(const bool val);

  void __set_config_path(const std::string& val);

  void __set_config_path_file(const std::string& val);

  void __set_version(const int32_t val);

  void __set_power_state(const hv_vm_power_state::type val);

  void __set_connection_state(const hv_vm_connection_state::type val);

  void __set_tools_status(const hv_vm_tools_status::type val);

  void __set_firmware(const hv_vm_firmware::type val);

  void __set_guest_os_type(const hv_guest_os_type::type val);

  void __set_guest_id(const std::string& val);

  void __set_guest_full_name(const std::string& val);

  void __set_is_disk_uuid_enabled(const bool val);

  void __set_folder_path(const std::string& val);

  void __set_resource_pool_path(const std::string& val);

  void __set_disks(const std::vector<virtual_disk_info> & val);

  void __set_networks(const std::map<std::string, std::string> & val);

  void __set_datacenter_name(const std::string& val);

  void __set_network_adapters(const std::vector<virtual_network_adapter> & val);

  void __set_root_snapshot_list(const std::vector<virtual_machine_snapshots> & val);

  bool operator == (const virtual_machine & rhs) const
  {
    if (__isset.uuid != rhs.__isset.uuid)
      return false;
    else if (__isset.uuid && !(uuid == rhs.uuid))
      return false;
    if (__isset.name != rhs.__isset.name)
      return false;
    else if (__isset.name && !(name == rhs.name))
      return false;
    if (__isset.host_key != rhs.__isset.host_key)
      return false;
    else if (__isset.host_key && !(host_key == rhs.host_key))
      return false;
    if (__isset.host_ip != rhs.__isset.host_ip)
      return false;
    else if (__isset.host_ip && !(host_ip == rhs.host_ip))
      return false;
    if (__isset.host_name != rhs.__isset.host_name)
      return false;
    else if (__isset.host_name && !(host_name == rhs.host_name))
      return false;
    if (__isset.cluster_key != rhs.__isset.cluster_key)
      return false;
    else if (__isset.cluster_key && !(cluster_key == rhs.cluster_key))
      return false;
    if (__isset.cluster_name != rhs.__isset.cluster_name)
      return false;
    else if (__isset.cluster_name && !(cluster_name == rhs.cluster_name))
      return false;
    if (__isset.annotation != rhs.__isset.annotation)
      return false;
    else if (__isset.annotation && !(annotation == rhs.annotation))
      return false;
    if (__isset.is_cpu_hot_add != rhs.__isset.is_cpu_hot_add)
      return false;
    else if (__isset.is_cpu_hot_add && !(is_cpu_hot_add == rhs.is_cpu_hot_add))
      return false;
    if (__isset.is_cpu_hot_remove != rhs.__isset.is_cpu_hot_remove)
      return false;
    else if (__isset.is_cpu_hot_remove && !(is_cpu_hot_remove == rhs.is_cpu_hot_remove))
      return false;
    if (__isset.memory_mb != rhs.__isset.memory_mb)
      return false;
    else if (__isset.memory_mb && !(memory_mb == rhs.memory_mb))
      return false;
    if (__isset.number_of_cpu != rhs.__isset.number_of_cpu)
      return false;
    else if (__isset.number_of_cpu && !(number_of_cpu == rhs.number_of_cpu))
      return false;
    if (__isset.is_template != rhs.__isset.is_template)
      return false;
    else if (__isset.is_template && !(is_template == rhs.is_template))
      return false;
    if (__isset.config_path != rhs.__isset.config_path)
      return false;
    else if (__isset.config_path && !(config_path == rhs.config_path))
      return false;
    if (__isset.config_path_file != rhs.__isset.config_path_file)
      return false;
    else if (__isset.config_path_file && !(config_path_file == rhs.config_path_file))
      return false;
    if (__isset.version != rhs.__isset.version)
      return false;
    else if (__isset.version && !(version == rhs.version))
      return false;
    if (__isset.power_state != rhs.__isset.power_state)
      return false;
    else if (__isset.power_state && !(power_state == rhs.power_state))
      return false;
    if (__isset.connection_state != rhs.__isset.connection_state)
      return false;
    else if (__isset.connection_state && !(connection_state == rhs.connection_state))
      return false;
    if (__isset.tools_status != rhs.__isset.tools_status)
      return false;
    else if (__isset.tools_status && !(tools_status == rhs.tools_status))
      return false;
    if (__isset.firmware != rhs.__isset.firmware)
      return false;
    else if (__isset.firmware && !(firmware == rhs.firmware))
      return false;
    if (__isset.guest_os_type != rhs.__isset.guest_os_type)
      return false;
    else if (__isset.guest_os_type && !(guest_os_type == rhs.guest_os_type))
      return false;
    if (__isset.guest_id != rhs.__isset.guest_id)
      return false;
    else if (__isset.guest_id && !(guest_id == rhs.guest_id))
      return false;
    if (__isset.guest_full_name != rhs.__isset.guest_full_name)
      return false;
    else if (__isset.guest_full_name && !(guest_full_name == rhs.guest_full_name))
      return false;
    if (__isset.is_disk_uuid_enabled != rhs.__isset.is_disk_uuid_enabled)
      return false;
    else if (__isset.is_disk_uuid_enabled && !(is_disk_uuid_enabled == rhs.is_disk_uuid_enabled))
      return false;
    if (__isset.folder_path != rhs.__isset.folder_path)
      return false;
    else if (__isset.folder_path && !(folder_path == rhs.folder_path))
      return false;
    if (__isset.resource_pool_path != rhs.__isset.resource_pool_path)
      return false;
    else if (__isset.resource_pool_path && !(resource_pool_path == rhs.resource_pool_path))
      return false;
    if (__isset.disks != rhs.__isset.disks)
      return false;
    else if (__isset.disks && !(disks == rhs.disks))
      return false;
    if (__isset.networks != rhs.__isset.networks)
      return false;
    else if (__isset.networks && !(networks == rhs.networks))
      return false;
    if (__isset.datacenter_name != rhs.__isset.datacenter_name)
      return false;
    else if (__isset.datacenter_name && !(datacenter_name == rhs.datacenter_name))
      return false;
    if (__isset.network_adapters != rhs.__isset.network_adapters)
      return false;
    else if (__isset.network_adapters && !(network_adapters == rhs.network_adapters))
      return false;
    if (__isset.root_snapshot_list != rhs.__isset.root_snapshot_list)
      return false;
    else if (__isset.root_snapshot_list && !(root_snapshot_list == rhs.root_snapshot_list))
      return false;
    return true;
  }
  bool operator != (const virtual_machine &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const virtual_machine & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(virtual_machine &a, virtual_machine &b);

inline std::ostream& operator<<(std::ostream& out, const virtual_machine& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _invalid_operation__isset {
  _invalid_operation__isset() : what_op(false), why(false) {}
  bool what_op :1;
  bool why :1;
} _invalid_operation__isset;

class invalid_operation : public ::apache::thrift::TException {
 public:

  invalid_operation(const invalid_operation&);
  invalid_operation& operator=(const invalid_operation&);
  invalid_operation() : what_op(0), why() {
  }

  virtual ~invalid_operation() throw();
  int32_t what_op;
  std::string why;

  _invalid_operation__isset __isset;

  void __set_what_op(const int32_t val);

  void __set_why(const std::string& val);

  bool operator == (const invalid_operation & rhs) const
  {
    if (!(what_op == rhs.what_op))
      return false;
    if (!(why == rhs.why))
      return false;
    return true;
  }
  bool operator != (const invalid_operation &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const invalid_operation & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(invalid_operation &a, invalid_operation &b);

inline std::ostream& operator<<(std::ostream& out, const invalid_operation& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _job_trigger__isset {
  _job_trigger__isset() : start(true), interval(true) {}
  bool start :1;
  bool interval :1;
} _job_trigger__isset;

class job_trigger {
 public:

  job_trigger(const job_trigger&);
  job_trigger& operator=(const job_trigger&);
  job_trigger() : start(""), interval(15) {
  }

  virtual ~job_trigger() throw();
  std::string start;
  int32_t interval;

  _job_trigger__isset __isset;

  void __set_start(const std::string& val);

  void __set_interval(const int32_t val);

  bool operator == (const job_trigger & rhs) const
  {
    if (__isset.start != rhs.__isset.start)
      return false;
    else if (__isset.start && !(start == rhs.start))
      return false;
    if (__isset.interval != rhs.__isset.interval)
      return false;
    else if (__isset.interval && !(interval == rhs.interval))
      return false;
    return true;
  }
  bool operator != (const job_trigger &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const job_trigger & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(job_trigger &a, job_trigger &b);

inline std::ostream& operator<<(std::ostream& out, const job_trigger& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _output_folder__isset {
  _output_folder__isset() : folder(true), username(true), password(true) {}
  bool folder :1;
  bool username :1;
  bool password :1;
} _output_folder__isset;

class output_folder {
 public:

  output_folder(const output_folder&);
  output_folder& operator=(const output_folder&);
  output_folder() : folder(""), username(""), password("") {
  }

  virtual ~output_folder() throw();
  std::string folder;
  std::string username;
  std::string password;

  _output_folder__isset __isset;

  void __set_folder(const std::string& val);

  void __set_username(const std::string& val);

  void __set_password(const std::string& val);

  bool operator == (const output_folder & rhs) const
  {
    if (__isset.folder != rhs.__isset.folder)
      return false;
    else if (__isset.folder && !(folder == rhs.folder))
      return false;
    if (__isset.username != rhs.__isset.username)
      return false;
    else if (__isset.username && !(username == rhs.username))
      return false;
    if (__isset.password != rhs.__isset.password)
      return false;
    else if (__isset.password && !(password == rhs.password))
      return false;
    return true;
  }
  bool operator != (const output_folder &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const output_folder & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(output_folder &a, output_folder &b);

inline std::ostream& operator<<(std::ostream& out, const output_folder& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _create_job_detail__isset {
  _create_job_detail__isset() : host(true), username(true), password(true), type(false), select_all(true), disks(false), virtual_machine_id(true), vdisks(false), output(false), display_name(true), triggers(false), url(true), post(true) {}
  bool host :1;
  bool username :1;
  bool password :1;
  bool type :1;
  bool select_all :1;
  bool disks :1;
  bool virtual_machine_id :1;
  bool vdisks :1;
  bool output :1;
  bool display_name :1;
  bool triggers :1;
  bool url :1;
  bool post :1;
} _create_job_detail__isset;

class create_job_detail {
 public:

  create_job_detail(const create_job_detail&);
  create_job_detail& operator=(const create_job_detail&);
  create_job_detail() : host(""), username(""), password(""), type((job_type::type)0), select_all(false), virtual_machine_id(""), display_name(""), url(""), post("") {
  }

  virtual ~create_job_detail() throw();
  std::string host;
  std::string username;
  std::string password;
  job_type::type type;
  bool select_all;
  std::set<int32_t>  disks;
  std::string virtual_machine_id;
  std::set<std::string>  vdisks;
  output_folder output;
  std::string display_name;
  std::vector<job_trigger>  triggers;
  std::string url;
  std::string post;

  _create_job_detail__isset __isset;

  void __set_host(const std::string& val);

  void __set_username(const std::string& val);

  void __set_password(const std::string& val);

  void __set_type(const job_type::type val);

  void __set_select_all(const bool val);

  void __set_disks(const std::set<int32_t> & val);

  void __set_virtual_machine_id(const std::string& val);

  void __set_vdisks(const std::set<std::string> & val);

  void __set_output(const output_folder& val);

  void __set_display_name(const std::string& val);

  void __set_triggers(const std::vector<job_trigger> & val);

  void __set_url(const std::string& val);

  void __set_post(const std::string& val);

  bool operator == (const create_job_detail & rhs) const
  {
    if (__isset.host != rhs.__isset.host)
      return false;
    else if (__isset.host && !(host == rhs.host))
      return false;
    if (__isset.username != rhs.__isset.username)
      return false;
    else if (__isset.username && !(username == rhs.username))
      return false;
    if (__isset.password != rhs.__isset.password)
      return false;
    else if (__isset.password && !(password == rhs.password))
      return false;
    if (__isset.type != rhs.__isset.type)
      return false;
    else if (__isset.type && !(type == rhs.type))
      return false;
    if (__isset.select_all != rhs.__isset.select_all)
      return false;
    else if (__isset.select_all && !(select_all == rhs.select_all))
      return false;
    if (__isset.disks != rhs.__isset.disks)
      return false;
    else if (__isset.disks && !(disks == rhs.disks))
      return false;
    if (__isset.virtual_machine_id != rhs.__isset.virtual_machine_id)
      return false;
    else if (__isset.virtual_machine_id && !(virtual_machine_id == rhs.virtual_machine_id))
      return false;
    if (__isset.vdisks != rhs.__isset.vdisks)
      return false;
    else if (__isset.vdisks && !(vdisks == rhs.vdisks))
      return false;
    if (__isset.output != rhs.__isset.output)
      return false;
    else if (__isset.output && !(output == rhs.output))
      return false;
    if (__isset.display_name != rhs.__isset.display_name)
      return false;
    else if (__isset.display_name && !(display_name == rhs.display_name))
      return false;
    if (__isset.triggers != rhs.__isset.triggers)
      return false;
    else if (__isset.triggers && !(triggers == rhs.triggers))
      return false;
    if (__isset.url != rhs.__isset.url)
      return false;
    else if (__isset.url && !(url == rhs.url))
      return false;
    if (__isset.post != rhs.__isset.post)
      return false;
    else if (__isset.post && !(post == rhs.post))
      return false;
    return true;
  }
  bool operator != (const create_job_detail &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const create_job_detail & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(create_job_detail &a, create_job_detail &b);

inline std::ostream& operator<<(std::ostream& out, const create_job_detail& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _job_history__isset {
  _job_history__isset() : time(true), state(true), error(true), description(true) {}
  bool time :1;
  bool state :1;
  bool error :1;
  bool description :1;
} _job_history__isset;

class job_history {
 public:

  job_history(const job_history&);
  job_history& operator=(const job_history&);
  job_history() : time(""), state((job_state::type)1), error(0), description("") {
    state = (job_state::type)1;

  }

  virtual ~job_history() throw();
  std::string time;
  job_state::type state;
  int32_t error;
  std::string description;

  _job_history__isset __isset;

  void __set_time(const std::string& val);

  void __set_state(const job_state::type val);

  void __set_error(const int32_t val);

  void __set_description(const std::string& val);

  bool operator == (const job_history & rhs) const
  {
    if (__isset.time != rhs.__isset.time)
      return false;
    else if (__isset.time && !(time == rhs.time))
      return false;
    if (__isset.state != rhs.__isset.state)
      return false;
    else if (__isset.state && !(state == rhs.state))
      return false;
    if (__isset.error != rhs.__isset.error)
      return false;
    else if (__isset.error && !(error == rhs.error))
      return false;
    if (__isset.description != rhs.__isset.description)
      return false;
    else if (__isset.description && !(description == rhs.description))
      return false;
    return true;
  }
  bool operator != (const job_history &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const job_history & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(job_history &a, job_history &b);

inline std::ostream& operator<<(std::ostream& out, const job_history& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _job_detail__isset {
  _job_detail__isset() : id(true), host(true), username(true), password(true), type(false), disks(false), virtual_machine_id(true), vdisks(false), output(false), state(true), original_size(false), backup_progress(false), output_files(false), what(true), why(true), created_time(true), created_time_ll(true), display_name(true), triggers(false), histories(false), url(true), post(true) {}
  bool id :1;
  bool host :1;
  bool username :1;
  bool password :1;
  bool type :1;
  bool disks :1;
  bool virtual_machine_id :1;
  bool vdisks :1;
  bool output :1;
  bool state :1;
  bool original_size :1;
  bool backup_progress :1;
  bool output_files :1;
  bool what :1;
  bool why :1;
  bool created_time :1;
  bool created_time_ll :1;
  bool display_name :1;
  bool triggers :1;
  bool histories :1;
  bool url :1;
  bool post :1;
} _job_detail__isset;

class job_detail {
 public:

  job_detail(const job_detail&);
  job_detail& operator=(const job_detail&);
  job_detail() : id(""), host(""), username(""), password(""), type((job_type::type)0), virtual_machine_id(""), state((job_state::type)1), what(0), why(""), created_time(""), created_time_ll(0LL), display_name(""), url(""), post("") {
    state = (job_state::type)1;

  }

  virtual ~job_detail() throw();
  std::string id;
  std::string host;
  std::string username;
  std::string password;
  job_type::type type;
  std::set<int32_t>  disks;
  std::string virtual_machine_id;
  std::set<std::string>  vdisks;
  output_folder output;
  job_state::type state;
  std::map<std::string, int64_t>  original_size;
  std::map<std::string, int64_t>  backup_progress;
  std::map<std::string, std::string>  output_files;
  int32_t what;
  std::string why;
  std::string created_time;
  int64_t created_time_ll;
  std::string display_name;
  std::vector<job_trigger>  triggers;
  std::vector<job_history>  histories;
  std::string url;
  std::string post;

  _job_detail__isset __isset;

  void __set_id(const std::string& val);

  void __set_host(const std::string& val);

  void __set_username(const std::string& val);

  void __set_password(const std::string& val);

  void __set_type(const job_type::type val);

  void __set_disks(const std::set<int32_t> & val);

  void __set_virtual_machine_id(const std::string& val);

  void __set_vdisks(const std::set<std::string> & val);

  void __set_output(const output_folder& val);

  void __set_state(const job_state::type val);

  void __set_original_size(const std::map<std::string, int64_t> & val);

  void __set_backup_progress(const std::map<std::string, int64_t> & val);

  void __set_output_files(const std::map<std::string, std::string> & val);

  void __set_what(const int32_t val);

  void __set_why(const std::string& val);

  void __set_created_time(const std::string& val);

  void __set_created_time_ll(const int64_t val);

  void __set_display_name(const std::string& val);

  void __set_triggers(const std::vector<job_trigger> & val);

  void __set_histories(const std::vector<job_history> & val);

  void __set_url(const std::string& val);

  void __set_post(const std::string& val);

  bool operator == (const job_detail & rhs) const
  {
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.host != rhs.__isset.host)
      return false;
    else if (__isset.host && !(host == rhs.host))
      return false;
    if (__isset.username != rhs.__isset.username)
      return false;
    else if (__isset.username && !(username == rhs.username))
      return false;
    if (__isset.password != rhs.__isset.password)
      return false;
    else if (__isset.password && !(password == rhs.password))
      return false;
    if (__isset.type != rhs.__isset.type)
      return false;
    else if (__isset.type && !(type == rhs.type))
      return false;
    if (__isset.disks != rhs.__isset.disks)
      return false;
    else if (__isset.disks && !(disks == rhs.disks))
      return false;
    if (__isset.virtual_machine_id != rhs.__isset.virtual_machine_id)
      return false;
    else if (__isset.virtual_machine_id && !(virtual_machine_id == rhs.virtual_machine_id))
      return false;
    if (__isset.vdisks != rhs.__isset.vdisks)
      return false;
    else if (__isset.vdisks && !(vdisks == rhs.vdisks))
      return false;
    if (__isset.output != rhs.__isset.output)
      return false;
    else if (__isset.output && !(output == rhs.output))
      return false;
    if (__isset.state != rhs.__isset.state)
      return false;
    else if (__isset.state && !(state == rhs.state))
      return false;
    if (__isset.original_size != rhs.__isset.original_size)
      return false;
    else if (__isset.original_size && !(original_size == rhs.original_size))
      return false;
    if (__isset.backup_progress != rhs.__isset.backup_progress)
      return false;
    else if (__isset.backup_progress && !(backup_progress == rhs.backup_progress))
      return false;
    if (__isset.output_files != rhs.__isset.output_files)
      return false;
    else if (__isset.output_files && !(output_files == rhs.output_files))
      return false;
    if (__isset.what != rhs.__isset.what)
      return false;
    else if (__isset.what && !(what == rhs.what))
      return false;
    if (__isset.why != rhs.__isset.why)
      return false;
    else if (__isset.why && !(why == rhs.why))
      return false;
    if (__isset.created_time != rhs.__isset.created_time)
      return false;
    else if (__isset.created_time && !(created_time == rhs.created_time))
      return false;
    if (__isset.created_time_ll != rhs.__isset.created_time_ll)
      return false;
    else if (__isset.created_time_ll && !(created_time_ll == rhs.created_time_ll))
      return false;
    if (__isset.display_name != rhs.__isset.display_name)
      return false;
    else if (__isset.display_name && !(display_name == rhs.display_name))
      return false;
    if (__isset.triggers != rhs.__isset.triggers)
      return false;
    else if (__isset.triggers && !(triggers == rhs.triggers))
      return false;
    if (__isset.histories != rhs.__isset.histories)
      return false;
    else if (__isset.histories && !(histories == rhs.histories))
      return false;
    if (__isset.url != rhs.__isset.url)
      return false;
    else if (__isset.url && !(url == rhs.url))
      return false;
    if (__isset.post != rhs.__isset.post)
      return false;
    else if (__isset.post && !(post == rhs.post))
      return false;
    return true;
  }
  bool operator != (const job_detail &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const job_detail & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(job_detail &a, job_detail &b);

inline std::ostream& operator<<(std::ostream& out, const job_detail& obj)
{
  obj.printTo(out);
  return out;
}

}} // namespace

#endif
