/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "IronMan_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace mwdc { namespace ironman { namespace remoting { namespace thrift {


disk_info::~disk_info() throw() {
}


void disk_info::__set_boot_from_disk(const bool val) {
  this->boot_from_disk = val;
__isset.boot_from_disk = true;
}

void disk_info::__set_bus_type(const int16_t val) {
  this->bus_type = val;
__isset.bus_type = true;
}

void disk_info::__set_cluster_owner(const std::string& val) {
  this->cluster_owner = val;
__isset.cluster_owner = true;
}

void disk_info::__set_cylinders(const int64_t val) {
  this->cylinders = val;
__isset.cylinders = true;
}

void disk_info::__set_friend_name(const std::string& val) {
  this->friend_name = val;
__isset.friend_name = true;
}

void disk_info::__set_guid(const std::string& val) {
  this->guid = val;
__isset.guid = true;
}

void disk_info::__set_tracks_per_cylinder(const int32_t val) {
  this->tracks_per_cylinder = val;
__isset.tracks_per_cylinder = true;
}

void disk_info::__set_is_boot(const bool val) {
  this->is_boot = val;
__isset.is_boot = true;
}

void disk_info::__set_is_clustered(const bool val) {
  this->is_clustered = val;
__isset.is_clustered = true;
}

void disk_info::__set_is_offline(const bool val) {
  this->is_offline = val;
__isset.is_offline = true;
}

void disk_info::__set_is_readonly(const bool val) {
  this->is_readonly = val;
__isset.is_readonly = true;
}

void disk_info::__set_is_snapshot(const bool val) {
  this->is_snapshot = val;
__isset.is_snapshot = true;
}

void disk_info::__set_is_system(const bool val) {
  this->is_system = val;
__isset.is_system = true;
}

void disk_info::__set_location(const std::string& val) {
  this->location = val;
__isset.location = true;
}

void disk_info::__set_logical_sector_size(const int64_t val) {
  this->logical_sector_size = val;
__isset.logical_sector_size = true;
}

void disk_info::__set_manufacturer(const std::string& val) {
  this->manufacturer = val;
__isset.manufacturer = true;
}

void disk_info::__set_model(const std::string& val) {
  this->model = val;
__isset.model = true;
}

void disk_info::__set_number(const int32_t val) {
  this->number = val;
__isset.number = true;
}

void disk_info::__set_number_of_partitions(const int32_t val) {
  this->number_of_partitions = val;
__isset.number_of_partitions = true;
}

void disk_info::__set_offline_reason(const int16_t val) {
  this->offline_reason = val;
__isset.offline_reason = true;
}

void disk_info::__set_partition_style(const int16_t val) {
  this->partition_style = val;
__isset.partition_style = true;
}

void disk_info::__set_path(const std::string& val) {
  this->path = val;
__isset.path = true;
}

void disk_info::__set_physical_sector_size(const int64_t val) {
  this->physical_sector_size = val;
__isset.physical_sector_size = true;
}

void disk_info::__set_sectors_per_track(const int32_t val) {
  this->sectors_per_track = val;
__isset.sectors_per_track = true;
}

void disk_info::__set_serial_number(const std::string& val) {
  this->serial_number = val;
__isset.serial_number = true;
}

void disk_info::__set_signature(const int32_t val) {
  this->signature = val;
__isset.signature = true;
}

void disk_info::__set_size(const int64_t val) {
  this->size = val;
__isset.size = true;
}

void disk_info::__set_storage_device_id(const std::string& val) {
  this->storage_device_id = val;
__isset.storage_device_id = true;
}

void disk_info::__set_storage_server(const std::string& val) {
  this->storage_server = val;
__isset.storage_server = true;
}

void disk_info::__set_uri(const std::string& val) {
  this->uri = val;
__isset.uri = true;
}

const char* disk_info::ascii_fingerprint = "09DB4A5DED6A00DC0C8F72E3830808A3";
const uint8_t disk_info::binary_fingerprint[16] = {0x09,0xDB,0x4A,0x5D,0xED,0x6A,0x00,0xDC,0x0C,0x8F,0x72,0xE3,0x83,0x08,0x08,0xA3};

uint32_t disk_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->boot_from_disk);
          this->__isset.boot_from_disk = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->bus_type);
          this->__isset.bus_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cluster_owner);
          this->__isset.cluster_owner = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cylinders);
          this->__isset.cylinders = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->friend_name);
          this->__isset.friend_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guid);
          this->__isset.guid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->tracks_per_cylinder);
          this->__isset.tracks_per_cylinder = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_boot);
          this->__isset.is_boot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_clustered);
          this->__isset.is_clustered = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_offline);
          this->__isset.is_offline = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_readonly);
          this->__isset.is_readonly = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_snapshot);
          this->__isset.is_snapshot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_system);
          this->__isset.is_system = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->location);
          this->__isset.location = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->logical_sector_size);
          this->__isset.logical_sector_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->manufacturer);
          this->__isset.manufacturer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->model);
          this->__isset.model = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->number);
          this->__isset.number = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->number_of_partitions);
          this->__isset.number_of_partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->offline_reason);
          this->__isset.offline_reason = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->partition_style);
          this->__isset.partition_style = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->path);
          this->__isset.path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->physical_sector_size);
          this->__isset.physical_sector_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sectors_per_track);
          this->__isset.sectors_per_track = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->serial_number);
          this->__isset.serial_number = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 26:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->signature);
          this->__isset.signature = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 27:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->size);
          this->__isset.size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 28:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->storage_device_id);
          this->__isset.storage_device_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 29:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->storage_server);
          this->__isset.storage_server = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->uri);
          this->__isset.uri = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t disk_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("disk_info");

  if (this->__isset.boot_from_disk) {
    xfer += oprot->writeFieldBegin("boot_from_disk", ::apache::thrift::protocol::T_BOOL, 1);
    xfer += oprot->writeBool(this->boot_from_disk);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.bus_type) {
    xfer += oprot->writeFieldBegin("bus_type", ::apache::thrift::protocol::T_I16, 2);
    xfer += oprot->writeI16(this->bus_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_owner) {
    xfer += oprot->writeFieldBegin("cluster_owner", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->cluster_owner);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cylinders) {
    xfer += oprot->writeFieldBegin("cylinders", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->cylinders);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.friend_name) {
    xfer += oprot->writeFieldBegin("friend_name", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->friend_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.guid) {
    xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->guid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tracks_per_cylinder) {
    xfer += oprot->writeFieldBegin("tracks_per_cylinder", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32(this->tracks_per_cylinder);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_boot) {
    xfer += oprot->writeFieldBegin("is_boot", ::apache::thrift::protocol::T_BOOL, 8);
    xfer += oprot->writeBool(this->is_boot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_clustered) {
    xfer += oprot->writeFieldBegin("is_clustered", ::apache::thrift::protocol::T_BOOL, 9);
    xfer += oprot->writeBool(this->is_clustered);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_offline) {
    xfer += oprot->writeFieldBegin("is_offline", ::apache::thrift::protocol::T_BOOL, 10);
    xfer += oprot->writeBool(this->is_offline);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_readonly) {
    xfer += oprot->writeFieldBegin("is_readonly", ::apache::thrift::protocol::T_BOOL, 11);
    xfer += oprot->writeBool(this->is_readonly);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_snapshot) {
    xfer += oprot->writeFieldBegin("is_snapshot", ::apache::thrift::protocol::T_BOOL, 12);
    xfer += oprot->writeBool(this->is_snapshot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_system) {
    xfer += oprot->writeFieldBegin("is_system", ::apache::thrift::protocol::T_BOOL, 13);
    xfer += oprot->writeBool(this->is_system);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.location) {
    xfer += oprot->writeFieldBegin("location", ::apache::thrift::protocol::T_STRING, 14);
    xfer += oprot->writeString(this->location);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.logical_sector_size) {
    xfer += oprot->writeFieldBegin("logical_sector_size", ::apache::thrift::protocol::T_I64, 15);
    xfer += oprot->writeI64(this->logical_sector_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.manufacturer) {
    xfer += oprot->writeFieldBegin("manufacturer", ::apache::thrift::protocol::T_STRING, 16);
    xfer += oprot->writeString(this->manufacturer);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.model) {
    xfer += oprot->writeFieldBegin("model", ::apache::thrift::protocol::T_STRING, 17);
    xfer += oprot->writeString(this->model);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.number) {
    xfer += oprot->writeFieldBegin("number", ::apache::thrift::protocol::T_I32, 18);
    xfer += oprot->writeI32(this->number);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.number_of_partitions) {
    xfer += oprot->writeFieldBegin("number_of_partitions", ::apache::thrift::protocol::T_I32, 19);
    xfer += oprot->writeI32(this->number_of_partitions);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.offline_reason) {
    xfer += oprot->writeFieldBegin("offline_reason", ::apache::thrift::protocol::T_I16, 20);
    xfer += oprot->writeI16(this->offline_reason);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partition_style) {
    xfer += oprot->writeFieldBegin("partition_style", ::apache::thrift::protocol::T_I16, 21);
    xfer += oprot->writeI16(this->partition_style);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.path) {
    xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_STRING, 22);
    xfer += oprot->writeString(this->path);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.physical_sector_size) {
    xfer += oprot->writeFieldBegin("physical_sector_size", ::apache::thrift::protocol::T_I64, 23);
    xfer += oprot->writeI64(this->physical_sector_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sectors_per_track) {
    xfer += oprot->writeFieldBegin("sectors_per_track", ::apache::thrift::protocol::T_I32, 24);
    xfer += oprot->writeI32(this->sectors_per_track);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.serial_number) {
    xfer += oprot->writeFieldBegin("serial_number", ::apache::thrift::protocol::T_STRING, 25);
    xfer += oprot->writeString(this->serial_number);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.signature) {
    xfer += oprot->writeFieldBegin("signature", ::apache::thrift::protocol::T_I32, 26);
    xfer += oprot->writeI32(this->signature);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.size) {
    xfer += oprot->writeFieldBegin("size", ::apache::thrift::protocol::T_I64, 27);
    xfer += oprot->writeI64(this->size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.storage_device_id) {
    xfer += oprot->writeFieldBegin("storage_device_id", ::apache::thrift::protocol::T_STRING, 28);
    xfer += oprot->writeString(this->storage_device_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.storage_server) {
    xfer += oprot->writeFieldBegin("storage_server", ::apache::thrift::protocol::T_STRING, 29);
    xfer += oprot->writeString(this->storage_server);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.uri) {
    xfer += oprot->writeFieldBegin("uri", ::apache::thrift::protocol::T_STRING, 30);
    xfer += oprot->writeString(this->uri);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(disk_info &a, disk_info &b) {
  using ::std::swap;
  swap(a.boot_from_disk, b.boot_from_disk);
  swap(a.bus_type, b.bus_type);
  swap(a.cluster_owner, b.cluster_owner);
  swap(a.cylinders, b.cylinders);
  swap(a.friend_name, b.friend_name);
  swap(a.guid, b.guid);
  swap(a.tracks_per_cylinder, b.tracks_per_cylinder);
  swap(a.is_boot, b.is_boot);
  swap(a.is_clustered, b.is_clustered);
  swap(a.is_offline, b.is_offline);
  swap(a.is_readonly, b.is_readonly);
  swap(a.is_snapshot, b.is_snapshot);
  swap(a.is_system, b.is_system);
  swap(a.location, b.location);
  swap(a.logical_sector_size, b.logical_sector_size);
  swap(a.manufacturer, b.manufacturer);
  swap(a.model, b.model);
  swap(a.number, b.number);
  swap(a.number_of_partitions, b.number_of_partitions);
  swap(a.offline_reason, b.offline_reason);
  swap(a.partition_style, b.partition_style);
  swap(a.path, b.path);
  swap(a.physical_sector_size, b.physical_sector_size);
  swap(a.sectors_per_track, b.sectors_per_track);
  swap(a.serial_number, b.serial_number);
  swap(a.signature, b.signature);
  swap(a.size, b.size);
  swap(a.storage_device_id, b.storage_device_id);
  swap(a.storage_server, b.storage_server);
  swap(a.uri, b.uri);
  swap(a.__isset, b.__isset);
}

disk_info::disk_info(const disk_info& other0) {
  boot_from_disk = other0.boot_from_disk;
  bus_type = other0.bus_type;
  cluster_owner = other0.cluster_owner;
  cylinders = other0.cylinders;
  friend_name = other0.friend_name;
  guid = other0.guid;
  tracks_per_cylinder = other0.tracks_per_cylinder;
  is_boot = other0.is_boot;
  is_clustered = other0.is_clustered;
  is_offline = other0.is_offline;
  is_readonly = other0.is_readonly;
  is_snapshot = other0.is_snapshot;
  is_system = other0.is_system;
  location = other0.location;
  logical_sector_size = other0.logical_sector_size;
  manufacturer = other0.manufacturer;
  model = other0.model;
  number = other0.number;
  number_of_partitions = other0.number_of_partitions;
  offline_reason = other0.offline_reason;
  partition_style = other0.partition_style;
  path = other0.path;
  physical_sector_size = other0.physical_sector_size;
  sectors_per_track = other0.sectors_per_track;
  serial_number = other0.serial_number;
  signature = other0.signature;
  size = other0.size;
  storage_device_id = other0.storage_device_id;
  storage_server = other0.storage_server;
  uri = other0.uri;
  __isset = other0.__isset;
}
disk_info& disk_info::operator=(const disk_info& other1) {
  boot_from_disk = other1.boot_from_disk;
  bus_type = other1.bus_type;
  cluster_owner = other1.cluster_owner;
  cylinders = other1.cylinders;
  friend_name = other1.friend_name;
  guid = other1.guid;
  tracks_per_cylinder = other1.tracks_per_cylinder;
  is_boot = other1.is_boot;
  is_clustered = other1.is_clustered;
  is_offline = other1.is_offline;
  is_readonly = other1.is_readonly;
  is_snapshot = other1.is_snapshot;
  is_system = other1.is_system;
  location = other1.location;
  logical_sector_size = other1.logical_sector_size;
  manufacturer = other1.manufacturer;
  model = other1.model;
  number = other1.number;
  number_of_partitions = other1.number_of_partitions;
  offline_reason = other1.offline_reason;
  partition_style = other1.partition_style;
  path = other1.path;
  physical_sector_size = other1.physical_sector_size;
  sectors_per_track = other1.sectors_per_track;
  serial_number = other1.serial_number;
  signature = other1.signature;
  size = other1.size;
  storage_device_id = other1.storage_device_id;
  storage_server = other1.storage_server;
  uri = other1.uri;
  __isset = other1.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const disk_info& obj) {
  using apache::thrift::to_string;
  out << "disk_info(";
  out << "boot_from_disk="; (obj.__isset.boot_from_disk ? (out << to_string(obj.boot_from_disk)) : (out << "<null>"));
  out << ", " << "bus_type="; (obj.__isset.bus_type ? (out << to_string(obj.bus_type)) : (out << "<null>"));
  out << ", " << "cluster_owner="; (obj.__isset.cluster_owner ? (out << to_string(obj.cluster_owner)) : (out << "<null>"));
  out << ", " << "cylinders="; (obj.__isset.cylinders ? (out << to_string(obj.cylinders)) : (out << "<null>"));
  out << ", " << "friend_name="; (obj.__isset.friend_name ? (out << to_string(obj.friend_name)) : (out << "<null>"));
  out << ", " << "guid="; (obj.__isset.guid ? (out << to_string(obj.guid)) : (out << "<null>"));
  out << ", " << "tracks_per_cylinder="; (obj.__isset.tracks_per_cylinder ? (out << to_string(obj.tracks_per_cylinder)) : (out << "<null>"));
  out << ", " << "is_boot="; (obj.__isset.is_boot ? (out << to_string(obj.is_boot)) : (out << "<null>"));
  out << ", " << "is_clustered="; (obj.__isset.is_clustered ? (out << to_string(obj.is_clustered)) : (out << "<null>"));
  out << ", " << "is_offline="; (obj.__isset.is_offline ? (out << to_string(obj.is_offline)) : (out << "<null>"));
  out << ", " << "is_readonly="; (obj.__isset.is_readonly ? (out << to_string(obj.is_readonly)) : (out << "<null>"));
  out << ", " << "is_snapshot="; (obj.__isset.is_snapshot ? (out << to_string(obj.is_snapshot)) : (out << "<null>"));
  out << ", " << "is_system="; (obj.__isset.is_system ? (out << to_string(obj.is_system)) : (out << "<null>"));
  out << ", " << "location="; (obj.__isset.location ? (out << to_string(obj.location)) : (out << "<null>"));
  out << ", " << "logical_sector_size="; (obj.__isset.logical_sector_size ? (out << to_string(obj.logical_sector_size)) : (out << "<null>"));
  out << ", " << "manufacturer="; (obj.__isset.manufacturer ? (out << to_string(obj.manufacturer)) : (out << "<null>"));
  out << ", " << "model="; (obj.__isset.model ? (out << to_string(obj.model)) : (out << "<null>"));
  out << ", " << "number="; (obj.__isset.number ? (out << to_string(obj.number)) : (out << "<null>"));
  out << ", " << "number_of_partitions="; (obj.__isset.number_of_partitions ? (out << to_string(obj.number_of_partitions)) : (out << "<null>"));
  out << ", " << "offline_reason="; (obj.__isset.offline_reason ? (out << to_string(obj.offline_reason)) : (out << "<null>"));
  out << ", " << "partition_style="; (obj.__isset.partition_style ? (out << to_string(obj.partition_style)) : (out << "<null>"));
  out << ", " << "path="; (obj.__isset.path ? (out << to_string(obj.path)) : (out << "<null>"));
  out << ", " << "physical_sector_size="; (obj.__isset.physical_sector_size ? (out << to_string(obj.physical_sector_size)) : (out << "<null>"));
  out << ", " << "sectors_per_track="; (obj.__isset.sectors_per_track ? (out << to_string(obj.sectors_per_track)) : (out << "<null>"));
  out << ", " << "serial_number="; (obj.__isset.serial_number ? (out << to_string(obj.serial_number)) : (out << "<null>"));
  out << ", " << "signature="; (obj.__isset.signature ? (out << to_string(obj.signature)) : (out << "<null>"));
  out << ", " << "size="; (obj.__isset.size ? (out << to_string(obj.size)) : (out << "<null>"));
  out << ", " << "storage_device_id="; (obj.__isset.storage_device_id ? (out << to_string(obj.storage_device_id)) : (out << "<null>"));
  out << ", " << "storage_server="; (obj.__isset.storage_server ? (out << to_string(obj.storage_server)) : (out << "<null>"));
  out << ", " << "uri="; (obj.__isset.uri ? (out << to_string(obj.uri)) : (out << "<null>"));
  out << ")";
  return out;
}


partition_info::~partition_info() throw() {
}


void partition_info::__set_access_paths(const std::set<std::string> & val) {
  this->access_paths = val;
__isset.access_paths = true;
}

void partition_info::__set_disk_number(const int32_t val) {
  this->disk_number = val;
__isset.disk_number = true;
}

void partition_info::__set_drive_letter(const std::string& val) {
  this->drive_letter = val;
__isset.drive_letter = true;
}

void partition_info::__set_gpt_type(const std::string& val) {
  this->gpt_type = val;
__isset.gpt_type = true;
}

void partition_info::__set_guid(const std::string& val) {
  this->guid = val;
__isset.guid = true;
}

void partition_info::__set_is_active(const bool val) {
  this->is_active = val;
__isset.is_active = true;
}

void partition_info::__set_is_boot(const bool val) {
  this->is_boot = val;
__isset.is_boot = true;
}

void partition_info::__set_is_hidden(const bool val) {
  this->is_hidden = val;
__isset.is_hidden = true;
}

void partition_info::__set_is_offline(const bool val) {
  this->is_offline = val;
__isset.is_offline = true;
}

void partition_info::__set_is_readonly(const bool val) {
  this->is_readonly = val;
__isset.is_readonly = true;
}

void partition_info::__set_is_shadowcopy(const bool val) {
  this->is_shadowcopy = val;
__isset.is_shadowcopy = true;
}

void partition_info::__set_is_system(const bool val) {
  this->is_system = val;
__isset.is_system = true;
}

void partition_info::__set_mbr_type(const int16_t val) {
  this->mbr_type = val;
__isset.mbr_type = true;
}

void partition_info::__set_offset(const int64_t val) {
  this->offset = val;
__isset.offset = true;
}

void partition_info::__set_partition_number(const int32_t val) {
  this->partition_number = val;
__isset.partition_number = true;
}

void partition_info::__set_size(const int64_t val) {
  this->size = val;
__isset.size = true;
}

const char* partition_info::ascii_fingerprint = "2838EA5A45F046B99982FD60699BA459";
const uint8_t partition_info::binary_fingerprint[16] = {0x28,0x38,0xEA,0x5A,0x45,0xF0,0x46,0xB9,0x99,0x82,0xFD,0x60,0x69,0x9B,0xA4,0x59};

uint32_t partition_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->access_paths.clear();
            uint32_t _size2;
            ::apache::thrift::protocol::TType _etype5;
            xfer += iprot->readSetBegin(_etype5, _size2);
            uint32_t _i6;
            for (_i6 = 0; _i6 < _size2; ++_i6)
            {
              std::string _elem7;
              xfer += iprot->readString(_elem7);
              this->access_paths.insert(_elem7);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.access_paths = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->disk_number);
          this->__isset.disk_number = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->drive_letter);
          this->__isset.drive_letter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->gpt_type);
          this->__isset.gpt_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guid);
          this->__isset.guid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_active);
          this->__isset.is_active = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_boot);
          this->__isset.is_boot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_hidden);
          this->__isset.is_hidden = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_offline);
          this->__isset.is_offline = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_readonly);
          this->__isset.is_readonly = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_shadowcopy);
          this->__isset.is_shadowcopy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_system);
          this->__isset.is_system = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->mbr_type);
          this->__isset.mbr_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->offset);
          this->__isset.offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->partition_number);
          this->__isset.partition_number = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->size);
          this->__isset.size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t partition_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("partition_info");

  if (this->__isset.access_paths) {
    xfer += oprot->writeFieldBegin("access_paths", ::apache::thrift::protocol::T_SET, 1);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->access_paths.size()));
      std::set<std::string> ::const_iterator _iter8;
      for (_iter8 = this->access_paths.begin(); _iter8 != this->access_paths.end(); ++_iter8)
      {
        xfer += oprot->writeString((*_iter8));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.disk_number) {
    xfer += oprot->writeFieldBegin("disk_number", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->disk_number);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.drive_letter) {
    xfer += oprot->writeFieldBegin("drive_letter", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->drive_letter);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.gpt_type) {
    xfer += oprot->writeFieldBegin("gpt_type", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->gpt_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.guid) {
    xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->guid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_active) {
    xfer += oprot->writeFieldBegin("is_active", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->is_active);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_boot) {
    xfer += oprot->writeFieldBegin("is_boot", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->is_boot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_hidden) {
    xfer += oprot->writeFieldBegin("is_hidden", ::apache::thrift::protocol::T_BOOL, 8);
    xfer += oprot->writeBool(this->is_hidden);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_offline) {
    xfer += oprot->writeFieldBegin("is_offline", ::apache::thrift::protocol::T_BOOL, 9);
    xfer += oprot->writeBool(this->is_offline);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_readonly) {
    xfer += oprot->writeFieldBegin("is_readonly", ::apache::thrift::protocol::T_BOOL, 10);
    xfer += oprot->writeBool(this->is_readonly);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_shadowcopy) {
    xfer += oprot->writeFieldBegin("is_shadowcopy", ::apache::thrift::protocol::T_BOOL, 11);
    xfer += oprot->writeBool(this->is_shadowcopy);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_system) {
    xfer += oprot->writeFieldBegin("is_system", ::apache::thrift::protocol::T_BOOL, 12);
    xfer += oprot->writeBool(this->is_system);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mbr_type) {
    xfer += oprot->writeFieldBegin("mbr_type", ::apache::thrift::protocol::T_I16, 13);
    xfer += oprot->writeI16(this->mbr_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.offset) {
    xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I64, 14);
    xfer += oprot->writeI64(this->offset);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partition_number) {
    xfer += oprot->writeFieldBegin("partition_number", ::apache::thrift::protocol::T_I32, 15);
    xfer += oprot->writeI32(this->partition_number);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.size) {
    xfer += oprot->writeFieldBegin("size", ::apache::thrift::protocol::T_I64, 16);
    xfer += oprot->writeI64(this->size);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(partition_info &a, partition_info &b) {
  using ::std::swap;
  swap(a.access_paths, b.access_paths);
  swap(a.disk_number, b.disk_number);
  swap(a.drive_letter, b.drive_letter);
  swap(a.gpt_type, b.gpt_type);
  swap(a.guid, b.guid);
  swap(a.is_active, b.is_active);
  swap(a.is_boot, b.is_boot);
  swap(a.is_hidden, b.is_hidden);
  swap(a.is_offline, b.is_offline);
  swap(a.is_readonly, b.is_readonly);
  swap(a.is_shadowcopy, b.is_shadowcopy);
  swap(a.is_system, b.is_system);
  swap(a.mbr_type, b.mbr_type);
  swap(a.offset, b.offset);
  swap(a.partition_number, b.partition_number);
  swap(a.size, b.size);
  swap(a.__isset, b.__isset);
}

partition_info::partition_info(const partition_info& other9) {
  access_paths = other9.access_paths;
  disk_number = other9.disk_number;
  drive_letter = other9.drive_letter;
  gpt_type = other9.gpt_type;
  guid = other9.guid;
  is_active = other9.is_active;
  is_boot = other9.is_boot;
  is_hidden = other9.is_hidden;
  is_offline = other9.is_offline;
  is_readonly = other9.is_readonly;
  is_shadowcopy = other9.is_shadowcopy;
  is_system = other9.is_system;
  mbr_type = other9.mbr_type;
  offset = other9.offset;
  partition_number = other9.partition_number;
  size = other9.size;
  __isset = other9.__isset;
}
partition_info& partition_info::operator=(const partition_info& other10) {
  access_paths = other10.access_paths;
  disk_number = other10.disk_number;
  drive_letter = other10.drive_letter;
  gpt_type = other10.gpt_type;
  guid = other10.guid;
  is_active = other10.is_active;
  is_boot = other10.is_boot;
  is_hidden = other10.is_hidden;
  is_offline = other10.is_offline;
  is_readonly = other10.is_readonly;
  is_shadowcopy = other10.is_shadowcopy;
  is_system = other10.is_system;
  mbr_type = other10.mbr_type;
  offset = other10.offset;
  partition_number = other10.partition_number;
  size = other10.size;
  __isset = other10.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const partition_info& obj) {
  using apache::thrift::to_string;
  out << "partition_info(";
  out << "access_paths="; (obj.__isset.access_paths ? (out << to_string(obj.access_paths)) : (out << "<null>"));
  out << ", " << "disk_number="; (obj.__isset.disk_number ? (out << to_string(obj.disk_number)) : (out << "<null>"));
  out << ", " << "drive_letter="; (obj.__isset.drive_letter ? (out << to_string(obj.drive_letter)) : (out << "<null>"));
  out << ", " << "gpt_type="; (obj.__isset.gpt_type ? (out << to_string(obj.gpt_type)) : (out << "<null>"));
  out << ", " << "guid="; (obj.__isset.guid ? (out << to_string(obj.guid)) : (out << "<null>"));
  out << ", " << "is_active="; (obj.__isset.is_active ? (out << to_string(obj.is_active)) : (out << "<null>"));
  out << ", " << "is_boot="; (obj.__isset.is_boot ? (out << to_string(obj.is_boot)) : (out << "<null>"));
  out << ", " << "is_hidden="; (obj.__isset.is_hidden ? (out << to_string(obj.is_hidden)) : (out << "<null>"));
  out << ", " << "is_offline="; (obj.__isset.is_offline ? (out << to_string(obj.is_offline)) : (out << "<null>"));
  out << ", " << "is_readonly="; (obj.__isset.is_readonly ? (out << to_string(obj.is_readonly)) : (out << "<null>"));
  out << ", " << "is_shadowcopy="; (obj.__isset.is_shadowcopy ? (out << to_string(obj.is_shadowcopy)) : (out << "<null>"));
  out << ", " << "is_system="; (obj.__isset.is_system ? (out << to_string(obj.is_system)) : (out << "<null>"));
  out << ", " << "mbr_type="; (obj.__isset.mbr_type ? (out << to_string(obj.mbr_type)) : (out << "<null>"));
  out << ", " << "offset="; (obj.__isset.offset ? (out << to_string(obj.offset)) : (out << "<null>"));
  out << ", " << "partition_number="; (obj.__isset.partition_number ? (out << to_string(obj.partition_number)) : (out << "<null>"));
  out << ", " << "size="; (obj.__isset.size ? (out << to_string(obj.size)) : (out << "<null>"));
  out << ")";
  return out;
}


volume_info::~volume_info() throw() {
}


void volume_info::__set_access_paths(const std::set<std::string> & val) {
  this->access_paths = val;
__isset.access_paths = true;
}

void volume_info::__set_cluster_access_path(const std::string& val) {
  this->cluster_access_path = val;
__isset.cluster_access_path = true;
}

void volume_info::__set_drive_letter(const std::string& val) {
  this->drive_letter = val;
__isset.drive_letter = true;
}

void volume_info::__set_drive_type(const int32_t val) {
  this->drive_type = val;
__isset.drive_type = true;
}

void volume_info::__set_file_system(const std::string& val) {
  this->file_system = val;
__isset.file_system = true;
}

void volume_info::__set_file_system_catalogid(const std::string& val) {
  this->file_system_catalogid = val;
__isset.file_system_catalogid = true;
}

void volume_info::__set_file_system_label(const std::string& val) {
  this->file_system_label = val;
__isset.file_system_label = true;
}

void volume_info::__set_object_id(const std::string& val) {
  this->object_id = val;
__isset.object_id = true;
}

void volume_info::__set_path(const std::string& val) {
  this->path = val;
__isset.path = true;
}

void volume_info::__set_size(const int64_t val) {
  this->size = val;
__isset.size = true;
}

void volume_info::__set_size_remaining(const int64_t val) {
  this->size_remaining = val;
__isset.size_remaining = true;
}

const char* volume_info::ascii_fingerprint = "7E703337DA196F91F548DE52BCCDB580";
const uint8_t volume_info::binary_fingerprint[16] = {0x7E,0x70,0x33,0x37,0xDA,0x19,0x6F,0x91,0xF5,0x48,0xDE,0x52,0xBC,0xCD,0xB5,0x80};

uint32_t volume_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->access_paths.clear();
            uint32_t _size11;
            ::apache::thrift::protocol::TType _etype14;
            xfer += iprot->readSetBegin(_etype14, _size11);
            uint32_t _i15;
            for (_i15 = 0; _i15 < _size11; ++_i15)
            {
              std::string _elem16;
              xfer += iprot->readString(_elem16);
              this->access_paths.insert(_elem16);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.access_paths = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cluster_access_path);
          this->__isset.cluster_access_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->drive_letter);
          this->__isset.drive_letter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->drive_type);
          this->__isset.drive_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->file_system);
          this->__isset.file_system = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->file_system_catalogid);
          this->__isset.file_system_catalogid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->file_system_label);
          this->__isset.file_system_label = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->object_id);
          this->__isset.object_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->path);
          this->__isset.path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->size);
          this->__isset.size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->size_remaining);
          this->__isset.size_remaining = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t volume_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("volume_info");

  if (this->__isset.access_paths) {
    xfer += oprot->writeFieldBegin("access_paths", ::apache::thrift::protocol::T_SET, 1);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->access_paths.size()));
      std::set<std::string> ::const_iterator _iter17;
      for (_iter17 = this->access_paths.begin(); _iter17 != this->access_paths.end(); ++_iter17)
      {
        xfer += oprot->writeString((*_iter17));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_access_path) {
    xfer += oprot->writeFieldBegin("cluster_access_path", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->cluster_access_path);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.drive_letter) {
    xfer += oprot->writeFieldBegin("drive_letter", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->drive_letter);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.drive_type) {
    xfer += oprot->writeFieldBegin("drive_type", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->drive_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.file_system) {
    xfer += oprot->writeFieldBegin("file_system", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->file_system);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.file_system_catalogid) {
    xfer += oprot->writeFieldBegin("file_system_catalogid", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->file_system_catalogid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.file_system_label) {
    xfer += oprot->writeFieldBegin("file_system_label", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->file_system_label);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.object_id) {
    xfer += oprot->writeFieldBegin("object_id", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->object_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.path) {
    xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->path);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.size) {
    xfer += oprot->writeFieldBegin("size", ::apache::thrift::protocol::T_I64, 10);
    xfer += oprot->writeI64(this->size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.size_remaining) {
    xfer += oprot->writeFieldBegin("size_remaining", ::apache::thrift::protocol::T_I64, 11);
    xfer += oprot->writeI64(this->size_remaining);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(volume_info &a, volume_info &b) {
  using ::std::swap;
  swap(a.access_paths, b.access_paths);
  swap(a.cluster_access_path, b.cluster_access_path);
  swap(a.drive_letter, b.drive_letter);
  swap(a.drive_type, b.drive_type);
  swap(a.file_system, b.file_system);
  swap(a.file_system_catalogid, b.file_system_catalogid);
  swap(a.file_system_label, b.file_system_label);
  swap(a.object_id, b.object_id);
  swap(a.path, b.path);
  swap(a.size, b.size);
  swap(a.size_remaining, b.size_remaining);
  swap(a.__isset, b.__isset);
}

volume_info::volume_info(const volume_info& other18) {
  access_paths = other18.access_paths;
  cluster_access_path = other18.cluster_access_path;
  drive_letter = other18.drive_letter;
  drive_type = other18.drive_type;
  file_system = other18.file_system;
  file_system_catalogid = other18.file_system_catalogid;
  file_system_label = other18.file_system_label;
  object_id = other18.object_id;
  path = other18.path;
  size = other18.size;
  size_remaining = other18.size_remaining;
  __isset = other18.__isset;
}
volume_info& volume_info::operator=(const volume_info& other19) {
  access_paths = other19.access_paths;
  cluster_access_path = other19.cluster_access_path;
  drive_letter = other19.drive_letter;
  drive_type = other19.drive_type;
  file_system = other19.file_system;
  file_system_catalogid = other19.file_system_catalogid;
  file_system_label = other19.file_system_label;
  object_id = other19.object_id;
  path = other19.path;
  size = other19.size;
  size_remaining = other19.size_remaining;
  __isset = other19.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const volume_info& obj) {
  using apache::thrift::to_string;
  out << "volume_info(";
  out << "access_paths="; (obj.__isset.access_paths ? (out << to_string(obj.access_paths)) : (out << "<null>"));
  out << ", " << "cluster_access_path="; (obj.__isset.cluster_access_path ? (out << to_string(obj.cluster_access_path)) : (out << "<null>"));
  out << ", " << "drive_letter="; (obj.__isset.drive_letter ? (out << to_string(obj.drive_letter)) : (out << "<null>"));
  out << ", " << "drive_type="; (obj.__isset.drive_type ? (out << to_string(obj.drive_type)) : (out << "<null>"));
  out << ", " << "file_system="; (obj.__isset.file_system ? (out << to_string(obj.file_system)) : (out << "<null>"));
  out << ", " << "file_system_catalogid="; (obj.__isset.file_system_catalogid ? (out << to_string(obj.file_system_catalogid)) : (out << "<null>"));
  out << ", " << "file_system_label="; (obj.__isset.file_system_label ? (out << to_string(obj.file_system_label)) : (out << "<null>"));
  out << ", " << "object_id="; (obj.__isset.object_id ? (out << to_string(obj.object_id)) : (out << "<null>"));
  out << ", " << "path="; (obj.__isset.path ? (out << to_string(obj.path)) : (out << "<null>"));
  out << ", " << "size="; (obj.__isset.size ? (out << to_string(obj.size)) : (out << "<null>"));
  out << ", " << "size_remaining="; (obj.__isset.size_remaining ? (out << to_string(obj.size_remaining)) : (out << "<null>"));
  out << ")";
  return out;
}


protection_relationship::~protection_relationship() throw() {
}


void protection_relationship::__set_guid(const std::string& val) {
  this->guid = val;
}

void protection_relationship::__set_cluster_protection(const bool val) {
  this->cluster_protection = val;
__isset.cluster_protection = true;
}

void protection_relationship::__set_mirror_serial(const std::string& val) {
  this->mirror_serial = val;
__isset.mirror_serial = true;
}

void protection_relationship::__set_mirror_server(const std::string& val) {
  this->mirror_server = val;
__isset.mirror_server = true;
}

void protection_relationship::__set_mirror_start_offset(const int64_t val) {
  this->mirror_start_offset = val;
__isset.mirror_start_offset = true;
}

void protection_relationship::__set_mirror_uri(const std::string& val) {
  this->mirror_uri = val;
__isset.mirror_uri = true;
}

void protection_relationship::__set_mirror_vid(const int64_t val) {
  this->mirror_vid = val;
__isset.mirror_vid = true;
}

void protection_relationship::__set_primary_serial(const std::string& val) {
  this->primary_serial = val;
__isset.primary_serial = true;
}

void protection_relationship::__set_primary_start_offset(const int64_t val) {
  this->primary_start_offset = val;
__isset.primary_start_offset = true;
}

void protection_relationship::__set_primary_uri(const std::string& val) {
  this->primary_uri = val;
__isset.primary_uri = true;
}

void protection_relationship::__set_site_id(const std::string& val) {
  this->site_id = val;
__isset.site_id = true;
}

void protection_relationship::__set_site_ids(const std::string& val) {
  this->site_ids = val;
__isset.site_ids = true;
}

const char* protection_relationship::ascii_fingerprint = "6F136D548D07491F6ACD1DA6BB69F74F";
const uint8_t protection_relationship::binary_fingerprint[16] = {0x6F,0x13,0x6D,0x54,0x8D,0x07,0x49,0x1F,0x6A,0xCD,0x1D,0xA6,0xBB,0x69,0xF7,0x4F};

uint32_t protection_relationship::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_guid = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guid);
          isset_guid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->cluster_protection);
          this->__isset.cluster_protection = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->mirror_serial);
          this->__isset.mirror_serial = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->mirror_server);
          this->__isset.mirror_server = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->mirror_start_offset);
          this->__isset.mirror_start_offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->mirror_uri);
          this->__isset.mirror_uri = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->mirror_vid);
          this->__isset.mirror_vid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->primary_serial);
          this->__isset.primary_serial = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->primary_start_offset);
          this->__isset.primary_start_offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->primary_uri);
          this->__isset.primary_uri = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->site_id);
          this->__isset.site_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->site_ids);
          this->__isset.site_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_guid)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t protection_relationship::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("protection_relationship");

  xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->guid);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.cluster_protection) {
    xfer += oprot->writeFieldBegin("cluster_protection", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->cluster_protection);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mirror_serial) {
    xfer += oprot->writeFieldBegin("mirror_serial", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->mirror_serial);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mirror_server) {
    xfer += oprot->writeFieldBegin("mirror_server", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->mirror_server);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mirror_start_offset) {
    xfer += oprot->writeFieldBegin("mirror_start_offset", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->mirror_start_offset);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mirror_uri) {
    xfer += oprot->writeFieldBegin("mirror_uri", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->mirror_uri);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mirror_vid) {
    xfer += oprot->writeFieldBegin("mirror_vid", ::apache::thrift::protocol::T_I64, 7);
    xfer += oprot->writeI64(this->mirror_vid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.primary_serial) {
    xfer += oprot->writeFieldBegin("primary_serial", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->primary_serial);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.primary_start_offset) {
    xfer += oprot->writeFieldBegin("primary_start_offset", ::apache::thrift::protocol::T_I64, 9);
    xfer += oprot->writeI64(this->primary_start_offset);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.primary_uri) {
    xfer += oprot->writeFieldBegin("primary_uri", ::apache::thrift::protocol::T_STRING, 10);
    xfer += oprot->writeString(this->primary_uri);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.site_id) {
    xfer += oprot->writeFieldBegin("site_id", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeString(this->site_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.site_ids) {
    xfer += oprot->writeFieldBegin("site_ids", ::apache::thrift::protocol::T_STRING, 12);
    xfer += oprot->writeString(this->site_ids);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(protection_relationship &a, protection_relationship &b) {
  using ::std::swap;
  swap(a.guid, b.guid);
  swap(a.cluster_protection, b.cluster_protection);
  swap(a.mirror_serial, b.mirror_serial);
  swap(a.mirror_server, b.mirror_server);
  swap(a.mirror_start_offset, b.mirror_start_offset);
  swap(a.mirror_uri, b.mirror_uri);
  swap(a.mirror_vid, b.mirror_vid);
  swap(a.primary_serial, b.primary_serial);
  swap(a.primary_start_offset, b.primary_start_offset);
  swap(a.primary_uri, b.primary_uri);
  swap(a.site_id, b.site_id);
  swap(a.site_ids, b.site_ids);
  swap(a.__isset, b.__isset);
}

protection_relationship::protection_relationship(const protection_relationship& other20) {
  guid = other20.guid;
  cluster_protection = other20.cluster_protection;
  mirror_serial = other20.mirror_serial;
  mirror_server = other20.mirror_server;
  mirror_start_offset = other20.mirror_start_offset;
  mirror_uri = other20.mirror_uri;
  mirror_vid = other20.mirror_vid;
  primary_serial = other20.primary_serial;
  primary_start_offset = other20.primary_start_offset;
  primary_uri = other20.primary_uri;
  site_id = other20.site_id;
  site_ids = other20.site_ids;
  __isset = other20.__isset;
}
protection_relationship& protection_relationship::operator=(const protection_relationship& other21) {
  guid = other21.guid;
  cluster_protection = other21.cluster_protection;
  mirror_serial = other21.mirror_serial;
  mirror_server = other21.mirror_server;
  mirror_start_offset = other21.mirror_start_offset;
  mirror_uri = other21.mirror_uri;
  mirror_vid = other21.mirror_vid;
  primary_serial = other21.primary_serial;
  primary_start_offset = other21.primary_start_offset;
  primary_uri = other21.primary_uri;
  site_id = other21.site_id;
  site_ids = other21.site_ids;
  __isset = other21.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const protection_relationship& obj) {
  using apache::thrift::to_string;
  out << "protection_relationship(";
  out << "guid=" << to_string(obj.guid);
  out << ", " << "cluster_protection="; (obj.__isset.cluster_protection ? (out << to_string(obj.cluster_protection)) : (out << "<null>"));
  out << ", " << "mirror_serial="; (obj.__isset.mirror_serial ? (out << to_string(obj.mirror_serial)) : (out << "<null>"));
  out << ", " << "mirror_server="; (obj.__isset.mirror_server ? (out << to_string(obj.mirror_server)) : (out << "<null>"));
  out << ", " << "mirror_start_offset="; (obj.__isset.mirror_start_offset ? (out << to_string(obj.mirror_start_offset)) : (out << "<null>"));
  out << ", " << "mirror_uri="; (obj.__isset.mirror_uri ? (out << to_string(obj.mirror_uri)) : (out << "<null>"));
  out << ", " << "mirror_vid="; (obj.__isset.mirror_vid ? (out << to_string(obj.mirror_vid)) : (out << "<null>"));
  out << ", " << "primary_serial="; (obj.__isset.primary_serial ? (out << to_string(obj.primary_serial)) : (out << "<null>"));
  out << ", " << "primary_start_offset="; (obj.__isset.primary_start_offset ? (out << to_string(obj.primary_start_offset)) : (out << "<null>"));
  out << ", " << "primary_uri="; (obj.__isset.primary_uri ? (out << to_string(obj.primary_uri)) : (out << "<null>"));
  out << ", " << "site_id="; (obj.__isset.site_id ? (out << to_string(obj.site_id)) : (out << "<null>"));
  out << ", " << "site_ids="; (obj.__isset.site_ids ? (out << to_string(obj.site_ids)) : (out << "<null>"));
  out << ")";
  return out;
}


protection_set::~protection_set() throw() {
}


void protection_set::__set_comment(const std::string& val) {
  this->comment = val;
__isset.comment = true;
}

void protection_set::__set_mode(const int32_t val) {
  this->mode = val;
__isset.mode = true;
}

void protection_set::__set_site_ids(const std::string& val) {
  this->site_ids = val;
__isset.site_ids = true;
}

void protection_set::__set_site_name(const std::string& val) {
  this->site_name = val;
__isset.site_name = true;
}

void protection_set::__set_protection_relationships(const std::map<std::string, protection_relationship> & val) {
  this->protection_relationships = val;
__isset.protection_relationships = true;
}

const char* protection_set::ascii_fingerprint = "6AFFFCD88F56575E4CFCCB7CB7DA2EA4";
const uint8_t protection_set::binary_fingerprint[16] = {0x6A,0xFF,0xFC,0xD8,0x8F,0x56,0x57,0x5E,0x4C,0xFC,0xCB,0x7C,0xB7,0xDA,0x2E,0xA4};

uint32_t protection_set::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comment);
          this->__isset.comment = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->mode);
          this->__isset.mode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->site_ids);
          this->__isset.site_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->site_name);
          this->__isset.site_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->protection_relationships.clear();
            uint32_t _size22;
            ::apache::thrift::protocol::TType _ktype23;
            ::apache::thrift::protocol::TType _vtype24;
            xfer += iprot->readMapBegin(_ktype23, _vtype24, _size22);
            uint32_t _i26;
            for (_i26 = 0; _i26 < _size22; ++_i26)
            {
              std::string _key27;
              xfer += iprot->readString(_key27);
              protection_relationship& _val28 = this->protection_relationships[_key27];
              xfer += _val28.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.protection_relationships = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t protection_set::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("protection_set");

  if (this->__isset.comment) {
    xfer += oprot->writeFieldBegin("comment", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->comment);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mode) {
    xfer += oprot->writeFieldBegin("mode", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->mode);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.site_ids) {
    xfer += oprot->writeFieldBegin("site_ids", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->site_ids);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.site_name) {
    xfer += oprot->writeFieldBegin("site_name", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->site_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.protection_relationships) {
    xfer += oprot->writeFieldBegin("protection_relationships", ::apache::thrift::protocol::T_MAP, 5);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->protection_relationships.size()));
      std::map<std::string, protection_relationship> ::const_iterator _iter29;
      for (_iter29 = this->protection_relationships.begin(); _iter29 != this->protection_relationships.end(); ++_iter29)
      {
        xfer += oprot->writeString(_iter29->first);
        xfer += _iter29->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(protection_set &a, protection_set &b) {
  using ::std::swap;
  swap(a.comment, b.comment);
  swap(a.mode, b.mode);
  swap(a.site_ids, b.site_ids);
  swap(a.site_name, b.site_name);
  swap(a.protection_relationships, b.protection_relationships);
  swap(a.__isset, b.__isset);
}

protection_set::protection_set(const protection_set& other30) {
  comment = other30.comment;
  mode = other30.mode;
  site_ids = other30.site_ids;
  site_name = other30.site_name;
  protection_relationships = other30.protection_relationships;
  __isset = other30.__isset;
}
protection_set& protection_set::operator=(const protection_set& other31) {
  comment = other31.comment;
  mode = other31.mode;
  site_ids = other31.site_ids;
  site_name = other31.site_name;
  protection_relationships = other31.protection_relationships;
  __isset = other31.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const protection_set& obj) {
  using apache::thrift::to_string;
  out << "protection_set(";
  out << "comment="; (obj.__isset.comment ? (out << to_string(obj.comment)) : (out << "<null>"));
  out << ", " << "mode="; (obj.__isset.mode ? (out << to_string(obj.mode)) : (out << "<null>"));
  out << ", " << "site_ids="; (obj.__isset.site_ids ? (out << to_string(obj.site_ids)) : (out << "<null>"));
  out << ", " << "site_name="; (obj.__isset.site_name ? (out << to_string(obj.site_name)) : (out << "<null>"));
  out << ", " << "protection_relationships="; (obj.__isset.protection_relationships ? (out << to_string(obj.protection_relationships)) : (out << "<null>"));
  out << ")";
  return out;
}


network_info::~network_info() throw() {
}


void network_info::__set_adapter_name(const std::string& val) {
  this->adapter_name = val;
__isset.adapter_name = true;
}

void network_info::__set_description(const std::string& val) {
  this->description = val;
__isset.description = true;
}

void network_info::__set_dnss(const std::vector<std::string> & val) {
  this->dnss = val;
__isset.dnss = true;
}

void network_info::__set_gateways(const std::vector<std::string> & val) {
  this->gateways = val;
__isset.gateways = true;
}

void network_info::__set_ip_addresses(const std::vector<std::string> & val) {
  this->ip_addresses = val;
__isset.ip_addresses = true;
}

void network_info::__set_is_dhcp_v4(const bool val) {
  this->is_dhcp_v4 = val;
__isset.is_dhcp_v4 = true;
}

void network_info::__set_is_dhcp_v6(const bool val) {
  this->is_dhcp_v6 = val;
__isset.is_dhcp_v6 = true;
}

void network_info::__set_mac_address(const std::string& val) {
  this->mac_address = val;
__isset.mac_address = true;
}

void network_info::__set_subnet_masks(const std::vector<std::string> & val) {
  this->subnet_masks = val;
__isset.subnet_masks = true;
}

const char* network_info::ascii_fingerprint = "DDDA7A540FF28949AE68C66C5FBB71E0";
const uint8_t network_info::binary_fingerprint[16] = {0xDD,0xDA,0x7A,0x54,0x0F,0xF2,0x89,0x49,0xAE,0x68,0xC6,0x6C,0x5F,0xBB,0x71,0xE0};

uint32_t network_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->adapter_name);
          this->__isset.adapter_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->description);
          this->__isset.description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->dnss.clear();
            uint32_t _size32;
            ::apache::thrift::protocol::TType _etype35;
            xfer += iprot->readListBegin(_etype35, _size32);
            this->dnss.resize(_size32);
            uint32_t _i36;
            for (_i36 = 0; _i36 < _size32; ++_i36)
            {
              xfer += iprot->readString(this->dnss[_i36]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.dnss = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->gateways.clear();
            uint32_t _size37;
            ::apache::thrift::protocol::TType _etype40;
            xfer += iprot->readListBegin(_etype40, _size37);
            this->gateways.resize(_size37);
            uint32_t _i41;
            for (_i41 = 0; _i41 < _size37; ++_i41)
            {
              xfer += iprot->readString(this->gateways[_i41]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.gateways = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->ip_addresses.clear();
            uint32_t _size42;
            ::apache::thrift::protocol::TType _etype45;
            xfer += iprot->readListBegin(_etype45, _size42);
            this->ip_addresses.resize(_size42);
            uint32_t _i46;
            for (_i46 = 0; _i46 < _size42; ++_i46)
            {
              xfer += iprot->readString(this->ip_addresses[_i46]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.ip_addresses = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_dhcp_v4);
          this->__isset.is_dhcp_v4 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_dhcp_v6);
          this->__isset.is_dhcp_v6 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->mac_address);
          this->__isset.mac_address = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->subnet_masks.clear();
            uint32_t _size47;
            ::apache::thrift::protocol::TType _etype50;
            xfer += iprot->readListBegin(_etype50, _size47);
            this->subnet_masks.resize(_size47);
            uint32_t _i51;
            for (_i51 = 0; _i51 < _size47; ++_i51)
            {
              xfer += iprot->readString(this->subnet_masks[_i51]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.subnet_masks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t network_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("network_info");

  if (this->__isset.adapter_name) {
    xfer += oprot->writeFieldBegin("adapter_name", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->adapter_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.description) {
    xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->description);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dnss) {
    xfer += oprot->writeFieldBegin("dnss", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->dnss.size()));
      std::vector<std::string> ::const_iterator _iter52;
      for (_iter52 = this->dnss.begin(); _iter52 != this->dnss.end(); ++_iter52)
      {
        xfer += oprot->writeString((*_iter52));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.gateways) {
    xfer += oprot->writeFieldBegin("gateways", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->gateways.size()));
      std::vector<std::string> ::const_iterator _iter53;
      for (_iter53 = this->gateways.begin(); _iter53 != this->gateways.end(); ++_iter53)
      {
        xfer += oprot->writeString((*_iter53));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ip_addresses) {
    xfer += oprot->writeFieldBegin("ip_addresses", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->ip_addresses.size()));
      std::vector<std::string> ::const_iterator _iter54;
      for (_iter54 = this->ip_addresses.begin(); _iter54 != this->ip_addresses.end(); ++_iter54)
      {
        xfer += oprot->writeString((*_iter54));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_dhcp_v4) {
    xfer += oprot->writeFieldBegin("is_dhcp_v4", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->is_dhcp_v4);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_dhcp_v6) {
    xfer += oprot->writeFieldBegin("is_dhcp_v6", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->is_dhcp_v6);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mac_address) {
    xfer += oprot->writeFieldBegin("mac_address", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->mac_address);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.subnet_masks) {
    xfer += oprot->writeFieldBegin("subnet_masks", ::apache::thrift::protocol::T_LIST, 9);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->subnet_masks.size()));
      std::vector<std::string> ::const_iterator _iter55;
      for (_iter55 = this->subnet_masks.begin(); _iter55 != this->subnet_masks.end(); ++_iter55)
      {
        xfer += oprot->writeString((*_iter55));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(network_info &a, network_info &b) {
  using ::std::swap;
  swap(a.adapter_name, b.adapter_name);
  swap(a.description, b.description);
  swap(a.dnss, b.dnss);
  swap(a.gateways, b.gateways);
  swap(a.ip_addresses, b.ip_addresses);
  swap(a.is_dhcp_v4, b.is_dhcp_v4);
  swap(a.is_dhcp_v6, b.is_dhcp_v6);
  swap(a.mac_address, b.mac_address);
  swap(a.subnet_masks, b.subnet_masks);
  swap(a.__isset, b.__isset);
}

network_info::network_info(const network_info& other56) {
  adapter_name = other56.adapter_name;
  description = other56.description;
  dnss = other56.dnss;
  gateways = other56.gateways;
  ip_addresses = other56.ip_addresses;
  is_dhcp_v4 = other56.is_dhcp_v4;
  is_dhcp_v6 = other56.is_dhcp_v6;
  mac_address = other56.mac_address;
  subnet_masks = other56.subnet_masks;
  __isset = other56.__isset;
}
network_info& network_info::operator=(const network_info& other57) {
  adapter_name = other57.adapter_name;
  description = other57.description;
  dnss = other57.dnss;
  gateways = other57.gateways;
  ip_addresses = other57.ip_addresses;
  is_dhcp_v4 = other57.is_dhcp_v4;
  is_dhcp_v6 = other57.is_dhcp_v6;
  mac_address = other57.mac_address;
  subnet_masks = other57.subnet_masks;
  __isset = other57.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const network_info& obj) {
  using apache::thrift::to_string;
  out << "network_info(";
  out << "adapter_name="; (obj.__isset.adapter_name ? (out << to_string(obj.adapter_name)) : (out << "<null>"));
  out << ", " << "description="; (obj.__isset.description ? (out << to_string(obj.description)) : (out << "<null>"));
  out << ", " << "dnss="; (obj.__isset.dnss ? (out << to_string(obj.dnss)) : (out << "<null>"));
  out << ", " << "gateways="; (obj.__isset.gateways ? (out << to_string(obj.gateways)) : (out << "<null>"));
  out << ", " << "ip_addresses="; (obj.__isset.ip_addresses ? (out << to_string(obj.ip_addresses)) : (out << "<null>"));
  out << ", " << "is_dhcp_v4="; (obj.__isset.is_dhcp_v4 ? (out << to_string(obj.is_dhcp_v4)) : (out << "<null>"));
  out << ", " << "is_dhcp_v6="; (obj.__isset.is_dhcp_v6 ? (out << to_string(obj.is_dhcp_v6)) : (out << "<null>"));
  out << ", " << "mac_address="; (obj.__isset.mac_address ? (out << to_string(obj.mac_address)) : (out << "<null>"));
  out << ", " << "subnet_masks="; (obj.__isset.subnet_masks ? (out << to_string(obj.subnet_masks)) : (out << "<null>"));
  out << ")";
  return out;
}


storage_info::~storage_info() throw() {
}


void storage_info::__set_connection_type(const int32_t val) {
  this->connection_type = val;
__isset.connection_type = true;
}

void storage_info::__set_protocol(const int32_t val) {
  this->protocol = val;
__isset.protocol = true;
}

void storage_info::__set_storage_id(const std::string& val) {
  this->storage_id = val;
__isset.storage_id = true;
}

void storage_info::__set_storage_name(const std::string& val) {
  this->storage_name = val;
__isset.storage_name = true;
}

void storage_info::__set_network_infos(const std::set<network_info> & val) {
  this->network_infos = val;
__isset.network_infos = true;
}

void storage_info::__set_sanclient_names(const std::set<std::string> & val) {
  this->sanclient_names = val;
__isset.sanclient_names = true;
}

const char* storage_info::ascii_fingerprint = "E62053777EB83E74C5E383E2F603E879";
const uint8_t storage_info::binary_fingerprint[16] = {0xE6,0x20,0x53,0x77,0x7E,0xB8,0x3E,0x74,0xC5,0xE3,0x83,0xE2,0xF6,0x03,0xE8,0x79};

uint32_t storage_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->connection_type);
          this->__isset.connection_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->protocol);
          this->__isset.protocol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->storage_id);
          this->__isset.storage_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->storage_name);
          this->__isset.storage_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->network_infos.clear();
            uint32_t _size58;
            ::apache::thrift::protocol::TType _etype61;
            xfer += iprot->readSetBegin(_etype61, _size58);
            uint32_t _i62;
            for (_i62 = 0; _i62 < _size58; ++_i62)
            {
              network_info _elem63;
              xfer += _elem63.read(iprot);
              this->network_infos.insert(_elem63);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.network_infos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->sanclient_names.clear();
            uint32_t _size64;
            ::apache::thrift::protocol::TType _etype67;
            xfer += iprot->readSetBegin(_etype67, _size64);
            uint32_t _i68;
            for (_i68 = 0; _i68 < _size64; ++_i68)
            {
              std::string _elem69;
              xfer += iprot->readString(_elem69);
              this->sanclient_names.insert(_elem69);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.sanclient_names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t storage_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("storage_info");

  if (this->__isset.connection_type) {
    xfer += oprot->writeFieldBegin("connection_type", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->connection_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.protocol) {
    xfer += oprot->writeFieldBegin("protocol", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->protocol);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.storage_id) {
    xfer += oprot->writeFieldBegin("storage_id", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->storage_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.storage_name) {
    xfer += oprot->writeFieldBegin("storage_name", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->storage_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.network_infos) {
    xfer += oprot->writeFieldBegin("network_infos", ::apache::thrift::protocol::T_SET, 5);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->network_infos.size()));
      std::set<network_info> ::const_iterator _iter70;
      for (_iter70 = this->network_infos.begin(); _iter70 != this->network_infos.end(); ++_iter70)
      {
        xfer += (*_iter70).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sanclient_names) {
    xfer += oprot->writeFieldBegin("sanclient_names", ::apache::thrift::protocol::T_SET, 6);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->sanclient_names.size()));
      std::set<std::string> ::const_iterator _iter71;
      for (_iter71 = this->sanclient_names.begin(); _iter71 != this->sanclient_names.end(); ++_iter71)
      {
        xfer += oprot->writeString((*_iter71));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(storage_info &a, storage_info &b) {
  using ::std::swap;
  swap(a.connection_type, b.connection_type);
  swap(a.protocol, b.protocol);
  swap(a.storage_id, b.storage_id);
  swap(a.storage_name, b.storage_name);
  swap(a.network_infos, b.network_infos);
  swap(a.sanclient_names, b.sanclient_names);
  swap(a.__isset, b.__isset);
}

storage_info::storage_info(const storage_info& other72) {
  connection_type = other72.connection_type;
  protocol = other72.protocol;
  storage_id = other72.storage_id;
  storage_name = other72.storage_name;
  network_infos = other72.network_infos;
  sanclient_names = other72.sanclient_names;
  __isset = other72.__isset;
}
storage_info& storage_info::operator=(const storage_info& other73) {
  connection_type = other73.connection_type;
  protocol = other73.protocol;
  storage_id = other73.storage_id;
  storage_name = other73.storage_name;
  network_infos = other73.network_infos;
  sanclient_names = other73.sanclient_names;
  __isset = other73.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const storage_info& obj) {
  using apache::thrift::to_string;
  out << "storage_info(";
  out << "connection_type="; (obj.__isset.connection_type ? (out << to_string(obj.connection_type)) : (out << "<null>"));
  out << ", " << "protocol="; (obj.__isset.protocol ? (out << to_string(obj.protocol)) : (out << "<null>"));
  out << ", " << "storage_id="; (obj.__isset.storage_id ? (out << to_string(obj.storage_id)) : (out << "<null>"));
  out << ", " << "storage_name="; (obj.__isset.storage_name ? (out << to_string(obj.storage_name)) : (out << "<null>"));
  out << ", " << "network_infos="; (obj.__isset.network_infos ? (out << to_string(obj.network_infos)) : (out << "<null>"));
  out << ", " << "sanclient_names="; (obj.__isset.sanclient_names ? (out << to_string(obj.sanclient_names)) : (out << "<null>"));
  out << ")";
  return out;
}


server_info::~server_info() throw() {
}


void server_info::__set_initiator_name(const std::string& val) {
  this->initiator_name = val;
__isset.initiator_name = true;
}

void server_info::__set_server_id(const std::string& val) {
  this->server_id = val;
__isset.server_id = true;
}

void server_info::__set_server_name(const std::string& val) {
  this->server_name = val;
__isset.server_name = true;
}

void server_info::__set_network_infos(const std::set<network_info> & val) {
  this->network_infos = val;
__isset.network_infos = true;
}

const char* server_info::ascii_fingerprint = "C0684AB42E8CC6DEAF815897FDB9122E";
const uint8_t server_info::binary_fingerprint[16] = {0xC0,0x68,0x4A,0xB4,0x2E,0x8C,0xC6,0xDE,0xAF,0x81,0x58,0x97,0xFD,0xB9,0x12,0x2E};

uint32_t server_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->initiator_name);
          this->__isset.initiator_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->server_id);
          this->__isset.server_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->server_name);
          this->__isset.server_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->network_infos.clear();
            uint32_t _size74;
            ::apache::thrift::protocol::TType _etype77;
            xfer += iprot->readSetBegin(_etype77, _size74);
            uint32_t _i78;
            for (_i78 = 0; _i78 < _size74; ++_i78)
            {
              network_info _elem79;
              xfer += _elem79.read(iprot);
              this->network_infos.insert(_elem79);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.network_infos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t server_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("server_info");

  if (this->__isset.initiator_name) {
    xfer += oprot->writeFieldBegin("initiator_name", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->initiator_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.server_id) {
    xfer += oprot->writeFieldBegin("server_id", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->server_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.server_name) {
    xfer += oprot->writeFieldBegin("server_name", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->server_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.network_infos) {
    xfer += oprot->writeFieldBegin("network_infos", ::apache::thrift::protocol::T_SET, 4);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->network_infos.size()));
      std::set<network_info> ::const_iterator _iter80;
      for (_iter80 = this->network_infos.begin(); _iter80 != this->network_infos.end(); ++_iter80)
      {
        xfer += (*_iter80).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(server_info &a, server_info &b) {
  using ::std::swap;
  swap(a.initiator_name, b.initiator_name);
  swap(a.server_id, b.server_id);
  swap(a.server_name, b.server_name);
  swap(a.network_infos, b.network_infos);
  swap(a.__isset, b.__isset);
}

server_info::server_info(const server_info& other81) {
  initiator_name = other81.initiator_name;
  server_id = other81.server_id;
  server_name = other81.server_name;
  network_infos = other81.network_infos;
  __isset = other81.__isset;
}
server_info& server_info::operator=(const server_info& other82) {
  initiator_name = other82.initiator_name;
  server_id = other82.server_id;
  server_name = other82.server_name;
  network_infos = other82.network_infos;
  __isset = other82.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const server_info& obj) {
  using apache::thrift::to_string;
  out << "server_info(";
  out << "initiator_name="; (obj.__isset.initiator_name ? (out << to_string(obj.initiator_name)) : (out << "<null>"));
  out << ", " << "server_id="; (obj.__isset.server_id ? (out << to_string(obj.server_id)) : (out << "<null>"));
  out << ", " << "server_name="; (obj.__isset.server_name ? (out << to_string(obj.server_name)) : (out << "<null>"));
  out << ", " << "network_infos="; (obj.__isset.network_infos ? (out << to_string(obj.network_infos)) : (out << "<null>"));
  out << ")";
  return out;
}


cluster_network::~cluster_network() throw() {
}


void cluster_network::__set_cluster_network_name(const std::string& val) {
  this->cluster_network_name = val;
__isset.cluster_network_name = true;
}

void cluster_network::__set_cluster_network_id(const std::string& val) {
  this->cluster_network_id = val;
__isset.cluster_network_id = true;
}

void cluster_network::__set_cluster_network_address(const std::string& val) {
  this->cluster_network_address = val;
__isset.cluster_network_address = true;
}

void cluster_network::__set_cluster_network_address_mask(const std::string& val) {
  this->cluster_network_address_mask = val;
__isset.cluster_network_address_mask = true;
}

void cluster_network::__set_network_infos(const std::set<network_info> & val) {
  this->network_infos = val;
__isset.network_infos = true;
}

const char* cluster_network::ascii_fingerprint = "AF43E4841CC6FC09852238B8ACF26430";
const uint8_t cluster_network::binary_fingerprint[16] = {0xAF,0x43,0xE4,0x84,0x1C,0xC6,0xFC,0x09,0x85,0x22,0x38,0xB8,0xAC,0xF2,0x64,0x30};

uint32_t cluster_network::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cluster_network_name);
          this->__isset.cluster_network_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cluster_network_id);
          this->__isset.cluster_network_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cluster_network_address);
          this->__isset.cluster_network_address = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cluster_network_address_mask);
          this->__isset.cluster_network_address_mask = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->network_infos.clear();
            uint32_t _size83;
            ::apache::thrift::protocol::TType _etype86;
            xfer += iprot->readSetBegin(_etype86, _size83);
            uint32_t _i87;
            for (_i87 = 0; _i87 < _size83; ++_i87)
            {
              network_info _elem88;
              xfer += _elem88.read(iprot);
              this->network_infos.insert(_elem88);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.network_infos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t cluster_network::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("cluster_network");

  if (this->__isset.cluster_network_name) {
    xfer += oprot->writeFieldBegin("cluster_network_name", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->cluster_network_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_network_id) {
    xfer += oprot->writeFieldBegin("cluster_network_id", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->cluster_network_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_network_address) {
    xfer += oprot->writeFieldBegin("cluster_network_address", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->cluster_network_address);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_network_address_mask) {
    xfer += oprot->writeFieldBegin("cluster_network_address_mask", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->cluster_network_address_mask);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.network_infos) {
    xfer += oprot->writeFieldBegin("network_infos", ::apache::thrift::protocol::T_SET, 5);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->network_infos.size()));
      std::set<network_info> ::const_iterator _iter89;
      for (_iter89 = this->network_infos.begin(); _iter89 != this->network_infos.end(); ++_iter89)
      {
        xfer += (*_iter89).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(cluster_network &a, cluster_network &b) {
  using ::std::swap;
  swap(a.cluster_network_name, b.cluster_network_name);
  swap(a.cluster_network_id, b.cluster_network_id);
  swap(a.cluster_network_address, b.cluster_network_address);
  swap(a.cluster_network_address_mask, b.cluster_network_address_mask);
  swap(a.network_infos, b.network_infos);
  swap(a.__isset, b.__isset);
}

cluster_network::cluster_network(const cluster_network& other90) {
  cluster_network_name = other90.cluster_network_name;
  cluster_network_id = other90.cluster_network_id;
  cluster_network_address = other90.cluster_network_address;
  cluster_network_address_mask = other90.cluster_network_address_mask;
  network_infos = other90.network_infos;
  __isset = other90.__isset;
}
cluster_network& cluster_network::operator=(const cluster_network& other91) {
  cluster_network_name = other91.cluster_network_name;
  cluster_network_id = other91.cluster_network_id;
  cluster_network_address = other91.cluster_network_address;
  cluster_network_address_mask = other91.cluster_network_address_mask;
  network_infos = other91.network_infos;
  __isset = other91.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const cluster_network& obj) {
  using apache::thrift::to_string;
  out << "cluster_network(";
  out << "cluster_network_name="; (obj.__isset.cluster_network_name ? (out << to_string(obj.cluster_network_name)) : (out << "<null>"));
  out << ", " << "cluster_network_id="; (obj.__isset.cluster_network_id ? (out << to_string(obj.cluster_network_id)) : (out << "<null>"));
  out << ", " << "cluster_network_address="; (obj.__isset.cluster_network_address ? (out << to_string(obj.cluster_network_address)) : (out << "<null>"));
  out << ", " << "cluster_network_address_mask="; (obj.__isset.cluster_network_address_mask ? (out << to_string(obj.cluster_network_address_mask)) : (out << "<null>"));
  out << ", " << "network_infos="; (obj.__isset.network_infos ? (out << to_string(obj.network_infos)) : (out << "<null>"));
  out << ")";
  return out;
}


cluster_group::~cluster_group() throw() {
}


void cluster_group::__set_group_id(const std::string& val) {
  this->group_id = val;
__isset.group_id = true;
}

void cluster_group::__set_group_name(const std::string& val) {
  this->group_name = val;
__isset.group_name = true;
}

void cluster_group::__set_group_owner(const std::string& val) {
  this->group_owner = val;
__isset.group_owner = true;
}

void cluster_group::__set_cluster_disks(const std::set<disk_info> & val) {
  this->cluster_disks = val;
__isset.cluster_disks = true;
}

void cluster_group::__set_cluster_partitions(const std::set<volume_info> & val) {
  this->cluster_partitions = val;
__isset.cluster_partitions = true;
}

void cluster_group::__set_cluster_network_infos(const std::set<cluster_network> & val) {
  this->cluster_network_infos = val;
__isset.cluster_network_infos = true;
}

const char* cluster_group::ascii_fingerprint = "5C7E5267DAAC84834D6BA4237633DB5D";
const uint8_t cluster_group::binary_fingerprint[16] = {0x5C,0x7E,0x52,0x67,0xDA,0xAC,0x84,0x83,0x4D,0x6B,0xA4,0x23,0x76,0x33,0xDB,0x5D};

uint32_t cluster_group::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->group_id);
          this->__isset.group_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->group_name);
          this->__isset.group_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->group_owner);
          this->__isset.group_owner = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->cluster_disks.clear();
            uint32_t _size92;
            ::apache::thrift::protocol::TType _etype95;
            xfer += iprot->readSetBegin(_etype95, _size92);
            uint32_t _i96;
            for (_i96 = 0; _i96 < _size92; ++_i96)
            {
              disk_info _elem97;
              xfer += _elem97.read(iprot);
              this->cluster_disks.insert(_elem97);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.cluster_disks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->cluster_partitions.clear();
            uint32_t _size98;
            ::apache::thrift::protocol::TType _etype101;
            xfer += iprot->readSetBegin(_etype101, _size98);
            uint32_t _i102;
            for (_i102 = 0; _i102 < _size98; ++_i102)
            {
              volume_info _elem103;
              xfer += _elem103.read(iprot);
              this->cluster_partitions.insert(_elem103);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.cluster_partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->cluster_network_infos.clear();
            uint32_t _size104;
            ::apache::thrift::protocol::TType _etype107;
            xfer += iprot->readSetBegin(_etype107, _size104);
            uint32_t _i108;
            for (_i108 = 0; _i108 < _size104; ++_i108)
            {
              cluster_network _elem109;
              xfer += _elem109.read(iprot);
              this->cluster_network_infos.insert(_elem109);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.cluster_network_infos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t cluster_group::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("cluster_group");

  if (this->__isset.group_id) {
    xfer += oprot->writeFieldBegin("group_id", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->group_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.group_name) {
    xfer += oprot->writeFieldBegin("group_name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->group_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.group_owner) {
    xfer += oprot->writeFieldBegin("group_owner", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->group_owner);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_disks) {
    xfer += oprot->writeFieldBegin("cluster_disks", ::apache::thrift::protocol::T_SET, 4);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cluster_disks.size()));
      std::set<disk_info> ::const_iterator _iter110;
      for (_iter110 = this->cluster_disks.begin(); _iter110 != this->cluster_disks.end(); ++_iter110)
      {
        xfer += (*_iter110).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_partitions) {
    xfer += oprot->writeFieldBegin("cluster_partitions", ::apache::thrift::protocol::T_SET, 5);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cluster_partitions.size()));
      std::set<volume_info> ::const_iterator _iter111;
      for (_iter111 = this->cluster_partitions.begin(); _iter111 != this->cluster_partitions.end(); ++_iter111)
      {
        xfer += (*_iter111).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_network_infos) {
    xfer += oprot->writeFieldBegin("cluster_network_infos", ::apache::thrift::protocol::T_SET, 6);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cluster_network_infos.size()));
      std::set<cluster_network> ::const_iterator _iter112;
      for (_iter112 = this->cluster_network_infos.begin(); _iter112 != this->cluster_network_infos.end(); ++_iter112)
      {
        xfer += (*_iter112).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(cluster_group &a, cluster_group &b) {
  using ::std::swap;
  swap(a.group_id, b.group_id);
  swap(a.group_name, b.group_name);
  swap(a.group_owner, b.group_owner);
  swap(a.cluster_disks, b.cluster_disks);
  swap(a.cluster_partitions, b.cluster_partitions);
  swap(a.cluster_network_infos, b.cluster_network_infos);
  swap(a.__isset, b.__isset);
}

cluster_group::cluster_group(const cluster_group& other113) {
  group_id = other113.group_id;
  group_name = other113.group_name;
  group_owner = other113.group_owner;
  cluster_disks = other113.cluster_disks;
  cluster_partitions = other113.cluster_partitions;
  cluster_network_infos = other113.cluster_network_infos;
  __isset = other113.__isset;
}
cluster_group& cluster_group::operator=(const cluster_group& other114) {
  group_id = other114.group_id;
  group_name = other114.group_name;
  group_owner = other114.group_owner;
  cluster_disks = other114.cluster_disks;
  cluster_partitions = other114.cluster_partitions;
  cluster_network_infos = other114.cluster_network_infos;
  __isset = other114.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const cluster_group& obj) {
  using apache::thrift::to_string;
  out << "cluster_group(";
  out << "group_id="; (obj.__isset.group_id ? (out << to_string(obj.group_id)) : (out << "<null>"));
  out << ", " << "group_name="; (obj.__isset.group_name ? (out << to_string(obj.group_name)) : (out << "<null>"));
  out << ", " << "group_owner="; (obj.__isset.group_owner ? (out << to_string(obj.group_owner)) : (out << "<null>"));
  out << ", " << "cluster_disks="; (obj.__isset.cluster_disks ? (out << to_string(obj.cluster_disks)) : (out << "<null>"));
  out << ", " << "cluster_partitions="; (obj.__isset.cluster_partitions ? (out << to_string(obj.cluster_partitions)) : (out << "<null>"));
  out << ", " << "cluster_network_infos="; (obj.__isset.cluster_network_infos ? (out << to_string(obj.cluster_network_infos)) : (out << "<null>"));
  out << ")";
  return out;
}


cluster_info::~cluster_info() throw() {
}


void cluster_info::__set_cluster_name(const std::string& val) {
  this->cluster_name = val;
__isset.cluster_name = true;
}

void cluster_info::__set_quorum_disk(const disk_info& val) {
  this->quorum_disk = val;
__isset.quorum_disk = true;
}

void cluster_info::__set_cluster_nodes(const std::set<std::string> & val) {
  this->cluster_nodes = val;
__isset.cluster_nodes = true;
}

void cluster_info::__set_client_ids(const std::set<std::string> & val) {
  this->client_ids = val;
__isset.client_ids = true;
}

void cluster_info::__set_machine_ids(const std::set<std::string> & val) {
  this->machine_ids = val;
__isset.machine_ids = true;
}

void cluster_info::__set_cluster_network_infos(const std::set<cluster_network> & val) {
  this->cluster_network_infos = val;
__isset.cluster_network_infos = true;
}

void cluster_info::__set_cluster_groups(const std::set<cluster_group> & val) {
  this->cluster_groups = val;
__isset.cluster_groups = true;
}

const char* cluster_info::ascii_fingerprint = "C8BAB221FCDC9B72897C67B01F9BAE71";
const uint8_t cluster_info::binary_fingerprint[16] = {0xC8,0xBA,0xB2,0x21,0xFC,0xDC,0x9B,0x72,0x89,0x7C,0x67,0xB0,0x1F,0x9B,0xAE,0x71};

uint32_t cluster_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cluster_name);
          this->__isset.cluster_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->quorum_disk.read(iprot);
          this->__isset.quorum_disk = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->cluster_nodes.clear();
            uint32_t _size115;
            ::apache::thrift::protocol::TType _etype118;
            xfer += iprot->readSetBegin(_etype118, _size115);
            uint32_t _i119;
            for (_i119 = 0; _i119 < _size115; ++_i119)
            {
              std::string _elem120;
              xfer += iprot->readString(_elem120);
              this->cluster_nodes.insert(_elem120);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.cluster_nodes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->client_ids.clear();
            uint32_t _size121;
            ::apache::thrift::protocol::TType _etype124;
            xfer += iprot->readSetBegin(_etype124, _size121);
            uint32_t _i125;
            for (_i125 = 0; _i125 < _size121; ++_i125)
            {
              std::string _elem126;
              xfer += iprot->readString(_elem126);
              this->client_ids.insert(_elem126);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.client_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->machine_ids.clear();
            uint32_t _size127;
            ::apache::thrift::protocol::TType _etype130;
            xfer += iprot->readSetBegin(_etype130, _size127);
            uint32_t _i131;
            for (_i131 = 0; _i131 < _size127; ++_i131)
            {
              std::string _elem132;
              xfer += iprot->readString(_elem132);
              this->machine_ids.insert(_elem132);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.machine_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->cluster_network_infos.clear();
            uint32_t _size133;
            ::apache::thrift::protocol::TType _etype136;
            xfer += iprot->readSetBegin(_etype136, _size133);
            uint32_t _i137;
            for (_i137 = 0; _i137 < _size133; ++_i137)
            {
              cluster_network _elem138;
              xfer += _elem138.read(iprot);
              this->cluster_network_infos.insert(_elem138);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.cluster_network_infos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->cluster_groups.clear();
            uint32_t _size139;
            ::apache::thrift::protocol::TType _etype142;
            xfer += iprot->readSetBegin(_etype142, _size139);
            uint32_t _i143;
            for (_i143 = 0; _i143 < _size139; ++_i143)
            {
              cluster_group _elem144;
              xfer += _elem144.read(iprot);
              this->cluster_groups.insert(_elem144);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.cluster_groups = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t cluster_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("cluster_info");

  if (this->__isset.cluster_name) {
    xfer += oprot->writeFieldBegin("cluster_name", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->cluster_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.quorum_disk) {
    xfer += oprot->writeFieldBegin("quorum_disk", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->quorum_disk.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_nodes) {
    xfer += oprot->writeFieldBegin("cluster_nodes", ::apache::thrift::protocol::T_SET, 3);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->cluster_nodes.size()));
      std::set<std::string> ::const_iterator _iter145;
      for (_iter145 = this->cluster_nodes.begin(); _iter145 != this->cluster_nodes.end(); ++_iter145)
      {
        xfer += oprot->writeString((*_iter145));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.client_ids) {
    xfer += oprot->writeFieldBegin("client_ids", ::apache::thrift::protocol::T_SET, 4);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->client_ids.size()));
      std::set<std::string> ::const_iterator _iter146;
      for (_iter146 = this->client_ids.begin(); _iter146 != this->client_ids.end(); ++_iter146)
      {
        xfer += oprot->writeString((*_iter146));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.machine_ids) {
    xfer += oprot->writeFieldBegin("machine_ids", ::apache::thrift::protocol::T_SET, 5);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->machine_ids.size()));
      std::set<std::string> ::const_iterator _iter147;
      for (_iter147 = this->machine_ids.begin(); _iter147 != this->machine_ids.end(); ++_iter147)
      {
        xfer += oprot->writeString((*_iter147));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_network_infos) {
    xfer += oprot->writeFieldBegin("cluster_network_infos", ::apache::thrift::protocol::T_SET, 6);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cluster_network_infos.size()));
      std::set<cluster_network> ::const_iterator _iter148;
      for (_iter148 = this->cluster_network_infos.begin(); _iter148 != this->cluster_network_infos.end(); ++_iter148)
      {
        xfer += (*_iter148).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_groups) {
    xfer += oprot->writeFieldBegin("cluster_groups", ::apache::thrift::protocol::T_SET, 7);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cluster_groups.size()));
      std::set<cluster_group> ::const_iterator _iter149;
      for (_iter149 = this->cluster_groups.begin(); _iter149 != this->cluster_groups.end(); ++_iter149)
      {
        xfer += (*_iter149).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(cluster_info &a, cluster_info &b) {
  using ::std::swap;
  swap(a.cluster_name, b.cluster_name);
  swap(a.quorum_disk, b.quorum_disk);
  swap(a.cluster_nodes, b.cluster_nodes);
  swap(a.client_ids, b.client_ids);
  swap(a.machine_ids, b.machine_ids);
  swap(a.cluster_network_infos, b.cluster_network_infos);
  swap(a.cluster_groups, b.cluster_groups);
  swap(a.__isset, b.__isset);
}

cluster_info::cluster_info(const cluster_info& other150) {
  cluster_name = other150.cluster_name;
  quorum_disk = other150.quorum_disk;
  cluster_nodes = other150.cluster_nodes;
  client_ids = other150.client_ids;
  machine_ids = other150.machine_ids;
  cluster_network_infos = other150.cluster_network_infos;
  cluster_groups = other150.cluster_groups;
  __isset = other150.__isset;
}
cluster_info& cluster_info::operator=(const cluster_info& other151) {
  cluster_name = other151.cluster_name;
  quorum_disk = other151.quorum_disk;
  cluster_nodes = other151.cluster_nodes;
  client_ids = other151.client_ids;
  machine_ids = other151.machine_ids;
  cluster_network_infos = other151.cluster_network_infos;
  cluster_groups = other151.cluster_groups;
  __isset = other151.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const cluster_info& obj) {
  using apache::thrift::to_string;
  out << "cluster_info(";
  out << "cluster_name="; (obj.__isset.cluster_name ? (out << to_string(obj.cluster_name)) : (out << "<null>"));
  out << ", " << "quorum_disk="; (obj.__isset.quorum_disk ? (out << to_string(obj.quorum_disk)) : (out << "<null>"));
  out << ", " << "cluster_nodes="; (obj.__isset.cluster_nodes ? (out << to_string(obj.cluster_nodes)) : (out << "<null>"));
  out << ", " << "client_ids="; (obj.__isset.client_ids ? (out << to_string(obj.client_ids)) : (out << "<null>"));
  out << ", " << "machine_ids="; (obj.__isset.machine_ids ? (out << to_string(obj.machine_ids)) : (out << "<null>"));
  out << ", " << "cluster_network_infos="; (obj.__isset.cluster_network_infos ? (out << to_string(obj.cluster_network_infos)) : (out << "<null>"));
  out << ", " << "cluster_groups="; (obj.__isset.cluster_groups ? (out << to_string(obj.cluster_groups)) : (out << "<null>"));
  out << ")";
  return out;
}


agent_info::~agent_info() throw() {
}


void agent_info::__set_agent_id(const std::string& val) {
  this->agent_id = val;
__isset.agent_id = true;
}

void agent_info::__set_agent_name(const std::string& val) {
  this->agent_name = val;
__isset.agent_name = true;
}

void agent_info::__set_agent_version(const std::string& val) {
  this->agent_version = val;
__isset.agent_version = true;
}

void agent_info::__set_status(const int64_t val) {
  this->status = val;
__isset.status = true;
}

const char* agent_info::ascii_fingerprint = "EA56942314ECD5D27DC4278DCD614C8D";
const uint8_t agent_info::binary_fingerprint[16] = {0xEA,0x56,0x94,0x23,0x14,0xEC,0xD5,0xD2,0x7D,0xC4,0x27,0x8D,0xCD,0x61,0x4C,0x8D};

uint32_t agent_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->agent_id);
          this->__isset.agent_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->agent_name);
          this->__isset.agent_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->agent_version);
          this->__isset.agent_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->status);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t agent_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("agent_info");

  if (this->__isset.agent_id) {
    xfer += oprot->writeFieldBegin("agent_id", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->agent_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.agent_name) {
    xfer += oprot->writeFieldBegin("agent_name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->agent_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.agent_version) {
    xfer += oprot->writeFieldBegin("agent_version", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->agent_version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.status) {
    xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->status);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(agent_info &a, agent_info &b) {
  using ::std::swap;
  swap(a.agent_id, b.agent_id);
  swap(a.agent_name, b.agent_name);
  swap(a.agent_version, b.agent_version);
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

agent_info::agent_info(const agent_info& other152) {
  agent_id = other152.agent_id;
  agent_name = other152.agent_name;
  agent_version = other152.agent_version;
  status = other152.status;
  __isset = other152.__isset;
}
agent_info& agent_info::operator=(const agent_info& other153) {
  agent_id = other153.agent_id;
  agent_name = other153.agent_name;
  agent_version = other153.agent_version;
  status = other153.status;
  __isset = other153.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const agent_info& obj) {
  using apache::thrift::to_string;
  out << "agent_info(";
  out << "agent_id="; (obj.__isset.agent_id ? (out << to_string(obj.agent_id)) : (out << "<null>"));
  out << ", " << "agent_name="; (obj.__isset.agent_name ? (out << to_string(obj.agent_name)) : (out << "<null>"));
  out << ", " << "agent_version="; (obj.__isset.agent_version ? (out << to_string(obj.agent_version)) : (out << "<null>"));
  out << ", " << "status="; (obj.__isset.status ? (out << to_string(obj.status)) : (out << "<null>"));
  out << ")";
  return out;
}


os_version_info::~os_version_info() throw() {
}


void os_version_info::__set_csd_version(const std::string& val) {
  this->csd_version = val;
__isset.csd_version = true;
}

void os_version_info::__set_build_number(const int32_t val) {
  this->build_number = val;
__isset.build_number = true;
}

void os_version_info::__set_major_version(const int32_t val) {
  this->major_version = val;
__isset.major_version = true;
}

void os_version_info::__set_minor_version(const int32_t val) {
  this->minor_version = val;
__isset.minor_version = true;
}

void os_version_info::__set_platform_id(const int32_t val) {
  this->platform_id = val;
__isset.platform_id = true;
}

void os_version_info::__set_product_type(const int16_t val) {
  this->product_type = val;
__isset.product_type = true;
}

void os_version_info::__set_servicepack_major(const int32_t val) {
  this->servicepack_major = val;
__isset.servicepack_major = true;
}

void os_version_info::__set_servicepack_minor(const int32_t val) {
  this->servicepack_minor = val;
__isset.servicepack_minor = true;
}

void os_version_info::__set_suite_mask(const int32_t val) {
  this->suite_mask = val;
__isset.suite_mask = true;
}

const char* os_version_info::ascii_fingerprint = "255B0BEA48975067F628CED39DEE9D25";
const uint8_t os_version_info::binary_fingerprint[16] = {0x25,0x5B,0x0B,0xEA,0x48,0x97,0x50,0x67,0xF6,0x28,0xCE,0xD3,0x9D,0xEE,0x9D,0x25};

uint32_t os_version_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->csd_version);
          this->__isset.csd_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->build_number);
          this->__isset.build_number = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->major_version);
          this->__isset.major_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->minor_version);
          this->__isset.minor_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->platform_id);
          this->__isset.platform_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->product_type);
          this->__isset.product_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->servicepack_major);
          this->__isset.servicepack_major = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->servicepack_minor);
          this->__isset.servicepack_minor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->suite_mask);
          this->__isset.suite_mask = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t os_version_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("os_version_info");

  if (this->__isset.csd_version) {
    xfer += oprot->writeFieldBegin("csd_version", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->csd_version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.build_number) {
    xfer += oprot->writeFieldBegin("build_number", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->build_number);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.major_version) {
    xfer += oprot->writeFieldBegin("major_version", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->major_version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.minor_version) {
    xfer += oprot->writeFieldBegin("minor_version", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->minor_version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.platform_id) {
    xfer += oprot->writeFieldBegin("platform_id", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->platform_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.product_type) {
    xfer += oprot->writeFieldBegin("product_type", ::apache::thrift::protocol::T_I16, 6);
    xfer += oprot->writeI16(this->product_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.servicepack_major) {
    xfer += oprot->writeFieldBegin("servicepack_major", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32(this->servicepack_major);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.servicepack_minor) {
    xfer += oprot->writeFieldBegin("servicepack_minor", ::apache::thrift::protocol::T_I32, 8);
    xfer += oprot->writeI32(this->servicepack_minor);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.suite_mask) {
    xfer += oprot->writeFieldBegin("suite_mask", ::apache::thrift::protocol::T_I32, 9);
    xfer += oprot->writeI32(this->suite_mask);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(os_version_info &a, os_version_info &b) {
  using ::std::swap;
  swap(a.csd_version, b.csd_version);
  swap(a.build_number, b.build_number);
  swap(a.major_version, b.major_version);
  swap(a.minor_version, b.minor_version);
  swap(a.platform_id, b.platform_id);
  swap(a.product_type, b.product_type);
  swap(a.servicepack_major, b.servicepack_major);
  swap(a.servicepack_minor, b.servicepack_minor);
  swap(a.suite_mask, b.suite_mask);
  swap(a.__isset, b.__isset);
}

os_version_info::os_version_info(const os_version_info& other154) {
  csd_version = other154.csd_version;
  build_number = other154.build_number;
  major_version = other154.major_version;
  minor_version = other154.minor_version;
  platform_id = other154.platform_id;
  product_type = other154.product_type;
  servicepack_major = other154.servicepack_major;
  servicepack_minor = other154.servicepack_minor;
  suite_mask = other154.suite_mask;
  __isset = other154.__isset;
}
os_version_info& os_version_info::operator=(const os_version_info& other155) {
  csd_version = other155.csd_version;
  build_number = other155.build_number;
  major_version = other155.major_version;
  minor_version = other155.minor_version;
  platform_id = other155.platform_id;
  product_type = other155.product_type;
  servicepack_major = other155.servicepack_major;
  servicepack_minor = other155.servicepack_minor;
  suite_mask = other155.suite_mask;
  __isset = other155.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const os_version_info& obj) {
  using apache::thrift::to_string;
  out << "os_version_info(";
  out << "csd_version="; (obj.__isset.csd_version ? (out << to_string(obj.csd_version)) : (out << "<null>"));
  out << ", " << "build_number="; (obj.__isset.build_number ? (out << to_string(obj.build_number)) : (out << "<null>"));
  out << ", " << "major_version="; (obj.__isset.major_version ? (out << to_string(obj.major_version)) : (out << "<null>"));
  out << ", " << "minor_version="; (obj.__isset.minor_version ? (out << to_string(obj.minor_version)) : (out << "<null>"));
  out << ", " << "platform_id="; (obj.__isset.platform_id ? (out << to_string(obj.platform_id)) : (out << "<null>"));
  out << ", " << "product_type="; (obj.__isset.product_type ? (out << to_string(obj.product_type)) : (out << "<null>"));
  out << ", " << "servicepack_major="; (obj.__isset.servicepack_major ? (out << to_string(obj.servicepack_major)) : (out << "<null>"));
  out << ", " << "servicepack_minor="; (obj.__isset.servicepack_minor ? (out << to_string(obj.servicepack_minor)) : (out << "<null>"));
  out << ", " << "suite_mask="; (obj.__isset.suite_mask ? (out << to_string(obj.suite_mask)) : (out << "<null>"));
  out << ")";
  return out;
}


client_info::~client_info() throw() {
}


void client_info::__set_architecture(const std::string& val) {
  this->architecture = val;
__isset.architecture = true;
}

void client_info::__set_client_id(const std::string& val) {
  this->client_id = val;
__isset.client_id = true;
}

void client_info::__set_client_name(const std::string& val) {
  this->client_name = val;
__isset.client_name = true;
}

void client_info::__set_domain(const std::string& val) {
  this->domain = val;
__isset.domain = true;
}

void client_info::__set_hal(const std::string& val) {
  this->hal = val;
__isset.hal = true;
}

void client_info::__set_initiator_name(const std::string& val) {
  this->initiator_name = val;
__isset.initiator_name = true;
}

void client_info::__set_is_oem(const bool val) {
  this->is_oem = val;
__isset.is_oem = true;
}

void client_info::__set_logical_processors(const int16_t val) {
  this->logical_processors = val;
__isset.logical_processors = true;
}

void client_info::__set_machine_id(const std::string& val) {
  this->machine_id = val;
__isset.machine_id = true;
}

void client_info::__set_manufacturer(const std::string& val) {
  this->manufacturer = val;
__isset.manufacturer = true;
}

void client_info::__set_os_name(const std::string& val) {
  this->os_name = val;
__isset.os_name = true;
}

void client_info::__set_os_type(const int32_t val) {
  this->os_type = val;
__isset.os_type = true;
}

void client_info::__set_os_system_info(const std::string& val) {
  this->os_system_info = val;
__isset.os_system_info = true;
}

void client_info::__set_physical_memory(const int64_t val) {
  this->physical_memory = val;
__isset.physical_memory = true;
}

void client_info::__set_processors(const int16_t val) {
  this->processors = val;
__isset.processors = true;
}

void client_info::__set_role(const int32_t val) {
  this->role = val;
__isset.role = true;
}

void client_info::__set_system_model(const std::string& val) {
  this->system_model = val;
__isset.system_model = true;
}

void client_info::__set_system_root(const std::string& val) {
  this->system_root = val;
__isset.system_root = true;
}

void client_info::__set_workgroup(const std::string& val) {
  this->workgroup = val;
__isset.workgroup = true;
}

void client_info::__set_os_version(const os_version_info& val) {
  this->os_version = val;
__isset.os_version = true;
}

void client_info::__set_agent_infos(const std::set<agent_info> & val) {
  this->agent_infos = val;
__isset.agent_infos = true;
}

void client_info::__set_cluster_infos(const std::set<cluster_info> & val) {
  this->cluster_infos = val;
__isset.cluster_infos = true;
}

void client_info::__set_disk_infos(const std::set<disk_info> & val) {
  this->disk_infos = val;
__isset.disk_infos = true;
}

void client_info::__set_network_infos(const std::set<network_info> & val) {
  this->network_infos = val;
__isset.network_infos = true;
}

void client_info::__set_partition_infos(const std::set<partition_info> & val) {
  this->partition_infos = val;
__isset.partition_infos = true;
}

void client_info::__set_protection_relationships(const std::map<std::string, protection_relationship> & val) {
  this->protection_relationships = val;
__isset.protection_relationships = true;
}

void client_info::__set_protection_sets(const std::set<protection_set> & val) {
  this->protection_sets = val;
__isset.protection_sets = true;
}

void client_info::__set_storage_infos(const std::set<storage_info> & val) {
  this->storage_infos = val;
__isset.storage_infos = true;
}

void client_info::__set_volume_infos(const std::set<volume_info> & val) {
  this->volume_infos = val;
__isset.volume_infos = true;
}

const char* client_info::ascii_fingerprint = "86268AF2F5D2F1EF9E8A15E93D6927E0";
const uint8_t client_info::binary_fingerprint[16] = {0x86,0x26,0x8A,0xF2,0xF5,0xD2,0xF1,0xEF,0x9E,0x8A,0x15,0xE9,0x3D,0x69,0x27,0xE0};

uint32_t client_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->architecture);
          this->__isset.architecture = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->client_id);
          this->__isset.client_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->client_name);
          this->__isset.client_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->domain);
          this->__isset.domain = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hal);
          this->__isset.hal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->initiator_name);
          this->__isset.initiator_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_oem);
          this->__isset.is_oem = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->logical_processors);
          this->__isset.logical_processors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->machine_id);
          this->__isset.machine_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->manufacturer);
          this->__isset.manufacturer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->os_name);
          this->__isset.os_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->os_type);
          this->__isset.os_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->os_system_info);
          this->__isset.os_system_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->physical_memory);
          this->__isset.physical_memory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->processors);
          this->__isset.processors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->role);
          this->__isset.role = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->system_model);
          this->__isset.system_model = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->system_root);
          this->__isset.system_root = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->workgroup);
          this->__isset.workgroup = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->os_version.read(iprot);
          this->__isset.os_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->agent_infos.clear();
            uint32_t _size156;
            ::apache::thrift::protocol::TType _etype159;
            xfer += iprot->readSetBegin(_etype159, _size156);
            uint32_t _i160;
            for (_i160 = 0; _i160 < _size156; ++_i160)
            {
              agent_info _elem161;
              xfer += _elem161.read(iprot);
              this->agent_infos.insert(_elem161);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.agent_infos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->cluster_infos.clear();
            uint32_t _size162;
            ::apache::thrift::protocol::TType _etype165;
            xfer += iprot->readSetBegin(_etype165, _size162);
            uint32_t _i166;
            for (_i166 = 0; _i166 < _size162; ++_i166)
            {
              cluster_info _elem167;
              xfer += _elem167.read(iprot);
              this->cluster_infos.insert(_elem167);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.cluster_infos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->disk_infos.clear();
            uint32_t _size168;
            ::apache::thrift::protocol::TType _etype171;
            xfer += iprot->readSetBegin(_etype171, _size168);
            uint32_t _i172;
            for (_i172 = 0; _i172 < _size168; ++_i172)
            {
              disk_info _elem173;
              xfer += _elem173.read(iprot);
              this->disk_infos.insert(_elem173);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.disk_infos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->network_infos.clear();
            uint32_t _size174;
            ::apache::thrift::protocol::TType _etype177;
            xfer += iprot->readSetBegin(_etype177, _size174);
            uint32_t _i178;
            for (_i178 = 0; _i178 < _size174; ++_i178)
            {
              network_info _elem179;
              xfer += _elem179.read(iprot);
              this->network_infos.insert(_elem179);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.network_infos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->partition_infos.clear();
            uint32_t _size180;
            ::apache::thrift::protocol::TType _etype183;
            xfer += iprot->readSetBegin(_etype183, _size180);
            uint32_t _i184;
            for (_i184 = 0; _i184 < _size180; ++_i184)
            {
              partition_info _elem185;
              xfer += _elem185.read(iprot);
              this->partition_infos.insert(_elem185);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.partition_infos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 26:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->protection_relationships.clear();
            uint32_t _size186;
            ::apache::thrift::protocol::TType _ktype187;
            ::apache::thrift::protocol::TType _vtype188;
            xfer += iprot->readMapBegin(_ktype187, _vtype188, _size186);
            uint32_t _i190;
            for (_i190 = 0; _i190 < _size186; ++_i190)
            {
              std::string _key191;
              xfer += iprot->readString(_key191);
              protection_relationship& _val192 = this->protection_relationships[_key191];
              xfer += _val192.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.protection_relationships = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 27:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->protection_sets.clear();
            uint32_t _size193;
            ::apache::thrift::protocol::TType _etype196;
            xfer += iprot->readSetBegin(_etype196, _size193);
            uint32_t _i197;
            for (_i197 = 0; _i197 < _size193; ++_i197)
            {
              protection_set _elem198;
              xfer += _elem198.read(iprot);
              this->protection_sets.insert(_elem198);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.protection_sets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 28:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->storage_infos.clear();
            uint32_t _size199;
            ::apache::thrift::protocol::TType _etype202;
            xfer += iprot->readSetBegin(_etype202, _size199);
            uint32_t _i203;
            for (_i203 = 0; _i203 < _size199; ++_i203)
            {
              storage_info _elem204;
              xfer += _elem204.read(iprot);
              this->storage_infos.insert(_elem204);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.storage_infos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 29:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->volume_infos.clear();
            uint32_t _size205;
            ::apache::thrift::protocol::TType _etype208;
            xfer += iprot->readSetBegin(_etype208, _size205);
            uint32_t _i209;
            for (_i209 = 0; _i209 < _size205; ++_i209)
            {
              volume_info _elem210;
              xfer += _elem210.read(iprot);
              this->volume_infos.insert(_elem210);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.volume_infos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t client_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("client_info");

  if (this->__isset.architecture) {
    xfer += oprot->writeFieldBegin("architecture", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->architecture);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.client_id) {
    xfer += oprot->writeFieldBegin("client_id", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->client_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.client_name) {
    xfer += oprot->writeFieldBegin("client_name", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->client_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.domain) {
    xfer += oprot->writeFieldBegin("domain", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->domain);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.hal) {
    xfer += oprot->writeFieldBegin("hal", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->hal);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.initiator_name) {
    xfer += oprot->writeFieldBegin("initiator_name", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->initiator_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_oem) {
    xfer += oprot->writeFieldBegin("is_oem", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->is_oem);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.logical_processors) {
    xfer += oprot->writeFieldBegin("logical_processors", ::apache::thrift::protocol::T_I16, 8);
    xfer += oprot->writeI16(this->logical_processors);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.machine_id) {
    xfer += oprot->writeFieldBegin("machine_id", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->machine_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.manufacturer) {
    xfer += oprot->writeFieldBegin("manufacturer", ::apache::thrift::protocol::T_STRING, 10);
    xfer += oprot->writeString(this->manufacturer);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.os_name) {
    xfer += oprot->writeFieldBegin("os_name", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeString(this->os_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.os_type) {
    xfer += oprot->writeFieldBegin("os_type", ::apache::thrift::protocol::T_I32, 12);
    xfer += oprot->writeI32(this->os_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.os_system_info) {
    xfer += oprot->writeFieldBegin("os_system_info", ::apache::thrift::protocol::T_STRING, 13);
    xfer += oprot->writeString(this->os_system_info);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.physical_memory) {
    xfer += oprot->writeFieldBegin("physical_memory", ::apache::thrift::protocol::T_I64, 14);
    xfer += oprot->writeI64(this->physical_memory);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.processors) {
    xfer += oprot->writeFieldBegin("processors", ::apache::thrift::protocol::T_I16, 15);
    xfer += oprot->writeI16(this->processors);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.role) {
    xfer += oprot->writeFieldBegin("role", ::apache::thrift::protocol::T_I32, 16);
    xfer += oprot->writeI32(this->role);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.system_model) {
    xfer += oprot->writeFieldBegin("system_model", ::apache::thrift::protocol::T_STRING, 17);
    xfer += oprot->writeString(this->system_model);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.system_root) {
    xfer += oprot->writeFieldBegin("system_root", ::apache::thrift::protocol::T_STRING, 18);
    xfer += oprot->writeString(this->system_root);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.workgroup) {
    xfer += oprot->writeFieldBegin("workgroup", ::apache::thrift::protocol::T_STRING, 19);
    xfer += oprot->writeString(this->workgroup);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.os_version) {
    xfer += oprot->writeFieldBegin("os_version", ::apache::thrift::protocol::T_STRUCT, 20);
    xfer += this->os_version.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.agent_infos) {
    xfer += oprot->writeFieldBegin("agent_infos", ::apache::thrift::protocol::T_SET, 21);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->agent_infos.size()));
      std::set<agent_info> ::const_iterator _iter211;
      for (_iter211 = this->agent_infos.begin(); _iter211 != this->agent_infos.end(); ++_iter211)
      {
        xfer += (*_iter211).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_infos) {
    xfer += oprot->writeFieldBegin("cluster_infos", ::apache::thrift::protocol::T_SET, 22);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cluster_infos.size()));
      std::set<cluster_info> ::const_iterator _iter212;
      for (_iter212 = this->cluster_infos.begin(); _iter212 != this->cluster_infos.end(); ++_iter212)
      {
        xfer += (*_iter212).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.disk_infos) {
    xfer += oprot->writeFieldBegin("disk_infos", ::apache::thrift::protocol::T_SET, 23);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->disk_infos.size()));
      std::set<disk_info> ::const_iterator _iter213;
      for (_iter213 = this->disk_infos.begin(); _iter213 != this->disk_infos.end(); ++_iter213)
      {
        xfer += (*_iter213).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.network_infos) {
    xfer += oprot->writeFieldBegin("network_infos", ::apache::thrift::protocol::T_SET, 24);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->network_infos.size()));
      std::set<network_info> ::const_iterator _iter214;
      for (_iter214 = this->network_infos.begin(); _iter214 != this->network_infos.end(); ++_iter214)
      {
        xfer += (*_iter214).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partition_infos) {
    xfer += oprot->writeFieldBegin("partition_infos", ::apache::thrift::protocol::T_SET, 25);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partition_infos.size()));
      std::set<partition_info> ::const_iterator _iter215;
      for (_iter215 = this->partition_infos.begin(); _iter215 != this->partition_infos.end(); ++_iter215)
      {
        xfer += (*_iter215).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.protection_relationships) {
    xfer += oprot->writeFieldBegin("protection_relationships", ::apache::thrift::protocol::T_MAP, 26);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->protection_relationships.size()));
      std::map<std::string, protection_relationship> ::const_iterator _iter216;
      for (_iter216 = this->protection_relationships.begin(); _iter216 != this->protection_relationships.end(); ++_iter216)
      {
        xfer += oprot->writeString(_iter216->first);
        xfer += _iter216->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.protection_sets) {
    xfer += oprot->writeFieldBegin("protection_sets", ::apache::thrift::protocol::T_SET, 27);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->protection_sets.size()));
      std::set<protection_set> ::const_iterator _iter217;
      for (_iter217 = this->protection_sets.begin(); _iter217 != this->protection_sets.end(); ++_iter217)
      {
        xfer += (*_iter217).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.storage_infos) {
    xfer += oprot->writeFieldBegin("storage_infos", ::apache::thrift::protocol::T_SET, 28);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->storage_infos.size()));
      std::set<storage_info> ::const_iterator _iter218;
      for (_iter218 = this->storage_infos.begin(); _iter218 != this->storage_infos.end(); ++_iter218)
      {
        xfer += (*_iter218).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.volume_infos) {
    xfer += oprot->writeFieldBegin("volume_infos", ::apache::thrift::protocol::T_SET, 29);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->volume_infos.size()));
      std::set<volume_info> ::const_iterator _iter219;
      for (_iter219 = this->volume_infos.begin(); _iter219 != this->volume_infos.end(); ++_iter219)
      {
        xfer += (*_iter219).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(client_info &a, client_info &b) {
  using ::std::swap;
  swap(a.architecture, b.architecture);
  swap(a.client_id, b.client_id);
  swap(a.client_name, b.client_name);
  swap(a.domain, b.domain);
  swap(a.hal, b.hal);
  swap(a.initiator_name, b.initiator_name);
  swap(a.is_oem, b.is_oem);
  swap(a.logical_processors, b.logical_processors);
  swap(a.machine_id, b.machine_id);
  swap(a.manufacturer, b.manufacturer);
  swap(a.os_name, b.os_name);
  swap(a.os_type, b.os_type);
  swap(a.os_system_info, b.os_system_info);
  swap(a.physical_memory, b.physical_memory);
  swap(a.processors, b.processors);
  swap(a.role, b.role);
  swap(a.system_model, b.system_model);
  swap(a.system_root, b.system_root);
  swap(a.workgroup, b.workgroup);
  swap(a.os_version, b.os_version);
  swap(a.agent_infos, b.agent_infos);
  swap(a.cluster_infos, b.cluster_infos);
  swap(a.disk_infos, b.disk_infos);
  swap(a.network_infos, b.network_infos);
  swap(a.partition_infos, b.partition_infos);
  swap(a.protection_relationships, b.protection_relationships);
  swap(a.protection_sets, b.protection_sets);
  swap(a.storage_infos, b.storage_infos);
  swap(a.volume_infos, b.volume_infos);
  swap(a.__isset, b.__isset);
}

client_info::client_info(const client_info& other220) {
  architecture = other220.architecture;
  client_id = other220.client_id;
  client_name = other220.client_name;
  domain = other220.domain;
  hal = other220.hal;
  initiator_name = other220.initiator_name;
  is_oem = other220.is_oem;
  logical_processors = other220.logical_processors;
  machine_id = other220.machine_id;
  manufacturer = other220.manufacturer;
  os_name = other220.os_name;
  os_type = other220.os_type;
  os_system_info = other220.os_system_info;
  physical_memory = other220.physical_memory;
  processors = other220.processors;
  role = other220.role;
  system_model = other220.system_model;
  system_root = other220.system_root;
  workgroup = other220.workgroup;
  os_version = other220.os_version;
  agent_infos = other220.agent_infos;
  cluster_infos = other220.cluster_infos;
  disk_infos = other220.disk_infos;
  network_infos = other220.network_infos;
  partition_infos = other220.partition_infos;
  protection_relationships = other220.protection_relationships;
  protection_sets = other220.protection_sets;
  storage_infos = other220.storage_infos;
  volume_infos = other220.volume_infos;
  __isset = other220.__isset;
}
client_info& client_info::operator=(const client_info& other221) {
  architecture = other221.architecture;
  client_id = other221.client_id;
  client_name = other221.client_name;
  domain = other221.domain;
  hal = other221.hal;
  initiator_name = other221.initiator_name;
  is_oem = other221.is_oem;
  logical_processors = other221.logical_processors;
  machine_id = other221.machine_id;
  manufacturer = other221.manufacturer;
  os_name = other221.os_name;
  os_type = other221.os_type;
  os_system_info = other221.os_system_info;
  physical_memory = other221.physical_memory;
  processors = other221.processors;
  role = other221.role;
  system_model = other221.system_model;
  system_root = other221.system_root;
  workgroup = other221.workgroup;
  os_version = other221.os_version;
  agent_infos = other221.agent_infos;
  cluster_infos = other221.cluster_infos;
  disk_infos = other221.disk_infos;
  network_infos = other221.network_infos;
  partition_infos = other221.partition_infos;
  protection_relationships = other221.protection_relationships;
  protection_sets = other221.protection_sets;
  storage_infos = other221.storage_infos;
  volume_infos = other221.volume_infos;
  __isset = other221.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const client_info& obj) {
  using apache::thrift::to_string;
  out << "client_info(";
  out << "architecture="; (obj.__isset.architecture ? (out << to_string(obj.architecture)) : (out << "<null>"));
  out << ", " << "client_id="; (obj.__isset.client_id ? (out << to_string(obj.client_id)) : (out << "<null>"));
  out << ", " << "client_name="; (obj.__isset.client_name ? (out << to_string(obj.client_name)) : (out << "<null>"));
  out << ", " << "domain="; (obj.__isset.domain ? (out << to_string(obj.domain)) : (out << "<null>"));
  out << ", " << "hal="; (obj.__isset.hal ? (out << to_string(obj.hal)) : (out << "<null>"));
  out << ", " << "initiator_name="; (obj.__isset.initiator_name ? (out << to_string(obj.initiator_name)) : (out << "<null>"));
  out << ", " << "is_oem="; (obj.__isset.is_oem ? (out << to_string(obj.is_oem)) : (out << "<null>"));
  out << ", " << "logical_processors="; (obj.__isset.logical_processors ? (out << to_string(obj.logical_processors)) : (out << "<null>"));
  out << ", " << "machine_id="; (obj.__isset.machine_id ? (out << to_string(obj.machine_id)) : (out << "<null>"));
  out << ", " << "manufacturer="; (obj.__isset.manufacturer ? (out << to_string(obj.manufacturer)) : (out << "<null>"));
  out << ", " << "os_name="; (obj.__isset.os_name ? (out << to_string(obj.os_name)) : (out << "<null>"));
  out << ", " << "os_type="; (obj.__isset.os_type ? (out << to_string(obj.os_type)) : (out << "<null>"));
  out << ", " << "os_system_info="; (obj.__isset.os_system_info ? (out << to_string(obj.os_system_info)) : (out << "<null>"));
  out << ", " << "physical_memory="; (obj.__isset.physical_memory ? (out << to_string(obj.physical_memory)) : (out << "<null>"));
  out << ", " << "processors="; (obj.__isset.processors ? (out << to_string(obj.processors)) : (out << "<null>"));
  out << ", " << "role="; (obj.__isset.role ? (out << to_string(obj.role)) : (out << "<null>"));
  out << ", " << "system_model="; (obj.__isset.system_model ? (out << to_string(obj.system_model)) : (out << "<null>"));
  out << ", " << "system_root="; (obj.__isset.system_root ? (out << to_string(obj.system_root)) : (out << "<null>"));
  out << ", " << "workgroup="; (obj.__isset.workgroup ? (out << to_string(obj.workgroup)) : (out << "<null>"));
  out << ", " << "os_version="; (obj.__isset.os_version ? (out << to_string(obj.os_version)) : (out << "<null>"));
  out << ", " << "agent_infos="; (obj.__isset.agent_infos ? (out << to_string(obj.agent_infos)) : (out << "<null>"));
  out << ", " << "cluster_infos="; (obj.__isset.cluster_infos ? (out << to_string(obj.cluster_infos)) : (out << "<null>"));
  out << ", " << "disk_infos="; (obj.__isset.disk_infos ? (out << to_string(obj.disk_infos)) : (out << "<null>"));
  out << ", " << "network_infos="; (obj.__isset.network_infos ? (out << to_string(obj.network_infos)) : (out << "<null>"));
  out << ", " << "partition_infos="; (obj.__isset.partition_infos ? (out << to_string(obj.partition_infos)) : (out << "<null>"));
  out << ", " << "protection_relationships="; (obj.__isset.protection_relationships ? (out << to_string(obj.protection_relationships)) : (out << "<null>"));
  out << ", " << "protection_sets="; (obj.__isset.protection_sets ? (out << to_string(obj.protection_sets)) : (out << "<null>"));
  out << ", " << "storage_infos="; (obj.__isset.storage_infos ? (out << to_string(obj.storage_infos)) : (out << "<null>"));
  out << ", " << "volume_infos="; (obj.__isset.volume_infos ? (out << to_string(obj.volume_infos)) : (out << "<null>"));
  out << ")";
  return out;
}


command_request::~command_request() throw() {
}


void command_request::__set_command(const std::string& val) {
  this->command = val;
__isset.command = true;
}

void command_request::__set_event_id(const std::string& val) {
  this->event_id = val;
__isset.event_id = true;
}

void command_request::__set_pre_command(const std::string& val) {
  this->pre_command = val;
__isset.pre_command = true;
}

void command_request::__set_post_command(const std::string& val) {
  this->post_command = val;
__isset.post_command = true;
}

void command_request::__set_set_ids(const std::set<std::string> & val) {
  this->set_ids = val;
__isset.set_ids = true;
}

void command_request::__set_protection_relationships(const std::map<std::string, protection_relationship> & val) {
  this->protection_relationships = val;
__isset.protection_relationships = true;
}

void command_request::__set_protection_sets(const std::set<protection_set> & val) {
  this->protection_sets = val;
__isset.protection_sets = true;
}

const char* command_request::ascii_fingerprint = "DEBEE7CA4E3650EBAC0ED438704A51CF";
const uint8_t command_request::binary_fingerprint[16] = {0xDE,0xBE,0xE7,0xCA,0x4E,0x36,0x50,0xEB,0xAC,0x0E,0xD4,0x38,0x70,0x4A,0x51,0xCF};

uint32_t command_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->command);
          this->__isset.command = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->event_id);
          this->__isset.event_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pre_command);
          this->__isset.pre_command = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->post_command);
          this->__isset.post_command = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->set_ids.clear();
            uint32_t _size222;
            ::apache::thrift::protocol::TType _etype225;
            xfer += iprot->readSetBegin(_etype225, _size222);
            uint32_t _i226;
            for (_i226 = 0; _i226 < _size222; ++_i226)
            {
              std::string _elem227;
              xfer += iprot->readString(_elem227);
              this->set_ids.insert(_elem227);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.set_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->protection_relationships.clear();
            uint32_t _size228;
            ::apache::thrift::protocol::TType _ktype229;
            ::apache::thrift::protocol::TType _vtype230;
            xfer += iprot->readMapBegin(_ktype229, _vtype230, _size228);
            uint32_t _i232;
            for (_i232 = 0; _i232 < _size228; ++_i232)
            {
              std::string _key233;
              xfer += iprot->readString(_key233);
              protection_relationship& _val234 = this->protection_relationships[_key233];
              xfer += _val234.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.protection_relationships = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->protection_sets.clear();
            uint32_t _size235;
            ::apache::thrift::protocol::TType _etype238;
            xfer += iprot->readSetBegin(_etype238, _size235);
            uint32_t _i239;
            for (_i239 = 0; _i239 < _size235; ++_i239)
            {
              protection_set _elem240;
              xfer += _elem240.read(iprot);
              this->protection_sets.insert(_elem240);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.protection_sets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t command_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("command_request");

  if (this->__isset.command) {
    xfer += oprot->writeFieldBegin("command", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->command);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.event_id) {
    xfer += oprot->writeFieldBegin("event_id", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->event_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.pre_command) {
    xfer += oprot->writeFieldBegin("pre_command", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->pre_command);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.post_command) {
    xfer += oprot->writeFieldBegin("post_command", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->post_command);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.set_ids) {
    xfer += oprot->writeFieldBegin("set_ids", ::apache::thrift::protocol::T_SET, 5);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->set_ids.size()));
      std::set<std::string> ::const_iterator _iter241;
      for (_iter241 = this->set_ids.begin(); _iter241 != this->set_ids.end(); ++_iter241)
      {
        xfer += oprot->writeString((*_iter241));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.protection_relationships) {
    xfer += oprot->writeFieldBegin("protection_relationships", ::apache::thrift::protocol::T_MAP, 6);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->protection_relationships.size()));
      std::map<std::string, protection_relationship> ::const_iterator _iter242;
      for (_iter242 = this->protection_relationships.begin(); _iter242 != this->protection_relationships.end(); ++_iter242)
      {
        xfer += oprot->writeString(_iter242->first);
        xfer += _iter242->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.protection_sets) {
    xfer += oprot->writeFieldBegin("protection_sets", ::apache::thrift::protocol::T_SET, 7);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->protection_sets.size()));
      std::set<protection_set> ::const_iterator _iter243;
      for (_iter243 = this->protection_sets.begin(); _iter243 != this->protection_sets.end(); ++_iter243)
      {
        xfer += (*_iter243).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(command_request &a, command_request &b) {
  using ::std::swap;
  swap(a.command, b.command);
  swap(a.event_id, b.event_id);
  swap(a.pre_command, b.pre_command);
  swap(a.post_command, b.post_command);
  swap(a.set_ids, b.set_ids);
  swap(a.protection_relationships, b.protection_relationships);
  swap(a.protection_sets, b.protection_sets);
  swap(a.__isset, b.__isset);
}

command_request::command_request(const command_request& other244) {
  command = other244.command;
  event_id = other244.event_id;
  pre_command = other244.pre_command;
  post_command = other244.post_command;
  set_ids = other244.set_ids;
  protection_relationships = other244.protection_relationships;
  protection_sets = other244.protection_sets;
  __isset = other244.__isset;
}
command_request& command_request::operator=(const command_request& other245) {
  command = other245.command;
  event_id = other245.event_id;
  pre_command = other245.pre_command;
  post_command = other245.post_command;
  set_ids = other245.set_ids;
  protection_relationships = other245.protection_relationships;
  protection_sets = other245.protection_sets;
  __isset = other245.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const command_request& obj) {
  using apache::thrift::to_string;
  out << "command_request(";
  out << "command="; (obj.__isset.command ? (out << to_string(obj.command)) : (out << "<null>"));
  out << ", " << "event_id="; (obj.__isset.event_id ? (out << to_string(obj.event_id)) : (out << "<null>"));
  out << ", " << "pre_command="; (obj.__isset.pre_command ? (out << to_string(obj.pre_command)) : (out << "<null>"));
  out << ", " << "post_command="; (obj.__isset.post_command ? (out << to_string(obj.post_command)) : (out << "<null>"));
  out << ", " << "set_ids="; (obj.__isset.set_ids ? (out << to_string(obj.set_ids)) : (out << "<null>"));
  out << ", " << "protection_relationships="; (obj.__isset.protection_relationships ? (out << to_string(obj.protection_relationships)) : (out << "<null>"));
  out << ", " << "protection_sets="; (obj.__isset.protection_sets ? (out << to_string(obj.protection_sets)) : (out << "<null>"));
  out << ")";
  return out;
}


command_result::~command_result() throw() {
}


void command_result::__set_client_id(const std::string& val) {
  this->client_id = val;
__isset.client_id = true;
}

void command_result::__set_machine_id(const std::string& val) {
  this->machine_id = val;
__isset.machine_id = true;
}

void command_result::__set_code(const int64_t val) {
  this->code = val;
__isset.code = true;
}

void command_result::__set_command(const std::string& val) {
  this->command = val;
__isset.command = true;
}

void command_result::__set_message(const std::string& val) {
  this->message = val;
__isset.message = true;
}

void command_result::__set_event_id(const std::string& val) {
  this->event_id = val;
__isset.event_id = true;
}

void command_result::__set_pre_command_message(const std::string& val) {
  this->pre_command_message = val;
__isset.pre_command_message = true;
}

void command_result::__set_post_command_message(const std::string& val) {
  this->post_command_message = val;
__isset.post_command_message = true;
}

void command_result::__set_set_ids(const std::set<std::string> & val) {
  this->set_ids = val;
__isset.set_ids = true;
}

const char* command_result::ascii_fingerprint = "ACA1F6744558CEAD04C48E10EAC67655";
const uint8_t command_result::binary_fingerprint[16] = {0xAC,0xA1,0xF6,0x74,0x45,0x58,0xCE,0xAD,0x04,0xC4,0x8E,0x10,0xEA,0xC6,0x76,0x55};

uint32_t command_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->client_id);
          this->__isset.client_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->machine_id);
          this->__isset.machine_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->code);
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->command);
          this->__isset.command = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->event_id);
          this->__isset.event_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pre_command_message);
          this->__isset.pre_command_message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->post_command_message);
          this->__isset.post_command_message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->set_ids.clear();
            uint32_t _size246;
            ::apache::thrift::protocol::TType _etype249;
            xfer += iprot->readSetBegin(_etype249, _size246);
            uint32_t _i250;
            for (_i250 = 0; _i250 < _size246; ++_i250)
            {
              std::string _elem251;
              xfer += iprot->readString(_elem251);
              this->set_ids.insert(_elem251);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.set_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t command_result::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("command_result");

  if (this->__isset.client_id) {
    xfer += oprot->writeFieldBegin("client_id", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->client_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.machine_id) {
    xfer += oprot->writeFieldBegin("machine_id", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->machine_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.code) {
    xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->code);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.command) {
    xfer += oprot->writeFieldBegin("command", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->command);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.message) {
    xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->message);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.event_id) {
    xfer += oprot->writeFieldBegin("event_id", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->event_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.pre_command_message) {
    xfer += oprot->writeFieldBegin("pre_command_message", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->pre_command_message);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.post_command_message) {
    xfer += oprot->writeFieldBegin("post_command_message", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->post_command_message);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.set_ids) {
    xfer += oprot->writeFieldBegin("set_ids", ::apache::thrift::protocol::T_SET, 9);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->set_ids.size()));
      std::set<std::string> ::const_iterator _iter252;
      for (_iter252 = this->set_ids.begin(); _iter252 != this->set_ids.end(); ++_iter252)
      {
        xfer += oprot->writeString((*_iter252));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(command_result &a, command_result &b) {
  using ::std::swap;
  swap(a.client_id, b.client_id);
  swap(a.machine_id, b.machine_id);
  swap(a.code, b.code);
  swap(a.command, b.command);
  swap(a.message, b.message);
  swap(a.event_id, b.event_id);
  swap(a.pre_command_message, b.pre_command_message);
  swap(a.post_command_message, b.post_command_message);
  swap(a.set_ids, b.set_ids);
  swap(a.__isset, b.__isset);
}

command_result::command_result(const command_result& other253) {
  client_id = other253.client_id;
  machine_id = other253.machine_id;
  code = other253.code;
  command = other253.command;
  message = other253.message;
  event_id = other253.event_id;
  pre_command_message = other253.pre_command_message;
  post_command_message = other253.post_command_message;
  set_ids = other253.set_ids;
  __isset = other253.__isset;
}
command_result& command_result::operator=(const command_result& other254) {
  client_id = other254.client_id;
  machine_id = other254.machine_id;
  code = other254.code;
  command = other254.command;
  message = other254.message;
  event_id = other254.event_id;
  pre_command_message = other254.pre_command_message;
  post_command_message = other254.post_command_message;
  set_ids = other254.set_ids;
  __isset = other254.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const command_result& obj) {
  using apache::thrift::to_string;
  out << "command_result(";
  out << "client_id="; (obj.__isset.client_id ? (out << to_string(obj.client_id)) : (out << "<null>"));
  out << ", " << "machine_id="; (obj.__isset.machine_id ? (out << to_string(obj.machine_id)) : (out << "<null>"));
  out << ", " << "code="; (obj.__isset.code ? (out << to_string(obj.code)) : (out << "<null>"));
  out << ", " << "command="; (obj.__isset.command ? (out << to_string(obj.command)) : (out << "<null>"));
  out << ", " << "message="; (obj.__isset.message ? (out << to_string(obj.message)) : (out << "<null>"));
  out << ", " << "event_id="; (obj.__isset.event_id ? (out << to_string(obj.event_id)) : (out << "<null>"));
  out << ", " << "pre_command_message="; (obj.__isset.pre_command_message ? (out << to_string(obj.pre_command_message)) : (out << "<null>"));
  out << ", " << "post_command_message="; (obj.__isset.post_command_message ? (out << to_string(obj.post_command_message)) : (out << "<null>"));
  out << ", " << "set_ids="; (obj.__isset.set_ids ? (out << to_string(obj.set_ids)) : (out << "<null>"));
  out << ")";
  return out;
}

}}}} // namespace
