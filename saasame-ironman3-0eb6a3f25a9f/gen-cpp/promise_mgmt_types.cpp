/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "promise_mgmt_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace mwdc { namespace ironman { namespace mgmt {

int _kenumerate_disk_filter_styleValues[] = {
  enumerate_disk_filter_style::ALL_DISK,
  enumerate_disk_filter_style::UNINITIALIZED_DISK
};
const char* _kenumerate_disk_filter_styleNames[] = {
  "ALL_DISK",
  "UNINITIALIZED_DISK"
};
const std::map<int, const char*> _enumerate_disk_filter_style_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kenumerate_disk_filter_styleValues, _kenumerate_disk_filter_styleNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kpartition_styleValues[] = {
  partition_style::PARTITION_UNKNOWN,
  partition_style::PARTITION_MBR,
  partition_style::PARTITION_GPT
};
const char* _kpartition_styleNames[] = {
  "PARTITION_UNKNOWN",
  "PARTITION_MBR",
  "PARTITION_GPT"
};
const std::map<int, const char*> _partition_style_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kpartition_styleValues, _kpartition_styleNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kdrive_typeValues[] = {
  drive_type::DT_UNKNOWN,
  drive_type::DT_NO_ROOT_PATH,
  drive_type::DT_REMOVABLE,
  drive_type::DT_FIXED,
  drive_type::DT_REMOTE,
  drive_type::DT_CDROM,
  drive_type::DT_RAMDISK
};
const char* _kdrive_typeNames[] = {
  "DT_UNKNOWN",
  "DT_NO_ROOT_PATH",
  "DT_REMOVABLE",
  "DT_FIXED",
  "DT_REMOTE",
  "DT_CDROM",
  "DT_RAMDISK"
};
const std::map<int, const char*> _drive_type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kdrive_typeValues, _kdrive_typeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kbus_typeValues[] = {
  bus_type::Unknown,
  bus_type::SCSI,
  bus_type::ATAPI,
  bus_type::ATA,
  bus_type::IEEE_1394,
  bus_type::SSA,
  bus_type::Fibre_Channel,
  bus_type::USB,
  bus_type::RAID,
  bus_type::iSCSI,
  bus_type::SAS,
  bus_type::SATA,
  bus_type::SD,
  bus_type::MMC,
  bus_type::Virtual,
  bus_type::File_Backed_Virtual,
  bus_type::Storage_Spaces,
  bus_type::NVMe
};
const char* _kbus_typeNames[] = {
  "Unknown",
  "SCSI",
  "ATAPI",
  "ATA",
  "IEEE_1394",
  "SSA",
  "Fibre_Channel",
  "USB",
  "RAID",
  "iSCSI",
  "SAS",
  "SATA",
  "SD",
  "MMC",
  "Virtual",
  "File_Backed_Virtual",
  "Storage_Spaces",
  "NVMe"
};
const std::map<int, const char*> _bus_type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(18, _kbus_typeValues, _kbus_typeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _khv_vm_tools_statusValues[] = {
  hv_vm_tools_status::HV_VMTOOLS_UNKNOWN,
  hv_vm_tools_status::HV_VMTOOLS_OK,
  hv_vm_tools_status::HV_VMTOOLS_NOTINSTALLED,
  hv_vm_tools_status::HV_VMTOOLS_OLD,
  hv_vm_tools_status::HV_VMTOOLS_NOTRUNNING
};
const char* _khv_vm_tools_statusNames[] = {
  "HV_VMTOOLS_UNKNOWN",
  "HV_VMTOOLS_OK",
  "HV_VMTOOLS_NOTINSTALLED",
  "HV_VMTOOLS_OLD",
  "HV_VMTOOLS_NOTRUNNING"
};
const std::map<int, const char*> _hv_vm_tools_status_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _khv_vm_tools_statusValues, _khv_vm_tools_statusNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _khv_vm_power_stateValues[] = {
  hv_vm_power_state::HV_VMPOWER_UNKNOWN,
  hv_vm_power_state::HV_VMPOWER_ON,
  hv_vm_power_state::HV_VMPOWER_OFF,
  hv_vm_power_state::HV_VMPOWER_SUSPENDED
};
const char* _khv_vm_power_stateNames[] = {
  "HV_VMPOWER_UNKNOWN",
  "HV_VMPOWER_ON",
  "HV_VMPOWER_OFF",
  "HV_VMPOWER_SUSPENDED"
};
const std::map<int, const char*> _hv_vm_power_state_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _khv_vm_power_stateValues, _khv_vm_power_stateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _khv_vm_connection_stateValues[] = {
  hv_vm_connection_state::HV_VMCONNECT_UNKNOWN,
  hv_vm_connection_state::HV_VMCONNECT_CONNECTED,
  hv_vm_connection_state::HV_VMCONNECT_DISCONNECTED,
  hv_vm_connection_state::HV_VMCONNECT_INACCESSIBLE,
  hv_vm_connection_state::HV_VMCONNECT_INVALID,
  hv_vm_connection_state::HV_VMCONNECT_ORPHANED
};
const char* _khv_vm_connection_stateNames[] = {
  "HV_VMCONNECT_UNKNOWN",
  "HV_VMCONNECT_CONNECTED",
  "HV_VMCONNECT_DISCONNECTED",
  "HV_VMCONNECT_INACCESSIBLE",
  "HV_VMCONNECT_INVALID",
  "HV_VMCONNECT_ORPHANED"
};
const std::map<int, const char*> _hv_vm_connection_state_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _khv_vm_connection_stateValues, _khv_vm_connection_stateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _khv_host_power_stateValues[] = {
  hv_host_power_state::HV_HOSTPOWER_UNKNOWN,
  hv_host_power_state::HV_HOSTPOWER_ON,
  hv_host_power_state::HV_HOSTPOWER_OFF,
  hv_host_power_state::HV_HOSTPOWER_STANDBY
};
const char* _khv_host_power_stateNames[] = {
  "HV_HOSTPOWER_UNKNOWN",
  "HV_HOSTPOWER_ON",
  "HV_HOSTPOWER_OFF",
  "HV_HOSTPOWER_STANDBY"
};
const std::map<int, const char*> _hv_host_power_state_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _khv_host_power_stateValues, _khv_host_power_stateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _khv_guest_os_typeValues[] = {
  hv_guest_os_type::HV_OS_UNKNOWN,
  hv_guest_os_type::HV_OS_WINDOWS,
  hv_guest_os_type::HV_OS_LINUX
};
const char* _khv_guest_os_typeNames[] = {
  "HV_OS_UNKNOWN",
  "HV_OS_WINDOWS",
  "HV_OS_LINUX"
};
const std::map<int, const char*> _hv_guest_os_type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _khv_guest_os_typeValues, _khv_guest_os_typeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _khv_vm_firmwareValues[] = {
  hv_vm_firmware::HV_VM_FIRMWARE_BIOS,
  hv_vm_firmware::HV_VM_FIRMWARE_EFI
};
const char* _khv_vm_firmwareNames[] = {
  "HV_VM_FIRMWARE_BIOS",
  "HV_VM_FIRMWARE_EFI"
};
const std::map<int, const char*> _hv_vm_firmware_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _khv_vm_firmwareValues, _khv_vm_firmwareNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kjob_typeValues[] = {
  job_type::physical_type,
  job_type::virtual_type
};
const char* _kjob_typeNames[] = {
  "physical_type",
  "virtual_type"
};
const std::map<int, const char*> _job_type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kjob_typeValues, _kjob_typeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kjob_stateValues[] = {
  job_state::job_state_none,
  job_state::job_state_initialed,
  job_state::job_state_replicating,
  job_state::job_state_replicated,
  job_state::job_state_converting,
  job_state::job_state_finished
};
const char* _kjob_stateNames[] = {
  "job_state_none",
  "job_state_initialed",
  "job_state_replicating",
  "job_state_replicated",
  "job_state_converting",
  "job_state_finished"
};
const std::map<int, const char*> _job_state_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kjob_stateValues, _kjob_stateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kerror_codesValues[] = {
  error_codes::IRONMAN_S_OK,
  error_codes::IRONMAN_NOERROR,
  error_codes::IRONMAN_E_FAIL,
  error_codes::IRONMAN_E_INITIAL_FAIL,
  error_codes::IRONMAN_E_DISK_FULL,
  error_codes::IRONMAN_E_INVALID_ARG,
  error_codes::IRONMAN_E_INVALID_AUTHENTICATION,
  error_codes::IRONMAN_E_INTERNAL_FAIL,
  error_codes::IRONMAN_E_CANNOT_CONNECT_TO_HOST,
  error_codes::IRONMAN_E_CANNOT_BRING_DISK_ONLINE,
  error_codes::IRONMAN_E_CANNOT_INITIALIZE_DISK,
  error_codes::IRONMAN_E_CANNOT_CREATE_PARTITION,
  error_codes::IRONMAN_E_CANNOT_FORMAT_PARTITION,
  error_codes::IRONMAN_E_JOB_CREATE_FAIL,
  error_codes::IRONMAN_E_JOB_REMOVE_FAIL,
  error_codes::IRONMAN_E_JOB_NOTFOUND,
  error_codes::IRONMAN_E_JOB_CONFIG_NOTFOUND,
  error_codes::IRONMAN_E_JOB_STATUS_NOTFOUND,
  error_codes::IRONMAN_E_JOB_CANCELLED,
  error_codes::IRONMAN_E_JOB_CONVERT_FAIL,
  error_codes::IRONMAN_E_JOB_REPLICATE_FAIL,
  error_codes::IRONMAN_E_JOB_ID_DUPLICATED,
  error_codes::IRONMAN_E_JOB_INTERRUPTED,
  error_codes::IRONMAN_E_PHYSICAL_CONFIG_FAILED,
  error_codes::IRONMAN_E_VIRTUAL_VM_NOTFOUND,
  error_codes::IRONMAN_E_IMAGE_NOTFOUND,
  error_codes::IRONMAN_E_IMAGE_CREATE_FAIL,
  error_codes::IRONMAN_E_IMAGE_OPEN_FAIL,
  error_codes::IRONMAN_E_IMAGE_READ,
  error_codes::IRONMAN_E_IMAGE_WRITE,
  error_codes::IRONMAN_E_IMAGE_OUTOFRANGE,
  error_codes::IRONMAN_E_IMAGE_ATTACH_FAIL,
  error_codes::IRONMAN_E_IMAGE_DETACH_FAIL,
  error_codes::IRONMAN_E_IMAGE_PROPERTY_FAIL,
  error_codes::IRONMAN_E_SNAPSHOT_CREATE_FAIL,
  error_codes::IRONMAN_E_SNAPSHOT_REMOVE_FAIL,
  error_codes::IRONMAN_E_SNAPSHOT_NOTFOUND,
  error_codes::IRONMAN_E_SNAPSHOT_INVALID
};
const char* _kerror_codesNames[] = {
  "IRONMAN_S_OK",
  "IRONMAN_NOERROR",
  "IRONMAN_E_FAIL",
  "IRONMAN_E_INITIAL_FAIL",
  "IRONMAN_E_DISK_FULL",
  "IRONMAN_E_INVALID_ARG",
  "IRONMAN_E_INVALID_AUTHENTICATION",
  "IRONMAN_E_INTERNAL_FAIL",
  "IRONMAN_E_CANNOT_CONNECT_TO_HOST",
  "IRONMAN_E_CANNOT_BRING_DISK_ONLINE",
  "IRONMAN_E_CANNOT_INITIALIZE_DISK",
  "IRONMAN_E_CANNOT_CREATE_PARTITION",
  "IRONMAN_E_CANNOT_FORMAT_PARTITION",
  "IRONMAN_E_JOB_CREATE_FAIL",
  "IRONMAN_E_JOB_REMOVE_FAIL",
  "IRONMAN_E_JOB_NOTFOUND",
  "IRONMAN_E_JOB_CONFIG_NOTFOUND",
  "IRONMAN_E_JOB_STATUS_NOTFOUND",
  "IRONMAN_E_JOB_CANCELLED",
  "IRONMAN_E_JOB_CONVERT_FAIL",
  "IRONMAN_E_JOB_REPLICATE_FAIL",
  "IRONMAN_E_JOB_ID_DUPLICATED",
  "IRONMAN_E_JOB_INTERRUPTED",
  "IRONMAN_E_PHYSICAL_CONFIG_FAILED",
  "IRONMAN_E_VIRTUAL_VM_NOTFOUND",
  "IRONMAN_E_IMAGE_NOTFOUND",
  "IRONMAN_E_IMAGE_CREATE_FAIL",
  "IRONMAN_E_IMAGE_OPEN_FAIL",
  "IRONMAN_E_IMAGE_READ",
  "IRONMAN_E_IMAGE_WRITE",
  "IRONMAN_E_IMAGE_OUTOFRANGE",
  "IRONMAN_E_IMAGE_ATTACH_FAIL",
  "IRONMAN_E_IMAGE_DETACH_FAIL",
  "IRONMAN_E_IMAGE_PROPERTY_FAIL",
  "IRONMAN_E_SNAPSHOT_CREATE_FAIL",
  "IRONMAN_E_SNAPSHOT_REMOVE_FAIL",
  "IRONMAN_E_SNAPSHOT_NOTFOUND",
  "IRONMAN_E_SNAPSHOT_INVALID"
};
const std::map<int, const char*> _error_codes_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(38, _kerror_codesValues, _kerror_codesNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


disk_info::~disk_info() throw() {
}


void disk_info::__set_boot_from_disk(const bool val) {
  this->boot_from_disk = val;
__isset.boot_from_disk = true;
}

void disk_info::__set_bus_type(const bus_type::type val) {
  this->bus_type = val;
__isset.bus_type = true;
}

void disk_info::__set_cluster_owner(const std::string& val) {
  this->cluster_owner = val;
__isset.cluster_owner = true;
}

void disk_info::__set_cylinders(const int64_t val) {
  this->cylinders = val;
__isset.cylinders = true;
}

void disk_info::__set_friend_name(const std::string& val) {
  this->friend_name = val;
__isset.friend_name = true;
}

void disk_info::__set_guid(const std::string& val) {
  this->guid = val;
__isset.guid = true;
}

void disk_info::__set_tracks_per_cylinder(const int32_t val) {
  this->tracks_per_cylinder = val;
__isset.tracks_per_cylinder = true;
}

void disk_info::__set_is_boot(const bool val) {
  this->is_boot = val;
__isset.is_boot = true;
}

void disk_info::__set_is_clustered(const bool val) {
  this->is_clustered = val;
__isset.is_clustered = true;
}

void disk_info::__set_is_offline(const bool val) {
  this->is_offline = val;
__isset.is_offline = true;
}

void disk_info::__set_is_readonly(const bool val) {
  this->is_readonly = val;
__isset.is_readonly = true;
}

void disk_info::__set_is_snapshot(const bool val) {
  this->is_snapshot = val;
__isset.is_snapshot = true;
}

void disk_info::__set_is_system(const bool val) {
  this->is_system = val;
__isset.is_system = true;
}

void disk_info::__set_location(const std::string& val) {
  this->location = val;
__isset.location = true;
}

void disk_info::__set_logical_sector_size(const int32_t val) {
  this->logical_sector_size = val;
__isset.logical_sector_size = true;
}

void disk_info::__set_manufacturer(const std::string& val) {
  this->manufacturer = val;
__isset.manufacturer = true;
}

void disk_info::__set_model(const std::string& val) {
  this->model = val;
__isset.model = true;
}

void disk_info::__set_number(const int32_t val) {
  this->number = val;
__isset.number = true;
}

void disk_info::__set_number_of_partitions(const int32_t val) {
  this->number_of_partitions = val;
__isset.number_of_partitions = true;
}

void disk_info::__set_offline_reason(const int16_t val) {
  this->offline_reason = val;
__isset.offline_reason = true;
}

void disk_info::__set_partition_style(const partition_style::type val) {
  this->partition_style = val;
__isset.partition_style = true;
}

void disk_info::__set_path(const std::string& val) {
  this->path = val;
__isset.path = true;
}

void disk_info::__set_physical_sector_size(const int32_t val) {
  this->physical_sector_size = val;
__isset.physical_sector_size = true;
}

void disk_info::__set_sectors_per_track(const int32_t val) {
  this->sectors_per_track = val;
__isset.sectors_per_track = true;
}

void disk_info::__set_serial_number(const std::string& val) {
  this->serial_number = val;
__isset.serial_number = true;
}

void disk_info::__set_signature(const int32_t val) {
  this->signature = val;
__isset.signature = true;
}

void disk_info::__set_size(const int64_t val) {
  this->size = val;
__isset.size = true;
}

void disk_info::__set_uri(const std::string& val) {
  this->uri = val;
__isset.uri = true;
}

void disk_info::__set_scsi_bus(const int32_t val) {
  this->scsi_bus = val;
__isset.scsi_bus = true;
}

void disk_info::__set_scsi_logical_unit(const int16_t val) {
  this->scsi_logical_unit = val;
__isset.scsi_logical_unit = true;
}

void disk_info::__set_scsi_port(const int16_t val) {
  this->scsi_port = val;
__isset.scsi_port = true;
}

void disk_info::__set_scsi_target_id(const int16_t val) {
  this->scsi_target_id = val;
__isset.scsi_target_id = true;
}

uint32_t disk_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->boot_from_disk);
          this->__isset.boot_from_disk = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->bus_type = (bus_type::type)ecast0;
          this->__isset.bus_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cluster_owner);
          this->__isset.cluster_owner = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cylinders);
          this->__isset.cylinders = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->friend_name);
          this->__isset.friend_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guid);
          this->__isset.guid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->tracks_per_cylinder);
          this->__isset.tracks_per_cylinder = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_boot);
          this->__isset.is_boot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_clustered);
          this->__isset.is_clustered = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_offline);
          this->__isset.is_offline = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_readonly);
          this->__isset.is_readonly = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_snapshot);
          this->__isset.is_snapshot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_system);
          this->__isset.is_system = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->location);
          this->__isset.location = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->logical_sector_size);
          this->__isset.logical_sector_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->manufacturer);
          this->__isset.manufacturer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->model);
          this->__isset.model = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->number);
          this->__isset.number = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->number_of_partitions);
          this->__isset.number_of_partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->offline_reason);
          this->__isset.offline_reason = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1;
          xfer += iprot->readI32(ecast1);
          this->partition_style = (partition_style::type)ecast1;
          this->__isset.partition_style = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->path);
          this->__isset.path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->physical_sector_size);
          this->__isset.physical_sector_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sectors_per_track);
          this->__isset.sectors_per_track = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->serial_number);
          this->__isset.serial_number = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 26:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->signature);
          this->__isset.signature = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 27:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->size);
          this->__isset.size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 28:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->uri);
          this->__isset.uri = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 29:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->scsi_bus);
          this->__isset.scsi_bus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->scsi_logical_unit);
          this->__isset.scsi_logical_unit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 31:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->scsi_port);
          this->__isset.scsi_port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 32:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->scsi_target_id);
          this->__isset.scsi_target_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t disk_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("disk_info");

  if (this->__isset.boot_from_disk) {
    xfer += oprot->writeFieldBegin("boot_from_disk", ::apache::thrift::protocol::T_BOOL, 1);
    xfer += oprot->writeBool(this->boot_from_disk);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.bus_type) {
    xfer += oprot->writeFieldBegin("bus_type", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32((int32_t)this->bus_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_owner) {
    xfer += oprot->writeFieldBegin("cluster_owner", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->cluster_owner);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cylinders) {
    xfer += oprot->writeFieldBegin("cylinders", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->cylinders);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.friend_name) {
    xfer += oprot->writeFieldBegin("friend_name", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->friend_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.guid) {
    xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->guid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tracks_per_cylinder) {
    xfer += oprot->writeFieldBegin("tracks_per_cylinder", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32(this->tracks_per_cylinder);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_boot) {
    xfer += oprot->writeFieldBegin("is_boot", ::apache::thrift::protocol::T_BOOL, 8);
    xfer += oprot->writeBool(this->is_boot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_clustered) {
    xfer += oprot->writeFieldBegin("is_clustered", ::apache::thrift::protocol::T_BOOL, 9);
    xfer += oprot->writeBool(this->is_clustered);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_offline) {
    xfer += oprot->writeFieldBegin("is_offline", ::apache::thrift::protocol::T_BOOL, 10);
    xfer += oprot->writeBool(this->is_offline);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_readonly) {
    xfer += oprot->writeFieldBegin("is_readonly", ::apache::thrift::protocol::T_BOOL, 11);
    xfer += oprot->writeBool(this->is_readonly);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_snapshot) {
    xfer += oprot->writeFieldBegin("is_snapshot", ::apache::thrift::protocol::T_BOOL, 12);
    xfer += oprot->writeBool(this->is_snapshot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_system) {
    xfer += oprot->writeFieldBegin("is_system", ::apache::thrift::protocol::T_BOOL, 13);
    xfer += oprot->writeBool(this->is_system);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.location) {
    xfer += oprot->writeFieldBegin("location", ::apache::thrift::protocol::T_STRING, 14);
    xfer += oprot->writeString(this->location);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.logical_sector_size) {
    xfer += oprot->writeFieldBegin("logical_sector_size", ::apache::thrift::protocol::T_I32, 15);
    xfer += oprot->writeI32(this->logical_sector_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.manufacturer) {
    xfer += oprot->writeFieldBegin("manufacturer", ::apache::thrift::protocol::T_STRING, 16);
    xfer += oprot->writeString(this->manufacturer);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.model) {
    xfer += oprot->writeFieldBegin("model", ::apache::thrift::protocol::T_STRING, 17);
    xfer += oprot->writeString(this->model);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.number) {
    xfer += oprot->writeFieldBegin("number", ::apache::thrift::protocol::T_I32, 18);
    xfer += oprot->writeI32(this->number);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.number_of_partitions) {
    xfer += oprot->writeFieldBegin("number_of_partitions", ::apache::thrift::protocol::T_I32, 19);
    xfer += oprot->writeI32(this->number_of_partitions);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.offline_reason) {
    xfer += oprot->writeFieldBegin("offline_reason", ::apache::thrift::protocol::T_I16, 20);
    xfer += oprot->writeI16(this->offline_reason);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partition_style) {
    xfer += oprot->writeFieldBegin("partition_style", ::apache::thrift::protocol::T_I32, 21);
    xfer += oprot->writeI32((int32_t)this->partition_style);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.path) {
    xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_STRING, 22);
    xfer += oprot->writeString(this->path);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.physical_sector_size) {
    xfer += oprot->writeFieldBegin("physical_sector_size", ::apache::thrift::protocol::T_I32, 23);
    xfer += oprot->writeI32(this->physical_sector_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sectors_per_track) {
    xfer += oprot->writeFieldBegin("sectors_per_track", ::apache::thrift::protocol::T_I32, 24);
    xfer += oprot->writeI32(this->sectors_per_track);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.serial_number) {
    xfer += oprot->writeFieldBegin("serial_number", ::apache::thrift::protocol::T_STRING, 25);
    xfer += oprot->writeString(this->serial_number);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.signature) {
    xfer += oprot->writeFieldBegin("signature", ::apache::thrift::protocol::T_I32, 26);
    xfer += oprot->writeI32(this->signature);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.size) {
    xfer += oprot->writeFieldBegin("size", ::apache::thrift::protocol::T_I64, 27);
    xfer += oprot->writeI64(this->size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.uri) {
    xfer += oprot->writeFieldBegin("uri", ::apache::thrift::protocol::T_STRING, 28);
    xfer += oprot->writeString(this->uri);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.scsi_bus) {
    xfer += oprot->writeFieldBegin("scsi_bus", ::apache::thrift::protocol::T_I32, 29);
    xfer += oprot->writeI32(this->scsi_bus);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.scsi_logical_unit) {
    xfer += oprot->writeFieldBegin("scsi_logical_unit", ::apache::thrift::protocol::T_I16, 30);
    xfer += oprot->writeI16(this->scsi_logical_unit);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.scsi_port) {
    xfer += oprot->writeFieldBegin("scsi_port", ::apache::thrift::protocol::T_I16, 31);
    xfer += oprot->writeI16(this->scsi_port);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.scsi_target_id) {
    xfer += oprot->writeFieldBegin("scsi_target_id", ::apache::thrift::protocol::T_I16, 32);
    xfer += oprot->writeI16(this->scsi_target_id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(disk_info &a, disk_info &b) {
  using ::std::swap;
  swap(a.boot_from_disk, b.boot_from_disk);
  swap(a.bus_type, b.bus_type);
  swap(a.cluster_owner, b.cluster_owner);
  swap(a.cylinders, b.cylinders);
  swap(a.friend_name, b.friend_name);
  swap(a.guid, b.guid);
  swap(a.tracks_per_cylinder, b.tracks_per_cylinder);
  swap(a.is_boot, b.is_boot);
  swap(a.is_clustered, b.is_clustered);
  swap(a.is_offline, b.is_offline);
  swap(a.is_readonly, b.is_readonly);
  swap(a.is_snapshot, b.is_snapshot);
  swap(a.is_system, b.is_system);
  swap(a.location, b.location);
  swap(a.logical_sector_size, b.logical_sector_size);
  swap(a.manufacturer, b.manufacturer);
  swap(a.model, b.model);
  swap(a.number, b.number);
  swap(a.number_of_partitions, b.number_of_partitions);
  swap(a.offline_reason, b.offline_reason);
  swap(a.partition_style, b.partition_style);
  swap(a.path, b.path);
  swap(a.physical_sector_size, b.physical_sector_size);
  swap(a.sectors_per_track, b.sectors_per_track);
  swap(a.serial_number, b.serial_number);
  swap(a.signature, b.signature);
  swap(a.size, b.size);
  swap(a.uri, b.uri);
  swap(a.scsi_bus, b.scsi_bus);
  swap(a.scsi_logical_unit, b.scsi_logical_unit);
  swap(a.scsi_port, b.scsi_port);
  swap(a.scsi_target_id, b.scsi_target_id);
  swap(a.__isset, b.__isset);
}

disk_info::disk_info(const disk_info& other2) {
  boot_from_disk = other2.boot_from_disk;
  bus_type = other2.bus_type;
  cluster_owner = other2.cluster_owner;
  cylinders = other2.cylinders;
  friend_name = other2.friend_name;
  guid = other2.guid;
  tracks_per_cylinder = other2.tracks_per_cylinder;
  is_boot = other2.is_boot;
  is_clustered = other2.is_clustered;
  is_offline = other2.is_offline;
  is_readonly = other2.is_readonly;
  is_snapshot = other2.is_snapshot;
  is_system = other2.is_system;
  location = other2.location;
  logical_sector_size = other2.logical_sector_size;
  manufacturer = other2.manufacturer;
  model = other2.model;
  number = other2.number;
  number_of_partitions = other2.number_of_partitions;
  offline_reason = other2.offline_reason;
  partition_style = other2.partition_style;
  path = other2.path;
  physical_sector_size = other2.physical_sector_size;
  sectors_per_track = other2.sectors_per_track;
  serial_number = other2.serial_number;
  signature = other2.signature;
  size = other2.size;
  uri = other2.uri;
  scsi_bus = other2.scsi_bus;
  scsi_logical_unit = other2.scsi_logical_unit;
  scsi_port = other2.scsi_port;
  scsi_target_id = other2.scsi_target_id;
  __isset = other2.__isset;
}
disk_info& disk_info::operator=(const disk_info& other3) {
  boot_from_disk = other3.boot_from_disk;
  bus_type = other3.bus_type;
  cluster_owner = other3.cluster_owner;
  cylinders = other3.cylinders;
  friend_name = other3.friend_name;
  guid = other3.guid;
  tracks_per_cylinder = other3.tracks_per_cylinder;
  is_boot = other3.is_boot;
  is_clustered = other3.is_clustered;
  is_offline = other3.is_offline;
  is_readonly = other3.is_readonly;
  is_snapshot = other3.is_snapshot;
  is_system = other3.is_system;
  location = other3.location;
  logical_sector_size = other3.logical_sector_size;
  manufacturer = other3.manufacturer;
  model = other3.model;
  number = other3.number;
  number_of_partitions = other3.number_of_partitions;
  offline_reason = other3.offline_reason;
  partition_style = other3.partition_style;
  path = other3.path;
  physical_sector_size = other3.physical_sector_size;
  sectors_per_track = other3.sectors_per_track;
  serial_number = other3.serial_number;
  signature = other3.signature;
  size = other3.size;
  uri = other3.uri;
  scsi_bus = other3.scsi_bus;
  scsi_logical_unit = other3.scsi_logical_unit;
  scsi_port = other3.scsi_port;
  scsi_target_id = other3.scsi_target_id;
  __isset = other3.__isset;
  return *this;
}
void disk_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "disk_info(";
  out << "boot_from_disk="; (__isset.boot_from_disk ? (out << to_string(boot_from_disk)) : (out << "<null>"));
  out << ", " << "bus_type="; (__isset.bus_type ? (out << to_string(bus_type)) : (out << "<null>"));
  out << ", " << "cluster_owner="; (__isset.cluster_owner ? (out << to_string(cluster_owner)) : (out << "<null>"));
  out << ", " << "cylinders="; (__isset.cylinders ? (out << to_string(cylinders)) : (out << "<null>"));
  out << ", " << "friend_name="; (__isset.friend_name ? (out << to_string(friend_name)) : (out << "<null>"));
  out << ", " << "guid="; (__isset.guid ? (out << to_string(guid)) : (out << "<null>"));
  out << ", " << "tracks_per_cylinder="; (__isset.tracks_per_cylinder ? (out << to_string(tracks_per_cylinder)) : (out << "<null>"));
  out << ", " << "is_boot="; (__isset.is_boot ? (out << to_string(is_boot)) : (out << "<null>"));
  out << ", " << "is_clustered="; (__isset.is_clustered ? (out << to_string(is_clustered)) : (out << "<null>"));
  out << ", " << "is_offline="; (__isset.is_offline ? (out << to_string(is_offline)) : (out << "<null>"));
  out << ", " << "is_readonly="; (__isset.is_readonly ? (out << to_string(is_readonly)) : (out << "<null>"));
  out << ", " << "is_snapshot="; (__isset.is_snapshot ? (out << to_string(is_snapshot)) : (out << "<null>"));
  out << ", " << "is_system="; (__isset.is_system ? (out << to_string(is_system)) : (out << "<null>"));
  out << ", " << "location="; (__isset.location ? (out << to_string(location)) : (out << "<null>"));
  out << ", " << "logical_sector_size="; (__isset.logical_sector_size ? (out << to_string(logical_sector_size)) : (out << "<null>"));
  out << ", " << "manufacturer="; (__isset.manufacturer ? (out << to_string(manufacturer)) : (out << "<null>"));
  out << ", " << "model="; (__isset.model ? (out << to_string(model)) : (out << "<null>"));
  out << ", " << "number="; (__isset.number ? (out << to_string(number)) : (out << "<null>"));
  out << ", " << "number_of_partitions="; (__isset.number_of_partitions ? (out << to_string(number_of_partitions)) : (out << "<null>"));
  out << ", " << "offline_reason="; (__isset.offline_reason ? (out << to_string(offline_reason)) : (out << "<null>"));
  out << ", " << "partition_style="; (__isset.partition_style ? (out << to_string(partition_style)) : (out << "<null>"));
  out << ", " << "path="; (__isset.path ? (out << to_string(path)) : (out << "<null>"));
  out << ", " << "physical_sector_size="; (__isset.physical_sector_size ? (out << to_string(physical_sector_size)) : (out << "<null>"));
  out << ", " << "sectors_per_track="; (__isset.sectors_per_track ? (out << to_string(sectors_per_track)) : (out << "<null>"));
  out << ", " << "serial_number="; (__isset.serial_number ? (out << to_string(serial_number)) : (out << "<null>"));
  out << ", " << "signature="; (__isset.signature ? (out << to_string(signature)) : (out << "<null>"));
  out << ", " << "size="; (__isset.size ? (out << to_string(size)) : (out << "<null>"));
  out << ", " << "uri="; (__isset.uri ? (out << to_string(uri)) : (out << "<null>"));
  out << ", " << "scsi_bus="; (__isset.scsi_bus ? (out << to_string(scsi_bus)) : (out << "<null>"));
  out << ", " << "scsi_logical_unit="; (__isset.scsi_logical_unit ? (out << to_string(scsi_logical_unit)) : (out << "<null>"));
  out << ", " << "scsi_port="; (__isset.scsi_port ? (out << to_string(scsi_port)) : (out << "<null>"));
  out << ", " << "scsi_target_id="; (__isset.scsi_target_id ? (out << to_string(scsi_target_id)) : (out << "<null>"));
  out << ")";
}


partition_info::~partition_info() throw() {
}


void partition_info::__set_access_paths(const std::set<std::string> & val) {
  this->access_paths = val;
__isset.access_paths = true;
}

void partition_info::__set_disk_number(const int32_t val) {
  this->disk_number = val;
__isset.disk_number = true;
}

void partition_info::__set_drive_letter(const std::string& val) {
  this->drive_letter = val;
__isset.drive_letter = true;
}

void partition_info::__set_gpt_type(const std::string& val) {
  this->gpt_type = val;
__isset.gpt_type = true;
}

void partition_info::__set_guid(const std::string& val) {
  this->guid = val;
__isset.guid = true;
}

void partition_info::__set_is_active(const bool val) {
  this->is_active = val;
__isset.is_active = true;
}

void partition_info::__set_is_boot(const bool val) {
  this->is_boot = val;
__isset.is_boot = true;
}

void partition_info::__set_is_hidden(const bool val) {
  this->is_hidden = val;
__isset.is_hidden = true;
}

void partition_info::__set_is_offline(const bool val) {
  this->is_offline = val;
__isset.is_offline = true;
}

void partition_info::__set_is_readonly(const bool val) {
  this->is_readonly = val;
__isset.is_readonly = true;
}

void partition_info::__set_is_shadowcopy(const bool val) {
  this->is_shadowcopy = val;
__isset.is_shadowcopy = true;
}

void partition_info::__set_is_system(const bool val) {
  this->is_system = val;
__isset.is_system = true;
}

void partition_info::__set_mbr_type(const int16_t val) {
  this->mbr_type = val;
__isset.mbr_type = true;
}

void partition_info::__set_offset(const int64_t val) {
  this->offset = val;
__isset.offset = true;
}

void partition_info::__set_partition_number(const int32_t val) {
  this->partition_number = val;
__isset.partition_number = true;
}

void partition_info::__set_size(const int64_t val) {
  this->size = val;
__isset.size = true;
}

uint32_t partition_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->access_paths.clear();
            uint32_t _size4;
            ::apache::thrift::protocol::TType _etype7;
            xfer += iprot->readSetBegin(_etype7, _size4);
            uint32_t _i8;
            for (_i8 = 0; _i8 < _size4; ++_i8)
            {
              std::string _elem9;
              xfer += iprot->readString(_elem9);
              this->access_paths.insert(_elem9);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.access_paths = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->disk_number);
          this->__isset.disk_number = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->drive_letter);
          this->__isset.drive_letter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->gpt_type);
          this->__isset.gpt_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guid);
          this->__isset.guid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_active);
          this->__isset.is_active = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_boot);
          this->__isset.is_boot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_hidden);
          this->__isset.is_hidden = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_offline);
          this->__isset.is_offline = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_readonly);
          this->__isset.is_readonly = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_shadowcopy);
          this->__isset.is_shadowcopy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_system);
          this->__isset.is_system = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->mbr_type);
          this->__isset.mbr_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->offset);
          this->__isset.offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->partition_number);
          this->__isset.partition_number = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->size);
          this->__isset.size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t partition_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("partition_info");

  if (this->__isset.access_paths) {
    xfer += oprot->writeFieldBegin("access_paths", ::apache::thrift::protocol::T_SET, 1);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->access_paths.size()));
      std::set<std::string> ::const_iterator _iter10;
      for (_iter10 = this->access_paths.begin(); _iter10 != this->access_paths.end(); ++_iter10)
      {
        xfer += oprot->writeString((*_iter10));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.disk_number) {
    xfer += oprot->writeFieldBegin("disk_number", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->disk_number);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.drive_letter) {
    xfer += oprot->writeFieldBegin("drive_letter", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->drive_letter);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.gpt_type) {
    xfer += oprot->writeFieldBegin("gpt_type", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->gpt_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.guid) {
    xfer += oprot->writeFieldBegin("guid", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->guid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_active) {
    xfer += oprot->writeFieldBegin("is_active", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->is_active);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_boot) {
    xfer += oprot->writeFieldBegin("is_boot", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->is_boot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_hidden) {
    xfer += oprot->writeFieldBegin("is_hidden", ::apache::thrift::protocol::T_BOOL, 8);
    xfer += oprot->writeBool(this->is_hidden);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_offline) {
    xfer += oprot->writeFieldBegin("is_offline", ::apache::thrift::protocol::T_BOOL, 9);
    xfer += oprot->writeBool(this->is_offline);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_readonly) {
    xfer += oprot->writeFieldBegin("is_readonly", ::apache::thrift::protocol::T_BOOL, 10);
    xfer += oprot->writeBool(this->is_readonly);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_shadowcopy) {
    xfer += oprot->writeFieldBegin("is_shadowcopy", ::apache::thrift::protocol::T_BOOL, 11);
    xfer += oprot->writeBool(this->is_shadowcopy);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_system) {
    xfer += oprot->writeFieldBegin("is_system", ::apache::thrift::protocol::T_BOOL, 12);
    xfer += oprot->writeBool(this->is_system);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mbr_type) {
    xfer += oprot->writeFieldBegin("mbr_type", ::apache::thrift::protocol::T_I16, 13);
    xfer += oprot->writeI16(this->mbr_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.offset) {
    xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I64, 14);
    xfer += oprot->writeI64(this->offset);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partition_number) {
    xfer += oprot->writeFieldBegin("partition_number", ::apache::thrift::protocol::T_I32, 15);
    xfer += oprot->writeI32(this->partition_number);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.size) {
    xfer += oprot->writeFieldBegin("size", ::apache::thrift::protocol::T_I64, 16);
    xfer += oprot->writeI64(this->size);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(partition_info &a, partition_info &b) {
  using ::std::swap;
  swap(a.access_paths, b.access_paths);
  swap(a.disk_number, b.disk_number);
  swap(a.drive_letter, b.drive_letter);
  swap(a.gpt_type, b.gpt_type);
  swap(a.guid, b.guid);
  swap(a.is_active, b.is_active);
  swap(a.is_boot, b.is_boot);
  swap(a.is_hidden, b.is_hidden);
  swap(a.is_offline, b.is_offline);
  swap(a.is_readonly, b.is_readonly);
  swap(a.is_shadowcopy, b.is_shadowcopy);
  swap(a.is_system, b.is_system);
  swap(a.mbr_type, b.mbr_type);
  swap(a.offset, b.offset);
  swap(a.partition_number, b.partition_number);
  swap(a.size, b.size);
  swap(a.__isset, b.__isset);
}

partition_info::partition_info(const partition_info& other11) {
  access_paths = other11.access_paths;
  disk_number = other11.disk_number;
  drive_letter = other11.drive_letter;
  gpt_type = other11.gpt_type;
  guid = other11.guid;
  is_active = other11.is_active;
  is_boot = other11.is_boot;
  is_hidden = other11.is_hidden;
  is_offline = other11.is_offline;
  is_readonly = other11.is_readonly;
  is_shadowcopy = other11.is_shadowcopy;
  is_system = other11.is_system;
  mbr_type = other11.mbr_type;
  offset = other11.offset;
  partition_number = other11.partition_number;
  size = other11.size;
  __isset = other11.__isset;
}
partition_info& partition_info::operator=(const partition_info& other12) {
  access_paths = other12.access_paths;
  disk_number = other12.disk_number;
  drive_letter = other12.drive_letter;
  gpt_type = other12.gpt_type;
  guid = other12.guid;
  is_active = other12.is_active;
  is_boot = other12.is_boot;
  is_hidden = other12.is_hidden;
  is_offline = other12.is_offline;
  is_readonly = other12.is_readonly;
  is_shadowcopy = other12.is_shadowcopy;
  is_system = other12.is_system;
  mbr_type = other12.mbr_type;
  offset = other12.offset;
  partition_number = other12.partition_number;
  size = other12.size;
  __isset = other12.__isset;
  return *this;
}
void partition_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "partition_info(";
  out << "access_paths="; (__isset.access_paths ? (out << to_string(access_paths)) : (out << "<null>"));
  out << ", " << "disk_number="; (__isset.disk_number ? (out << to_string(disk_number)) : (out << "<null>"));
  out << ", " << "drive_letter="; (__isset.drive_letter ? (out << to_string(drive_letter)) : (out << "<null>"));
  out << ", " << "gpt_type="; (__isset.gpt_type ? (out << to_string(gpt_type)) : (out << "<null>"));
  out << ", " << "guid="; (__isset.guid ? (out << to_string(guid)) : (out << "<null>"));
  out << ", " << "is_active="; (__isset.is_active ? (out << to_string(is_active)) : (out << "<null>"));
  out << ", " << "is_boot="; (__isset.is_boot ? (out << to_string(is_boot)) : (out << "<null>"));
  out << ", " << "is_hidden="; (__isset.is_hidden ? (out << to_string(is_hidden)) : (out << "<null>"));
  out << ", " << "is_offline="; (__isset.is_offline ? (out << to_string(is_offline)) : (out << "<null>"));
  out << ", " << "is_readonly="; (__isset.is_readonly ? (out << to_string(is_readonly)) : (out << "<null>"));
  out << ", " << "is_shadowcopy="; (__isset.is_shadowcopy ? (out << to_string(is_shadowcopy)) : (out << "<null>"));
  out << ", " << "is_system="; (__isset.is_system ? (out << to_string(is_system)) : (out << "<null>"));
  out << ", " << "mbr_type="; (__isset.mbr_type ? (out << to_string(mbr_type)) : (out << "<null>"));
  out << ", " << "offset="; (__isset.offset ? (out << to_string(offset)) : (out << "<null>"));
  out << ", " << "partition_number="; (__isset.partition_number ? (out << to_string(partition_number)) : (out << "<null>"));
  out << ", " << "size="; (__isset.size ? (out << to_string(size)) : (out << "<null>"));
  out << ")";
}


volume_info::~volume_info() throw() {
}


void volume_info::__set_access_paths(const std::set<std::string> & val) {
  this->access_paths = val;
__isset.access_paths = true;
}

void volume_info::__set_cluster_access_path(const std::string& val) {
  this->cluster_access_path = val;
__isset.cluster_access_path = true;
}

void volume_info::__set_drive_letter(const std::string& val) {
  this->drive_letter = val;
__isset.drive_letter = true;
}

void volume_info::__set_drive_type(const drive_type::type val) {
  this->drive_type = val;
__isset.drive_type = true;
}

void volume_info::__set_file_system(const std::string& val) {
  this->file_system = val;
__isset.file_system = true;
}

void volume_info::__set_file_system_catalogid(const std::string& val) {
  this->file_system_catalogid = val;
__isset.file_system_catalogid = true;
}

void volume_info::__set_file_system_label(const std::string& val) {
  this->file_system_label = val;
__isset.file_system_label = true;
}

void volume_info::__set_object_id(const std::string& val) {
  this->object_id = val;
__isset.object_id = true;
}

void volume_info::__set_path(const std::string& val) {
  this->path = val;
__isset.path = true;
}

void volume_info::__set_size(const int64_t val) {
  this->size = val;
__isset.size = true;
}

void volume_info::__set_size_remaining(const int64_t val) {
  this->size_remaining = val;
__isset.size_remaining = true;
}

uint32_t volume_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->access_paths.clear();
            uint32_t _size13;
            ::apache::thrift::protocol::TType _etype16;
            xfer += iprot->readSetBegin(_etype16, _size13);
            uint32_t _i17;
            for (_i17 = 0; _i17 < _size13; ++_i17)
            {
              std::string _elem18;
              xfer += iprot->readString(_elem18);
              this->access_paths.insert(_elem18);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.access_paths = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cluster_access_path);
          this->__isset.cluster_access_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->drive_letter);
          this->__isset.drive_letter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast19;
          xfer += iprot->readI32(ecast19);
          this->drive_type = (drive_type::type)ecast19;
          this->__isset.drive_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->file_system);
          this->__isset.file_system = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->file_system_catalogid);
          this->__isset.file_system_catalogid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->file_system_label);
          this->__isset.file_system_label = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->object_id);
          this->__isset.object_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->path);
          this->__isset.path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->size);
          this->__isset.size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->size_remaining);
          this->__isset.size_remaining = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t volume_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("volume_info");

  if (this->__isset.access_paths) {
    xfer += oprot->writeFieldBegin("access_paths", ::apache::thrift::protocol::T_SET, 1);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->access_paths.size()));
      std::set<std::string> ::const_iterator _iter20;
      for (_iter20 = this->access_paths.begin(); _iter20 != this->access_paths.end(); ++_iter20)
      {
        xfer += oprot->writeString((*_iter20));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_access_path) {
    xfer += oprot->writeFieldBegin("cluster_access_path", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->cluster_access_path);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.drive_letter) {
    xfer += oprot->writeFieldBegin("drive_letter", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->drive_letter);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.drive_type) {
    xfer += oprot->writeFieldBegin("drive_type", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32((int32_t)this->drive_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.file_system) {
    xfer += oprot->writeFieldBegin("file_system", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->file_system);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.file_system_catalogid) {
    xfer += oprot->writeFieldBegin("file_system_catalogid", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->file_system_catalogid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.file_system_label) {
    xfer += oprot->writeFieldBegin("file_system_label", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->file_system_label);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.object_id) {
    xfer += oprot->writeFieldBegin("object_id", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->object_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.path) {
    xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->path);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.size) {
    xfer += oprot->writeFieldBegin("size", ::apache::thrift::protocol::T_I64, 10);
    xfer += oprot->writeI64(this->size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.size_remaining) {
    xfer += oprot->writeFieldBegin("size_remaining", ::apache::thrift::protocol::T_I64, 11);
    xfer += oprot->writeI64(this->size_remaining);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(volume_info &a, volume_info &b) {
  using ::std::swap;
  swap(a.access_paths, b.access_paths);
  swap(a.cluster_access_path, b.cluster_access_path);
  swap(a.drive_letter, b.drive_letter);
  swap(a.drive_type, b.drive_type);
  swap(a.file_system, b.file_system);
  swap(a.file_system_catalogid, b.file_system_catalogid);
  swap(a.file_system_label, b.file_system_label);
  swap(a.object_id, b.object_id);
  swap(a.path, b.path);
  swap(a.size, b.size);
  swap(a.size_remaining, b.size_remaining);
  swap(a.__isset, b.__isset);
}

volume_info::volume_info(const volume_info& other21) {
  access_paths = other21.access_paths;
  cluster_access_path = other21.cluster_access_path;
  drive_letter = other21.drive_letter;
  drive_type = other21.drive_type;
  file_system = other21.file_system;
  file_system_catalogid = other21.file_system_catalogid;
  file_system_label = other21.file_system_label;
  object_id = other21.object_id;
  path = other21.path;
  size = other21.size;
  size_remaining = other21.size_remaining;
  __isset = other21.__isset;
}
volume_info& volume_info::operator=(const volume_info& other22) {
  access_paths = other22.access_paths;
  cluster_access_path = other22.cluster_access_path;
  drive_letter = other22.drive_letter;
  drive_type = other22.drive_type;
  file_system = other22.file_system;
  file_system_catalogid = other22.file_system_catalogid;
  file_system_label = other22.file_system_label;
  object_id = other22.object_id;
  path = other22.path;
  size = other22.size;
  size_remaining = other22.size_remaining;
  __isset = other22.__isset;
  return *this;
}
void volume_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "volume_info(";
  out << "access_paths="; (__isset.access_paths ? (out << to_string(access_paths)) : (out << "<null>"));
  out << ", " << "cluster_access_path="; (__isset.cluster_access_path ? (out << to_string(cluster_access_path)) : (out << "<null>"));
  out << ", " << "drive_letter="; (__isset.drive_letter ? (out << to_string(drive_letter)) : (out << "<null>"));
  out << ", " << "drive_type="; (__isset.drive_type ? (out << to_string(drive_type)) : (out << "<null>"));
  out << ", " << "file_system="; (__isset.file_system ? (out << to_string(file_system)) : (out << "<null>"));
  out << ", " << "file_system_catalogid="; (__isset.file_system_catalogid ? (out << to_string(file_system_catalogid)) : (out << "<null>"));
  out << ", " << "file_system_label="; (__isset.file_system_label ? (out << to_string(file_system_label)) : (out << "<null>"));
  out << ", " << "object_id="; (__isset.object_id ? (out << to_string(object_id)) : (out << "<null>"));
  out << ", " << "path="; (__isset.path ? (out << to_string(path)) : (out << "<null>"));
  out << ", " << "size="; (__isset.size ? (out << to_string(size)) : (out << "<null>"));
  out << ", " << "size_remaining="; (__isset.size_remaining ? (out << to_string(size_remaining)) : (out << "<null>"));
  out << ")";
}


network_info::~network_info() throw() {
}


void network_info::__set_adapter_name(const std::string& val) {
  this->adapter_name = val;
__isset.adapter_name = true;
}

void network_info::__set_description(const std::string& val) {
  this->description = val;
__isset.description = true;
}

void network_info::__set_dnss(const std::vector<std::string> & val) {
  this->dnss = val;
__isset.dnss = true;
}

void network_info::__set_gateways(const std::vector<std::string> & val) {
  this->gateways = val;
__isset.gateways = true;
}

void network_info::__set_ip_addresses(const std::vector<std::string> & val) {
  this->ip_addresses = val;
__isset.ip_addresses = true;
}

void network_info::__set_is_dhcp_v4(const bool val) {
  this->is_dhcp_v4 = val;
__isset.is_dhcp_v4 = true;
}

void network_info::__set_is_dhcp_v6(const bool val) {
  this->is_dhcp_v6 = val;
__isset.is_dhcp_v6 = true;
}

void network_info::__set_mac_address(const std::string& val) {
  this->mac_address = val;
__isset.mac_address = true;
}

void network_info::__set_subnet_masks(const std::vector<std::string> & val) {
  this->subnet_masks = val;
__isset.subnet_masks = true;
}

uint32_t network_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->adapter_name);
          this->__isset.adapter_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->description);
          this->__isset.description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->dnss.clear();
            uint32_t _size23;
            ::apache::thrift::protocol::TType _etype26;
            xfer += iprot->readListBegin(_etype26, _size23);
            this->dnss.resize(_size23);
            uint32_t _i27;
            for (_i27 = 0; _i27 < _size23; ++_i27)
            {
              xfer += iprot->readString(this->dnss[_i27]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.dnss = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->gateways.clear();
            uint32_t _size28;
            ::apache::thrift::protocol::TType _etype31;
            xfer += iprot->readListBegin(_etype31, _size28);
            this->gateways.resize(_size28);
            uint32_t _i32;
            for (_i32 = 0; _i32 < _size28; ++_i32)
            {
              xfer += iprot->readString(this->gateways[_i32]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.gateways = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->ip_addresses.clear();
            uint32_t _size33;
            ::apache::thrift::protocol::TType _etype36;
            xfer += iprot->readListBegin(_etype36, _size33);
            this->ip_addresses.resize(_size33);
            uint32_t _i37;
            for (_i37 = 0; _i37 < _size33; ++_i37)
            {
              xfer += iprot->readString(this->ip_addresses[_i37]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.ip_addresses = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_dhcp_v4);
          this->__isset.is_dhcp_v4 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_dhcp_v6);
          this->__isset.is_dhcp_v6 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->mac_address);
          this->__isset.mac_address = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->subnet_masks.clear();
            uint32_t _size38;
            ::apache::thrift::protocol::TType _etype41;
            xfer += iprot->readListBegin(_etype41, _size38);
            this->subnet_masks.resize(_size38);
            uint32_t _i42;
            for (_i42 = 0; _i42 < _size38; ++_i42)
            {
              xfer += iprot->readString(this->subnet_masks[_i42]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.subnet_masks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t network_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("network_info");

  if (this->__isset.adapter_name) {
    xfer += oprot->writeFieldBegin("adapter_name", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->adapter_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.description) {
    xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->description);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dnss) {
    xfer += oprot->writeFieldBegin("dnss", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->dnss.size()));
      std::vector<std::string> ::const_iterator _iter43;
      for (_iter43 = this->dnss.begin(); _iter43 != this->dnss.end(); ++_iter43)
      {
        xfer += oprot->writeString((*_iter43));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.gateways) {
    xfer += oprot->writeFieldBegin("gateways", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->gateways.size()));
      std::vector<std::string> ::const_iterator _iter44;
      for (_iter44 = this->gateways.begin(); _iter44 != this->gateways.end(); ++_iter44)
      {
        xfer += oprot->writeString((*_iter44));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ip_addresses) {
    xfer += oprot->writeFieldBegin("ip_addresses", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->ip_addresses.size()));
      std::vector<std::string> ::const_iterator _iter45;
      for (_iter45 = this->ip_addresses.begin(); _iter45 != this->ip_addresses.end(); ++_iter45)
      {
        xfer += oprot->writeString((*_iter45));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_dhcp_v4) {
    xfer += oprot->writeFieldBegin("is_dhcp_v4", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->is_dhcp_v4);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_dhcp_v6) {
    xfer += oprot->writeFieldBegin("is_dhcp_v6", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->is_dhcp_v6);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mac_address) {
    xfer += oprot->writeFieldBegin("mac_address", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->mac_address);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.subnet_masks) {
    xfer += oprot->writeFieldBegin("subnet_masks", ::apache::thrift::protocol::T_LIST, 9);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->subnet_masks.size()));
      std::vector<std::string> ::const_iterator _iter46;
      for (_iter46 = this->subnet_masks.begin(); _iter46 != this->subnet_masks.end(); ++_iter46)
      {
        xfer += oprot->writeString((*_iter46));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(network_info &a, network_info &b) {
  using ::std::swap;
  swap(a.adapter_name, b.adapter_name);
  swap(a.description, b.description);
  swap(a.dnss, b.dnss);
  swap(a.gateways, b.gateways);
  swap(a.ip_addresses, b.ip_addresses);
  swap(a.is_dhcp_v4, b.is_dhcp_v4);
  swap(a.is_dhcp_v6, b.is_dhcp_v6);
  swap(a.mac_address, b.mac_address);
  swap(a.subnet_masks, b.subnet_masks);
  swap(a.__isset, b.__isset);
}

network_info::network_info(const network_info& other47) {
  adapter_name = other47.adapter_name;
  description = other47.description;
  dnss = other47.dnss;
  gateways = other47.gateways;
  ip_addresses = other47.ip_addresses;
  is_dhcp_v4 = other47.is_dhcp_v4;
  is_dhcp_v6 = other47.is_dhcp_v6;
  mac_address = other47.mac_address;
  subnet_masks = other47.subnet_masks;
  __isset = other47.__isset;
}
network_info& network_info::operator=(const network_info& other48) {
  adapter_name = other48.adapter_name;
  description = other48.description;
  dnss = other48.dnss;
  gateways = other48.gateways;
  ip_addresses = other48.ip_addresses;
  is_dhcp_v4 = other48.is_dhcp_v4;
  is_dhcp_v6 = other48.is_dhcp_v6;
  mac_address = other48.mac_address;
  subnet_masks = other48.subnet_masks;
  __isset = other48.__isset;
  return *this;
}
void network_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "network_info(";
  out << "adapter_name="; (__isset.adapter_name ? (out << to_string(adapter_name)) : (out << "<null>"));
  out << ", " << "description="; (__isset.description ? (out << to_string(description)) : (out << "<null>"));
  out << ", " << "dnss="; (__isset.dnss ? (out << to_string(dnss)) : (out << "<null>"));
  out << ", " << "gateways="; (__isset.gateways ? (out << to_string(gateways)) : (out << "<null>"));
  out << ", " << "ip_addresses="; (__isset.ip_addresses ? (out << to_string(ip_addresses)) : (out << "<null>"));
  out << ", " << "is_dhcp_v4="; (__isset.is_dhcp_v4 ? (out << to_string(is_dhcp_v4)) : (out << "<null>"));
  out << ", " << "is_dhcp_v6="; (__isset.is_dhcp_v6 ? (out << to_string(is_dhcp_v6)) : (out << "<null>"));
  out << ", " << "mac_address="; (__isset.mac_address ? (out << to_string(mac_address)) : (out << "<null>"));
  out << ", " << "subnet_masks="; (__isset.subnet_masks ? (out << to_string(subnet_masks)) : (out << "<null>"));
  out << ")";
}


os_version_info::~os_version_info() throw() {
}


void os_version_info::__set_csd_version(const std::string& val) {
  this->csd_version = val;
__isset.csd_version = true;
}

void os_version_info::__set_build_number(const int32_t val) {
  this->build_number = val;
__isset.build_number = true;
}

void os_version_info::__set_major_version(const int32_t val) {
  this->major_version = val;
__isset.major_version = true;
}

void os_version_info::__set_minor_version(const int32_t val) {
  this->minor_version = val;
__isset.minor_version = true;
}

void os_version_info::__set_platform_id(const int32_t val) {
  this->platform_id = val;
__isset.platform_id = true;
}

void os_version_info::__set_product_type(const int16_t val) {
  this->product_type = val;
__isset.product_type = true;
}

void os_version_info::__set_servicepack_major(const int32_t val) {
  this->servicepack_major = val;
__isset.servicepack_major = true;
}

void os_version_info::__set_servicepack_minor(const int32_t val) {
  this->servicepack_minor = val;
__isset.servicepack_minor = true;
}

void os_version_info::__set_suite_mask(const int32_t val) {
  this->suite_mask = val;
__isset.suite_mask = true;
}

uint32_t os_version_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->csd_version);
          this->__isset.csd_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->build_number);
          this->__isset.build_number = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->major_version);
          this->__isset.major_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->minor_version);
          this->__isset.minor_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->platform_id);
          this->__isset.platform_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->product_type);
          this->__isset.product_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->servicepack_major);
          this->__isset.servicepack_major = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->servicepack_minor);
          this->__isset.servicepack_minor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->suite_mask);
          this->__isset.suite_mask = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t os_version_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("os_version_info");

  if (this->__isset.csd_version) {
    xfer += oprot->writeFieldBegin("csd_version", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->csd_version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.build_number) {
    xfer += oprot->writeFieldBegin("build_number", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->build_number);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.major_version) {
    xfer += oprot->writeFieldBegin("major_version", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->major_version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.minor_version) {
    xfer += oprot->writeFieldBegin("minor_version", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->minor_version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.platform_id) {
    xfer += oprot->writeFieldBegin("platform_id", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->platform_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.product_type) {
    xfer += oprot->writeFieldBegin("product_type", ::apache::thrift::protocol::T_I16, 6);
    xfer += oprot->writeI16(this->product_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.servicepack_major) {
    xfer += oprot->writeFieldBegin("servicepack_major", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32(this->servicepack_major);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.servicepack_minor) {
    xfer += oprot->writeFieldBegin("servicepack_minor", ::apache::thrift::protocol::T_I32, 8);
    xfer += oprot->writeI32(this->servicepack_minor);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.suite_mask) {
    xfer += oprot->writeFieldBegin("suite_mask", ::apache::thrift::protocol::T_I32, 9);
    xfer += oprot->writeI32(this->suite_mask);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(os_version_info &a, os_version_info &b) {
  using ::std::swap;
  swap(a.csd_version, b.csd_version);
  swap(a.build_number, b.build_number);
  swap(a.major_version, b.major_version);
  swap(a.minor_version, b.minor_version);
  swap(a.platform_id, b.platform_id);
  swap(a.product_type, b.product_type);
  swap(a.servicepack_major, b.servicepack_major);
  swap(a.servicepack_minor, b.servicepack_minor);
  swap(a.suite_mask, b.suite_mask);
  swap(a.__isset, b.__isset);
}

os_version_info::os_version_info(const os_version_info& other49) {
  csd_version = other49.csd_version;
  build_number = other49.build_number;
  major_version = other49.major_version;
  minor_version = other49.minor_version;
  platform_id = other49.platform_id;
  product_type = other49.product_type;
  servicepack_major = other49.servicepack_major;
  servicepack_minor = other49.servicepack_minor;
  suite_mask = other49.suite_mask;
  __isset = other49.__isset;
}
os_version_info& os_version_info::operator=(const os_version_info& other50) {
  csd_version = other50.csd_version;
  build_number = other50.build_number;
  major_version = other50.major_version;
  minor_version = other50.minor_version;
  platform_id = other50.platform_id;
  product_type = other50.product_type;
  servicepack_major = other50.servicepack_major;
  servicepack_minor = other50.servicepack_minor;
  suite_mask = other50.suite_mask;
  __isset = other50.__isset;
  return *this;
}
void os_version_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "os_version_info(";
  out << "csd_version="; (__isset.csd_version ? (out << to_string(csd_version)) : (out << "<null>"));
  out << ", " << "build_number="; (__isset.build_number ? (out << to_string(build_number)) : (out << "<null>"));
  out << ", " << "major_version="; (__isset.major_version ? (out << to_string(major_version)) : (out << "<null>"));
  out << ", " << "minor_version="; (__isset.minor_version ? (out << to_string(minor_version)) : (out << "<null>"));
  out << ", " << "platform_id="; (__isset.platform_id ? (out << to_string(platform_id)) : (out << "<null>"));
  out << ", " << "product_type="; (__isset.product_type ? (out << to_string(product_type)) : (out << "<null>"));
  out << ", " << "servicepack_major="; (__isset.servicepack_major ? (out << to_string(servicepack_major)) : (out << "<null>"));
  out << ", " << "servicepack_minor="; (__isset.servicepack_minor ? (out << to_string(servicepack_minor)) : (out << "<null>"));
  out << ", " << "suite_mask="; (__isset.suite_mask ? (out << to_string(suite_mask)) : (out << "<null>"));
  out << ")";
}


physical_client_info::~physical_client_info() throw() {
}


void physical_client_info::__set_architecture(const std::string& val) {
  this->architecture = val;
__isset.architecture = true;
}

void physical_client_info::__set_client_name(const std::string& val) {
  this->client_name = val;
__isset.client_name = true;
}

void physical_client_info::__set_domain(const std::string& val) {
  this->domain = val;
__isset.domain = true;
}

void physical_client_info::__set_hal(const std::string& val) {
  this->hal = val;
__isset.hal = true;
}

void physical_client_info::__set_initiator_name(const std::string& val) {
  this->initiator_name = val;
__isset.initiator_name = true;
}

void physical_client_info::__set_is_oem(const bool val) {
  this->is_oem = val;
__isset.is_oem = true;
}

void physical_client_info::__set_logical_processors(const int16_t val) {
  this->logical_processors = val;
__isset.logical_processors = true;
}

void physical_client_info::__set_manufacturer(const std::string& val) {
  this->manufacturer = val;
__isset.manufacturer = true;
}

void physical_client_info::__set_os_name(const std::string& val) {
  this->os_name = val;
__isset.os_name = true;
}

void physical_client_info::__set_os_type(const int32_t val) {
  this->os_type = val;
__isset.os_type = true;
}

void physical_client_info::__set_os_system_info(const std::string& val) {
  this->os_system_info = val;
__isset.os_system_info = true;
}

void physical_client_info::__set_physical_memory(const int64_t val) {
  this->physical_memory = val;
__isset.physical_memory = true;
}

void physical_client_info::__set_processors(const int16_t val) {
  this->processors = val;
__isset.processors = true;
}

void physical_client_info::__set_role(const int32_t val) {
  this->role = val;
__isset.role = true;
}

void physical_client_info::__set_system_model(const std::string& val) {
  this->system_model = val;
__isset.system_model = true;
}

void physical_client_info::__set_system_root(const std::string& val) {
  this->system_root = val;
__isset.system_root = true;
}

void physical_client_info::__set_workgroup(const std::string& val) {
  this->workgroup = val;
__isset.workgroup = true;
}

void physical_client_info::__set_os_version(const os_version_info& val) {
  this->os_version = val;
__isset.os_version = true;
}

void physical_client_info::__set_disk_infos(const std::set<disk_info> & val) {
  this->disk_infos = val;
__isset.disk_infos = true;
}

void physical_client_info::__set_partition_infos(const std::set<partition_info> & val) {
  this->partition_infos = val;
__isset.partition_infos = true;
}

void physical_client_info::__set_volume_infos(const std::set<volume_info> & val) {
  this->volume_infos = val;
__isset.volume_infos = true;
}

void physical_client_info::__set_network_infos(const std::set<network_info> & val) {
  this->network_infos = val;
__isset.network_infos = true;
}

uint32_t physical_client_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->architecture);
          this->__isset.architecture = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->client_name);
          this->__isset.client_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->domain);
          this->__isset.domain = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hal);
          this->__isset.hal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->initiator_name);
          this->__isset.initiator_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_oem);
          this->__isset.is_oem = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->logical_processors);
          this->__isset.logical_processors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->manufacturer);
          this->__isset.manufacturer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->os_name);
          this->__isset.os_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->os_type);
          this->__isset.os_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->os_system_info);
          this->__isset.os_system_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->physical_memory);
          this->__isset.physical_memory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->processors);
          this->__isset.processors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->role);
          this->__isset.role = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->system_model);
          this->__isset.system_model = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->system_root);
          this->__isset.system_root = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->workgroup);
          this->__isset.workgroup = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->os_version.read(iprot);
          this->__isset.os_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->disk_infos.clear();
            uint32_t _size51;
            ::apache::thrift::protocol::TType _etype54;
            xfer += iprot->readSetBegin(_etype54, _size51);
            uint32_t _i55;
            for (_i55 = 0; _i55 < _size51; ++_i55)
            {
              disk_info _elem56;
              xfer += _elem56.read(iprot);
              this->disk_infos.insert(_elem56);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.disk_infos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->partition_infos.clear();
            uint32_t _size57;
            ::apache::thrift::protocol::TType _etype60;
            xfer += iprot->readSetBegin(_etype60, _size57);
            uint32_t _i61;
            for (_i61 = 0; _i61 < _size57; ++_i61)
            {
              partition_info _elem62;
              xfer += _elem62.read(iprot);
              this->partition_infos.insert(_elem62);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.partition_infos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->volume_infos.clear();
            uint32_t _size63;
            ::apache::thrift::protocol::TType _etype66;
            xfer += iprot->readSetBegin(_etype66, _size63);
            uint32_t _i67;
            for (_i67 = 0; _i67 < _size63; ++_i67)
            {
              volume_info _elem68;
              xfer += _elem68.read(iprot);
              this->volume_infos.insert(_elem68);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.volume_infos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->network_infos.clear();
            uint32_t _size69;
            ::apache::thrift::protocol::TType _etype72;
            xfer += iprot->readSetBegin(_etype72, _size69);
            uint32_t _i73;
            for (_i73 = 0; _i73 < _size69; ++_i73)
            {
              network_info _elem74;
              xfer += _elem74.read(iprot);
              this->network_infos.insert(_elem74);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.network_infos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t physical_client_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("physical_client_info");

  if (this->__isset.architecture) {
    xfer += oprot->writeFieldBegin("architecture", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->architecture);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.client_name) {
    xfer += oprot->writeFieldBegin("client_name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->client_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.domain) {
    xfer += oprot->writeFieldBegin("domain", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->domain);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.hal) {
    xfer += oprot->writeFieldBegin("hal", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->hal);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.initiator_name) {
    xfer += oprot->writeFieldBegin("initiator_name", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->initiator_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_oem) {
    xfer += oprot->writeFieldBegin("is_oem", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->is_oem);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.logical_processors) {
    xfer += oprot->writeFieldBegin("logical_processors", ::apache::thrift::protocol::T_I16, 7);
    xfer += oprot->writeI16(this->logical_processors);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.manufacturer) {
    xfer += oprot->writeFieldBegin("manufacturer", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->manufacturer);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.os_name) {
    xfer += oprot->writeFieldBegin("os_name", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->os_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.os_type) {
    xfer += oprot->writeFieldBegin("os_type", ::apache::thrift::protocol::T_I32, 10);
    xfer += oprot->writeI32(this->os_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.os_system_info) {
    xfer += oprot->writeFieldBegin("os_system_info", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeString(this->os_system_info);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.physical_memory) {
    xfer += oprot->writeFieldBegin("physical_memory", ::apache::thrift::protocol::T_I64, 12);
    xfer += oprot->writeI64(this->physical_memory);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.processors) {
    xfer += oprot->writeFieldBegin("processors", ::apache::thrift::protocol::T_I16, 13);
    xfer += oprot->writeI16(this->processors);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.role) {
    xfer += oprot->writeFieldBegin("role", ::apache::thrift::protocol::T_I32, 14);
    xfer += oprot->writeI32(this->role);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.system_model) {
    xfer += oprot->writeFieldBegin("system_model", ::apache::thrift::protocol::T_STRING, 15);
    xfer += oprot->writeString(this->system_model);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.system_root) {
    xfer += oprot->writeFieldBegin("system_root", ::apache::thrift::protocol::T_STRING, 16);
    xfer += oprot->writeString(this->system_root);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.workgroup) {
    xfer += oprot->writeFieldBegin("workgroup", ::apache::thrift::protocol::T_STRING, 17);
    xfer += oprot->writeString(this->workgroup);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.os_version) {
    xfer += oprot->writeFieldBegin("os_version", ::apache::thrift::protocol::T_STRUCT, 18);
    xfer += this->os_version.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.disk_infos) {
    xfer += oprot->writeFieldBegin("disk_infos", ::apache::thrift::protocol::T_SET, 19);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->disk_infos.size()));
      std::set<disk_info> ::const_iterator _iter75;
      for (_iter75 = this->disk_infos.begin(); _iter75 != this->disk_infos.end(); ++_iter75)
      {
        xfer += (*_iter75).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partition_infos) {
    xfer += oprot->writeFieldBegin("partition_infos", ::apache::thrift::protocol::T_SET, 20);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partition_infos.size()));
      std::set<partition_info> ::const_iterator _iter76;
      for (_iter76 = this->partition_infos.begin(); _iter76 != this->partition_infos.end(); ++_iter76)
      {
        xfer += (*_iter76).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.volume_infos) {
    xfer += oprot->writeFieldBegin("volume_infos", ::apache::thrift::protocol::T_SET, 21);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->volume_infos.size()));
      std::set<volume_info> ::const_iterator _iter77;
      for (_iter77 = this->volume_infos.begin(); _iter77 != this->volume_infos.end(); ++_iter77)
      {
        xfer += (*_iter77).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.network_infos) {
    xfer += oprot->writeFieldBegin("network_infos", ::apache::thrift::protocol::T_SET, 22);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->network_infos.size()));
      std::set<network_info> ::const_iterator _iter78;
      for (_iter78 = this->network_infos.begin(); _iter78 != this->network_infos.end(); ++_iter78)
      {
        xfer += (*_iter78).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(physical_client_info &a, physical_client_info &b) {
  using ::std::swap;
  swap(a.architecture, b.architecture);
  swap(a.client_name, b.client_name);
  swap(a.domain, b.domain);
  swap(a.hal, b.hal);
  swap(a.initiator_name, b.initiator_name);
  swap(a.is_oem, b.is_oem);
  swap(a.logical_processors, b.logical_processors);
  swap(a.manufacturer, b.manufacturer);
  swap(a.os_name, b.os_name);
  swap(a.os_type, b.os_type);
  swap(a.os_system_info, b.os_system_info);
  swap(a.physical_memory, b.physical_memory);
  swap(a.processors, b.processors);
  swap(a.role, b.role);
  swap(a.system_model, b.system_model);
  swap(a.system_root, b.system_root);
  swap(a.workgroup, b.workgroup);
  swap(a.os_version, b.os_version);
  swap(a.disk_infos, b.disk_infos);
  swap(a.partition_infos, b.partition_infos);
  swap(a.volume_infos, b.volume_infos);
  swap(a.network_infos, b.network_infos);
  swap(a.__isset, b.__isset);
}

physical_client_info::physical_client_info(const physical_client_info& other79) {
  architecture = other79.architecture;
  client_name = other79.client_name;
  domain = other79.domain;
  hal = other79.hal;
  initiator_name = other79.initiator_name;
  is_oem = other79.is_oem;
  logical_processors = other79.logical_processors;
  manufacturer = other79.manufacturer;
  os_name = other79.os_name;
  os_type = other79.os_type;
  os_system_info = other79.os_system_info;
  physical_memory = other79.physical_memory;
  processors = other79.processors;
  role = other79.role;
  system_model = other79.system_model;
  system_root = other79.system_root;
  workgroup = other79.workgroup;
  os_version = other79.os_version;
  disk_infos = other79.disk_infos;
  partition_infos = other79.partition_infos;
  volume_infos = other79.volume_infos;
  network_infos = other79.network_infos;
  __isset = other79.__isset;
}
physical_client_info& physical_client_info::operator=(const physical_client_info& other80) {
  architecture = other80.architecture;
  client_name = other80.client_name;
  domain = other80.domain;
  hal = other80.hal;
  initiator_name = other80.initiator_name;
  is_oem = other80.is_oem;
  logical_processors = other80.logical_processors;
  manufacturer = other80.manufacturer;
  os_name = other80.os_name;
  os_type = other80.os_type;
  os_system_info = other80.os_system_info;
  physical_memory = other80.physical_memory;
  processors = other80.processors;
  role = other80.role;
  system_model = other80.system_model;
  system_root = other80.system_root;
  workgroup = other80.workgroup;
  os_version = other80.os_version;
  disk_infos = other80.disk_infos;
  partition_infos = other80.partition_infos;
  volume_infos = other80.volume_infos;
  network_infos = other80.network_infos;
  __isset = other80.__isset;
  return *this;
}
void physical_client_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "physical_client_info(";
  out << "architecture="; (__isset.architecture ? (out << to_string(architecture)) : (out << "<null>"));
  out << ", " << "client_name="; (__isset.client_name ? (out << to_string(client_name)) : (out << "<null>"));
  out << ", " << "domain="; (__isset.domain ? (out << to_string(domain)) : (out << "<null>"));
  out << ", " << "hal="; (__isset.hal ? (out << to_string(hal)) : (out << "<null>"));
  out << ", " << "initiator_name="; (__isset.initiator_name ? (out << to_string(initiator_name)) : (out << "<null>"));
  out << ", " << "is_oem="; (__isset.is_oem ? (out << to_string(is_oem)) : (out << "<null>"));
  out << ", " << "logical_processors="; (__isset.logical_processors ? (out << to_string(logical_processors)) : (out << "<null>"));
  out << ", " << "manufacturer="; (__isset.manufacturer ? (out << to_string(manufacturer)) : (out << "<null>"));
  out << ", " << "os_name="; (__isset.os_name ? (out << to_string(os_name)) : (out << "<null>"));
  out << ", " << "os_type="; (__isset.os_type ? (out << to_string(os_type)) : (out << "<null>"));
  out << ", " << "os_system_info="; (__isset.os_system_info ? (out << to_string(os_system_info)) : (out << "<null>"));
  out << ", " << "physical_memory="; (__isset.physical_memory ? (out << to_string(physical_memory)) : (out << "<null>"));
  out << ", " << "processors="; (__isset.processors ? (out << to_string(processors)) : (out << "<null>"));
  out << ", " << "role="; (__isset.role ? (out << to_string(role)) : (out << "<null>"));
  out << ", " << "system_model="; (__isset.system_model ? (out << to_string(system_model)) : (out << "<null>"));
  out << ", " << "system_root="; (__isset.system_root ? (out << to_string(system_root)) : (out << "<null>"));
  out << ", " << "workgroup="; (__isset.workgroup ? (out << to_string(workgroup)) : (out << "<null>"));
  out << ", " << "os_version="; (__isset.os_version ? (out << to_string(os_version)) : (out << "<null>"));
  out << ", " << "disk_infos="; (__isset.disk_infos ? (out << to_string(disk_infos)) : (out << "<null>"));
  out << ", " << "partition_infos="; (__isset.partition_infos ? (out << to_string(partition_infos)) : (out << "<null>"));
  out << ", " << "volume_infos="; (__isset.volume_infos ? (out << to_string(volume_infos)) : (out << "<null>"));
  out << ", " << "network_infos="; (__isset.network_infos ? (out << to_string(network_infos)) : (out << "<null>"));
  out << ")";
}


virtual_host::~virtual_host() throw() {
}


void virtual_host::__set_name_ref(const std::string& val) {
  this->name_ref = val;
__isset.name_ref = true;
}

void virtual_host::__set_name(const std::string& val) {
  this->name = val;
__isset.name = true;
}

void virtual_host::__set_ip_addresses(const std::vector<std::string> & val) {
  this->ip_addresses = val;
__isset.ip_addresses = true;
}

void virtual_host::__set_ip_address(const std::string& val) {
  this->ip_address = val;
__isset.ip_address = true;
}

void virtual_host::__set_product_name(const std::string& val) {
  this->product_name = val;
__isset.product_name = true;
}

void virtual_host::__set_version(const std::string& val) {
  this->version = val;
__isset.version = true;
}

void virtual_host::__set_power_state(const hv_host_power_state::type val) {
  this->power_state = val;
__isset.power_state = true;
}

void virtual_host::__set_state(const std::string& val) {
  this->state = val;
__isset.state = true;
}

void virtual_host::__set_in_maintenance_mode(const bool val) {
  this->in_maintenance_mode = val;
__isset.in_maintenance_mode = true;
}

void virtual_host::__set_vms(const std::map<std::string, std::string> & val) {
  this->vms = val;
__isset.vms = true;
}

void virtual_host::__set_datastores(const std::map<std::string, std::string> & val) {
  this->datastores = val;
__isset.datastores = true;
}

void virtual_host::__set_networks(const std::map<std::string, std::string> & val) {
  this->networks = val;
__isset.networks = true;
}

void virtual_host::__set_datacenter_name(const std::string& val) {
  this->datacenter_name = val;
__isset.datacenter_name = true;
}

void virtual_host::__set_domain_name(const std::string& val) {
  this->domain_name = val;
__isset.domain_name = true;
}

void virtual_host::__set_cluster_key(const std::string& val) {
  this->cluster_key = val;
__isset.cluster_key = true;
}

void virtual_host::__set_full_name(const std::string& val) {
  this->full_name = val;
__isset.full_name = true;
}

uint32_t virtual_host::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name_ref);
          this->__isset.name_ref = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->ip_addresses.clear();
            uint32_t _size81;
            ::apache::thrift::protocol::TType _etype84;
            xfer += iprot->readListBegin(_etype84, _size81);
            this->ip_addresses.resize(_size81);
            uint32_t _i85;
            for (_i85 = 0; _i85 < _size81; ++_i85)
            {
              xfer += iprot->readString(this->ip_addresses[_i85]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.ip_addresses = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ip_address);
          this->__isset.ip_address = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->product_name);
          this->__isset.product_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast86;
          xfer += iprot->readI32(ecast86);
          this->power_state = (hv_host_power_state::type)ecast86;
          this->__isset.power_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->state);
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->in_maintenance_mode);
          this->__isset.in_maintenance_mode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->vms.clear();
            uint32_t _size87;
            ::apache::thrift::protocol::TType _ktype88;
            ::apache::thrift::protocol::TType _vtype89;
            xfer += iprot->readMapBegin(_ktype88, _vtype89, _size87);
            uint32_t _i91;
            for (_i91 = 0; _i91 < _size87; ++_i91)
            {
              std::string _key92;
              xfer += iprot->readString(_key92);
              std::string& _val93 = this->vms[_key92];
              xfer += iprot->readString(_val93);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.vms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->datastores.clear();
            uint32_t _size94;
            ::apache::thrift::protocol::TType _ktype95;
            ::apache::thrift::protocol::TType _vtype96;
            xfer += iprot->readMapBegin(_ktype95, _vtype96, _size94);
            uint32_t _i98;
            for (_i98 = 0; _i98 < _size94; ++_i98)
            {
              std::string _key99;
              xfer += iprot->readString(_key99);
              std::string& _val100 = this->datastores[_key99];
              xfer += iprot->readString(_val100);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.datastores = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->networks.clear();
            uint32_t _size101;
            ::apache::thrift::protocol::TType _ktype102;
            ::apache::thrift::protocol::TType _vtype103;
            xfer += iprot->readMapBegin(_ktype102, _vtype103, _size101);
            uint32_t _i105;
            for (_i105 = 0; _i105 < _size101; ++_i105)
            {
              std::string _key106;
              xfer += iprot->readString(_key106);
              std::string& _val107 = this->networks[_key106];
              xfer += iprot->readString(_val107);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.networks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->datacenter_name);
          this->__isset.datacenter_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->domain_name);
          this->__isset.domain_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cluster_key);
          this->__isset.cluster_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->full_name);
          this->__isset.full_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t virtual_host::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("virtual_host");

  if (this->__isset.name_ref) {
    xfer += oprot->writeFieldBegin("name_ref", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->name_ref);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ip_addresses) {
    xfer += oprot->writeFieldBegin("ip_addresses", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->ip_addresses.size()));
      std::vector<std::string> ::const_iterator _iter108;
      for (_iter108 = this->ip_addresses.begin(); _iter108 != this->ip_addresses.end(); ++_iter108)
      {
        xfer += oprot->writeString((*_iter108));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ip_address) {
    xfer += oprot->writeFieldBegin("ip_address", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->ip_address);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.product_name) {
    xfer += oprot->writeFieldBegin("product_name", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->product_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.version) {
    xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.power_state) {
    xfer += oprot->writeFieldBegin("power_state", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32((int32_t)this->power_state);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.state) {
    xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->state);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.in_maintenance_mode) {
    xfer += oprot->writeFieldBegin("in_maintenance_mode", ::apache::thrift::protocol::T_BOOL, 9);
    xfer += oprot->writeBool(this->in_maintenance_mode);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vms) {
    xfer += oprot->writeFieldBegin("vms", ::apache::thrift::protocol::T_MAP, 10);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->vms.size()));
      std::map<std::string, std::string> ::const_iterator _iter109;
      for (_iter109 = this->vms.begin(); _iter109 != this->vms.end(); ++_iter109)
      {
        xfer += oprot->writeString(_iter109->first);
        xfer += oprot->writeString(_iter109->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.datastores) {
    xfer += oprot->writeFieldBegin("datastores", ::apache::thrift::protocol::T_MAP, 11);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->datastores.size()));
      std::map<std::string, std::string> ::const_iterator _iter110;
      for (_iter110 = this->datastores.begin(); _iter110 != this->datastores.end(); ++_iter110)
      {
        xfer += oprot->writeString(_iter110->first);
        xfer += oprot->writeString(_iter110->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.networks) {
    xfer += oprot->writeFieldBegin("networks", ::apache::thrift::protocol::T_MAP, 12);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->networks.size()));
      std::map<std::string, std::string> ::const_iterator _iter111;
      for (_iter111 = this->networks.begin(); _iter111 != this->networks.end(); ++_iter111)
      {
        xfer += oprot->writeString(_iter111->first);
        xfer += oprot->writeString(_iter111->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.datacenter_name) {
    xfer += oprot->writeFieldBegin("datacenter_name", ::apache::thrift::protocol::T_STRING, 13);
    xfer += oprot->writeString(this->datacenter_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.domain_name) {
    xfer += oprot->writeFieldBegin("domain_name", ::apache::thrift::protocol::T_STRING, 14);
    xfer += oprot->writeString(this->domain_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_key) {
    xfer += oprot->writeFieldBegin("cluster_key", ::apache::thrift::protocol::T_STRING, 15);
    xfer += oprot->writeString(this->cluster_key);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.full_name) {
    xfer += oprot->writeFieldBegin("full_name", ::apache::thrift::protocol::T_STRING, 16);
    xfer += oprot->writeString(this->full_name);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(virtual_host &a, virtual_host &b) {
  using ::std::swap;
  swap(a.name_ref, b.name_ref);
  swap(a.name, b.name);
  swap(a.ip_addresses, b.ip_addresses);
  swap(a.ip_address, b.ip_address);
  swap(a.product_name, b.product_name);
  swap(a.version, b.version);
  swap(a.power_state, b.power_state);
  swap(a.state, b.state);
  swap(a.in_maintenance_mode, b.in_maintenance_mode);
  swap(a.vms, b.vms);
  swap(a.datastores, b.datastores);
  swap(a.networks, b.networks);
  swap(a.datacenter_name, b.datacenter_name);
  swap(a.domain_name, b.domain_name);
  swap(a.cluster_key, b.cluster_key);
  swap(a.full_name, b.full_name);
  swap(a.__isset, b.__isset);
}

virtual_host::virtual_host(const virtual_host& other112) {
  name_ref = other112.name_ref;
  name = other112.name;
  ip_addresses = other112.ip_addresses;
  ip_address = other112.ip_address;
  product_name = other112.product_name;
  version = other112.version;
  power_state = other112.power_state;
  state = other112.state;
  in_maintenance_mode = other112.in_maintenance_mode;
  vms = other112.vms;
  datastores = other112.datastores;
  networks = other112.networks;
  datacenter_name = other112.datacenter_name;
  domain_name = other112.domain_name;
  cluster_key = other112.cluster_key;
  full_name = other112.full_name;
  __isset = other112.__isset;
}
virtual_host& virtual_host::operator=(const virtual_host& other113) {
  name_ref = other113.name_ref;
  name = other113.name;
  ip_addresses = other113.ip_addresses;
  ip_address = other113.ip_address;
  product_name = other113.product_name;
  version = other113.version;
  power_state = other113.power_state;
  state = other113.state;
  in_maintenance_mode = other113.in_maintenance_mode;
  vms = other113.vms;
  datastores = other113.datastores;
  networks = other113.networks;
  datacenter_name = other113.datacenter_name;
  domain_name = other113.domain_name;
  cluster_key = other113.cluster_key;
  full_name = other113.full_name;
  __isset = other113.__isset;
  return *this;
}
void virtual_host::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "virtual_host(";
  out << "name_ref="; (__isset.name_ref ? (out << to_string(name_ref)) : (out << "<null>"));
  out << ", " << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
  out << ", " << "ip_addresses="; (__isset.ip_addresses ? (out << to_string(ip_addresses)) : (out << "<null>"));
  out << ", " << "ip_address="; (__isset.ip_address ? (out << to_string(ip_address)) : (out << "<null>"));
  out << ", " << "product_name="; (__isset.product_name ? (out << to_string(product_name)) : (out << "<null>"));
  out << ", " << "version="; (__isset.version ? (out << to_string(version)) : (out << "<null>"));
  out << ", " << "power_state="; (__isset.power_state ? (out << to_string(power_state)) : (out << "<null>"));
  out << ", " << "state="; (__isset.state ? (out << to_string(state)) : (out << "<null>"));
  out << ", " << "in_maintenance_mode="; (__isset.in_maintenance_mode ? (out << to_string(in_maintenance_mode)) : (out << "<null>"));
  out << ", " << "vms="; (__isset.vms ? (out << to_string(vms)) : (out << "<null>"));
  out << ", " << "datastores="; (__isset.datastores ? (out << to_string(datastores)) : (out << "<null>"));
  out << ", " << "networks="; (__isset.networks ? (out << to_string(networks)) : (out << "<null>"));
  out << ", " << "datacenter_name="; (__isset.datacenter_name ? (out << to_string(datacenter_name)) : (out << "<null>"));
  out << ", " << "domain_name="; (__isset.domain_name ? (out << to_string(domain_name)) : (out << "<null>"));
  out << ", " << "cluster_key="; (__isset.cluster_key ? (out << to_string(cluster_key)) : (out << "<null>"));
  out << ", " << "full_name="; (__isset.full_name ? (out << to_string(full_name)) : (out << "<null>"));
  out << ")";
}


virtual_network_adapter::~virtual_network_adapter() throw() {
}


void virtual_network_adapter::__set_key(const int32_t val) {
  this->key = val;
__isset.key = true;
}

void virtual_network_adapter::__set_name(const std::string& val) {
  this->name = val;
__isset.name = true;
}

void virtual_network_adapter::__set_mac_address(const std::string& val) {
  this->mac_address = val;
__isset.mac_address = true;
}

void virtual_network_adapter::__set_network(const std::string& val) {
  this->network = val;
__isset.network = true;
}

void virtual_network_adapter::__set_port_group(const std::string& val) {
  this->port_group = val;
__isset.port_group = true;
}

void virtual_network_adapter::__set_type(const std::string& val) {
  this->type = val;
__isset.type = true;
}

void virtual_network_adapter::__set_is_connected(const bool val) {
  this->is_connected = val;
__isset.is_connected = true;
}

void virtual_network_adapter::__set_is_start_connected(const bool val) {
  this->is_start_connected = val;
__isset.is_start_connected = true;
}

void virtual_network_adapter::__set_is_allow_guest_control(const bool val) {
  this->is_allow_guest_control = val;
__isset.is_allow_guest_control = true;
}

void virtual_network_adapter::__set_address_type(const std::string& val) {
  this->address_type = val;
__isset.address_type = true;
}

uint32_t virtual_network_adapter::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->mac_address);
          this->__isset.mac_address = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->network);
          this->__isset.network = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->port_group);
          this->__isset.port_group = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_connected);
          this->__isset.is_connected = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_start_connected);
          this->__isset.is_start_connected = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_allow_guest_control);
          this->__isset.is_allow_guest_control = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->address_type);
          this->__isset.address_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t virtual_network_adapter::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("virtual_network_adapter");

  if (this->__isset.key) {
    xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->key);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mac_address) {
    xfer += oprot->writeFieldBegin("mac_address", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->mac_address);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.network) {
    xfer += oprot->writeFieldBegin("network", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->network);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.port_group) {
    xfer += oprot->writeFieldBegin("port_group", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->port_group);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.type) {
    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_connected) {
    xfer += oprot->writeFieldBegin("is_connected", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->is_connected);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_start_connected) {
    xfer += oprot->writeFieldBegin("is_start_connected", ::apache::thrift::protocol::T_BOOL, 8);
    xfer += oprot->writeBool(this->is_start_connected);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_allow_guest_control) {
    xfer += oprot->writeFieldBegin("is_allow_guest_control", ::apache::thrift::protocol::T_BOOL, 9);
    xfer += oprot->writeBool(this->is_allow_guest_control);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.address_type) {
    xfer += oprot->writeFieldBegin("address_type", ::apache::thrift::protocol::T_STRING, 10);
    xfer += oprot->writeString(this->address_type);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(virtual_network_adapter &a, virtual_network_adapter &b) {
  using ::std::swap;
  swap(a.key, b.key);
  swap(a.name, b.name);
  swap(a.mac_address, b.mac_address);
  swap(a.network, b.network);
  swap(a.port_group, b.port_group);
  swap(a.type, b.type);
  swap(a.is_connected, b.is_connected);
  swap(a.is_start_connected, b.is_start_connected);
  swap(a.is_allow_guest_control, b.is_allow_guest_control);
  swap(a.address_type, b.address_type);
  swap(a.__isset, b.__isset);
}

virtual_network_adapter::virtual_network_adapter(const virtual_network_adapter& other114) {
  key = other114.key;
  name = other114.name;
  mac_address = other114.mac_address;
  network = other114.network;
  port_group = other114.port_group;
  type = other114.type;
  is_connected = other114.is_connected;
  is_start_connected = other114.is_start_connected;
  is_allow_guest_control = other114.is_allow_guest_control;
  address_type = other114.address_type;
  __isset = other114.__isset;
}
virtual_network_adapter& virtual_network_adapter::operator=(const virtual_network_adapter& other115) {
  key = other115.key;
  name = other115.name;
  mac_address = other115.mac_address;
  network = other115.network;
  port_group = other115.port_group;
  type = other115.type;
  is_connected = other115.is_connected;
  is_start_connected = other115.is_start_connected;
  is_allow_guest_control = other115.is_allow_guest_control;
  address_type = other115.address_type;
  __isset = other115.__isset;
  return *this;
}
void virtual_network_adapter::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "virtual_network_adapter(";
  out << "key="; (__isset.key ? (out << to_string(key)) : (out << "<null>"));
  out << ", " << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
  out << ", " << "mac_address="; (__isset.mac_address ? (out << to_string(mac_address)) : (out << "<null>"));
  out << ", " << "network="; (__isset.network ? (out << to_string(network)) : (out << "<null>"));
  out << ", " << "port_group="; (__isset.port_group ? (out << to_string(port_group)) : (out << "<null>"));
  out << ", " << "type="; (__isset.type ? (out << to_string(type)) : (out << "<null>"));
  out << ", " << "is_connected="; (__isset.is_connected ? (out << to_string(is_connected)) : (out << "<null>"));
  out << ", " << "is_start_connected="; (__isset.is_start_connected ? (out << to_string(is_start_connected)) : (out << "<null>"));
  out << ", " << "is_allow_guest_control="; (__isset.is_allow_guest_control ? (out << to_string(is_allow_guest_control)) : (out << "<null>"));
  out << ", " << "address_type="; (__isset.address_type ? (out << to_string(address_type)) : (out << "<null>"));
  out << ")";
}


virtual_machine_snapshots::~virtual_machine_snapshots() throw() {
}


void virtual_machine_snapshots::__set_name(const std::string& val) {
  this->name = val;
__isset.name = true;
}

void virtual_machine_snapshots::__set_description(const std::string& val) {
  this->description = val;
__isset.description = true;
}

void virtual_machine_snapshots::__set_create_time(const std::string& val) {
  this->create_time = val;
__isset.create_time = true;
}

void virtual_machine_snapshots::__set_quiesced(const bool val) {
  this->quiesced = val;
__isset.quiesced = true;
}

void virtual_machine_snapshots::__set_id(const int32_t val) {
  this->id = val;
__isset.id = true;
}

void virtual_machine_snapshots::__set_backup_manifest(const std::string& val) {
  this->backup_manifest = val;
__isset.backup_manifest = true;
}

void virtual_machine_snapshots::__set_replay_supported(const bool val) {
  this->replay_supported = val;
__isset.replay_supported = true;
}

void virtual_machine_snapshots::__set_child_snapshot_list(const std::vector<virtual_machine_snapshots> & val) {
  this->child_snapshot_list = val;
__isset.child_snapshot_list = true;
}

uint32_t virtual_machine_snapshots::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->description);
          this->__isset.description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->create_time);
          this->__isset.create_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->quiesced);
          this->__isset.quiesced = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->backup_manifest);
          this->__isset.backup_manifest = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->replay_supported);
          this->__isset.replay_supported = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->child_snapshot_list.clear();
            uint32_t _size116;
            ::apache::thrift::protocol::TType _etype119;
            xfer += iprot->readListBegin(_etype119, _size116);
            this->child_snapshot_list.resize(_size116);
            uint32_t _i120;
            for (_i120 = 0; _i120 < _size116; ++_i120)
            {
              xfer += this->child_snapshot_list[_i120].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.child_snapshot_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t virtual_machine_snapshots::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("virtual_machine_snapshots");

  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.description) {
    xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->description);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.create_time) {
    xfer += oprot->writeFieldBegin("create_time", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->create_time);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.quiesced) {
    xfer += oprot->writeFieldBegin("quiesced", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->quiesced);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.backup_manifest) {
    xfer += oprot->writeFieldBegin("backup_manifest", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->backup_manifest);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.replay_supported) {
    xfer += oprot->writeFieldBegin("replay_supported", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->replay_supported);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.child_snapshot_list) {
    xfer += oprot->writeFieldBegin("child_snapshot_list", ::apache::thrift::protocol::T_LIST, 8);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->child_snapshot_list.size()));
      std::vector<virtual_machine_snapshots> ::const_iterator _iter121;
      for (_iter121 = this->child_snapshot_list.begin(); _iter121 != this->child_snapshot_list.end(); ++_iter121)
      {
        xfer += (*_iter121).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(virtual_machine_snapshots &a, virtual_machine_snapshots &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.description, b.description);
  swap(a.create_time, b.create_time);
  swap(a.quiesced, b.quiesced);
  swap(a.id, b.id);
  swap(a.backup_manifest, b.backup_manifest);
  swap(a.replay_supported, b.replay_supported);
  swap(a.child_snapshot_list, b.child_snapshot_list);
  swap(a.__isset, b.__isset);
}

virtual_machine_snapshots::virtual_machine_snapshots(const virtual_machine_snapshots& other122) {
  name = other122.name;
  description = other122.description;
  create_time = other122.create_time;
  quiesced = other122.quiesced;
  id = other122.id;
  backup_manifest = other122.backup_manifest;
  replay_supported = other122.replay_supported;
  child_snapshot_list = other122.child_snapshot_list;
  __isset = other122.__isset;
}
virtual_machine_snapshots& virtual_machine_snapshots::operator=(const virtual_machine_snapshots& other123) {
  name = other123.name;
  description = other123.description;
  create_time = other123.create_time;
  quiesced = other123.quiesced;
  id = other123.id;
  backup_manifest = other123.backup_manifest;
  replay_supported = other123.replay_supported;
  child_snapshot_list = other123.child_snapshot_list;
  __isset = other123.__isset;
  return *this;
}
void virtual_machine_snapshots::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "virtual_machine_snapshots(";
  out << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
  out << ", " << "description="; (__isset.description ? (out << to_string(description)) : (out << "<null>"));
  out << ", " << "create_time="; (__isset.create_time ? (out << to_string(create_time)) : (out << "<null>"));
  out << ", " << "quiesced="; (__isset.quiesced ? (out << to_string(quiesced)) : (out << "<null>"));
  out << ", " << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "backup_manifest="; (__isset.backup_manifest ? (out << to_string(backup_manifest)) : (out << "<null>"));
  out << ", " << "replay_supported="; (__isset.replay_supported ? (out << to_string(replay_supported)) : (out << "<null>"));
  out << ", " << "child_snapshot_list="; (__isset.child_snapshot_list ? (out << to_string(child_snapshot_list)) : (out << "<null>"));
  out << ")";
}


virtual_disk_info::~virtual_disk_info() throw() {
}


void virtual_disk_info::__set_key(const std::string& val) {
  this->key = val;
__isset.key = true;
}

void virtual_disk_info::__set_name(const std::string& val) {
  this->name = val;
__isset.name = true;
}

void virtual_disk_info::__set_size_kb(const int64_t val) {
  this->size_kb = val;
__isset.size_kb = true;
}

uint32_t virtual_disk_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->size_kb);
          this->__isset.size_kb = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t virtual_disk_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("virtual_disk_info");

  if (this->__isset.key) {
    xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->key);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.size_kb) {
    xfer += oprot->writeFieldBegin("size_kb", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->size_kb);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(virtual_disk_info &a, virtual_disk_info &b) {
  using ::std::swap;
  swap(a.key, b.key);
  swap(a.name, b.name);
  swap(a.size_kb, b.size_kb);
  swap(a.__isset, b.__isset);
}

virtual_disk_info::virtual_disk_info(const virtual_disk_info& other124) {
  key = other124.key;
  name = other124.name;
  size_kb = other124.size_kb;
  __isset = other124.__isset;
}
virtual_disk_info& virtual_disk_info::operator=(const virtual_disk_info& other125) {
  key = other125.key;
  name = other125.name;
  size_kb = other125.size_kb;
  __isset = other125.__isset;
  return *this;
}
void virtual_disk_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "virtual_disk_info(";
  out << "key="; (__isset.key ? (out << to_string(key)) : (out << "<null>"));
  out << ", " << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
  out << ", " << "size_kb="; (__isset.size_kb ? (out << to_string(size_kb)) : (out << "<null>"));
  out << ")";
}


virtual_machine::~virtual_machine() throw() {
}


void virtual_machine::__set_uuid(const std::string& val) {
  this->uuid = val;
__isset.uuid = true;
}

void virtual_machine::__set_name(const std::string& val) {
  this->name = val;
__isset.name = true;
}

void virtual_machine::__set_host_key(const std::string& val) {
  this->host_key = val;
__isset.host_key = true;
}

void virtual_machine::__set_host_ip(const std::string& val) {
  this->host_ip = val;
__isset.host_ip = true;
}

void virtual_machine::__set_host_name(const std::string& val) {
  this->host_name = val;
__isset.host_name = true;
}

void virtual_machine::__set_cluster_key(const std::string& val) {
  this->cluster_key = val;
__isset.cluster_key = true;
}

void virtual_machine::__set_cluster_name(const std::string& val) {
  this->cluster_name = val;
__isset.cluster_name = true;
}

void virtual_machine::__set_annotation(const std::string& val) {
  this->annotation = val;
__isset.annotation = true;
}

void virtual_machine::__set_is_cpu_hot_add(const bool val) {
  this->is_cpu_hot_add = val;
__isset.is_cpu_hot_add = true;
}

void virtual_machine::__set_is_cpu_hot_remove(const bool val) {
  this->is_cpu_hot_remove = val;
__isset.is_cpu_hot_remove = true;
}

void virtual_machine::__set_memory_mb(const int32_t val) {
  this->memory_mb = val;
__isset.memory_mb = true;
}

void virtual_machine::__set_number_of_cpu(const int32_t val) {
  this->number_of_cpu = val;
__isset.number_of_cpu = true;
}

void virtual_machine::__set_is_template(const bool val) {
  this->is_template = val;
__isset.is_template = true;
}

void virtual_machine::__set_config_path(const std::string& val) {
  this->config_path = val;
__isset.config_path = true;
}

void virtual_machine::__set_config_path_file(const std::string& val) {
  this->config_path_file = val;
__isset.config_path_file = true;
}

void virtual_machine::__set_version(const int32_t val) {
  this->version = val;
__isset.version = true;
}

void virtual_machine::__set_power_state(const hv_vm_power_state::type val) {
  this->power_state = val;
__isset.power_state = true;
}

void virtual_machine::__set_connection_state(const hv_vm_connection_state::type val) {
  this->connection_state = val;
__isset.connection_state = true;
}

void virtual_machine::__set_tools_status(const hv_vm_tools_status::type val) {
  this->tools_status = val;
__isset.tools_status = true;
}

void virtual_machine::__set_firmware(const hv_vm_firmware::type val) {
  this->firmware = val;
__isset.firmware = true;
}

void virtual_machine::__set_guest_os_type(const hv_guest_os_type::type val) {
  this->guest_os_type = val;
__isset.guest_os_type = true;
}

void virtual_machine::__set_guest_id(const std::string& val) {
  this->guest_id = val;
__isset.guest_id = true;
}

void virtual_machine::__set_guest_full_name(const std::string& val) {
  this->guest_full_name = val;
__isset.guest_full_name = true;
}

void virtual_machine::__set_is_disk_uuid_enabled(const bool val) {
  this->is_disk_uuid_enabled = val;
__isset.is_disk_uuid_enabled = true;
}

void virtual_machine::__set_folder_path(const std::string& val) {
  this->folder_path = val;
__isset.folder_path = true;
}

void virtual_machine::__set_resource_pool_path(const std::string& val) {
  this->resource_pool_path = val;
__isset.resource_pool_path = true;
}

void virtual_machine::__set_disks(const std::vector<virtual_disk_info> & val) {
  this->disks = val;
__isset.disks = true;
}

void virtual_machine::__set_networks(const std::map<std::string, std::string> & val) {
  this->networks = val;
__isset.networks = true;
}

void virtual_machine::__set_datacenter_name(const std::string& val) {
  this->datacenter_name = val;
__isset.datacenter_name = true;
}

void virtual_machine::__set_network_adapters(const std::vector<virtual_network_adapter> & val) {
  this->network_adapters = val;
__isset.network_adapters = true;
}

void virtual_machine::__set_root_snapshot_list(const std::vector<virtual_machine_snapshots> & val) {
  this->root_snapshot_list = val;
__isset.root_snapshot_list = true;
}

uint32_t virtual_machine::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->uuid);
          this->__isset.uuid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host_key);
          this->__isset.host_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host_ip);
          this->__isset.host_ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host_name);
          this->__isset.host_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cluster_key);
          this->__isset.cluster_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cluster_name);
          this->__isset.cluster_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->annotation);
          this->__isset.annotation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_cpu_hot_add);
          this->__isset.is_cpu_hot_add = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_cpu_hot_remove);
          this->__isset.is_cpu_hot_remove = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->memory_mb);
          this->__isset.memory_mb = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->number_of_cpu);
          this->__isset.number_of_cpu = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_template);
          this->__isset.is_template = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->config_path);
          this->__isset.config_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->config_path_file);
          this->__isset.config_path_file = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast126;
          xfer += iprot->readI32(ecast126);
          this->power_state = (hv_vm_power_state::type)ecast126;
          this->__isset.power_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast127;
          xfer += iprot->readI32(ecast127);
          this->connection_state = (hv_vm_connection_state::type)ecast127;
          this->__isset.connection_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast128;
          xfer += iprot->readI32(ecast128);
          this->tools_status = (hv_vm_tools_status::type)ecast128;
          this->__isset.tools_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast129;
          xfer += iprot->readI32(ecast129);
          this->firmware = (hv_vm_firmware::type)ecast129;
          this->__isset.firmware = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast130;
          xfer += iprot->readI32(ecast130);
          this->guest_os_type = (hv_guest_os_type::type)ecast130;
          this->__isset.guest_os_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guest_id);
          this->__isset.guest_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guest_full_name);
          this->__isset.guest_full_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_disk_uuid_enabled);
          this->__isset.is_disk_uuid_enabled = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->folder_path);
          this->__isset.folder_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 26:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resource_pool_path);
          this->__isset.resource_pool_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 27:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->disks.clear();
            uint32_t _size131;
            ::apache::thrift::protocol::TType _etype134;
            xfer += iprot->readListBegin(_etype134, _size131);
            this->disks.resize(_size131);
            uint32_t _i135;
            for (_i135 = 0; _i135 < _size131; ++_i135)
            {
              xfer += this->disks[_i135].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.disks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 28:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->networks.clear();
            uint32_t _size136;
            ::apache::thrift::protocol::TType _ktype137;
            ::apache::thrift::protocol::TType _vtype138;
            xfer += iprot->readMapBegin(_ktype137, _vtype138, _size136);
            uint32_t _i140;
            for (_i140 = 0; _i140 < _size136; ++_i140)
            {
              std::string _key141;
              xfer += iprot->readString(_key141);
              std::string& _val142 = this->networks[_key141];
              xfer += iprot->readString(_val142);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.networks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 29:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->datacenter_name);
          this->__isset.datacenter_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->network_adapters.clear();
            uint32_t _size143;
            ::apache::thrift::protocol::TType _etype146;
            xfer += iprot->readListBegin(_etype146, _size143);
            this->network_adapters.resize(_size143);
            uint32_t _i147;
            for (_i147 = 0; _i147 < _size143; ++_i147)
            {
              xfer += this->network_adapters[_i147].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.network_adapters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 31:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->root_snapshot_list.clear();
            uint32_t _size148;
            ::apache::thrift::protocol::TType _etype151;
            xfer += iprot->readListBegin(_etype151, _size148);
            this->root_snapshot_list.resize(_size148);
            uint32_t _i152;
            for (_i152 = 0; _i152 < _size148; ++_i152)
            {
              xfer += this->root_snapshot_list[_i152].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.root_snapshot_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t virtual_machine::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("virtual_machine");

  if (this->__isset.uuid) {
    xfer += oprot->writeFieldBegin("uuid", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->uuid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.host_key) {
    xfer += oprot->writeFieldBegin("host_key", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->host_key);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.host_ip) {
    xfer += oprot->writeFieldBegin("host_ip", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->host_ip);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.host_name) {
    xfer += oprot->writeFieldBegin("host_name", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->host_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_key) {
    xfer += oprot->writeFieldBegin("cluster_key", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->cluster_key);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cluster_name) {
    xfer += oprot->writeFieldBegin("cluster_name", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->cluster_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.annotation) {
    xfer += oprot->writeFieldBegin("annotation", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->annotation);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_cpu_hot_add) {
    xfer += oprot->writeFieldBegin("is_cpu_hot_add", ::apache::thrift::protocol::T_BOOL, 9);
    xfer += oprot->writeBool(this->is_cpu_hot_add);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_cpu_hot_remove) {
    xfer += oprot->writeFieldBegin("is_cpu_hot_remove", ::apache::thrift::protocol::T_BOOL, 10);
    xfer += oprot->writeBool(this->is_cpu_hot_remove);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.memory_mb) {
    xfer += oprot->writeFieldBegin("memory_mb", ::apache::thrift::protocol::T_I32, 11);
    xfer += oprot->writeI32(this->memory_mb);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.number_of_cpu) {
    xfer += oprot->writeFieldBegin("number_of_cpu", ::apache::thrift::protocol::T_I32, 12);
    xfer += oprot->writeI32(this->number_of_cpu);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_template) {
    xfer += oprot->writeFieldBegin("is_template", ::apache::thrift::protocol::T_BOOL, 13);
    xfer += oprot->writeBool(this->is_template);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.config_path) {
    xfer += oprot->writeFieldBegin("config_path", ::apache::thrift::protocol::T_STRING, 14);
    xfer += oprot->writeString(this->config_path);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.config_path_file) {
    xfer += oprot->writeFieldBegin("config_path_file", ::apache::thrift::protocol::T_STRING, 15);
    xfer += oprot->writeString(this->config_path_file);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.version) {
    xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_I32, 16);
    xfer += oprot->writeI32(this->version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.power_state) {
    xfer += oprot->writeFieldBegin("power_state", ::apache::thrift::protocol::T_I32, 17);
    xfer += oprot->writeI32((int32_t)this->power_state);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.connection_state) {
    xfer += oprot->writeFieldBegin("connection_state", ::apache::thrift::protocol::T_I32, 18);
    xfer += oprot->writeI32((int32_t)this->connection_state);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tools_status) {
    xfer += oprot->writeFieldBegin("tools_status", ::apache::thrift::protocol::T_I32, 19);
    xfer += oprot->writeI32((int32_t)this->tools_status);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.firmware) {
    xfer += oprot->writeFieldBegin("firmware", ::apache::thrift::protocol::T_I32, 20);
    xfer += oprot->writeI32((int32_t)this->firmware);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.guest_os_type) {
    xfer += oprot->writeFieldBegin("guest_os_type", ::apache::thrift::protocol::T_I32, 21);
    xfer += oprot->writeI32((int32_t)this->guest_os_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.guest_id) {
    xfer += oprot->writeFieldBegin("guest_id", ::apache::thrift::protocol::T_STRING, 22);
    xfer += oprot->writeString(this->guest_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.guest_full_name) {
    xfer += oprot->writeFieldBegin("guest_full_name", ::apache::thrift::protocol::T_STRING, 23);
    xfer += oprot->writeString(this->guest_full_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_disk_uuid_enabled) {
    xfer += oprot->writeFieldBegin("is_disk_uuid_enabled", ::apache::thrift::protocol::T_BOOL, 24);
    xfer += oprot->writeBool(this->is_disk_uuid_enabled);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.folder_path) {
    xfer += oprot->writeFieldBegin("folder_path", ::apache::thrift::protocol::T_STRING, 25);
    xfer += oprot->writeString(this->folder_path);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.resource_pool_path) {
    xfer += oprot->writeFieldBegin("resource_pool_path", ::apache::thrift::protocol::T_STRING, 26);
    xfer += oprot->writeString(this->resource_pool_path);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.disks) {
    xfer += oprot->writeFieldBegin("disks", ::apache::thrift::protocol::T_LIST, 27);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->disks.size()));
      std::vector<virtual_disk_info> ::const_iterator _iter153;
      for (_iter153 = this->disks.begin(); _iter153 != this->disks.end(); ++_iter153)
      {
        xfer += (*_iter153).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.networks) {
    xfer += oprot->writeFieldBegin("networks", ::apache::thrift::protocol::T_MAP, 28);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->networks.size()));
      std::map<std::string, std::string> ::const_iterator _iter154;
      for (_iter154 = this->networks.begin(); _iter154 != this->networks.end(); ++_iter154)
      {
        xfer += oprot->writeString(_iter154->first);
        xfer += oprot->writeString(_iter154->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.datacenter_name) {
    xfer += oprot->writeFieldBegin("datacenter_name", ::apache::thrift::protocol::T_STRING, 29);
    xfer += oprot->writeString(this->datacenter_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.network_adapters) {
    xfer += oprot->writeFieldBegin("network_adapters", ::apache::thrift::protocol::T_LIST, 30);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->network_adapters.size()));
      std::vector<virtual_network_adapter> ::const_iterator _iter155;
      for (_iter155 = this->network_adapters.begin(); _iter155 != this->network_adapters.end(); ++_iter155)
      {
        xfer += (*_iter155).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.root_snapshot_list) {
    xfer += oprot->writeFieldBegin("root_snapshot_list", ::apache::thrift::protocol::T_LIST, 31);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->root_snapshot_list.size()));
      std::vector<virtual_machine_snapshots> ::const_iterator _iter156;
      for (_iter156 = this->root_snapshot_list.begin(); _iter156 != this->root_snapshot_list.end(); ++_iter156)
      {
        xfer += (*_iter156).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(virtual_machine &a, virtual_machine &b) {
  using ::std::swap;
  swap(a.uuid, b.uuid);
  swap(a.name, b.name);
  swap(a.host_key, b.host_key);
  swap(a.host_ip, b.host_ip);
  swap(a.host_name, b.host_name);
  swap(a.cluster_key, b.cluster_key);
  swap(a.cluster_name, b.cluster_name);
  swap(a.annotation, b.annotation);
  swap(a.is_cpu_hot_add, b.is_cpu_hot_add);
  swap(a.is_cpu_hot_remove, b.is_cpu_hot_remove);
  swap(a.memory_mb, b.memory_mb);
  swap(a.number_of_cpu, b.number_of_cpu);
  swap(a.is_template, b.is_template);
  swap(a.config_path, b.config_path);
  swap(a.config_path_file, b.config_path_file);
  swap(a.version, b.version);
  swap(a.power_state, b.power_state);
  swap(a.connection_state, b.connection_state);
  swap(a.tools_status, b.tools_status);
  swap(a.firmware, b.firmware);
  swap(a.guest_os_type, b.guest_os_type);
  swap(a.guest_id, b.guest_id);
  swap(a.guest_full_name, b.guest_full_name);
  swap(a.is_disk_uuid_enabled, b.is_disk_uuid_enabled);
  swap(a.folder_path, b.folder_path);
  swap(a.resource_pool_path, b.resource_pool_path);
  swap(a.disks, b.disks);
  swap(a.networks, b.networks);
  swap(a.datacenter_name, b.datacenter_name);
  swap(a.network_adapters, b.network_adapters);
  swap(a.root_snapshot_list, b.root_snapshot_list);
  swap(a.__isset, b.__isset);
}

virtual_machine::virtual_machine(const virtual_machine& other157) {
  uuid = other157.uuid;
  name = other157.name;
  host_key = other157.host_key;
  host_ip = other157.host_ip;
  host_name = other157.host_name;
  cluster_key = other157.cluster_key;
  cluster_name = other157.cluster_name;
  annotation = other157.annotation;
  is_cpu_hot_add = other157.is_cpu_hot_add;
  is_cpu_hot_remove = other157.is_cpu_hot_remove;
  memory_mb = other157.memory_mb;
  number_of_cpu = other157.number_of_cpu;
  is_template = other157.is_template;
  config_path = other157.config_path;
  config_path_file = other157.config_path_file;
  version = other157.version;
  power_state = other157.power_state;
  connection_state = other157.connection_state;
  tools_status = other157.tools_status;
  firmware = other157.firmware;
  guest_os_type = other157.guest_os_type;
  guest_id = other157.guest_id;
  guest_full_name = other157.guest_full_name;
  is_disk_uuid_enabled = other157.is_disk_uuid_enabled;
  folder_path = other157.folder_path;
  resource_pool_path = other157.resource_pool_path;
  disks = other157.disks;
  networks = other157.networks;
  datacenter_name = other157.datacenter_name;
  network_adapters = other157.network_adapters;
  root_snapshot_list = other157.root_snapshot_list;
  __isset = other157.__isset;
}
virtual_machine& virtual_machine::operator=(const virtual_machine& other158) {
  uuid = other158.uuid;
  name = other158.name;
  host_key = other158.host_key;
  host_ip = other158.host_ip;
  host_name = other158.host_name;
  cluster_key = other158.cluster_key;
  cluster_name = other158.cluster_name;
  annotation = other158.annotation;
  is_cpu_hot_add = other158.is_cpu_hot_add;
  is_cpu_hot_remove = other158.is_cpu_hot_remove;
  memory_mb = other158.memory_mb;
  number_of_cpu = other158.number_of_cpu;
  is_template = other158.is_template;
  config_path = other158.config_path;
  config_path_file = other158.config_path_file;
  version = other158.version;
  power_state = other158.power_state;
  connection_state = other158.connection_state;
  tools_status = other158.tools_status;
  firmware = other158.firmware;
  guest_os_type = other158.guest_os_type;
  guest_id = other158.guest_id;
  guest_full_name = other158.guest_full_name;
  is_disk_uuid_enabled = other158.is_disk_uuid_enabled;
  folder_path = other158.folder_path;
  resource_pool_path = other158.resource_pool_path;
  disks = other158.disks;
  networks = other158.networks;
  datacenter_name = other158.datacenter_name;
  network_adapters = other158.network_adapters;
  root_snapshot_list = other158.root_snapshot_list;
  __isset = other158.__isset;
  return *this;
}
void virtual_machine::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "virtual_machine(";
  out << "uuid="; (__isset.uuid ? (out << to_string(uuid)) : (out << "<null>"));
  out << ", " << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
  out << ", " << "host_key="; (__isset.host_key ? (out << to_string(host_key)) : (out << "<null>"));
  out << ", " << "host_ip="; (__isset.host_ip ? (out << to_string(host_ip)) : (out << "<null>"));
  out << ", " << "host_name="; (__isset.host_name ? (out << to_string(host_name)) : (out << "<null>"));
  out << ", " << "cluster_key="; (__isset.cluster_key ? (out << to_string(cluster_key)) : (out << "<null>"));
  out << ", " << "cluster_name="; (__isset.cluster_name ? (out << to_string(cluster_name)) : (out << "<null>"));
  out << ", " << "annotation="; (__isset.annotation ? (out << to_string(annotation)) : (out << "<null>"));
  out << ", " << "is_cpu_hot_add="; (__isset.is_cpu_hot_add ? (out << to_string(is_cpu_hot_add)) : (out << "<null>"));
  out << ", " << "is_cpu_hot_remove="; (__isset.is_cpu_hot_remove ? (out << to_string(is_cpu_hot_remove)) : (out << "<null>"));
  out << ", " << "memory_mb="; (__isset.memory_mb ? (out << to_string(memory_mb)) : (out << "<null>"));
  out << ", " << "number_of_cpu="; (__isset.number_of_cpu ? (out << to_string(number_of_cpu)) : (out << "<null>"));
  out << ", " << "is_template="; (__isset.is_template ? (out << to_string(is_template)) : (out << "<null>"));
  out << ", " << "config_path="; (__isset.config_path ? (out << to_string(config_path)) : (out << "<null>"));
  out << ", " << "config_path_file="; (__isset.config_path_file ? (out << to_string(config_path_file)) : (out << "<null>"));
  out << ", " << "version="; (__isset.version ? (out << to_string(version)) : (out << "<null>"));
  out << ", " << "power_state="; (__isset.power_state ? (out << to_string(power_state)) : (out << "<null>"));
  out << ", " << "connection_state="; (__isset.connection_state ? (out << to_string(connection_state)) : (out << "<null>"));
  out << ", " << "tools_status="; (__isset.tools_status ? (out << to_string(tools_status)) : (out << "<null>"));
  out << ", " << "firmware="; (__isset.firmware ? (out << to_string(firmware)) : (out << "<null>"));
  out << ", " << "guest_os_type="; (__isset.guest_os_type ? (out << to_string(guest_os_type)) : (out << "<null>"));
  out << ", " << "guest_id="; (__isset.guest_id ? (out << to_string(guest_id)) : (out << "<null>"));
  out << ", " << "guest_full_name="; (__isset.guest_full_name ? (out << to_string(guest_full_name)) : (out << "<null>"));
  out << ", " << "is_disk_uuid_enabled="; (__isset.is_disk_uuid_enabled ? (out << to_string(is_disk_uuid_enabled)) : (out << "<null>"));
  out << ", " << "folder_path="; (__isset.folder_path ? (out << to_string(folder_path)) : (out << "<null>"));
  out << ", " << "resource_pool_path="; (__isset.resource_pool_path ? (out << to_string(resource_pool_path)) : (out << "<null>"));
  out << ", " << "disks="; (__isset.disks ? (out << to_string(disks)) : (out << "<null>"));
  out << ", " << "networks="; (__isset.networks ? (out << to_string(networks)) : (out << "<null>"));
  out << ", " << "datacenter_name="; (__isset.datacenter_name ? (out << to_string(datacenter_name)) : (out << "<null>"));
  out << ", " << "network_adapters="; (__isset.network_adapters ? (out << to_string(network_adapters)) : (out << "<null>"));
  out << ", " << "root_snapshot_list="; (__isset.root_snapshot_list ? (out << to_string(root_snapshot_list)) : (out << "<null>"));
  out << ")";
}


invalid_operation::~invalid_operation() throw() {
}


void invalid_operation::__set_what_op(const int32_t val) {
  this->what_op = val;
}

void invalid_operation::__set_why(const std::string& val) {
  this->why = val;
}

uint32_t invalid_operation::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->what_op);
          this->__isset.what_op = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->why);
          this->__isset.why = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t invalid_operation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("invalid_operation");

  xfer += oprot->writeFieldBegin("what_op", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->what_op);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("why", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->why);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(invalid_operation &a, invalid_operation &b) {
  using ::std::swap;
  swap(a.what_op, b.what_op);
  swap(a.why, b.why);
  swap(a.__isset, b.__isset);
}

invalid_operation::invalid_operation(const invalid_operation& other159) : TException() {
  what_op = other159.what_op;
  why = other159.why;
  __isset = other159.__isset;
}
invalid_operation& invalid_operation::operator=(const invalid_operation& other160) {
  what_op = other160.what_op;
  why = other160.why;
  __isset = other160.__isset;
  return *this;
}
void invalid_operation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "invalid_operation(";
  out << "what_op=" << to_string(what_op);
  out << ", " << "why=" << to_string(why);
  out << ")";
}

const char* invalid_operation::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: invalid_operation";
  }
}


create_job_detail::~create_job_detail() throw() {
}


void create_job_detail::__set_host(const std::string& val) {
  this->host = val;
__isset.host = true;
}

void create_job_detail::__set_username(const std::string& val) {
  this->username = val;
__isset.username = true;
}

void create_job_detail::__set_password(const std::string& val) {
  this->password = val;
__isset.password = true;
}

void create_job_detail::__set_type(const job_type::type val) {
  this->type = val;
__isset.type = true;
}

void create_job_detail::__set_select_all(const bool val) {
  this->select_all = val;
__isset.select_all = true;
}

void create_job_detail::__set_disks(const std::set<int32_t> & val) {
  this->disks = val;
__isset.disks = true;
}

void create_job_detail::__set_virtual_machine_id(const std::string& val) {
  this->virtual_machine_id = val;
__isset.virtual_machine_id = true;
}

void create_job_detail::__set_vdisks(const std::set<std::string> & val) {
  this->vdisks = val;
__isset.vdisks = true;
}

void create_job_detail::__set_output_folder(const std::string& val) {
  this->output_folder = val;
__isset.output_folder = true;
}

void create_job_detail::__set_output_disk(const std::string& val) {
  this->output_disk = val;
__isset.output_disk = true;
}

uint32_t create_job_detail::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host);
          this->__isset.host = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->username);
          this->__isset.username = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->password);
          this->__isset.password = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast161;
          xfer += iprot->readI32(ecast161);
          this->type = (job_type::type)ecast161;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->select_all);
          this->__isset.select_all = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->disks.clear();
            uint32_t _size162;
            ::apache::thrift::protocol::TType _etype165;
            xfer += iprot->readSetBegin(_etype165, _size162);
            uint32_t _i166;
            for (_i166 = 0; _i166 < _size162; ++_i166)
            {
              int32_t _elem167;
              xfer += iprot->readI32(_elem167);
              this->disks.insert(_elem167);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.disks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->virtual_machine_id);
          this->__isset.virtual_machine_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->vdisks.clear();
            uint32_t _size168;
            ::apache::thrift::protocol::TType _etype171;
            xfer += iprot->readSetBegin(_etype171, _size168);
            uint32_t _i172;
            for (_i172 = 0; _i172 < _size168; ++_i172)
            {
              std::string _elem173;
              xfer += iprot->readString(_elem173);
              this->vdisks.insert(_elem173);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.vdisks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->output_folder);
          this->__isset.output_folder = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->output_disk);
          this->__isset.output_disk = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t create_job_detail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("create_job_detail");

  if (this->__isset.host) {
    xfer += oprot->writeFieldBegin("host", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->host);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.username) {
    xfer += oprot->writeFieldBegin("username", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->username);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.password) {
    xfer += oprot->writeFieldBegin("password", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->password);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.type) {
    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32((int32_t)this->type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.select_all) {
    xfer += oprot->writeFieldBegin("select_all", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->select_all);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.disks) {
    xfer += oprot->writeFieldBegin("disks", ::apache::thrift::protocol::T_SET, 6);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->disks.size()));
      std::set<int32_t> ::const_iterator _iter174;
      for (_iter174 = this->disks.begin(); _iter174 != this->disks.end(); ++_iter174)
      {
        xfer += oprot->writeI32((*_iter174));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.virtual_machine_id) {
    xfer += oprot->writeFieldBegin("virtual_machine_id", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->virtual_machine_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vdisks) {
    xfer += oprot->writeFieldBegin("vdisks", ::apache::thrift::protocol::T_SET, 8);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->vdisks.size()));
      std::set<std::string> ::const_iterator _iter175;
      for (_iter175 = this->vdisks.begin(); _iter175 != this->vdisks.end(); ++_iter175)
      {
        xfer += oprot->writeString((*_iter175));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.output_folder) {
    xfer += oprot->writeFieldBegin("output_folder", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->output_folder);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.output_disk) {
    xfer += oprot->writeFieldBegin("output_disk", ::apache::thrift::protocol::T_STRING, 10);
    xfer += oprot->writeString(this->output_disk);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(create_job_detail &a, create_job_detail &b) {
  using ::std::swap;
  swap(a.host, b.host);
  swap(a.username, b.username);
  swap(a.password, b.password);
  swap(a.type, b.type);
  swap(a.select_all, b.select_all);
  swap(a.disks, b.disks);
  swap(a.virtual_machine_id, b.virtual_machine_id);
  swap(a.vdisks, b.vdisks);
  swap(a.output_folder, b.output_folder);
  swap(a.output_disk, b.output_disk);
  swap(a.__isset, b.__isset);
}

create_job_detail::create_job_detail(const create_job_detail& other176) {
  host = other176.host;
  username = other176.username;
  password = other176.password;
  type = other176.type;
  select_all = other176.select_all;
  disks = other176.disks;
  virtual_machine_id = other176.virtual_machine_id;
  vdisks = other176.vdisks;
  output_folder = other176.output_folder;
  output_disk = other176.output_disk;
  __isset = other176.__isset;
}
create_job_detail& create_job_detail::operator=(const create_job_detail& other177) {
  host = other177.host;
  username = other177.username;
  password = other177.password;
  type = other177.type;
  select_all = other177.select_all;
  disks = other177.disks;
  virtual_machine_id = other177.virtual_machine_id;
  vdisks = other177.vdisks;
  output_folder = other177.output_folder;
  output_disk = other177.output_disk;
  __isset = other177.__isset;
  return *this;
}
void create_job_detail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "create_job_detail(";
  out << "host="; (__isset.host ? (out << to_string(host)) : (out << "<null>"));
  out << ", " << "username="; (__isset.username ? (out << to_string(username)) : (out << "<null>"));
  out << ", " << "password="; (__isset.password ? (out << to_string(password)) : (out << "<null>"));
  out << ", " << "type="; (__isset.type ? (out << to_string(type)) : (out << "<null>"));
  out << ", " << "select_all="; (__isset.select_all ? (out << to_string(select_all)) : (out << "<null>"));
  out << ", " << "disks="; (__isset.disks ? (out << to_string(disks)) : (out << "<null>"));
  out << ", " << "virtual_machine_id="; (__isset.virtual_machine_id ? (out << to_string(virtual_machine_id)) : (out << "<null>"));
  out << ", " << "vdisks="; (__isset.vdisks ? (out << to_string(vdisks)) : (out << "<null>"));
  out << ", " << "output_folder="; (__isset.output_folder ? (out << to_string(output_folder)) : (out << "<null>"));
  out << ", " << "output_disk="; (__isset.output_disk ? (out << to_string(output_disk)) : (out << "<null>"));
  out << ")";
}


job_history::~job_history() throw() {
}


void job_history::__set_time(const std::string& val) {
  this->time = val;
__isset.time = true;
}

void job_history::__set_state(const job_state::type val) {
  this->state = val;
__isset.state = true;
}

void job_history::__set_error(const int32_t val) {
  this->error = val;
__isset.error = true;
}

void job_history::__set_description(const std::string& val) {
  this->description = val;
__isset.description = true;
}

uint32_t job_history::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->time);
          this->__isset.time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast178;
          xfer += iprot->readI32(ecast178);
          this->state = (job_state::type)ecast178;
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->error);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->description);
          this->__isset.description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t job_history::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("job_history");

  if (this->__isset.time) {
    xfer += oprot->writeFieldBegin("time", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->time);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.state) {
    xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32((int32_t)this->state);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->error);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.description) {
    xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->description);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(job_history &a, job_history &b) {
  using ::std::swap;
  swap(a.time, b.time);
  swap(a.state, b.state);
  swap(a.error, b.error);
  swap(a.description, b.description);
  swap(a.__isset, b.__isset);
}

job_history::job_history(const job_history& other179) {
  time = other179.time;
  state = other179.state;
  error = other179.error;
  description = other179.description;
  __isset = other179.__isset;
}
job_history& job_history::operator=(const job_history& other180) {
  time = other180.time;
  state = other180.state;
  error = other180.error;
  description = other180.description;
  __isset = other180.__isset;
  return *this;
}
void job_history::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "job_history(";
  out << "time="; (__isset.time ? (out << to_string(time)) : (out << "<null>"));
  out << ", " << "state="; (__isset.state ? (out << to_string(state)) : (out << "<null>"));
  out << ", " << "error="; (__isset.error ? (out << to_string(error)) : (out << "<null>"));
  out << ", " << "description="; (__isset.description ? (out << to_string(description)) : (out << "<null>"));
  out << ")";
}


job_detail::~job_detail() throw() {
}


void job_detail::__set_id(const std::string& val) {
  this->id = val;
__isset.id = true;
}

void job_detail::__set_host(const std::string& val) {
  this->host = val;
__isset.host = true;
}

void job_detail::__set_username(const std::string& val) {
  this->username = val;
__isset.username = true;
}

void job_detail::__set_password(const std::string& val) {
  this->password = val;
__isset.password = true;
}

void job_detail::__set_type(const job_type::type val) {
  this->type = val;
__isset.type = true;
}

void job_detail::__set_disks(const std::set<int32_t> & val) {
  this->disks = val;
__isset.disks = true;
}

void job_detail::__set_virtual_machine_id(const std::string& val) {
  this->virtual_machine_id = val;
__isset.virtual_machine_id = true;
}

void job_detail::__set_vdisks(const std::set<std::string> & val) {
  this->vdisks = val;
__isset.vdisks = true;
}

void job_detail::__set_output_folder(const std::string& val) {
  this->output_folder = val;
__isset.output_folder = true;
}

void job_detail::__set_state(const job_state::type val) {
  this->state = val;
__isset.state = true;
}

void job_detail::__set_original_size(const std::map<std::string, int64_t> & val) {
  this->original_size = val;
__isset.original_size = true;
}

void job_detail::__set_backup_progress(const std::map<std::string, int64_t> & val) {
  this->backup_progress = val;
__isset.backup_progress = true;
}

void job_detail::__set_output_files(const std::map<std::string, std::string> & val) {
  this->output_files = val;
__isset.output_files = true;
}

void job_detail::__set_what(const int32_t val) {
  this->what = val;
__isset.what = true;
}

void job_detail::__set_why(const std::string& val) {
  this->why = val;
__isset.why = true;
}

void job_detail::__set_created_time(const std::string& val) {
  this->created_time = val;
__isset.created_time = true;
}

void job_detail::__set_created_time_ll(const int64_t val) {
  this->created_time_ll = val;
__isset.created_time_ll = true;
}

void job_detail::__set_output_disk(const std::string& val) {
  this->output_disk = val;
__isset.output_disk = true;
}

void job_detail::__set_system_disk(const std::string& val) {
  this->system_disk = val;
__isset.system_disk = true;
}

void job_detail::__set_histories(const std::vector<job_history> & val) {
  this->histories = val;
__isset.histories = true;
}

uint32_t job_detail::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host);
          this->__isset.host = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->username);
          this->__isset.username = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->password);
          this->__isset.password = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast181;
          xfer += iprot->readI32(ecast181);
          this->type = (job_type::type)ecast181;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->disks.clear();
            uint32_t _size182;
            ::apache::thrift::protocol::TType _etype185;
            xfer += iprot->readSetBegin(_etype185, _size182);
            uint32_t _i186;
            for (_i186 = 0; _i186 < _size182; ++_i186)
            {
              int32_t _elem187;
              xfer += iprot->readI32(_elem187);
              this->disks.insert(_elem187);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.disks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->virtual_machine_id);
          this->__isset.virtual_machine_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->vdisks.clear();
            uint32_t _size188;
            ::apache::thrift::protocol::TType _etype191;
            xfer += iprot->readSetBegin(_etype191, _size188);
            uint32_t _i192;
            for (_i192 = 0; _i192 < _size188; ++_i192)
            {
              std::string _elem193;
              xfer += iprot->readString(_elem193);
              this->vdisks.insert(_elem193);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.vdisks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->output_folder);
          this->__isset.output_folder = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast194;
          xfer += iprot->readI32(ecast194);
          this->state = (job_state::type)ecast194;
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->original_size.clear();
            uint32_t _size195;
            ::apache::thrift::protocol::TType _ktype196;
            ::apache::thrift::protocol::TType _vtype197;
            xfer += iprot->readMapBegin(_ktype196, _vtype197, _size195);
            uint32_t _i199;
            for (_i199 = 0; _i199 < _size195; ++_i199)
            {
              std::string _key200;
              xfer += iprot->readString(_key200);
              int64_t& _val201 = this->original_size[_key200];
              xfer += iprot->readI64(_val201);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.original_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->backup_progress.clear();
            uint32_t _size202;
            ::apache::thrift::protocol::TType _ktype203;
            ::apache::thrift::protocol::TType _vtype204;
            xfer += iprot->readMapBegin(_ktype203, _vtype204, _size202);
            uint32_t _i206;
            for (_i206 = 0; _i206 < _size202; ++_i206)
            {
              std::string _key207;
              xfer += iprot->readString(_key207);
              int64_t& _val208 = this->backup_progress[_key207];
              xfer += iprot->readI64(_val208);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.backup_progress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->output_files.clear();
            uint32_t _size209;
            ::apache::thrift::protocol::TType _ktype210;
            ::apache::thrift::protocol::TType _vtype211;
            xfer += iprot->readMapBegin(_ktype210, _vtype211, _size209);
            uint32_t _i213;
            for (_i213 = 0; _i213 < _size209; ++_i213)
            {
              std::string _key214;
              xfer += iprot->readString(_key214);
              std::string& _val215 = this->output_files[_key214];
              xfer += iprot->readString(_val215);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.output_files = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->what);
          this->__isset.what = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->why);
          this->__isset.why = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->created_time);
          this->__isset.created_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->created_time_ll);
          this->__isset.created_time_ll = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->output_disk);
          this->__isset.output_disk = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->system_disk);
          this->__isset.system_disk = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->histories.clear();
            uint32_t _size216;
            ::apache::thrift::protocol::TType _etype219;
            xfer += iprot->readListBegin(_etype219, _size216);
            this->histories.resize(_size216);
            uint32_t _i220;
            for (_i220 = 0; _i220 < _size216; ++_i220)
            {
              xfer += this->histories[_i220].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.histories = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t job_detail::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("job_detail");

  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.host) {
    xfer += oprot->writeFieldBegin("host", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->host);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.username) {
    xfer += oprot->writeFieldBegin("username", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->username);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.password) {
    xfer += oprot->writeFieldBegin("password", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->password);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.type) {
    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32((int32_t)this->type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.disks) {
    xfer += oprot->writeFieldBegin("disks", ::apache::thrift::protocol::T_SET, 6);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->disks.size()));
      std::set<int32_t> ::const_iterator _iter221;
      for (_iter221 = this->disks.begin(); _iter221 != this->disks.end(); ++_iter221)
      {
        xfer += oprot->writeI32((*_iter221));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.virtual_machine_id) {
    xfer += oprot->writeFieldBegin("virtual_machine_id", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->virtual_machine_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vdisks) {
    xfer += oprot->writeFieldBegin("vdisks", ::apache::thrift::protocol::T_SET, 8);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->vdisks.size()));
      std::set<std::string> ::const_iterator _iter222;
      for (_iter222 = this->vdisks.begin(); _iter222 != this->vdisks.end(); ++_iter222)
      {
        xfer += oprot->writeString((*_iter222));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.output_folder) {
    xfer += oprot->writeFieldBegin("output_folder", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->output_folder);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.state) {
    xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 10);
    xfer += oprot->writeI32((int32_t)this->state);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.original_size) {
    xfer += oprot->writeFieldBegin("original_size", ::apache::thrift::protocol::T_MAP, 11);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->original_size.size()));
      std::map<std::string, int64_t> ::const_iterator _iter223;
      for (_iter223 = this->original_size.begin(); _iter223 != this->original_size.end(); ++_iter223)
      {
        xfer += oprot->writeString(_iter223->first);
        xfer += oprot->writeI64(_iter223->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.backup_progress) {
    xfer += oprot->writeFieldBegin("backup_progress", ::apache::thrift::protocol::T_MAP, 12);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->backup_progress.size()));
      std::map<std::string, int64_t> ::const_iterator _iter224;
      for (_iter224 = this->backup_progress.begin(); _iter224 != this->backup_progress.end(); ++_iter224)
      {
        xfer += oprot->writeString(_iter224->first);
        xfer += oprot->writeI64(_iter224->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.output_files) {
    xfer += oprot->writeFieldBegin("output_files", ::apache::thrift::protocol::T_MAP, 13);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->output_files.size()));
      std::map<std::string, std::string> ::const_iterator _iter225;
      for (_iter225 = this->output_files.begin(); _iter225 != this->output_files.end(); ++_iter225)
      {
        xfer += oprot->writeString(_iter225->first);
        xfer += oprot->writeString(_iter225->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.what) {
    xfer += oprot->writeFieldBegin("what", ::apache::thrift::protocol::T_I32, 14);
    xfer += oprot->writeI32(this->what);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.why) {
    xfer += oprot->writeFieldBegin("why", ::apache::thrift::protocol::T_STRING, 15);
    xfer += oprot->writeString(this->why);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.created_time) {
    xfer += oprot->writeFieldBegin("created_time", ::apache::thrift::protocol::T_STRING, 16);
    xfer += oprot->writeString(this->created_time);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.created_time_ll) {
    xfer += oprot->writeFieldBegin("created_time_ll", ::apache::thrift::protocol::T_I64, 17);
    xfer += oprot->writeI64(this->created_time_ll);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.output_disk) {
    xfer += oprot->writeFieldBegin("output_disk", ::apache::thrift::protocol::T_STRING, 18);
    xfer += oprot->writeString(this->output_disk);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.system_disk) {
    xfer += oprot->writeFieldBegin("system_disk", ::apache::thrift::protocol::T_STRING, 19);
    xfer += oprot->writeString(this->system_disk);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.histories) {
    xfer += oprot->writeFieldBegin("histories", ::apache::thrift::protocol::T_LIST, 20);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->histories.size()));
      std::vector<job_history> ::const_iterator _iter226;
      for (_iter226 = this->histories.begin(); _iter226 != this->histories.end(); ++_iter226)
      {
        xfer += (*_iter226).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(job_detail &a, job_detail &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.host, b.host);
  swap(a.username, b.username);
  swap(a.password, b.password);
  swap(a.type, b.type);
  swap(a.disks, b.disks);
  swap(a.virtual_machine_id, b.virtual_machine_id);
  swap(a.vdisks, b.vdisks);
  swap(a.output_folder, b.output_folder);
  swap(a.state, b.state);
  swap(a.original_size, b.original_size);
  swap(a.backup_progress, b.backup_progress);
  swap(a.output_files, b.output_files);
  swap(a.what, b.what);
  swap(a.why, b.why);
  swap(a.created_time, b.created_time);
  swap(a.created_time_ll, b.created_time_ll);
  swap(a.output_disk, b.output_disk);
  swap(a.system_disk, b.system_disk);
  swap(a.histories, b.histories);
  swap(a.__isset, b.__isset);
}

job_detail::job_detail(const job_detail& other227) {
  id = other227.id;
  host = other227.host;
  username = other227.username;
  password = other227.password;
  type = other227.type;
  disks = other227.disks;
  virtual_machine_id = other227.virtual_machine_id;
  vdisks = other227.vdisks;
  output_folder = other227.output_folder;
  state = other227.state;
  original_size = other227.original_size;
  backup_progress = other227.backup_progress;
  output_files = other227.output_files;
  what = other227.what;
  why = other227.why;
  created_time = other227.created_time;
  created_time_ll = other227.created_time_ll;
  output_disk = other227.output_disk;
  system_disk = other227.system_disk;
  histories = other227.histories;
  __isset = other227.__isset;
}
job_detail& job_detail::operator=(const job_detail& other228) {
  id = other228.id;
  host = other228.host;
  username = other228.username;
  password = other228.password;
  type = other228.type;
  disks = other228.disks;
  virtual_machine_id = other228.virtual_machine_id;
  vdisks = other228.vdisks;
  output_folder = other228.output_folder;
  state = other228.state;
  original_size = other228.original_size;
  backup_progress = other228.backup_progress;
  output_files = other228.output_files;
  what = other228.what;
  why = other228.why;
  created_time = other228.created_time;
  created_time_ll = other228.created_time_ll;
  output_disk = other228.output_disk;
  system_disk = other228.system_disk;
  histories = other228.histories;
  __isset = other228.__isset;
  return *this;
}
void job_detail::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "job_detail(";
  out << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "host="; (__isset.host ? (out << to_string(host)) : (out << "<null>"));
  out << ", " << "username="; (__isset.username ? (out << to_string(username)) : (out << "<null>"));
  out << ", " << "password="; (__isset.password ? (out << to_string(password)) : (out << "<null>"));
  out << ", " << "type="; (__isset.type ? (out << to_string(type)) : (out << "<null>"));
  out << ", " << "disks="; (__isset.disks ? (out << to_string(disks)) : (out << "<null>"));
  out << ", " << "virtual_machine_id="; (__isset.virtual_machine_id ? (out << to_string(virtual_machine_id)) : (out << "<null>"));
  out << ", " << "vdisks="; (__isset.vdisks ? (out << to_string(vdisks)) : (out << "<null>"));
  out << ", " << "output_folder="; (__isset.output_folder ? (out << to_string(output_folder)) : (out << "<null>"));
  out << ", " << "state="; (__isset.state ? (out << to_string(state)) : (out << "<null>"));
  out << ", " << "original_size="; (__isset.original_size ? (out << to_string(original_size)) : (out << "<null>"));
  out << ", " << "backup_progress="; (__isset.backup_progress ? (out << to_string(backup_progress)) : (out << "<null>"));
  out << ", " << "output_files="; (__isset.output_files ? (out << to_string(output_files)) : (out << "<null>"));
  out << ", " << "what="; (__isset.what ? (out << to_string(what)) : (out << "<null>"));
  out << ", " << "why="; (__isset.why ? (out << to_string(why)) : (out << "<null>"));
  out << ", " << "created_time="; (__isset.created_time ? (out << to_string(created_time)) : (out << "<null>"));
  out << ", " << "created_time_ll="; (__isset.created_time_ll ? (out << to_string(created_time_ll)) : (out << "<null>"));
  out << ", " << "output_disk="; (__isset.output_disk ? (out << to_string(output_disk)) : (out << "<null>"));
  out << ", " << "system_disk="; (__isset.system_disk ? (out << to_string(system_disk)) : (out << "<null>"));
  out << ", " << "histories="; (__isset.histories ? (out << to_string(histories)) : (out << "<null>"));
  out << ")";
}

}}} // namespace
