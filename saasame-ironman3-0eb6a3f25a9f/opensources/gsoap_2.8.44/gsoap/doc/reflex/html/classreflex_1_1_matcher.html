<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<meta http-equiv="cache-control" content="no-cache">
<title>reflex::Matcher Class Reference</title>
<link href="doxygen_tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="doxygen_content.css" rel="stylesheet" type="text/css">
</head>
<body>
<div id="top">
 <div id="titlearea">
  <table height="72px" width="100%" cellspacing="0" cellpadding="0">
   <tbody>
    <tr>
     <td width="10%">&nbsp;</td>
     <td><a href="https://github.com/Genivia/RE-flex"><img src="reflex-logo.png"/></a></td>
     <td>
      <div style="float: right; font-size: 18px; font-weight: bold;">reflex::Matcher Class Reference</div>
      <br>
      <div style="float: right; font-size: 10px;">updated Sat Mar 4 2017 by Robert van Engelen</div>
     </td>
     <td width="10%">&nbsp;</td>
    </tr>
   </tbody>
  </table>
 </div>
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacereflex.html">reflex</a></li><li class="navelem"><a class="el" href="classreflex_1_1_matcher.html">Matcher</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classreflex_1_1_matcher-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">reflex::Matcher Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>RE/flex matcher engine class, implements <a class="el" href="classreflex_1_1_pattern_matcher.html" title="The pattern matcher class template extends abstract matcher base class. ">reflex::PatternMatcher</a> pattern matching interface with scan, find, split functors and iterators.  
 <a href="classreflex_1_1_matcher.html#details">More...</a></p>

<p><code>#include &lt;matcher.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for reflex::Matcher:</div>
<div class="dyncontent">
<div class="center"><img src="classreflex_1_1_matcher__inherit__graph.png" border="0" usemap="#reflex_1_1_matcher_inherit__map" alt="Inheritance graph"/></div>
<map name="reflex_1_1_matcher_inherit__map" id="reflex_1_1_matcher_inherit__map">
<area shape="rect" id="node2" href="classreflex_1_1_pattern_matcher.html" title="reflex::PatternMatcher\l\&lt; reflex::Pattern \&gt;" alt="" coords="8,80,161,121"/>
<area shape="rect" id="node3" href="classreflex_1_1_abstract_matcher.html" title="The abstract matcher base class template defines an interface for all pattern matcher engines..." alt="" coords="5,5,164,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for reflex::Matcher:</div>
<div class="dyncontent">
<div class="center"><img src="classreflex_1_1_matcher__coll__graph.png" border="0" usemap="#reflex_1_1_matcher_coll__map" alt="Collaboration graph"/></div>
<map name="reflex_1_1_matcher_coll__map" id="reflex_1_1_matcher_coll__map">
<area shape="rect" id="node7" href="classreflex_1_1_pattern.html" title="Pattern class holds a regex pattern and its compiled FSM opcode table or code for the reflex::Matcher..." alt="" coords="499,159,604,186"/>
<area shape="rect" id="node2" href="classreflex_1_1_pattern_matcher.html" title="reflex::PatternMatcher\l\&lt; reflex::Pattern \&gt;" alt="" coords="741,152,895,193"/>
<area shape="rect" id="node3" href="classreflex_1_1_abstract_matcher.html" title="The abstract matcher base class template defines an interface for all pattern matcher engines..." alt="" coords="472,71,631,98"/>
<area shape="rect" id="node5" href="classreflex_1_1_abstract_matcher_1_1_operation.html" title="AbstractMatcher::Operation functor to match input to a pattern, also provides a (const) AbstractMatch..." alt="" coords="739,32,897,73"/>
<area shape="rect" id="node4" href="structreflex_1_1_abstract_matcher_1_1_option.html" title="AbstractMatcher::Options for matcher engines. " alt="" coords="232,5,391,47"/>
<area shape="rect" id="node6" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. " alt="" coords="265,71,357,98"/>
<area shape="rect" id="node8" href="structreflex_1_1_pattern_1_1_option.html" title="Global modifier modes, syntax flags, and compiler options. " alt="" coords="235,122,387,149"/>
<area shape="rect" id="node9" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. " alt="" coords="5,193,151,219"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html">FSM</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> data for <a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code.  <a href="structreflex_1_1_matcher_1_1_f_s_m.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acad91a095aa3a8e77da5d770a3c9561a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#acad91a095aa3a8e77da5d770a3c9561a">Matcher</a> ()</td></tr>
<tr class="memdesc:acad91a095aa3a8e77da5d770a3c9561a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#acad91a095aa3a8e77da5d770a3c9561a">More...</a><br /></td></tr>
<tr class="separator:acad91a095aa3a8e77da5d770a3c9561a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4552352f73af8554a9c21e810f22c40c"><td class="memTemplParams" colspan="2">template&lt;typename P &gt; </td></tr>
<tr class="memitem:a4552352f73af8554a9c21e810f22c40c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a4552352f73af8554a9c21e810f22c40c">Matcher</a> (const P *pat, const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;inp=<a class="el" href="classreflex_1_1_input.html">Input</a>(), const char *opt=NULL)</td></tr>
<tr class="memdesc:a4552352f73af8554a9c21e810f22c40c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct matcher engine from a pattern or a string regex, and an input character sequence.  <a href="#a4552352f73af8554a9c21e810f22c40c">More...</a><br /></td></tr>
<tr class="separator:a4552352f73af8554a9c21e810f22c40c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfaffe8a58a6fd0752966645361be090"><td class="memTemplParams" colspan="2">template&lt;typename P &gt; </td></tr>
<tr class="memitem:abfaffe8a58a6fd0752966645361be090"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#abfaffe8a58a6fd0752966645361be090">Matcher</a> (const P &amp;pat, const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;inp=<a class="el" href="classreflex_1_1_input.html">Input</a>(), const char *opt=NULL)</td></tr>
<tr class="memdesc:abfaffe8a58a6fd0752966645361be090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct matcher engine from a pattern or a string regex, and an input character sequence.  <a href="#abfaffe8a58a6fd0752966645361be090">More...</a><br /></td></tr>
<tr class="separator:abfaffe8a58a6fd0752966645361be090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a641754cf7025a978c7dc672a563ac5c0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a641754cf7025a978c7dc672a563ac5c0">reset</a> (const char *opt=NULL)</td></tr>
<tr class="memdesc:a641754cf7025a978c7dc672a563ac5c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset this matcher's state to the initial state.  <a href="#a641754cf7025a978c7dc672a563ac5c0">More...</a><br /></td></tr>
<tr class="separator:a641754cf7025a978c7dc672a563ac5c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf0031339b3f8426b730a6860e5feba2"><td class="memItemLeft" align="right" valign="top">virtual std::pair&lt; const char *, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#acf0031339b3f8426b730a6860e5feba2">operator[]</a> (size_t n) const </td></tr>
<tr class="memdesc:acf0031339b3f8426b730a6860e5feba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns captured text.  <a href="#acf0031339b3f8426b730a6860e5feba2">More...</a><br /></td></tr>
<tr class="separator:acf0031339b3f8426b730a6860e5feba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43734e349aec75a4afd05302f6c5fbb0"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; size_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a43734e349aec75a4afd05302f6c5fbb0">stops</a> (void) const </td></tr>
<tr class="memdesc:a43734e349aec75a4afd05302f6c5fbb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns vector of tab stops.  <a href="#a43734e349aec75a4afd05302f6c5fbb0">More...</a><br /></td></tr>
<tr class="separator:a43734e349aec75a4afd05302f6c5fbb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a980c06e7c868419074d7815de154ab3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a980c06e7c868419074d7815de154ab3d">clear_stops</a> (void)</td></tr>
<tr class="memdesc:a980c06e7c868419074d7815de154ab3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear tab stops.  <a href="#a980c06e7c868419074d7815de154ab3d">More...</a><br /></td></tr>
<tr class="separator:a980c06e7c868419074d7815de154ab3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4591c398bd930fb5bb0cda5b56ef03c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a4591c398bd930fb5bb0cda5b56ef03c8">push_stops</a> (void)</td></tr>
<tr class="memdesc:a4591c398bd930fb5bb0cda5b56ef03c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push stops and clear stops.  <a href="#a4591c398bd930fb5bb0cda5b56ef03c8">More...</a><br /></td></tr>
<tr class="separator:a4591c398bd930fb5bb0cda5b56ef03c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7736ffcc340ede12da1f9bbe8854a5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#ad7736ffcc340ede12da1f9bbe8854a5f">pop_stops</a> (void)</td></tr>
<tr class="memdesc:ad7736ffcc340ede12da1f9bbe8854a5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop stops.  <a href="#ad7736ffcc340ede12da1f9bbe8854a5f">More...</a><br /></td></tr>
<tr class="separator:ad7736ffcc340ede12da1f9bbe8854a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81899695d5bb82e06e49608ed9ebd629"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a81899695d5bb82e06e49608ed9ebd629">FSM_INIT</a> (int &amp;c1)</td></tr>
<tr class="memdesc:a81899695d5bb82e06e49608ed9ebd629"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code INIT,.  <a href="#a81899695d5bb82e06e49608ed9ebd629">More...</a><br /></td></tr>
<tr class="separator:a81899695d5bb82e06e49608ed9ebd629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c852851aeae6ed96e7adb0f6afe7932"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a1c852851aeae6ed96e7adb0f6afe7932">FSM_CHAR</a> (void)</td></tr>
<tr class="memdesc:a1c852851aeae6ed96e7adb0f6afe7932"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code CHAR.  <a href="#a1c852851aeae6ed96e7adb0f6afe7932">More...</a><br /></td></tr>
<tr class="separator:a1c852851aeae6ed96e7adb0f6afe7932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16876012f70f8957f689b9bda076a730"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a16876012f70f8957f689b9bda076a730">FSM_HALT</a> (int c1)</td></tr>
<tr class="memdesc:a16876012f70f8957f689b9bda076a730"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code HALT.  <a href="#a16876012f70f8957f689b9bda076a730">More...</a><br /></td></tr>
<tr class="separator:a16876012f70f8957f689b9bda076a730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6237f5989d641c75edc310beb73fd84d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a6237f5989d641c75edc310beb73fd84d">FSM_TAKE</a> (<a class="el" href="classreflex_1_1_pattern.html#a38d69acf1e472d48225a3ba50b138e02">Pattern::Index</a> cap)</td></tr>
<tr class="memdesc:a6237f5989d641c75edc310beb73fd84d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code TAKE.  <a href="#a6237f5989d641c75edc310beb73fd84d">More...</a><br /></td></tr>
<tr class="separator:a6237f5989d641c75edc310beb73fd84d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a041cea3bd793a450445cc82b24fc90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a1a041cea3bd793a450445cc82b24fc90">FSM_TAKE</a> (<a class="el" href="classreflex_1_1_pattern.html#a38d69acf1e472d48225a3ba50b138e02">Pattern::Index</a> cap, int c1)</td></tr>
<tr class="memdesc:a1a041cea3bd793a450445cc82b24fc90"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code TAKE.  <a href="#a1a041cea3bd793a450445cc82b24fc90">More...</a><br /></td></tr>
<tr class="separator:a1a041cea3bd793a450445cc82b24fc90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba89f6e60b06a9e280ceb6159d78dd2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a3ba89f6e60b06a9e280ceb6159d78dd2">FSM_REDO</a> (void)</td></tr>
<tr class="memdesc:a3ba89f6e60b06a9e280ceb6159d78dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code REDO.  <a href="#a3ba89f6e60b06a9e280ceb6159d78dd2">More...</a><br /></td></tr>
<tr class="separator:a3ba89f6e60b06a9e280ceb6159d78dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29425e4f07a84ed574e99e034891493d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a29425e4f07a84ed574e99e034891493d">FSM_REDO</a> (int c1)</td></tr>
<tr class="memdesc:a29425e4f07a84ed574e99e034891493d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code REDO.  <a href="#a29425e4f07a84ed574e99e034891493d">More...</a><br /></td></tr>
<tr class="separator:a29425e4f07a84ed574e99e034891493d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf6459dd5e3c961efae5285ae1e3ad4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#abaf6459dd5e3c961efae5285ae1e3ad4">FSM_HEAD</a> (<a class="el" href="classreflex_1_1_pattern.html#a38d69acf1e472d48225a3ba50b138e02">Pattern::Index</a> la)</td></tr>
<tr class="memdesc:abaf6459dd5e3c961efae5285ae1e3ad4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code HEAD.  <a href="#abaf6459dd5e3c961efae5285ae1e3ad4">More...</a><br /></td></tr>
<tr class="separator:abaf6459dd5e3c961efae5285ae1e3ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05bf4f34f39a43143b0942dc053c8718"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a05bf4f34f39a43143b0942dc053c8718">FSM_TAIL</a> (<a class="el" href="classreflex_1_1_pattern.html#a38d69acf1e472d48225a3ba50b138e02">Pattern::Index</a> la)</td></tr>
<tr class="memdesc:a05bf4f34f39a43143b0942dc053c8718"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code TAIL.  <a href="#a05bf4f34f39a43143b0942dc053c8718">More...</a><br /></td></tr>
<tr class="separator:a05bf4f34f39a43143b0942dc053c8718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb6dab47fc270e53d4b8af86aaf744f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a5fb6dab47fc270e53d4b8af86aaf744f">FSM_DENT</a> (void)</td></tr>
<tr class="memdesc:a5fb6dab47fc270e53d4b8af86aaf744f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code DENT.  <a href="#a5fb6dab47fc270e53d4b8af86aaf744f">More...</a><br /></td></tr>
<tr class="separator:a5fb6dab47fc270e53d4b8af86aaf744f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f07084ad78c0f79ecf3e01b279f450a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a6f07084ad78c0f79ecf3e01b279f450a">FSM_META_DED</a> (void)</td></tr>
<tr class="memdesc:a6f07084ad78c0f79ecf3e01b279f450a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code META DED.  <a href="#a6f07084ad78c0f79ecf3e01b279f450a">More...</a><br /></td></tr>
<tr class="separator:a6f07084ad78c0f79ecf3e01b279f450a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe1192161f249844190d6f3b76349c1b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#abe1192161f249844190d6f3b76349c1b">FSM_META_IND</a> (void)</td></tr>
<tr class="memdesc:abe1192161f249844190d6f3b76349c1b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code META IND.  <a href="#abe1192161f249844190d6f3b76349c1b">More...</a><br /></td></tr>
<tr class="separator:abe1192161f249844190d6f3b76349c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7acbb9557977ccf9a85f6baedc63287f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a7acbb9557977ccf9a85f6baedc63287f">FSM_META_EOB</a> (int c1)</td></tr>
<tr class="memdesc:a7acbb9557977ccf9a85f6baedc63287f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code META EOB.  <a href="#a7acbb9557977ccf9a85f6baedc63287f">More...</a><br /></td></tr>
<tr class="separator:a7acbb9557977ccf9a85f6baedc63287f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3714503b8e60531d572db6838b0d7d98"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a3714503b8e60531d572db6838b0d7d98">FSM_META_BOB</a> (void)</td></tr>
<tr class="memdesc:a3714503b8e60531d572db6838b0d7d98"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code META BOB.  <a href="#a3714503b8e60531d572db6838b0d7d98">More...</a><br /></td></tr>
<tr class="separator:a3714503b8e60531d572db6838b0d7d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0222ac0b08f7dfe4232cc1ae38ec86b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a0222ac0b08f7dfe4232cc1ae38ec86b0">FSM_META_EOL</a> (int c1)</td></tr>
<tr class="memdesc:a0222ac0b08f7dfe4232cc1ae38ec86b0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code META EOL.  <a href="#a0222ac0b08f7dfe4232cc1ae38ec86b0">More...</a><br /></td></tr>
<tr class="separator:a0222ac0b08f7dfe4232cc1ae38ec86b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a431d6fdd08b14eea0d758aa4d577f003"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a431d6fdd08b14eea0d758aa4d577f003">FSM_META_BOL</a> (void)</td></tr>
<tr class="memdesc:a431d6fdd08b14eea0d758aa4d577f003"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code META BOL.  <a href="#a431d6fdd08b14eea0d758aa4d577f003">More...</a><br /></td></tr>
<tr class="separator:a431d6fdd08b14eea0d758aa4d577f003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a108d0fa7893bd165a1103aca4e8708ca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a108d0fa7893bd165a1103aca4e8708ca">FSM_META_EWE</a> (int c0, int c1)</td></tr>
<tr class="memdesc:a108d0fa7893bd165a1103aca4e8708ca"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code META EWE.  <a href="#a108d0fa7893bd165a1103aca4e8708ca">More...</a><br /></td></tr>
<tr class="separator:a108d0fa7893bd165a1103aca4e8708ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade19817779426782ab997a7a5d8e2e3b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#ade19817779426782ab997a7a5d8e2e3b">FSM_META_BWE</a> (int c0, int c1)</td></tr>
<tr class="memdesc:ade19817779426782ab997a7a5d8e2e3b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code META BWE.  <a href="#ade19817779426782ab997a7a5d8e2e3b">More...</a><br /></td></tr>
<tr class="separator:ade19817779426782ab997a7a5d8e2e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53183f5dab031514f52bad12fb2dbca1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a53183f5dab031514f52bad12fb2dbca1">FSM_META_EWB</a> (void)</td></tr>
<tr class="memdesc:a53183f5dab031514f52bad12fb2dbca1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code META EWB.  <a href="#a53183f5dab031514f52bad12fb2dbca1">More...</a><br /></td></tr>
<tr class="separator:a53183f5dab031514f52bad12fb2dbca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1290821154dd3abd8646117c18bb0d24"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a1290821154dd3abd8646117c18bb0d24">FSM_META_BWB</a> (void)</td></tr>
<tr class="memdesc:a1290821154dd3abd8646117c18bb0d24"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code META BWB.  <a href="#a1290821154dd3abd8646117c18bb0d24">More...</a><br /></td></tr>
<tr class="separator:a1290821154dd3abd8646117c18bb0d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77fbd40b1c0fc532f3ec5dda683d5d86"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a77fbd40b1c0fc532f3ec5dda683d5d86">FSM_META_NWE</a> (int c0, int c1)</td></tr>
<tr class="memdesc:a77fbd40b1c0fc532f3ec5dda683d5d86"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code META NWE.  <a href="#a77fbd40b1c0fc532f3ec5dda683d5d86">More...</a><br /></td></tr>
<tr class="separator:a77fbd40b1c0fc532f3ec5dda683d5d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a406ca28596bc6f75dcf975d3abb4c963"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a406ca28596bc6f75dcf975d3abb4c963">FSM_META_NWB</a> (void)</td></tr>
<tr class="memdesc:a406ca28596bc6f75dcf975d3abb4c963"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code META NWB.  <a href="#a406ca28596bc6f75dcf975d3abb4c963">More...</a><br /></td></tr>
<tr class="separator:a406ca28596bc6f75dcf975d3abb4c963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classreflex_1_1_pattern_matcher"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classreflex_1_1_pattern_matcher')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classreflex_1_1_pattern_matcher.html">reflex::PatternMatcher&lt; reflex::Pattern &gt;</a></td></tr>
<tr class="memitem:a7b32893191d6bfb4af05e33b5643b2b2 inherit pub_methods_classreflex_1_1_pattern_matcher"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_pattern_matcher.html#a7b32893191d6bfb4af05e33b5643b2b2">PatternMatcher</a> (const <a class="el" href="classreflex_1_1_pattern_matcher.html">PatternMatcher</a> &amp;matcher)</td></tr>
<tr class="memdesc:a7b32893191d6bfb4af05e33b5643b2b2 inherit pub_methods_classreflex_1_1_pattern_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor, the underlying pattern object is shared (not deep copied).  <a href="#a7b32893191d6bfb4af05e33b5643b2b2">More...</a><br /></td></tr>
<tr class="separator:a7b32893191d6bfb4af05e33b5643b2b2 inherit pub_methods_classreflex_1_1_pattern_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a955ab9f88de963d9f9f20da788339aea inherit pub_methods_classreflex_1_1_pattern_matcher"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_pattern_matcher.html#a955ab9f88de963d9f9f20da788339aea">~PatternMatcher</a> ()</td></tr>
<tr class="memdesc:a955ab9f88de963d9f9f20da788339aea inherit pub_methods_classreflex_1_1_pattern_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete matcher, deletes pattern when owned, deletes this matcher's internal buffer.  <a href="#a955ab9f88de963d9f9f20da788339aea">More...</a><br /></td></tr>
<tr class="separator:a955ab9f88de963d9f9f20da788339aea inherit pub_methods_classreflex_1_1_pattern_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05c456bf148afd72ed92f54434cad16f inherit pub_methods_classreflex_1_1_pattern_matcher"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classreflex_1_1_pattern_matcher.html">PatternMatcher</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_pattern_matcher.html#a05c456bf148afd72ed92f54434cad16f">pattern</a> (const <a class="el" href="classreflex_1_1_pattern_matcher.html">PatternMatcher</a> &amp;matcher)</td></tr>
<tr class="memdesc:a05c456bf148afd72ed92f54434cad16f inherit pub_methods_classreflex_1_1_pattern_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the pattern to use with this matcher as a shared pointer to another matcher pattern.  <a href="#a05c456bf148afd72ed92f54434cad16f">More...</a><br /></td></tr>
<tr class="separator:a05c456bf148afd72ed92f54434cad16f inherit pub_methods_classreflex_1_1_pattern_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc8196f5ead44105f2857e842ab028c inherit pub_methods_classreflex_1_1_pattern_matcher"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classreflex_1_1_pattern_matcher.html">PatternMatcher</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_pattern_matcher.html#a8cc8196f5ead44105f2857e842ab028c">pattern</a> (const <a class="el" href="classreflex_1_1_pattern_matcher.html#a56c667f62f9d60ccfe3caf16bbc2a9fc">Pattern</a> &amp;pat)</td></tr>
<tr class="memdesc:a8cc8196f5ead44105f2857e842ab028c inherit pub_methods_classreflex_1_1_pattern_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the pattern to use with this matcher (the given pattern is shared and must be persistent).  <a href="#a8cc8196f5ead44105f2857e842ab028c">More...</a><br /></td></tr>
<tr class="separator:a8cc8196f5ead44105f2857e842ab028c inherit pub_methods_classreflex_1_1_pattern_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b4b43bad9e4fe91d32afbd9642231cd inherit pub_methods_classreflex_1_1_pattern_matcher"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classreflex_1_1_pattern_matcher.html">PatternMatcher</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_pattern_matcher.html#a7b4b43bad9e4fe91d32afbd9642231cd">pattern</a> (const <a class="el" href="classreflex_1_1_pattern_matcher.html#a56c667f62f9d60ccfe3caf16bbc2a9fc">Pattern</a> *pat)</td></tr>
<tr class="memdesc:a7b4b43bad9e4fe91d32afbd9642231cd inherit pub_methods_classreflex_1_1_pattern_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the pattern to use with this matcher (the given pattern is shared and must be persistent).  <a href="#a7b4b43bad9e4fe91d32afbd9642231cd">More...</a><br /></td></tr>
<tr class="separator:a7b4b43bad9e4fe91d32afbd9642231cd inherit pub_methods_classreflex_1_1_pattern_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1668eb2cb22b0a57ad8d88bfd35581b1 inherit pub_methods_classreflex_1_1_pattern_matcher"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classreflex_1_1_pattern_matcher.html">PatternMatcher</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_pattern_matcher.html#a1668eb2cb22b0a57ad8d88bfd35581b1">pattern</a> (const char *pat)</td></tr>
<tr class="memdesc:a1668eb2cb22b0a57ad8d88bfd35581b1 inherit pub_methods_classreflex_1_1_pattern_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the pattern from a regex string to use with this matcher.  <a href="#a1668eb2cb22b0a57ad8d88bfd35581b1">More...</a><br /></td></tr>
<tr class="separator:a1668eb2cb22b0a57ad8d88bfd35581b1 inherit pub_methods_classreflex_1_1_pattern_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac16a8a6b52ed6f186a990f789f260d3a inherit pub_methods_classreflex_1_1_pattern_matcher"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classreflex_1_1_pattern_matcher.html">PatternMatcher</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_pattern_matcher.html#ac16a8a6b52ed6f186a990f789f260d3a">pattern</a> (const std::string &amp;pat)</td></tr>
<tr class="memdesc:ac16a8a6b52ed6f186a990f789f260d3a inherit pub_methods_classreflex_1_1_pattern_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the pattern from a regex string to use with this matcher.  <a href="#ac16a8a6b52ed6f186a990f789f260d3a">More...</a><br /></td></tr>
<tr class="separator:ac16a8a6b52ed6f186a990f789f260d3a inherit pub_methods_classreflex_1_1_pattern_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb2eacba4c6b5a62d9c42e8bbdc2c63 inherit pub_methods_classreflex_1_1_pattern_matcher"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classreflex_1_1_pattern_matcher.html#a56c667f62f9d60ccfe3caf16bbc2a9fc">Pattern</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_pattern_matcher.html#a3cb2eacba4c6b5a62d9c42e8bbdc2c63">pattern</a> () const</td></tr>
<tr class="memdesc:a3cb2eacba4c6b5a62d9c42e8bbdc2c63 inherit pub_methods_classreflex_1_1_pattern_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the pattern object associated with this matcher.  <a href="#a3cb2eacba4c6b5a62d9c42e8bbdc2c63">More...</a><br /></td></tr>
<tr class="separator:a3cb2eacba4c6b5a62d9c42e8bbdc2c63 inherit pub_methods_classreflex_1_1_pattern_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac868861b716ce41e26f4a589517ae088 inherit pub_methods_classreflex_1_1_pattern_matcher"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_pattern_matcher.html#ac868861b716ce41e26f4a589517ae088">has_pattern</a> () const</td></tr>
<tr class="memdesc:ac868861b716ce41e26f4a589517ae088 inherit pub_methods_classreflex_1_1_pattern_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this matcher has a pattern.  <a href="#ac868861b716ce41e26f4a589517ae088">More...</a><br /></td></tr>
<tr class="separator:ac868861b716ce41e26f4a589517ae088 inherit pub_methods_classreflex_1_1_pattern_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1e17bf52c960356ba7308015e98a49 inherit pub_methods_classreflex_1_1_pattern_matcher"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_pattern_matcher.html#a5f1e17bf52c960356ba7308015e98a49">own_pattern</a> () const</td></tr>
<tr class="memdesc:a5f1e17bf52c960356ba7308015e98a49 inherit pub_methods_classreflex_1_1_pattern_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this matcher has its own pattern not received from another matcher (responsible to delete).  <a href="#a5f1e17bf52c960356ba7308015e98a49">More...</a><br /></td></tr>
<tr class="separator:a5f1e17bf52c960356ba7308015e98a49 inherit pub_methods_classreflex_1_1_pattern_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classreflex_1_1_abstract_matcher"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classreflex_1_1_abstract_matcher')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classreflex_1_1_abstract_matcher.html">reflex::AbstractMatcher</a></td></tr>
<tr class="memitem:a0fb96965d228951194f0a2b9ee574dcf inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a0fb96965d228951194f0a2b9ee574dcf">buffer</a> (size_t blk=0)</td></tr>
<tr class="memdesc:a0fb96965d228951194f0a2b9ee574dcf inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set buffer block size for reading: use 1 for interactive input, 0 (or omit argument) to buffer all input in which case returns true if all the data could be read and false if a read error occurred.  <a href="#a0fb96965d228951194f0a2b9ee574dcf">More...</a><br /></td></tr>
<tr class="separator:a0fb96965d228951194f0a2b9ee574dcf inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb1d22133cb4cf88f208c45ee8cdc0e0 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#acb1d22133cb4cf88f208c45ee8cdc0e0">interactive</a> ()</td></tr>
<tr class="memdesc:acb1d22133cb4cf88f208c45ee8cdc0e0 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set buffer to 1 for interactive input.  <a href="#acb1d22133cb4cf88f208c45ee8cdc0e0">More...</a><br /></td></tr>
<tr class="separator:acb1d22133cb4cf88f208c45ee8cdc0e0 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acafc5782952bb1e80c7e5bf367ffc6af inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#acafc5782952bb1e80c7e5bf367ffc6af">flush</a> ()</td></tr>
<tr class="memdesc:acafc5782952bb1e80c7e5bf367ffc6af inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush the buffer's remaining content.  <a href="#acafc5782952bb1e80c7e5bf367ffc6af">More...</a><br /></td></tr>
<tr class="separator:acafc5782952bb1e80c7e5bf367ffc6af inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9faa6a021d5d81e51408e0fa903ecbb7 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classreflex_1_1_abstract_matcher.html">AbstractMatcher</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a9faa6a021d5d81e51408e0fa903ecbb7">input</a> (const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;inp)</td></tr>
<tr class="memdesc:a9faa6a021d5d81e51408e0fa903ecbb7 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the input character sequence for this matcher and reset the matcher.  <a href="#a9faa6a021d5d81e51408e0fa903ecbb7">More...</a><br /></td></tr>
<tr class="separator:a9faa6a021d5d81e51408e0fa903ecbb7 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab880e6c8fe0df7c4ee7bb629aab41d0f inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#ab880e6c8fe0df7c4ee7bb629aab41d0f">matches</a> ()</td></tr>
<tr class="memdesc:ab880e6c8fe0df7c4ee7bb629aab41d0f inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns nonzero capture index (i.e. true) if the entire input matches this matcher's pattern (and internally caches the true/false result for repeat invocations).  <a href="#ab880e6c8fe0df7c4ee7bb629aab41d0f">More...</a><br /></td></tr>
<tr class="separator:ab880e6c8fe0df7c4ee7bb629aab41d0f inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af51252ce359e6106b58c81f70776ccfb inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#af51252ce359e6106b58c81f70776ccfb">accept</a> () const </td></tr>
<tr class="memdesc:af51252ce359e6106b58c81f70776ccfb inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a positive integer (true) indicating the capture index of the matched text in the pattern or zero (false) for a mismatch.  <a href="#af51252ce359e6106b58c81f70776ccfb">More...</a><br /></td></tr>
<tr class="separator:af51252ce359e6106b58c81f70776ccfb inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b7a345add39a481e8963cb04a4347b8 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a8b7a345add39a481e8963cb04a4347b8">text</a> () const </td></tr>
<tr class="memdesc:a8b7a345add39a481e8963cb04a4347b8 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns string with the text matched.  <a href="#a8b7a345add39a481e8963cb04a4347b8">More...</a><br /></td></tr>
<tr class="separator:a8b7a345add39a481e8963cb04a4347b8 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb5fec59e6c6a86b8cf405c40f93d1de inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#adb5fec59e6c6a86b8cf405c40f93d1de">size</a> () const </td></tr>
<tr class="memdesc:adb5fec59e6c6a86b8cf405c40f93d1de inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the matched text in number of bytes.  <a href="#adb5fec59e6c6a86b8cf405c40f93d1de">More...</a><br /></td></tr>
<tr class="separator:adb5fec59e6c6a86b8cf405c40f93d1de inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4bcff50974291fa01d4f7f7db4c77f5 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#af4bcff50974291fa01d4f7f7db4c77f5">wsize</a> () const </td></tr>
<tr class="memdesc:af4bcff50974291fa01d4f7f7db4c77f5 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the matched text in number of (wide) characters.  <a href="#af4bcff50974291fa01d4f7f7db4c77f5">More...</a><br /></td></tr>
<tr class="separator:af4bcff50974291fa01d4f7f7db4c77f5 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36ddaede89eef2b9b85f13dcb8c32008 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a36ddaede89eef2b9b85f13dcb8c32008">lineno</a> () const </td></tr>
<tr class="memdesc:a36ddaede89eef2b9b85f13dcb8c32008 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the line number of the match in the input character sequence.  <a href="#a36ddaede89eef2b9b85f13dcb8c32008">More...</a><br /></td></tr>
<tr class="separator:a36ddaede89eef2b9b85f13dcb8c32008 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb9be9a8326bbb70a5f43c96d5a2cf28 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#acb9be9a8326bbb70a5f43c96d5a2cf28">columno</a> () const </td></tr>
<tr class="memdesc:acb9be9a8326bbb70a5f43c96d5a2cf28 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the column number of matched text, counting wide characters (unless compiled with WITH_BYTE_COLUMNO).  <a href="#acb9be9a8326bbb70a5f43c96d5a2cf28">More...</a><br /></td></tr>
<tr class="separator:acb9be9a8326bbb70a5f43c96d5a2cf28 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc573eafc849b275d21b114abe1ea570 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">std::pair&lt; size_t, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#abc573eafc849b275d21b114abe1ea570">pair</a> () const </td></tr>
<tr class="memdesc:abc573eafc849b275d21b114abe1ea570 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pair of size_t <a class="el" href="classreflex_1_1_abstract_matcher.html#af51252ce359e6106b58c81f70776ccfb" title="Returns a positive integer (true) indicating the capture index of the matched text in the pattern or ...">accept()</a> and std::string <a class="el" href="classreflex_1_1_abstract_matcher.html#a8b7a345add39a481e8963cb04a4347b8" title="Returns string with the text matched. ">text()</a>, useful for tokenizing input into containers of pairs.  <a href="#abc573eafc849b275d21b114abe1ea570">More...</a><br /></td></tr>
<tr class="separator:abc573eafc849b275d21b114abe1ea570 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a112117a78682b9634806158e018dc6b4 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a112117a78682b9634806158e018dc6b4">first</a> () const </td></tr>
<tr class="memdesc:a112117a78682b9634806158e018dc6b4 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position of the first character starting the match in the input character sequence.  <a href="#a112117a78682b9634806158e018dc6b4">More...</a><br /></td></tr>
<tr class="separator:a112117a78682b9634806158e018dc6b4 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7840043710c3c45820390480c8f42315 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a7840043710c3c45820390480c8f42315">last</a> () const </td></tr>
<tr class="memdesc:a7840043710c3c45820390480c8f42315 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position of the last character + 1 after of the match in the input character sequence.  <a href="#a7840043710c3c45820390480c8f42315">More...</a><br /></td></tr>
<tr class="separator:a7840043710c3c45820390480c8f42315 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a146013ac9f6dcb1af9edef6ee5f3dc58 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a146013ac9f6dcb1af9edef6ee5f3dc58">at_bob</a> () const </td></tr>
<tr class="memdesc:a146013ac9f6dcb1af9edef6ee5f3dc58 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this matcher is at the start of an input character sequence. Use <a class="el" href="classreflex_1_1_abstract_matcher.html#a66f487ab96e7cef1a66e9780dc45e315" title="Reset this matcher&#39;s state to the initial state and set options (when provided). ">reset()</a> to restart input.  <a href="#a146013ac9f6dcb1af9edef6ee5f3dc58">More...</a><br /></td></tr>
<tr class="separator:a146013ac9f6dcb1af9edef6ee5f3dc58 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac843ab490d5ad9ba71a96c3b323eba19 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#ac843ab490d5ad9ba71a96c3b323eba19">at_end</a> ()</td></tr>
<tr class="memdesc:ac843ab490d5ad9ba71a96c3b323eba19 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this matcher has no more input to read from the input character sequence.  <a href="#ac843ab490d5ad9ba71a96c3b323eba19">More...</a><br /></td></tr>
<tr class="separator:ac843ab490d5ad9ba71a96c3b323eba19 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5ec19555d6e0f4a8210651f9343987 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#afb5ec19555d6e0f4a8210651f9343987">hit_end</a> () const </td></tr>
<tr class="memdesc:afb5ec19555d6e0f4a8210651f9343987 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this matcher hit the end of the input character sequence.  <a href="#afb5ec19555d6e0f4a8210651f9343987">More...</a><br /></td></tr>
<tr class="separator:afb5ec19555d6e0f4a8210651f9343987 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6dcc2b180a7139b52a6bfe1ebabf1b inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#aec6dcc2b180a7139b52a6bfe1ebabf1b">set_end</a> (bool eof)</td></tr>
<tr class="memdesc:aec6dcc2b180a7139b52a6bfe1ebabf1b inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set and force the end of input state.  <a href="#aec6dcc2b180a7139b52a6bfe1ebabf1b">More...</a><br /></td></tr>
<tr class="separator:aec6dcc2b180a7139b52a6bfe1ebabf1b inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a240d7d235b5a1d7aa32d464891cb96a5 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a240d7d235b5a1d7aa32d464891cb96a5">at_bol</a> () const </td></tr>
<tr class="memdesc:a240d7d235b5a1d7aa32d464891cb96a5 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this matcher reached the begin of a new line.  <a href="#a240d7d235b5a1d7aa32d464891cb96a5">More...</a><br /></td></tr>
<tr class="separator:a240d7d235b5a1d7aa32d464891cb96a5 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0860fa58e41f5a0d7e74d1fe33559df3 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a0860fa58e41f5a0d7e74d1fe33559df3">set_bol</a> (bool bol)</td></tr>
<tr class="memdesc:a0860fa58e41f5a0d7e74d1fe33559df3 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the begin of a new line state.  <a href="#a0860fa58e41f5a0d7e74d1fe33559df3">More...</a><br /></td></tr>
<tr class="separator:a0860fa58e41f5a0d7e74d1fe33559df3 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a827817fd1ed8edbe8eec84eeefa8a88e inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a827817fd1ed8edbe8eec84eeefa8a88e">input</a> ()</td></tr>
<tr class="memdesc:a827817fd1ed8edbe8eec84eeefa8a88e inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next character from the input character sequence while preserving the current text match.  <a href="#a827817fd1ed8edbe8eec84eeefa8a88e">More...</a><br /></td></tr>
<tr class="separator:a827817fd1ed8edbe8eec84eeefa8a88e inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb536d7812fcf52017e9d452e96381a inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a5fb536d7812fcf52017e9d452e96381a">unput</a> (char c)</td></tr>
<tr class="memdesc:a5fb536d7812fcf52017e9d452e96381a inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put back one character on the input character sequence for matching, invalidating the current match info and text.  <a href="#a5fb536d7812fcf52017e9d452e96381a">More...</a><br /></td></tr>
<tr class="separator:a5fb536d7812fcf52017e9d452e96381a inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab39dc592de42a7e044296f03bee4fdb3 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#ab39dc592de42a7e044296f03bee4fdb3">rest</a> ()</td></tr>
<tr class="memdesc:ab39dc592de42a7e044296f03bee4fdb3 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the rest of the input as text, useful for searching/splitting up to n times after which the rest is needed.  <a href="#ab39dc592de42a7e044296f03bee4fdb3">More...</a><br /></td></tr>
<tr class="separator:ab39dc592de42a7e044296f03bee4fdb3 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9577e765c5c1be82cb3f9b0ccdaf633f inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a9577e765c5c1be82cb3f9b0ccdaf633f">more</a> ()</td></tr>
<tr class="memdesc:a9577e765c5c1be82cb3f9b0ccdaf633f inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append the next match to the currently matched text returned by <a class="el" href="classreflex_1_1_abstract_matcher.html#a8b7a345add39a481e8963cb04a4347b8" title="Returns string with the text matched. ">AbstractMatcher::text</a>, when the next match found is adjacent to the current match.  <a href="#a9577e765c5c1be82cb3f9b0ccdaf633f">More...</a><br /></td></tr>
<tr class="separator:a9577e765c5c1be82cb3f9b0ccdaf633f inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12ca0aa2d6ff88ac26f565ec5660787a inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a12ca0aa2d6ff88ac26f565ec5660787a">less</a> (size_t n)</td></tr>
<tr class="memdesc:a12ca0aa2d6ff88ac26f565ec5660787a inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate the <a class="el" href="classreflex_1_1_abstract_matcher.html#a8b7a345add39a481e8963cb04a4347b8" title="Returns string with the text matched. ">AbstractMatcher::text</a> length of the match to n characters in length and reposition for next match.  <a href="#a12ca0aa2d6ff88ac26f565ec5660787a">More...</a><br /></td></tr>
<tr class="separator:a12ca0aa2d6ff88ac26f565ec5660787a inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e8cd6c7fde713a5ac68ec168291e03e inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a2e8cd6c7fde713a5ac68ec168291e03e">operator size_t</a> () const </td></tr>
<tr class="memdesc:a2e8cd6c7fde713a5ac68ec168291e03e inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast this matcher to positive integer indicating the nonzero capture index of the matched text in the pattern, same as <a class="el" href="classreflex_1_1_abstract_matcher.html#af51252ce359e6106b58c81f70776ccfb" title="Returns a positive integer (true) indicating the capture index of the matched text in the pattern or ...">AbstractMatcher::accept</a>.  <a href="#a2e8cd6c7fde713a5ac68ec168291e03e">More...</a><br /></td></tr>
<tr class="separator:a2e8cd6c7fde713a5ac68ec168291e03e inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a360028bf97e0da02f6ffbcae031f9f35 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a360028bf97e0da02f6ffbcae031f9f35">operator std::string</a> () const </td></tr>
<tr class="memdesc:a360028bf97e0da02f6ffbcae031f9f35 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast this matcher to a std::string of the text matched by this matcher.  <a href="#a360028bf97e0da02f6ffbcae031f9f35">More...</a><br /></td></tr>
<tr class="separator:a360028bf97e0da02f6ffbcae031f9f35 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aeee06821a94df33a8c531d3913a5d7 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a6aeee06821a94df33a8c531d3913a5d7">operator std::pair&lt; size_t, std::string &gt;</a> () const </td></tr>
<tr class="memdesc:a6aeee06821a94df33a8c531d3913a5d7 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast this matcher to a pair of size_t <a class="el" href="classreflex_1_1_abstract_matcher.html#af51252ce359e6106b58c81f70776ccfb" title="Returns a positive integer (true) indicating the capture index of the matched text in the pattern or ...">accept()</a> and std::string <a class="el" href="classreflex_1_1_abstract_matcher.html#a8b7a345add39a481e8963cb04a4347b8" title="Returns string with the text matched. ">text()</a>, useful for tokenization into containers.  <a href="#a6aeee06821a94df33a8c531d3913a5d7">More...</a><br /></td></tr>
<tr class="separator:a6aeee06821a94df33a8c531d3913a5d7 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0ccba7e796bc4cbf0fca4ddca5c7435 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#ac0ccba7e796bc4cbf0fca4ddca5c7435">operator==</a> (const char *rhs) const </td></tr>
<tr class="memdesc:ac0ccba7e796bc4cbf0fca4ddca5c7435 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if matched text is equal to a string, useful for std::algorithm.  <a href="#ac0ccba7e796bc4cbf0fca4ddca5c7435">More...</a><br /></td></tr>
<tr class="separator:ac0ccba7e796bc4cbf0fca4ddca5c7435 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad80d8b2a00e7e4342187f3e820aae4cc inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#ad80d8b2a00e7e4342187f3e820aae4cc">operator==</a> (const std::string &amp;rhs) const </td></tr>
<tr class="memdesc:ad80d8b2a00e7e4342187f3e820aae4cc inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if matched text is equalt to a string, useful for std::algorithm.  <a href="#ad80d8b2a00e7e4342187f3e820aae4cc">More...</a><br /></td></tr>
<tr class="separator:ad80d8b2a00e7e4342187f3e820aae4cc inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9bd073a805aa84f99af13d4f4d7810a inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#ac9bd073a805aa84f99af13d4f4d7810a">operator==</a> (size_t rhs) const </td></tr>
<tr class="memdesc:ac9bd073a805aa84f99af13d4f4d7810a inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if capture index is equal to a given size_t value, useful for std::algorithm.  <a href="#ac9bd073a805aa84f99af13d4f4d7810a">More...</a><br /></td></tr>
<tr class="separator:ac9bd073a805aa84f99af13d4f4d7810a inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeca9e1c83a9e7ea32adc7dedcba8891e inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#aeca9e1c83a9e7ea32adc7dedcba8891e">operator==</a> (int rhs) const </td></tr>
<tr class="memdesc:aeca9e1c83a9e7ea32adc7dedcba8891e inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if capture index is equal to a given int value, useful for std::algorithm.  <a href="#aeca9e1c83a9e7ea32adc7dedcba8891e">More...</a><br /></td></tr>
<tr class="separator:aeca9e1c83a9e7ea32adc7dedcba8891e inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a502f0e864626cbdc5a09b6045c7fd801 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a502f0e864626cbdc5a09b6045c7fd801">operator!=</a> (const char *rhs) const </td></tr>
<tr class="memdesc:a502f0e864626cbdc5a09b6045c7fd801 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if matched text is not equal to a string, useful for std::algorithm.  <a href="#a502f0e864626cbdc5a09b6045c7fd801">More...</a><br /></td></tr>
<tr class="separator:a502f0e864626cbdc5a09b6045c7fd801 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85763cb3d9dbb87906edb69545d4f616 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a85763cb3d9dbb87906edb69545d4f616">operator!=</a> (const std::string &amp;rhs) const </td></tr>
<tr class="memdesc:a85763cb3d9dbb87906edb69545d4f616 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if matched text is not equal to a string, useful for std::algorithm.  <a href="#a85763cb3d9dbb87906edb69545d4f616">More...</a><br /></td></tr>
<tr class="separator:a85763cb3d9dbb87906edb69545d4f616 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08e20564598a3871d32d95af33db5ea4 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a08e20564598a3871d32d95af33db5ea4">operator!=</a> (size_t rhs) const </td></tr>
<tr class="memdesc:a08e20564598a3871d32d95af33db5ea4 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if capture index is not equal to a given size_t value, useful for std::algorithm.  <a href="#a08e20564598a3871d32d95af33db5ea4">More...</a><br /></td></tr>
<tr class="separator:a08e20564598a3871d32d95af33db5ea4 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7157e28939ecc094dca648b3bf9759a2 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a7157e28939ecc094dca648b3bf9759a2">operator!=</a> (int rhs) const </td></tr>
<tr class="memdesc:a7157e28939ecc094dca648b3bf9759a2 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if capture index is not equal to a given int value, useful for std::algorithm.  <a href="#a7157e28939ecc094dca648b3bf9759a2">More...</a><br /></td></tr>
<tr class="separator:a7157e28939ecc094dca648b3bf9759a2 inherit pub_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a8862686f6d5680d4d0e5af146c4aed69"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8862686f6d5680d4d0e5af146c4aed69"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a8862686f6d5680d4d0e5af146c4aed69">convert</a> (T regex, <a class="el" href="namespacereflex.html#ab659f1b759d66631c2e2e32771af1200">convert_flag_type</a> flags=<a class="el" href="namespacereflex_1_1convert__flag.html#af5c6fe22fc79bb893e135d583d525930">convert_flag::none</a>)</td></tr>
<tr class="memdesc:a8862686f6d5680d4d0e5af146c4aed69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a regex to an acceptable form, given the specified regex library signature <code>"[decls:]escapes[?+]"</code>, see <a class="el" href="namespacereflex.html#a4f388dfde137fe178705346b44c56223" title="Returns the converted regex string given a regex library signature and conversion flags...">reflex::convert</a>.  <a href="#a8862686f6d5680d4d0e5af146c4aed69">More...</a><br /></td></tr>
<tr class="separator:a8862686f6d5680d4d0e5af146c4aed69"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a9748ab7e9dc48d3893968f432a3f7cfa"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a9748ab7e9dc48d3893968f432a3f7cfa">Stops</a></td></tr>
<tr class="separator:a9748ab7e9dc48d3893968f432a3f7cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_types_classreflex_1_1_abstract_matcher"><td colspan="2" onclick="javascript:toggleInherit('pro_types_classreflex_1_1_abstract_matcher')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="classreflex_1_1_abstract_matcher.html">reflex::AbstractMatcher</a></td></tr>
<tr class="memitem:a82ed7b2c125bd897dea73443d2650ac6 inherit pro_types_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a82ed7b2c125bd897dea73443d2650ac6">Method</a></td></tr>
<tr class="separator:a82ed7b2c125bd897dea73443d2650ac6 inherit pro_types_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ab8a1264b3ede06dbba853b1ca0baead5"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#ab8a1264b3ede06dbba853b1ca0baead5">match</a> (<a class="el" href="classreflex_1_1_abstract_matcher.html#a82ed7b2c125bd897dea73443d2650ac6">Method</a> method)</td></tr>
<tr class="memdesc:ab8a1264b3ede06dbba853b1ca0baead5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if input matched the pattern using method <a class="el" href="structreflex_1_1_abstract_matcher_1_1_const.html#a57efdf6e79f50205036bc4d55e9908e7" title="AbstractMatcher::match method is to scan input (tokenizer) ">Const::SCAN</a>, <a class="el" href="structreflex_1_1_abstract_matcher_1_1_const.html#af03daba13cf299ee0e6be2e37ebe59b7" title="AbstractMatcher::match method is to find pattern in input. ">Const::FIND</a>, <a class="el" href="structreflex_1_1_abstract_matcher_1_1_const.html#a48f6d3e22c2f018fef95b2367a2a9aa4" title="AbstractMatcher::match method is to split input at pattern matches. ">Const::SPLIT</a>, or <a class="el" href="structreflex_1_1_abstract_matcher_1_1_const.html#aa1fe9eb434ef5ff539b01a601977f9ee" title="AbstractMatcher::match method is to match the entire input. ">Const::MATCH</a>.  <a href="#ab8a1264b3ede06dbba853b1ca0baead5">More...</a><br /></td></tr>
<tr class="separator:ab8a1264b3ede06dbba853b1ca0baead5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d1e7b1dd59a0bc7e775d755b24d7872"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a6d1e7b1dd59a0bc7e775d755b24d7872">newline</a> (size_t &amp;col)</td></tr>
<tr class="memdesc:a6d1e7b1dd59a0bc7e775d755b24d7872"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update indentation column counter for <a class="el" href="classreflex_1_1_matcher.html#a5e56f9e50a7ce738ca4dbc8e65d424fe" title="Returns true if looking at indent. ">indent()</a> and <a class="el" href="classreflex_1_1_matcher.html#ae1fd3a8df2633a3f234be52022ca3406" title="Returns true if looking at dedent. ">dedent()</a>.  <a href="#a6d1e7b1dd59a0bc7e775d755b24d7872">More...</a><br /></td></tr>
<tr class="separator:a6d1e7b1dd59a0bc7e775d755b24d7872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e56f9e50a7ce738ca4dbc8e65d424fe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a5e56f9e50a7ce738ca4dbc8e65d424fe">indent</a> (size_t &amp;col)</td></tr>
<tr class="memdesc:a5e56f9e50a7ce738ca4dbc8e65d424fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if looking at indent.  <a href="#a5e56f9e50a7ce738ca4dbc8e65d424fe">More...</a><br /></td></tr>
<tr class="separator:a5e56f9e50a7ce738ca4dbc8e65d424fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1fd3a8df2633a3f234be52022ca3406"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#ae1fd3a8df2633a3f234be52022ca3406">dedent</a> (size_t &amp;col)</td></tr>
<tr class="memdesc:ae1fd3a8df2633a3f234be52022ca3406"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if looking at dedent.  <a href="#ae1fd3a8df2633a3f234be52022ca3406">More...</a><br /></td></tr>
<tr class="separator:ae1fd3a8df2633a3f234be52022ca3406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classreflex_1_1_pattern_matcher"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classreflex_1_1_pattern_matcher')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classreflex_1_1_pattern_matcher.html">reflex::PatternMatcher&lt; reflex::Pattern &gt;</a></td></tr>
<tr class="memitem:ada3af04ec62220060aa9f3090817b1c1 inherit pro_methods_classreflex_1_1_pattern_matcher"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_pattern_matcher.html#ada3af04ec62220060aa9f3090817b1c1">PatternMatcher</a> (const <a class="el" href="classreflex_1_1_pattern_matcher.html#a56c667f62f9d60ccfe3caf16bbc2a9fc">Pattern</a> *pat=NULL, const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;inp=<a class="el" href="classreflex_1_1_input.html">Input</a>(), const char *opt=NULL)</td></tr>
<tr class="memdesc:ada3af04ec62220060aa9f3090817b1c1 inherit pro_methods_classreflex_1_1_pattern_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a base abstract matcher from a pointer to a persistent pattern object (that is shared with this class) and an input character sequence.  <a href="#ada3af04ec62220060aa9f3090817b1c1">More...</a><br /></td></tr>
<tr class="separator:ada3af04ec62220060aa9f3090817b1c1 inherit pro_methods_classreflex_1_1_pattern_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da7f8ac8df06fa9eb326ebb4fc23299 inherit pro_methods_classreflex_1_1_pattern_matcher"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_pattern_matcher.html#a4da7f8ac8df06fa9eb326ebb4fc23299">PatternMatcher</a> (const <a class="el" href="classreflex_1_1_pattern_matcher.html#a56c667f62f9d60ccfe3caf16bbc2a9fc">Pattern</a> &amp;pat, const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;inp=<a class="el" href="classreflex_1_1_input.html">Input</a>(), const char *opt=NULL)</td></tr>
<tr class="separator:a4da7f8ac8df06fa9eb326ebb4fc23299 inherit pro_methods_classreflex_1_1_pattern_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a791971fa1b986ab4390cd2edef82047e inherit pro_methods_classreflex_1_1_pattern_matcher"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_pattern_matcher.html#a791971fa1b986ab4390cd2edef82047e">PatternMatcher</a> (const char *pat, const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;inp=<a class="el" href="classreflex_1_1_input.html">Input</a>(), const char *opt=NULL)</td></tr>
<tr class="memdesc:a791971fa1b986ab4390cd2edef82047e inherit pro_methods_classreflex_1_1_pattern_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a base abstract matcher from a regex pattern string and an input character sequence.  <a href="#a791971fa1b986ab4390cd2edef82047e">More...</a><br /></td></tr>
<tr class="separator:a791971fa1b986ab4390cd2edef82047e inherit pro_methods_classreflex_1_1_pattern_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58acc53b107c109a65e12dcd153782d1 inherit pro_methods_classreflex_1_1_pattern_matcher"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_pattern_matcher.html#a58acc53b107c109a65e12dcd153782d1">PatternMatcher</a> (const std::string &amp;pat, const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;inp=<a class="el" href="classreflex_1_1_input.html">Input</a>(), const char *opt=NULL)</td></tr>
<tr class="memdesc:a58acc53b107c109a65e12dcd153782d1 inherit pro_methods_classreflex_1_1_pattern_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a base abstract matcher from a regex pattern string and an input character sequence.  <a href="#a58acc53b107c109a65e12dcd153782d1">More...</a><br /></td></tr>
<tr class="separator:a58acc53b107c109a65e12dcd153782d1 inherit pro_methods_classreflex_1_1_pattern_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classreflex_1_1_abstract_matcher"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classreflex_1_1_abstract_matcher')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classreflex_1_1_abstract_matcher.html">reflex::AbstractMatcher</a></td></tr>
<tr class="memitem:ae819087683f79701d88152383c386ff4 inherit pro_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#ae819087683f79701d88152383c386ff4">AbstractMatcher</a> (const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;inp, const char *opt)</td></tr>
<tr class="memdesc:ae819087683f79701d88152383c386ff4 inherit pro_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a base abstract matcher.  <a href="#ae819087683f79701d88152383c386ff4">More...</a><br /></td></tr>
<tr class="separator:ae819087683f79701d88152383c386ff4 inherit pro_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4359a6cc60d672cb6818551a104c82d3 inherit pro_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a4359a6cc60d672cb6818551a104c82d3">AbstractMatcher</a> (const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;inp, const <a class="el" href="structreflex_1_1_abstract_matcher_1_1_option.html">Option</a> &amp;opt)</td></tr>
<tr class="memdesc:a4359a6cc60d672cb6818551a104c82d3 inherit pro_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a base abstract matcher.  <a href="#a4359a6cc60d672cb6818551a104c82d3">More...</a><br /></td></tr>
<tr class="separator:a4359a6cc60d672cb6818551a104c82d3 inherit pro_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1238e8acf76ec0c7eef558cc12a811b9 inherit pro_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a1238e8acf76ec0c7eef558cc12a811b9">init</a> (const char *opt=NULL)</td></tr>
<tr class="memdesc:a1238e8acf76ec0c7eef558cc12a811b9 inherit pro_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the base abstract matcher at construction.  <a href="#a1238e8acf76ec0c7eef558cc12a811b9">More...</a><br /></td></tr>
<tr class="separator:a1238e8acf76ec0c7eef558cc12a811b9 inherit pro_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92391ce2c5eab5a6dbce067a8326702e inherit pro_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a92391ce2c5eab5a6dbce067a8326702e">get</a> (char *s, size_t n)</td></tr>
<tr class="memdesc:a92391ce2c5eab5a6dbce067a8326702e inherit pro_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns more input (method can be overriden as by reflex::FlexLexer::get to invoke <a class="el" href="classreflex_1_1_flex_lexer.html#a2b2600310dd893711df5b357b4c79d9e" title="Invoked by FlexLexer::Matcher to read input character sequence. ">reflex::FlexLexer::LexerInput</a>).  <a href="#a92391ce2c5eab5a6dbce067a8326702e">More...</a><br /></td></tr>
<tr class="separator:a92391ce2c5eab5a6dbce067a8326702e inherit pro_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a046e0696b048d229ea2d77f5010c41e1 inherit pro_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a046e0696b048d229ea2d77f5010c41e1">wrap</a> ()</td></tr>
<tr class="memdesc:a046e0696b048d229ea2d77f5010c41e1 inherit pro_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if wrapping of input after EOF is supported.  <a href="#a046e0696b048d229ea2d77f5010c41e1">More...</a><br /></td></tr>
<tr class="separator:a046e0696b048d229ea2d77f5010c41e1 inherit pro_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a450e338dc97b63c595ae3b583ccc9037 inherit pro_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a450e338dc97b63c595ae3b583ccc9037">grow</a> (size_t need=<a class="el" href="structreflex_1_1_abstract_matcher_1_1_const.html#a6f7de58d1118b6f74f117a6b259359be">Const::BLOCK</a>)</td></tr>
<tr class="memdesc:a450e338dc97b63c595ae3b583ccc9037 inherit pro_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift or expand the internal buffer when it is too small to accommodate more input, where the buffer size is doubled when needed.  <a href="#a450e338dc97b63c595ae3b583ccc9037">More...</a><br /></td></tr>
<tr class="separator:a450e338dc97b63c595ae3b583ccc9037 inherit pro_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33cea639acc9ea8ff0afba554432ba64 inherit pro_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a33cea639acc9ea8ff0afba554432ba64">get</a> ()</td></tr>
<tr class="memdesc:a33cea639acc9ea8ff0afba554432ba64 inherit pro_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next character from the buffered input character sequence.  <a href="#a33cea639acc9ea8ff0afba554432ba64">More...</a><br /></td></tr>
<tr class="separator:a33cea639acc9ea8ff0afba554432ba64 inherit pro_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb8a8eff9fc980c7028c9399a1310849 inherit pro_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#acb8a8eff9fc980c7028c9399a1310849">peek</a> ()</td></tr>
<tr class="memdesc:acb8a8eff9fc980c7028c9399a1310849 inherit pro_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peek at the next character in the buffered input without consuming it.  <a href="#acb8a8eff9fc980c7028c9399a1310849">More...</a><br /></td></tr>
<tr class="separator:acb8a8eff9fc980c7028c9399a1310849 inherit pro_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8d28fc8c5326d5f05f84aaa588d564 inherit pro_methods_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a5f8d28fc8c5326d5f05f84aaa588d564">set_current</a> (size_t loc)</td></tr>
<tr class="memdesc:a5f8d28fc8c5326d5f05f84aaa588d564 inherit pro_methods_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current position to advance to the next match.  <a href="#a5f8d28fc8c5326d5f05f84aaa588d564">More...</a><br /></td></tr>
<tr class="separator:a5f8d28fc8c5326d5f05f84aaa588d564 inherit pro_methods_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a3b760391b7b16eed637ada38430d97e1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a3b760391b7b16eed637ada38430d97e1">ded_</a></td></tr>
<tr class="memdesc:a3b760391b7b16eed637ada38430d97e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">dedent count  <a href="#a3b760391b7b16eed637ada38430d97e1">More...</a><br /></td></tr>
<tr class="separator:a3b760391b7b16eed637ada38430d97e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a414c28bfea74537044bee654cb413820"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_matcher.html#a9748ab7e9dc48d3893968f432a3f7cfa">Stops</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a414c28bfea74537044bee654cb413820">tab_</a></td></tr>
<tr class="memdesc:a414c28bfea74537044bee654cb413820"><td class="mdescLeft">&#160;</td><td class="mdescRight">tab stops set by detecting indent margins  <a href="#a414c28bfea74537044bee654cb413820">More...</a><br /></td></tr>
<tr class="separator:a414c28bfea74537044bee654cb413820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31187ae9febac87f463145c18d248476"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a31187ae9febac87f463145c18d248476">lap_</a></td></tr>
<tr class="memdesc:a31187ae9febac87f463145c18d248476"><td class="mdescLeft">&#160;</td><td class="mdescRight">lookahead position in input that heads a lookahead match (indexed by lookahead number)  <a href="#a31187ae9febac87f463145c18d248476">More...</a><br /></td></tr>
<tr class="separator:a31187ae9febac87f463145c18d248476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfeefc270fb9f89da7122f1cea86872c"><td class="memItemLeft" align="right" valign="top">std::stack&lt; <a class="el" href="classreflex_1_1_matcher.html#a9748ab7e9dc48d3893968f432a3f7cfa">Stops</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#adfeefc270fb9f89da7122f1cea86872c">stk_</a></td></tr>
<tr class="memdesc:adfeefc270fb9f89da7122f1cea86872c"><td class="mdescLeft">&#160;</td><td class="mdescRight">stack to push/pop stops  <a href="#adfeefc270fb9f89da7122f1cea86872c">More...</a><br /></td></tr>
<tr class="separator:adfeefc270fb9f89da7122f1cea86872c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619a527eb79b444fba089a33fb1fdd33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html">FSM</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_matcher.html#a619a527eb79b444fba089a33fb1fdd33">fsm_</a></td></tr>
<tr class="memdesc:a619a527eb79b444fba089a33fb1fdd33"><td class="mdescLeft">&#160;</td><td class="mdescRight">local state for <a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code  <a href="#a619a527eb79b444fba089a33fb1fdd33">More...</a><br /></td></tr>
<tr class="separator:a619a527eb79b444fba089a33fb1fdd33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classreflex_1_1_pattern_matcher"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classreflex_1_1_pattern_matcher')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classreflex_1_1_pattern_matcher.html">reflex::PatternMatcher&lt; reflex::Pattern &gt;</a></td></tr>
<tr class="memitem:a609bef4919413b1448f4db3d4a1d0fd4 inherit pro_attribs_classreflex_1_1_pattern_matcher"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_pattern_matcher.html#a609bef4919413b1448f4db3d4a1d0fd4">own_</a></td></tr>
<tr class="memdesc:a609bef4919413b1448f4db3d4a1d0fd4 inherit pro_attribs_classreflex_1_1_pattern_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if PatternMatcher::pat_ was internally allocated  <a href="#a609bef4919413b1448f4db3d4a1d0fd4">More...</a><br /></td></tr>
<tr class="separator:a609bef4919413b1448f4db3d4a1d0fd4 inherit pro_attribs_classreflex_1_1_pattern_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dced0fc17ca335ce91a77ac1698e620 inherit pro_attribs_classreflex_1_1_pattern_matcher"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classreflex_1_1_pattern_matcher.html#a56c667f62f9d60ccfe3caf16bbc2a9fc">Pattern</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_pattern_matcher.html#a2dced0fc17ca335ce91a77ac1698e620">pat_</a></td></tr>
<tr class="memdesc:a2dced0fc17ca335ce91a77ac1698e620 inherit pro_attribs_classreflex_1_1_pattern_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">points to the pattern object used by the matcher  <a href="#a2dced0fc17ca335ce91a77ac1698e620">More...</a><br /></td></tr>
<tr class="separator:a2dced0fc17ca335ce91a77ac1698e620 inherit pro_attribs_classreflex_1_1_pattern_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classreflex_1_1_abstract_matcher"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classreflex_1_1_abstract_matcher')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classreflex_1_1_abstract_matcher.html">reflex::AbstractMatcher</a></td></tr>
<tr class="memitem:a7d944c389bc36abb15ba6c9f0601ab1b inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structreflex_1_1_abstract_matcher_1_1_option.html">Option</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a7d944c389bc36abb15ba6c9f0601ab1b">opt_</a></td></tr>
<tr class="memdesc:a7d944c389bc36abb15ba6c9f0601ab1b inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">options for matcher engines  <a href="#a7d944c389bc36abb15ba6c9f0601ab1b">More...</a><br /></td></tr>
<tr class="separator:a7d944c389bc36abb15ba6c9f0601ab1b inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a522144cc1e11d86a7a44f3f41acc4ba9 inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a522144cc1e11d86a7a44f3f41acc4ba9">buf_</a></td></tr>
<tr class="memdesc:a522144cc1e11d86a7a44f3f41acc4ba9 inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">input character sequence buffer  <a href="#a522144cc1e11d86a7a44f3f41acc4ba9">More...</a><br /></td></tr>
<tr class="separator:a522144cc1e11d86a7a44f3f41acc4ba9 inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f6c1781c265bafe81b8b147a3d20a04 inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a8f6c1781c265bafe81b8b147a3d20a04">txt_</a></td></tr>
<tr class="memdesc:a8f6c1781c265bafe81b8b147a3d20a04 inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">points to the matched text in buffer <a class="el" href="classreflex_1_1_abstract_matcher.html#a522144cc1e11d86a7a44f3f41acc4ba9" title="input character sequence buffer ">AbstractMatcher::buf_</a>  <a href="#a8f6c1781c265bafe81b8b147a3d20a04">More...</a><br /></td></tr>
<tr class="separator:a8f6c1781c265bafe81b8b147a3d20a04 inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63c1bbabe9a7e0dd1a8b43b9bce58dfc inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a63c1bbabe9a7e0dd1a8b43b9bce58dfc">len_</a></td></tr>
<tr class="memdesc:a63c1bbabe9a7e0dd1a8b43b9bce58dfc inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">size of the matched text  <a href="#a63c1bbabe9a7e0dd1a8b43b9bce58dfc">More...</a><br /></td></tr>
<tr class="separator:a63c1bbabe9a7e0dd1a8b43b9bce58dfc inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc1bd57b738b0eb3320a1861312d78e inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a7dc1bd57b738b0eb3320a1861312d78e">cap_</a></td></tr>
<tr class="memdesc:a7dc1bd57b738b0eb3320a1861312d78e inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">nonzero capture index of an accepted match or zero  <a href="#a7dc1bd57b738b0eb3320a1861312d78e">More...</a><br /></td></tr>
<tr class="separator:a7dc1bd57b738b0eb3320a1861312d78e inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d1bb45408688e9fe41050363a2240c inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a19d1bb45408688e9fe41050363a2240c">cur_</a></td></tr>
<tr class="memdesc:a19d1bb45408688e9fe41050363a2240c inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">next position in <a class="el" href="classreflex_1_1_abstract_matcher.html#a522144cc1e11d86a7a44f3f41acc4ba9" title="input character sequence buffer ">AbstractMatcher::buf_</a> to assign to <a class="el" href="classreflex_1_1_abstract_matcher.html#a8f6c1781c265bafe81b8b147a3d20a04" title="points to the matched text in buffer AbstractMatcher::buf_ ">AbstractMatcher::txt_</a>  <a href="#a19d1bb45408688e9fe41050363a2240c">More...</a><br /></td></tr>
<tr class="separator:a19d1bb45408688e9fe41050363a2240c inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028118ceb0a16e9ee12cfb74d7141689 inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a028118ceb0a16e9ee12cfb74d7141689">pos_</a></td></tr>
<tr class="memdesc:a028118ceb0a16e9ee12cfb74d7141689 inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">position in <a class="el" href="classreflex_1_1_abstract_matcher.html#a522144cc1e11d86a7a44f3f41acc4ba9" title="input character sequence buffer ">AbstractMatcher::buf_</a> after <a class="el" href="classreflex_1_1_abstract_matcher.html#a8f6c1781c265bafe81b8b147a3d20a04" title="points to the matched text in buffer AbstractMatcher::buf_ ">AbstractMatcher::txt_</a>  <a href="#a028118ceb0a16e9ee12cfb74d7141689">More...</a><br /></td></tr>
<tr class="separator:a028118ceb0a16e9ee12cfb74d7141689 inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5567cb2217e7d76122b4a7332cf12215 inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a5567cb2217e7d76122b4a7332cf12215">end_</a></td></tr>
<tr class="memdesc:a5567cb2217e7d76122b4a7332cf12215 inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">ending position of the input buffered in <a class="el" href="classreflex_1_1_abstract_matcher.html#a522144cc1e11d86a7a44f3f41acc4ba9" title="input character sequence buffer ">AbstractMatcher::buf_</a>  <a href="#a5567cb2217e7d76122b4a7332cf12215">More...</a><br /></td></tr>
<tr class="separator:a5567cb2217e7d76122b4a7332cf12215 inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c3372a98e775f5dd2d816d4f8dacf78 inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a8c3372a98e775f5dd2d816d4f8dacf78">max_</a></td></tr>
<tr class="memdesc:a8c3372a98e775f5dd2d816d4f8dacf78 inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">total buffer size and max position + 1 to fill  <a href="#a8c3372a98e775f5dd2d816d4f8dacf78">More...</a><br /></td></tr>
<tr class="separator:a8c3372a98e775f5dd2d816d4f8dacf78 inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0eb104096b1e02b78420bb02c89896c inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#ab0eb104096b1e02b78420bb02c89896c">ind_</a></td></tr>
<tr class="memdesc:ab0eb104096b1e02b78420bb02c89896c inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">current indent position  <a href="#ab0eb104096b1e02b78420bb02c89896c">More...</a><br /></td></tr>
<tr class="separator:ab0eb104096b1e02b78420bb02c89896c inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e77a5e960482ff2ee1bb89e3c06c5eb inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a6e77a5e960482ff2ee1bb89e3c06c5eb">blk_</a></td></tr>
<tr class="memdesc:a6e77a5e960482ff2ee1bb89e3c06c5eb inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">block size for block-based input reading, as set by <a class="el" href="classreflex_1_1_abstract_matcher.html#a0fb96965d228951194f0a2b9ee574dcf" title="Set buffer block size for reading: use 1 for interactive input, 0 (or omit argument) to buffer all in...">AbstractMatcher::buffer</a>  <a href="#a6e77a5e960482ff2ee1bb89e3c06c5eb">More...</a><br /></td></tr>
<tr class="separator:a6e77a5e960482ff2ee1bb89e3c06c5eb inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15e3fb0e851b132fd1e902de9ab56dba inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a15e3fb0e851b132fd1e902de9ab56dba">got_</a></td></tr>
<tr class="memdesc:a15e3fb0e851b132fd1e902de9ab56dba inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">last unsigned character we looked at (to determine anchors and boundaries)  <a href="#a15e3fb0e851b132fd1e902de9ab56dba">More...</a><br /></td></tr>
<tr class="separator:a15e3fb0e851b132fd1e902de9ab56dba inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae712053969ae8fadeee28c1e08421cf5 inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#ae712053969ae8fadeee28c1e08421cf5">chr_</a></td></tr>
<tr class="memdesc:ae712053969ae8fadeee28c1e08421cf5 inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">the character located at <a class="el" href="classreflex_1_1_abstract_matcher.html#a522144cc1e11d86a7a44f3f41acc4ba9" title="input character sequence buffer ">AbstractMatcher::buf_</a>[<a class="el" href="classreflex_1_1_abstract_matcher.html#a028118ceb0a16e9ee12cfb74d7141689" title="position in AbstractMatcher::buf_ after AbstractMatcher::txt_ ">AbstractMatcher::pos_</a>]  <a href="#ae712053969ae8fadeee28c1e08421cf5">More...</a><br /></td></tr>
<tr class="separator:ae712053969ae8fadeee28c1e08421cf5 inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad237874fc8405e2f701765de41d6cd37 inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#ad237874fc8405e2f701765de41d6cd37">lno_</a></td></tr>
<tr class="memdesc:ad237874fc8405e2f701765de41d6cd37 inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">line number count (prior to this buffered input)  <a href="#ad237874fc8405e2f701765de41d6cd37">More...</a><br /></td></tr>
<tr class="separator:ad237874fc8405e2f701765de41d6cd37 inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d20b0cfaa79571f201b52289c3fe2c inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a92d20b0cfaa79571f201b52289c3fe2c">cno_</a></td></tr>
<tr class="memdesc:a92d20b0cfaa79571f201b52289c3fe2c inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">column number count (prior to this buffered input)  <a href="#a92d20b0cfaa79571f201b52289c3fe2c">More...</a><br /></td></tr>
<tr class="separator:a92d20b0cfaa79571f201b52289c3fe2c inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf059b818f76cda98cfd8ef059d8586e inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#acf059b818f76cda98cfd8ef059d8586e">num_</a></td></tr>
<tr class="memdesc:acf059b818f76cda98cfd8ef059d8586e inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">character count (number of characters flushed prior to this buffered input)  <a href="#acf059b818f76cda98cfd8ef059d8586e">More...</a><br /></td></tr>
<tr class="separator:acf059b818f76cda98cfd8ef059d8586e inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bbc10723ccc884bb90ed85a0dbdaabd inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a2bbc10723ccc884bb90ed85a0dbdaabd">eof_</a></td></tr>
<tr class="memdesc:a2bbc10723ccc884bb90ed85a0dbdaabd inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">input has reached EOF  <a href="#a2bbc10723ccc884bb90ed85a0dbdaabd">More...</a><br /></td></tr>
<tr class="separator:a2bbc10723ccc884bb90ed85a0dbdaabd inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fdfd4999a13a782643d33da7bd2b5cf inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a4fdfd4999a13a782643d33da7bd2b5cf">mat_</a></td></tr>
<tr class="memdesc:a4fdfd4999a13a782643d33da7bd2b5cf inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if <a class="el" href="classreflex_1_1_abstract_matcher.html#ab880e6c8fe0df7c4ee7bb629aab41d0f" title="Returns nonzero capture index (i.e. true) if the entire input matches this matcher&#39;s pattern (and int...">AbstractMatcher::matches()</a> was successful  <a href="#a4fdfd4999a13a782643d33da7bd2b5cf">More...</a><br /></td></tr>
<tr class="separator:a4fdfd4999a13a782643d33da7bd2b5cf inherit pro_attribs_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classreflex_1_1_pattern_matcher"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classreflex_1_1_pattern_matcher')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classreflex_1_1_pattern_matcher.html">reflex::PatternMatcher&lt; reflex::Pattern &gt;</a></td></tr>
<tr class="memitem:a56c667f62f9d60ccfe3caf16bbc2a9fc inherit pub_types_classreflex_1_1_pattern_matcher"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classreflex_1_1_pattern.html">reflex::Pattern</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_pattern_matcher.html#a56c667f62f9d60ccfe3caf16bbc2a9fc">Pattern</a></td></tr>
<tr class="separator:a56c667f62f9d60ccfe3caf16bbc2a9fc inherit pub_types_classreflex_1_1_pattern_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classreflex_1_1_abstract_matcher"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classreflex_1_1_abstract_matcher')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classreflex_1_1_abstract_matcher.html">reflex::AbstractMatcher</a></td></tr>
<tr class="memitem:a7237c1fb8ab2a2283117739e6516c31f inherit pub_types_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classreflex_1_1_abstract_matcher_1_1_iterator.html">AbstractMatcher::Iterator</a>&lt; <a class="el" href="classreflex_1_1_abstract_matcher.html">AbstractMatcher</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a7237c1fb8ab2a2283117739e6516c31f">iterator</a></td></tr>
<tr class="memdesc:a7237c1fb8ab2a2283117739e6516c31f inherit pub_types_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::input_iterator for scanning, searching, and splitting input character sequences  <a href="#a7237c1fb8ab2a2283117739e6516c31f">More...</a><br /></td></tr>
<tr class="separator:a7237c1fb8ab2a2283117739e6516c31f inherit pub_types_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24336f3d3f122aa0e904fc18954943f8 inherit pub_types_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classreflex_1_1_abstract_matcher_1_1_iterator.html">AbstractMatcher::Iterator</a>&lt; const <a class="el" href="classreflex_1_1_abstract_matcher.html">AbstractMatcher</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a24336f3d3f122aa0e904fc18954943f8">const_iterator</a></td></tr>
<tr class="separator:a24336f3d3f122aa0e904fc18954943f8 inherit pub_types_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classreflex_1_1_abstract_matcher"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classreflex_1_1_abstract_matcher')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classreflex_1_1_abstract_matcher.html">reflex::AbstractMatcher</a></td></tr>
<tr class="memitem:a489c6327fb6521cc722852ada690f5ca inherit pub_attribs_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_abstract_matcher_1_1_operation.html">Operation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a489c6327fb6521cc722852ada690f5ca">scan</a></td></tr>
<tr class="memdesc:a489c6327fb6521cc722852ada690f5ca inherit pub_attribs_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">functor to scan input (to tokenize input)  <a href="#a489c6327fb6521cc722852ada690f5ca">More...</a><br /></td></tr>
<tr class="separator:a489c6327fb6521cc722852ada690f5ca inherit pub_attribs_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ec40e4c9070975bcafa94af5db0e514 inherit pub_attribs_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_abstract_matcher_1_1_operation.html">Operation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a3ec40e4c9070975bcafa94af5db0e514">find</a></td></tr>
<tr class="memdesc:a3ec40e4c9070975bcafa94af5db0e514 inherit pub_attribs_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">functor to search input  <a href="#a3ec40e4c9070975bcafa94af5db0e514">More...</a><br /></td></tr>
<tr class="separator:a3ec40e4c9070975bcafa94af5db0e514 inherit pub_attribs_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d0cb13c2dca93cc556c06c24633b8d inherit pub_attribs_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_abstract_matcher_1_1_operation.html">Operation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#a16d0cb13c2dca93cc556c06c24633b8d">split</a></td></tr>
<tr class="memdesc:a16d0cb13c2dca93cc556c06c24633b8d inherit pub_attribs_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">functor to split input  <a href="#a16d0cb13c2dca93cc556c06c24633b8d">More...</a><br /></td></tr>
<tr class="separator:a16d0cb13c2dca93cc556c06c24633b8d inherit pub_attribs_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e1dd16b4c2deca18d9093fc727ee3b inherit pub_attribs_classreflex_1_1_abstract_matcher"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_input.html">Input</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_matcher.html#ae4e1dd16b4c2deca18d9093fc727ee3b">in</a></td></tr>
<tr class="memdesc:ae4e1dd16b4c2deca18d9093fc727ee3b inherit pub_attribs_classreflex_1_1_abstract_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">input character sequence being matched by this matcher  <a href="#ae4e1dd16b4c2deca18d9093fc727ee3b">More...</a><br /></td></tr>
<tr class="separator:ae4e1dd16b4c2deca18d9093fc727ee3b inherit pub_attribs_classreflex_1_1_abstract_matcher"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>RE/flex matcher engine class, implements <a class="el" href="classreflex_1_1_pattern_matcher.html" title="The pattern matcher class template extends abstract matcher base class. ">reflex::PatternMatcher</a> pattern matching interface with scan, find, split functors and iterators. </p>
<p>More info TODO </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a9748ab7e9dc48d3893968f432a3f7cfa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;size_t&gt; <a class="el" href="classreflex_1_1_matcher.html#a9748ab7e9dc48d3893968f432a3f7cfa">reflex::Matcher::Stops</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>indent margin/tab stops </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="acad91a095aa3a8e77da5d770a3c9561a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::Matcher::Matcher </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>

</div>
</div>
<a class="anchor" id="a4552352f73af8554a9c21e810f22c40c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::Matcher::Matcher </td>
          <td>(</td>
          <td class="paramtype">const P *&#160;</td>
          <td class="paramname"><em>pat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;&#160;</td>
          <td class="paramname"><em>inp</em> = <code><a class="el" href="classreflex_1_1_input.html">Input</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>opt</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct matcher engine from a pattern or a string regex, and an input character sequence. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">&lt;P&gt;</td><td>a <a class="el" href="classreflex_1_1_pattern.html" title="Pattern class holds a regex pattern and its compiled FSM opcode table or code for the reflex::Matcher...">reflex::Pattern</a> or a string regex </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pat</td><td>points to a <a class="el" href="classreflex_1_1_pattern.html" title="Pattern class holds a regex pattern and its compiled FSM opcode table or code for the reflex::Matcher...">reflex::Pattern</a> or a string regex for this matcher </td></tr>
    <tr><td class="paramname">inp</td><td>input character sequence for this matcher </td></tr>
    <tr><td class="paramname">opt</td><td>option string of the form <code>(A|N|T(=[[:digit:]])?|;)*</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abfaffe8a58a6fd0752966645361be090"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::Matcher::Matcher </td>
          <td>(</td>
          <td class="paramtype">const P &amp;&#160;</td>
          <td class="paramname"><em>pat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;&#160;</td>
          <td class="paramname"><em>inp</em> = <code><a class="el" href="classreflex_1_1_input.html">Input</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>opt</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct matcher engine from a pattern or a string regex, and an input character sequence. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">&lt;P&gt;</td><td>a <a class="el" href="classreflex_1_1_pattern.html" title="Pattern class holds a regex pattern and its compiled FSM opcode table or code for the reflex::Matcher...">reflex::Pattern</a> or a string regex </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pat</td><td>a <a class="el" href="classreflex_1_1_pattern.html" title="Pattern class holds a regex pattern and its compiled FSM opcode table or code for the reflex::Matcher...">reflex::Pattern</a> or a string regex for this matcher </td></tr>
    <tr><td class="paramname">inp</td><td>input character sequence for this matcher </td></tr>
    <tr><td class="paramname">opt</td><td>option string of the form <code>(A|N|T(=[[:digit:]])?|;)*</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a980c06e7c868419074d7815de154ab3d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::Matcher::clear_stops </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear tab stops. </p>

</div>
</div>
<a class="anchor" id="a8862686f6d5680d4d0e5af146c4aed69"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string reflex::Matcher::convert </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>regex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacereflex.html#ab659f1b759d66631c2e2e32771af1200">convert_flag_type</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespacereflex_1_1convert__flag.html#af5c6fe22fc79bb893e135d583d525930">convert_flag::none</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a regex to an acceptable form, given the specified regex library signature <code>"[decls:]escapes[?+]"</code>, see <a class="el" href="namespacereflex.html#a4f388dfde137fe178705346b44c56223" title="Returns the converted regex string given a regex library signature and conversion flags...">reflex::convert</a>. </p>

</div>
</div>
<a class="anchor" id="ae1fd3a8df2633a3f234be52022ca3406"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::Matcher::dedent </td>
          <td>(</td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>col</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if looking at dedent. </p>
<dl class="section return"><dt>Returns</dt><dd>true if dedent. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">col</td><td>indent column counter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1c852851aeae6ed96e7adb0f6afe7932"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int reflex::Matcher::FSM_CHAR </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code CHAR. </p>

</div>
</div>
<a class="anchor" id="a5fb6dab47fc270e53d4b8af86aaf744f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::Matcher::FSM_DENT </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code DENT. </p>

</div>
</div>
<a class="anchor" id="a16876012f70f8957f689b9bda076a730"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::Matcher::FSM_HALT </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code HALT. </p>

</div>
</div>
<a class="anchor" id="abaf6459dd5e3c961efae5285ae1e3ad4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::Matcher::FSM_HEAD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classreflex_1_1_pattern.html#a38d69acf1e472d48225a3ba50b138e02">Pattern::Index</a>&#160;</td>
          <td class="paramname"><em>la</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code HEAD. </p>

</div>
</div>
<a class="anchor" id="a81899695d5bb82e06e49608ed9ebd629"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::Matcher::FSM_INIT </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>c1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code INIT,. </p>

</div>
</div>
<a class="anchor" id="a3714503b8e60531d572db6838b0d7d98"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::Matcher::FSM_META_BOB </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code META BOB. </p>

</div>
</div>
<a class="anchor" id="a431d6fdd08b14eea0d758aa4d577f003"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::Matcher::FSM_META_BOL </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code META BOL. </p>

</div>
</div>
<a class="anchor" id="a1290821154dd3abd8646117c18bb0d24"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::Matcher::FSM_META_BWB </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code META BWB. </p>

</div>
</div>
<a class="anchor" id="ade19817779426782ab997a7a5d8e2e3b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::Matcher::FSM_META_BWE </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code META BWE. </p>

</div>
</div>
<a class="anchor" id="a6f07084ad78c0f79ecf3e01b279f450a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::Matcher::FSM_META_DED </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code META DED. </p>

</div>
</div>
<a class="anchor" id="a7acbb9557977ccf9a85f6baedc63287f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::Matcher::FSM_META_EOB </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code META EOB. </p>

</div>
</div>
<a class="anchor" id="a0222ac0b08f7dfe4232cc1ae38ec86b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::Matcher::FSM_META_EOL </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code META EOL. </p>

</div>
</div>
<a class="anchor" id="a53183f5dab031514f52bad12fb2dbca1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::Matcher::FSM_META_EWB </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code META EWB. </p>

</div>
</div>
<a class="anchor" id="a108d0fa7893bd165a1103aca4e8708ca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::Matcher::FSM_META_EWE </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code META EWE. </p>

</div>
</div>
<a class="anchor" id="abe1192161f249844190d6f3b76349c1b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::Matcher::FSM_META_IND </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code META IND. </p>

</div>
</div>
<a class="anchor" id="a406ca28596bc6f75dcf975d3abb4c963"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::Matcher::FSM_META_NWB </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code META NWB. </p>

</div>
</div>
<a class="anchor" id="a77fbd40b1c0fc532f3ec5dda683d5d86"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::Matcher::FSM_META_NWE </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code META NWE. </p>

</div>
</div>
<a class="anchor" id="a3ba89f6e60b06a9e280ceb6159d78dd2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::Matcher::FSM_REDO </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code REDO. </p>

</div>
</div>
<a class="anchor" id="a29425e4f07a84ed574e99e034891493d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::Matcher::FSM_REDO </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code REDO. </p>

</div>
</div>
<a class="anchor" id="a05bf4f34f39a43143b0942dc053c8718"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::Matcher::FSM_TAIL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classreflex_1_1_pattern.html#a38d69acf1e472d48225a3ba50b138e02">Pattern::Index</a>&#160;</td>
          <td class="paramname"><em>la</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code TAIL. </p>

</div>
</div>
<a class="anchor" id="a6237f5989d641c75edc310beb73fd84d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::Matcher::FSM_TAKE </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classreflex_1_1_pattern.html#a38d69acf1e472d48225a3ba50b138e02">Pattern::Index</a>&#160;</td>
          <td class="paramname"><em>cap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code TAKE. </p>

</div>
</div>
<a class="anchor" id="a1a041cea3bd793a450445cc82b24fc90"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::Matcher::FSM_TAKE </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classreflex_1_1_pattern.html#a38d69acf1e472d48225a3ba50b138e02">Pattern::Index</a>&#160;</td>
          <td class="paramname"><em>cap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code TAKE. </p>

</div>
</div>
<a class="anchor" id="a5e56f9e50a7ce738ca4dbc8e65d424fe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::Matcher::indent </td>
          <td>(</td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>col</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if looking at indent. </p>
<dl class="section return"><dt>Returns</dt><dd>true if indent. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">col</td><td>indent column counter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab8a1264b3ede06dbba853b1ca0baead5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t reflex::Matcher::match </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classreflex_1_1_abstract_matcher.html#a82ed7b2c125bd897dea73443d2650ac6">Method</a>&#160;</td>
          <td class="paramname"><em>method</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if input matched the pattern using method <a class="el" href="structreflex_1_1_abstract_matcher_1_1_const.html#a57efdf6e79f50205036bc4d55e9908e7" title="AbstractMatcher::match method is to scan input (tokenizer) ">Const::SCAN</a>, <a class="el" href="structreflex_1_1_abstract_matcher_1_1_const.html#af03daba13cf299ee0e6be2e37ebe59b7" title="AbstractMatcher::match method is to find pattern in input. ">Const::FIND</a>, <a class="el" href="structreflex_1_1_abstract_matcher_1_1_const.html#a48f6d3e22c2f018fef95b2367a2a9aa4" title="AbstractMatcher::match method is to split input at pattern matches. ">Const::SPLIT</a>, or <a class="el" href="structreflex_1_1_abstract_matcher_1_1_const.html#aa1fe9eb434ef5ff539b01a601977f9ee" title="AbstractMatcher::match method is to match the entire input. ">Const::MATCH</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>nonzero if input matched the pattern. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">method</td><td><a class="el" href="structreflex_1_1_abstract_matcher_1_1_const.html#a57efdf6e79f50205036bc4d55e9908e7" title="AbstractMatcher::match method is to scan input (tokenizer) ">Const::SCAN</a>, <a class="el" href="structreflex_1_1_abstract_matcher_1_1_const.html#af03daba13cf299ee0e6be2e37ebe59b7" title="AbstractMatcher::match method is to find pattern in input. ">Const::FIND</a>, <a class="el" href="structreflex_1_1_abstract_matcher_1_1_const.html#a48f6d3e22c2f018fef95b2367a2a9aa4" title="AbstractMatcher::match method is to split input at pattern matches. ">Const::SPLIT</a>, or <a class="el" href="structreflex_1_1_abstract_matcher_1_1_const.html#aa1fe9eb434ef5ff539b01a601977f9ee" title="AbstractMatcher::match method is to match the entire input. ">Const::MATCH</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classreflex_1_1_abstract_matcher.html#aa3276cec0bb2daba22261e8aec147669">reflex::AbstractMatcher</a>.</p>

</div>
</div>
<a class="anchor" id="a6d1e7b1dd59a0bc7e775d755b24d7872"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::Matcher::newline </td>
          <td>(</td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>col</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update indentation column counter for <a class="el" href="classreflex_1_1_matcher.html#a5e56f9e50a7ce738ca4dbc8e65d424fe" title="Returns true if looking at indent. ">indent()</a> and <a class="el" href="classreflex_1_1_matcher.html#ae1fd3a8df2633a3f234be52022ca3406" title="Returns true if looking at dedent. ">dedent()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">col</td><td>indent column counter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acf0031339b3f8426b730a6860e5feba2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::pair&lt;const char*,size_t&gt; reflex::Matcher::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns captured text. </p>
<dl class="section return"><dt>Returns</dt><dd>std::pair of string pointer and its length in the captured text, where [0] returns std::pair(<a class="el" href="classreflex_1_1_abstract_matcher.html#a8b7a345add39a481e8963cb04a4347b8" title="Returns string with the text matched. ">text()</a>, <a class="el" href="classreflex_1_1_abstract_matcher.html#adb5fec59e6c6a86b8cf405c40f93d1de" title="Returns the length of the matched text in number of bytes. ">size()</a>). </dd></dl>

<p>Implements <a class="el" href="classreflex_1_1_abstract_matcher.html#a99e23c24c8e576f4f6463eda78539d05">reflex::AbstractMatcher</a>.</p>

</div>
</div>
<a class="anchor" id="ad7736ffcc340ede12da1f9bbe8854a5f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::Matcher::pop_stops </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop stops. </p>

</div>
</div>
<a class="anchor" id="a4591c398bd930fb5bb0cda5b56ef03c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::Matcher::push_stops </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push stops and clear stops. </p>

</div>
</div>
<a class="anchor" id="a641754cf7025a978c7dc672a563ac5c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void reflex::Matcher::reset </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>opt</em> = <code>NULL</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset this matcher's state to the initial state. </p>

<p>Reimplemented from <a class="el" href="classreflex_1_1_abstract_matcher.html#a66f487ab96e7cef1a66e9780dc45e315">reflex::AbstractMatcher</a>.</p>

</div>
</div>
<a class="anchor" id="a43734e349aec75a4afd05302f6c5fbb0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;size_t&gt;&amp; reflex::Matcher::stops </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns vector of tab stops. </p>
<dl class="section return"><dt>Returns</dt><dd>vector of size_t. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a3b760391b7b16eed637ada38430d97e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t reflex::Matcher::ded_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>dedent count </p>

</div>
</div>
<a class="anchor" id="a619a527eb79b444fba089a33fb1fdd33"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html">FSM</a> reflex::Matcher::fsm_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>local state for <a class="el" href="structreflex_1_1_matcher_1_1_f_s_m.html" title="FSM data for FSM code. ">FSM</a> code </p>

</div>
</div>
<a class="anchor" id="a31187ae9febac87f463145c18d248476"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; reflex::Matcher::lap_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>lookahead position in input that heads a lookahead match (indexed by lookahead number) </p>

</div>
</div>
<a class="anchor" id="adfeefc270fb9f89da7122f1cea86872c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::stack&lt;<a class="el" href="classreflex_1_1_matcher.html#a9748ab7e9dc48d3893968f432a3f7cfa">Stops</a>&gt; reflex::Matcher::stk_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>stack to push/pop stops </p>

</div>
</div>
<a class="anchor" id="a414c28bfea74537044bee654cb413820"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_matcher.html#a9748ab7e9dc48d3893968f432a3f7cfa">Stops</a> reflex::Matcher::tab_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>tab stops set by detecting indent margins </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="matcher_8h.html">matcher.h</a></li>
</ul>
</div><!-- contents -->
<hr class="footer">
<address class="footer"><small>
Converted on Sat Mar 4 2017 16:15:33 by <a target="_blank" href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.11</small></address>
<br>
<div style="height: 246px; background: #DBDBDB;">
</body>
</html>
