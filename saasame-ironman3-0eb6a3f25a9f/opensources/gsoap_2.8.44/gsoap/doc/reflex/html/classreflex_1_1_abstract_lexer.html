<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<meta http-equiv="cache-control" content="no-cache">
<title>reflex::AbstractLexer&lt; M &gt; Class Template Reference</title>
<link href="doxygen_tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="doxygen_content.css" rel="stylesheet" type="text/css">
</head>
<body>
<div id="top">
 <div id="titlearea">
  <table height="72px" width="100%" cellspacing="0" cellpadding="0">
   <tbody>
    <tr>
     <td width="10%">&nbsp;</td>
     <td><a href="https://github.com/Genivia/RE-flex"><img src="reflex-logo.png"/></a></td>
     <td>
      <div style="float: right; font-size: 18px; font-weight: bold;">reflex::AbstractLexer&lt; M &gt; Class Template Reference</div>
      <br>
      <div style="float: right; font-size: 10px;">updated Sat Mar 4 2017 by Robert van Engelen</div>
     </td>
     <td width="10%">&nbsp;</td>
    </tr>
   </tbody>
  </table>
 </div>
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacereflex.html">reflex</a></li><li class="navelem"><a class="el" href="classreflex_1_1_abstract_lexer.html">AbstractLexer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classreflex_1_1_abstract_lexer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">reflex::AbstractLexer&lt; M &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The abstract lexer class template that is the abstract root class of all reflex-generated scanners.  
 <a href="classreflex_1_1_abstract_lexer.html#details">More...</a></p>

<p><code>#include &lt;abslexer.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for reflex::AbstractLexer&lt; M &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classreflex_1_1_abstract_lexer__inherit__graph.png" border="0" usemap="#reflex_1_1_abstract_lexer_3_01_m_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="reflex_1_1_abstract_lexer_3_01_m_01_4_inherit__map" id="reflex_1_1_abstract_lexer_3_01_m_01_4_inherit__map">
<area shape="rect" id="node2" href="classreflex_1_1_flex_lexer.html" title="Flex&#45;compatible FlexLexer abstract base class template derived from reflex::AbstractMatcher for the r..." alt="" coords="17,80,172,107"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for reflex::AbstractLexer&lt; M &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classreflex_1_1_abstract_lexer__coll__graph.png" border="0" usemap="#reflex_1_1_abstract_lexer_3_01_m_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="reflex_1_1_abstract_lexer_3_01_m_01_4_coll__map" id="reflex_1_1_abstract_lexer_3_01_m_01_4_coll__map">
<area shape="rect" id="node2" href="classreflex_1_1_abstract_lexer_1_1_matcher.html" title="Extend matcher class M with a member pointing to the instantiating lexer class. " alt="" coords="14,184,158,225"/>
<area shape="rect" id="node4" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. " alt="" coords="112,5,204,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer_1_1_matcher.html">Matcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend matcher class M with a member pointing to the instantiating lexer class.  <a href="classreflex_1_1_abstract_lexer_1_1_matcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a536b9af11d41ac2441dd8739c64901ae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a536b9af11d41ac2441dd8739c64901ae">AbstractLexer</a> (const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;input, std::ostream &amp;os)</td></tr>
<tr class="memdesc:a536b9af11d41ac2441dd8739c64901ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct abstract lexer to scan an input character sequence and echo the text matches to output.  <a href="#a536b9af11d41ac2441dd8739c64901ae">More...</a><br /></td></tr>
<tr class="separator:a536b9af11d41ac2441dd8739c64901ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63559bee1fc440966ea12c9d5a14b586"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a63559bee1fc440966ea12c9d5a14b586">~AbstractLexer</a> (void)</td></tr>
<tr class="memdesc:a63559bee1fc440966ea12c9d5a14b586"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete lexer and its current matcher and input.  <a href="#a63559bee1fc440966ea12c9d5a14b586">More...</a><br /></td></tr>
<tr class="separator:a63559bee1fc440966ea12c9d5a14b586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a070058e52c93918d41b1f37901f01b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a3a070058e52c93918d41b1f37901f01b">set_debug</a> (int flag)</td></tr>
<tr class="memdesc:a3a070058e52c93918d41b1f37901f01b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set debug flag value.  <a href="#a3a070058e52c93918d41b1f37901f01b">More...</a><br /></td></tr>
<tr class="separator:a3a070058e52c93918d41b1f37901f01b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d6e805887811d8c2c061ab908eca79f"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a8d6e805887811d8c2c061ab908eca79f">debug</a> (void) const </td></tr>
<tr class="memdesc:a8d6e805887811d8c2c061ab908eca79f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get debug flag value.  <a href="#a8d6e805887811d8c2c061ab908eca79f">More...</a><br /></td></tr>
<tr class="separator:a8d6e805887811d8c2c061ab908eca79f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae77e2fac36ed991f62b1308557bfd146"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#ae77e2fac36ed991f62b1308557bfd146">wrap</a> (void)</td></tr>
<tr class="memdesc:ae77e2fac36ed991f62b1308557bfd146"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default wrap operation at EOF: do not wrap input.  <a href="#ae77e2fac36ed991f62b1308557bfd146">More...</a><br /></td></tr>
<tr class="separator:ae77e2fac36ed991f62b1308557bfd146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affea8a2b877c58c7c85f750b57f18df8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_abstract_lexer.html">AbstractLexer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#affea8a2b877c58c7c85f750b57f18df8">in</a> (const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;input)</td></tr>
<tr class="memdesc:affea8a2b877c58c7c85f750b57f18df8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start scanning from the given input character sequence.  <a href="#affea8a2b877c58c7c85f750b57f18df8">More...</a><br /></td></tr>
<tr class="separator:affea8a2b877c58c7c85f750b57f18df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66bec00e18d3e47c4ca395a54efcdc59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_input.html">Input</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a66bec00e18d3e47c4ca395a54efcdc59">in</a> (void)</td></tr>
<tr class="memdesc:a66bec00e18d3e47c4ca395a54efcdc59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current input character sequence that is being scanned.  <a href="#a66bec00e18d3e47c4ca395a54efcdc59">More...</a><br /></td></tr>
<tr class="separator:a66bec00e18d3e47c4ca395a54efcdc59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5611c94c961a216fc733244c9b688f8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_abstract_lexer.html">AbstractLexer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a5611c94c961a216fc733244c9b688f8f">out</a> (std::ostream &amp;os)</td></tr>
<tr class="memdesc:a5611c94c961a216fc733244c9b688f8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current output to the given output stream to echo text matches to.  <a href="#a5611c94c961a216fc733244c9b688f8f">More...</a><br /></td></tr>
<tr class="separator:a5611c94c961a216fc733244c9b688f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e6542bb8ef8e767f0237d1d85eb5bb6"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a3e6542bb8ef8e767f0237d1d85eb5bb6">out</a> (void) const </td></tr>
<tr class="memdesc:a3e6542bb8ef8e767f0237d1d85eb5bb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current output stream used to echo text matches to.  <a href="#a3e6542bb8ef8e767f0237d1d85eb5bb6">More...</a><br /></td></tr>
<tr class="separator:a3e6542bb8ef8e767f0237d1d85eb5bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3171a284ccd3e97985ec1d909f7eaf6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#ab3171a284ccd3e97985ec1d909f7eaf6">has_matcher</a> (void) const </td></tr>
<tr class="memdesc:ab3171a284ccd3e97985ec1d909f7eaf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if a matcher was assigned to this lexer for scanning.  <a href="#ab3171a284ccd3e97985ec1d909f7eaf6">More...</a><br /></td></tr>
<tr class="separator:ab3171a284ccd3e97985ec1d909f7eaf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70ee52cef2c37c2ca47a686eea75a5db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_abstract_lexer.html">AbstractLexer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a70ee52cef2c37c2ca47a686eea75a5db">matcher</a> (<a class="el" href="classreflex_1_1_abstract_lexer_1_1_matcher.html">Matcher</a> *matcher)</td></tr>
<tr class="memdesc:a70ee52cef2c37c2ca47a686eea75a5db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the matcher (and its current state) for scanning.  <a href="#a70ee52cef2c37c2ca47a686eea75a5db">More...</a><br /></td></tr>
<tr class="separator:a70ee52cef2c37c2ca47a686eea75a5db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e93b0111f4946f8b16690bd60bfbd37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_abstract_lexer_1_1_matcher.html">Matcher</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a0e93b0111f4946f8b16690bd60bfbd37">matcher</a> (void) const </td></tr>
<tr class="memdesc:a0e93b0111f4946f8b16690bd60bfbd37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the current matcher.  <a href="#a0e93b0111f4946f8b16690bd60bfbd37">More...</a><br /></td></tr>
<tr class="separator:a0e93b0111f4946f8b16690bd60bfbd37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a203aa970eb8f9bc13559b180118ffed9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_abstract_lexer_1_1_matcher.html">Matcher</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a203aa970eb8f9bc13559b180118ffed9">ptr_matcher</a> (void) const </td></tr>
<tr class="memdesc:a203aa970eb8f9bc13559b180118ffed9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the current matcher, NULL if none was set.  <a href="#a203aa970eb8f9bc13559b180118ffed9">More...</a><br /></td></tr>
<tr class="separator:a203aa970eb8f9bc13559b180118ffed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ab259fa3a2881fc2eb5580967f769b4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classreflex_1_1_abstract_lexer_1_1_matcher.html">Matcher</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a5ab259fa3a2881fc2eb5580967f769b4">new_matcher</a> (const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;input)</td></tr>
<tr class="memdesc:a5ab259fa3a2881fc2eb5580967f769b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new matcher for the given input.  <a href="#a5ab259fa3a2881fc2eb5580967f769b4">More...</a><br /></td></tr>
<tr class="separator:a5ab259fa3a2881fc2eb5580967f769b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45d00ce513ed727dc4fdde304fcb8d97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a45d00ce513ed727dc4fdde304fcb8d97">del_matcher</a> (<a class="el" href="classreflex_1_1_abstract_lexer_1_1_matcher.html">Matcher</a> *<a class="el" href="classreflex_1_1_abstract_lexer.html#a70ee52cef2c37c2ca47a686eea75a5db">matcher</a>)</td></tr>
<tr class="memdesc:a45d00ce513ed727dc4fdde304fcb8d97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a matcher.  <a href="#a45d00ce513ed727dc4fdde304fcb8d97">More...</a><br /></td></tr>
<tr class="separator:a45d00ce513ed727dc4fdde304fcb8d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7da8596b9eeb820214e2630a331e43d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#aa7da8596b9eeb820214e2630a331e43d">push_matcher</a> (<a class="el" href="classreflex_1_1_abstract_lexer_1_1_matcher.html">Matcher</a> *<a class="el" href="classreflex_1_1_abstract_lexer.html#a70ee52cef2c37c2ca47a686eea75a5db">matcher</a>)</td></tr>
<tr class="memdesc:aa7da8596b9eeb820214e2630a331e43d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push the current matcher on the stack and use the given matcher for scanning.  <a href="#aa7da8596b9eeb820214e2630a331e43d">More...</a><br /></td></tr>
<tr class="separator:aa7da8596b9eeb820214e2630a331e43d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d9621be1057537eb490a9ae63169af6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a1d9621be1057537eb490a9ae63169af6">pop_matcher</a> (void)</td></tr>
<tr class="memdesc:a1d9621be1057537eb490a9ae63169af6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop matcher from the stack and continue scanning where it left off, delete the current matcher.  <a href="#a1d9621be1057537eb490a9ae63169af6">More...</a><br /></td></tr>
<tr class="separator:a1d9621be1057537eb490a9ae63169af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a433d80dd674a3ac1b9929acbf9d78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a07a433d80dd674a3ac1b9929acbf9d78">echo</a> (void) const </td></tr>
<tr class="memdesc:a07a433d80dd674a3ac1b9929acbf9d78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Echo the matched text to the current output.  <a href="#a07a433d80dd674a3ac1b9929acbf9d78">More...</a><br /></td></tr>
<tr class="separator:a07a433d80dd674a3ac1b9929acbf9d78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4adc8cccffbc846e0f8408ddadfed22f"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a4adc8cccffbc846e0f8408ddadfed22f">text</a> (void) const </td></tr>
<tr class="memdesc:a4adc8cccffbc846e0f8408ddadfed22f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns string with the text matched.  <a href="#a4adc8cccffbc846e0f8408ddadfed22f">More...</a><br /></td></tr>
<tr class="separator:a4adc8cccffbc846e0f8408ddadfed22f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a981d20f5395a9d278cc7be9f8c8a50"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a8a981d20f5395a9d278cc7be9f8c8a50">size</a> (void) const </td></tr>
<tr class="memdesc:a8a981d20f5395a9d278cc7be9f8c8a50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the matched text size in number of bytes.  <a href="#a8a981d20f5395a9d278cc7be9f8c8a50">More...</a><br /></td></tr>
<tr class="separator:a8a981d20f5395a9d278cc7be9f8c8a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13cc5a6320d44382b1f1d825472749df"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a13cc5a6320d44382b1f1d825472749df">wsize</a> (void) const </td></tr>
<tr class="memdesc:a13cc5a6320d44382b1f1d825472749df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the matched text size in number of (wide) characters.  <a href="#a13cc5a6320d44382b1f1d825472749df">More...</a><br /></td></tr>
<tr class="separator:a13cc5a6320d44382b1f1d825472749df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36d6d30a2f3c8add23d379a1afa54e69"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a36d6d30a2f3c8add23d379a1afa54e69">lineno</a> (void) const </td></tr>
<tr class="memdesc:a36d6d30a2f3c8add23d379a1afa54e69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the line number of matched text.  <a href="#a36d6d30a2f3c8add23d379a1afa54e69">More...</a><br /></td></tr>
<tr class="separator:a36d6d30a2f3c8add23d379a1afa54e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab802f6d0c624523a0a7f34cc4eebb139"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#ab802f6d0c624523a0a7f34cc4eebb139">columno</a> (void) const </td></tr>
<tr class="memdesc:ab802f6d0c624523a0a7f34cc4eebb139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the column number of matched text, counting wide characters.  <a href="#ab802f6d0c624523a0a7f34cc4eebb139">More...</a><br /></td></tr>
<tr class="separator:ab802f6d0c624523a0a7f34cc4eebb139"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a905c83f6978b3599c43167ae3c7f5b30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_abstract_lexer.html">AbstractLexer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a905c83f6978b3599c43167ae3c7f5b30">start</a> (int state)</td></tr>
<tr class="memdesc:a905c83f6978b3599c43167ae3c7f5b30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transition to the given start condition state.  <a href="#a905c83f6978b3599c43167ae3c7f5b30">More...</a><br /></td></tr>
<tr class="separator:a905c83f6978b3599c43167ae3c7f5b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9230120566cda8006cb8549daa53f61f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a9230120566cda8006cb8549daa53f61f">start</a> (void) const </td></tr>
<tr class="memdesc:a9230120566cda8006cb8549daa53f61f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current start condition state.  <a href="#a9230120566cda8006cb8549daa53f61f">More...</a><br /></td></tr>
<tr class="separator:a9230120566cda8006cb8549daa53f61f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a996791039f153c27947dab23db026f41"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a996791039f153c27947dab23db026f41">push_state</a> (int state)</td></tr>
<tr class="memdesc:a996791039f153c27947dab23db026f41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push the current start condition state on the stack and transition to the given start condition state.  <a href="#a996791039f153c27947dab23db026f41">More...</a><br /></td></tr>
<tr class="separator:a996791039f153c27947dab23db026f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a329ce0260ce6b49ec00472ddaa7b3783"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a329ce0260ce6b49ec00472ddaa7b3783">pop_state</a> (void)</td></tr>
<tr class="memdesc:a329ce0260ce6b49ec00472ddaa7b3783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop the stack start condition state and transition to that state.  <a href="#a329ce0260ce6b49ec00472ddaa7b3783">More...</a><br /></td></tr>
<tr class="separator:a329ce0260ce6b49ec00472ddaa7b3783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3469ff468c7a2472af990876110b227"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#ab3469ff468c7a2472af990876110b227">top_state</a> (void) const </td></tr>
<tr class="memdesc:ab3469ff468c7a2472af990876110b227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the stack top start condition state.  <a href="#ab3469ff468c7a2472af990876110b227">More...</a><br /></td></tr>
<tr class="separator:ab3469ff468c7a2472af990876110b227"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a31804738641329190e2ab79c0429d805"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_abstract_lexer_1_1_matcher.html">Matcher</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a31804738641329190e2ab79c0429d805">matcher_</a></td></tr>
<tr class="memdesc:a31804738641329190e2ab79c0429d805"><td class="mdescLeft">&#160;</td><td class="mdescRight">the matcher used for scanning  <a href="#a31804738641329190e2ab79c0429d805">More...</a><br /></td></tr>
<tr class="separator:a31804738641329190e2ab79c0429d805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5476b6d021bcbb48aa1623f3a8338b5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreflex_1_1_input.html">Input</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a5476b6d021bcbb48aa1623f3a8338b5d">in_</a></td></tr>
<tr class="memdesc:a5476b6d021bcbb48aa1623f3a8338b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">the input character sequence to scan  <a href="#a5476b6d021bcbb48aa1623f3a8338b5d">More...</a><br /></td></tr>
<tr class="separator:a5476b6d021bcbb48aa1623f3a8338b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25646f2503ea4a20f5b73bc7da28545e"><td class="memItemLeft" align="right" valign="top">std::ostream *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a25646f2503ea4a20f5b73bc7da28545e">os_</a></td></tr>
<tr class="memdesc:a25646f2503ea4a20f5b73bc7da28545e"><td class="mdescLeft">&#160;</td><td class="mdescRight">the output stream to echo text matches to  <a href="#a25646f2503ea4a20f5b73bc7da28545e">More...</a><br /></td></tr>
<tr class="separator:a25646f2503ea4a20f5b73bc7da28545e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a588470b3af8d9c64437ea48f21f9e5fd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a588470b3af8d9c64437ea48f21f9e5fd">start_</a></td></tr>
<tr class="memdesc:a588470b3af8d9c64437ea48f21f9e5fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">the current start condition state  <a href="#a588470b3af8d9c64437ea48f21f9e5fd">More...</a><br /></td></tr>
<tr class="separator:a588470b3af8d9c64437ea48f21f9e5fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a278b6ed6fdf565b2ef4592ac7372660e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a278b6ed6fdf565b2ef4592ac7372660e">debug_</a></td></tr>
<tr class="memdesc:a278b6ed6fdf565b2ef4592ac7372660e"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 if -d (&ndash;debug) 0 otherwise:  <a href="#a278b6ed6fdf565b2ef4592ac7372660e">More...</a><br /></td></tr>
<tr class="separator:a278b6ed6fdf565b2ef4592ac7372660e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0b0705752b17d78302e4dae7d2b643"><td class="memItemLeft" align="right" valign="top">std::stack&lt; <a class="el" href="classreflex_1_1_abstract_lexer_1_1_matcher.html">Matcher</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#a5c0b0705752b17d78302e4dae7d2b643">stack_</a></td></tr>
<tr class="memdesc:a5c0b0705752b17d78302e4dae7d2b643"><td class="mdescLeft">&#160;</td><td class="mdescRight">a stack of pointers to matchers  <a href="#a5c0b0705752b17d78302e4dae7d2b643">More...</a><br /></td></tr>
<tr class="separator:a5c0b0705752b17d78302e4dae7d2b643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbffb98e8f214ace1a1c5a2c2b66243a"><td class="memItemLeft" align="right" valign="top">std::stack&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_abstract_lexer.html#acbffb98e8f214ace1a1c5a2c2b66243a">state_</a></td></tr>
<tr class="memdesc:acbffb98e8f214ace1a1c5a2c2b66243a"><td class="mdescLeft">&#160;</td><td class="mdescRight">a stack of start condition states  <a href="#acbffb98e8f214ace1a1c5a2c2b66243a">More...</a><br /></td></tr>
<tr class="separator:acbffb98e8f214ace1a1c5a2c2b66243a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename M&gt;<br />
class reflex::AbstractLexer&lt; M &gt;</h3>

<p>The abstract lexer class template that is the abstract root class of all reflex-generated scanners. </p>
<p>More info TODO </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">&lt;M&gt;</td><td>matcher class derived from <a class="el" href="classreflex_1_1_abstract_matcher.html" title="The abstract matcher base class template defines an interface for all pattern matcher engines...">reflex::AbstractMatcher</a> </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a536b9af11d41ac2441dd8739c64901ae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::<a class="el" href="classreflex_1_1_abstract_lexer.html">AbstractLexer</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct abstract lexer to scan an input character sequence and echo the text matches to output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td><a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">reflex::Input</a> character sequence to read from </td></tr>
    <tr><td class="paramname">os</td><td>echo the text matches to this std::ostream or to std::cout </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a63559bee1fc440966ea12c9d5a14b586"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::~<a class="el" href="classreflex_1_1_abstract_lexer.html">AbstractLexer</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete lexer and its current matcher and input. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ab802f6d0c624523a0a7f34cc4eebb139"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::columno </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the column number of matched text, counting wide characters. </p>
<dl class="section return"><dt>Returns</dt><dd>column number. </dd></dl>

</div>
</div>
<a class="anchor" id="a8d6e805887811d8c2c061ab908eca79f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::debug </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get debug flag value. </p>
<dl class="section return"><dt>Returns</dt><dd>debug flag value. </dd></dl>

</div>
</div>
<a class="anchor" id="a45d00ce513ed727dc4fdde304fcb8d97"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::del_matcher </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classreflex_1_1_abstract_lexer_1_1_matcher.html">Matcher</a> *&#160;</td>
          <td class="paramname"><em>matcher</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete a matcher. </p>

</div>
</div>
<a class="anchor" id="a07a433d80dd674a3ac1b9929acbf9d78"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::echo </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Echo the matched text to the current output. </p>

</div>
</div>
<a class="anchor" id="ab3171a284ccd3e97985ec1d909f7eaf6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::has_matcher </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if a matcher was assigned to this lexer for scanning. </p>
<dl class="section return"><dt>Returns</dt><dd>true if a matcher was assigned. </dd></dl>

</div>
</div>
<a class="anchor" id="affea8a2b877c58c7c85f750b57f18df8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_abstract_lexer.html">AbstractLexer</a>&amp; <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::in </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start scanning from the given input character sequence. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to *this. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td><a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">reflex::Input</a> character sequence to scan </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a66bec00e18d3e47c4ca395a54efcdc59"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_input.html">Input</a>&amp; <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::in </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current input character sequence that is being scanned. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to the current <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">reflex::Input</a> object. </dd></dl>

</div>
</div>
<a class="anchor" id="a36d6d30a2f3c8add23d379a1afa54e69"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::lineno </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the line number of matched text. </p>
<dl class="section return"><dt>Returns</dt><dd>line number. </dd></dl>

</div>
</div>
<a class="anchor" id="a70ee52cef2c37c2ca47a686eea75a5db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_abstract_lexer.html">AbstractLexer</a>&amp; <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::matcher </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classreflex_1_1_abstract_lexer_1_1_matcher.html">Matcher</a> *&#160;</td>
          <td class="paramname"><em>matcher</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the matcher (and its current state) for scanning. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to *this. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matcher</td><td>points to a matcher object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0e93b0111f4946f8b16690bd60bfbd37"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_abstract_lexer_1_1_matcher.html">Matcher</a>&amp; <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::matcher </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the current matcher. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to the current matcher. </dd></dl>

</div>
</div>
<a class="anchor" id="a5ab259fa3a2881fc2eb5580967f769b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classreflex_1_1_abstract_lexer_1_1_matcher.html">Matcher</a>* <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::new_matcher </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new matcher for the given input. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to new <a class="el" href="classreflex_1_1_abstract_lexer_1_1_matcher.html" title="Extend matcher class M with a member pointing to the instantiating lexer class. ">reflex::AbstractLexer::Matcher</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td><a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">reflex::Input</a> character sequence to match </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5611c94c961a216fc733244c9b688f8f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_abstract_lexer.html">AbstractLexer</a>&amp; <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::out </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the current output to the given output stream to echo text matches to. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to *this. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>output stream to echo text matches to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3e6542bb8ef8e767f0237d1d85eb5bb6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::out </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current output stream used to echo text matches to. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to the current std::ostream object. </dd></dl>

</div>
</div>
<a class="anchor" id="a1d9621be1057537eb490a9ae63169af6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::pop_matcher </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop matcher from the stack and continue scanning where it left off, delete the current matcher. </p>

</div>
</div>
<a class="anchor" id="a329ce0260ce6b49ec00472ddaa7b3783"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::pop_state </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop the stack start condition state and transition to that state. </p>

</div>
</div>
<a class="anchor" id="a203aa970eb8f9bc13559b180118ffed9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_abstract_lexer_1_1_matcher.html">Matcher</a>* <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::ptr_matcher </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the current matcher, NULL if none was set. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to the current matcher or NULL if no matcher was set. </dd></dl>

</div>
</div>
<a class="anchor" id="aa7da8596b9eeb820214e2630a331e43d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::push_matcher </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classreflex_1_1_abstract_lexer_1_1_matcher.html">Matcher</a> *&#160;</td>
          <td class="paramname"><em>matcher</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push the current matcher on the stack and use the given matcher for scanning. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matcher</td><td>points to a matcher object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a996791039f153c27947dab23db026f41"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::push_state </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push the current start condition state on the stack and transition to the given start condition state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>start condition state to transition to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3a070058e52c93918d41b1f37901f01b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::set_debug </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set debug flag value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>0 or 1 (false or true) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8a981d20f5395a9d278cc7be9f8c8a50"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the matched text size in number of bytes. </p>
<dl class="section return"><dt>Returns</dt><dd>size of the matched text. </dd></dl>

</div>
</div>
<a class="anchor" id="a905c83f6978b3599c43167ae3c7f5b30"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_abstract_lexer.html">AbstractLexer</a>&amp; <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::start </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transition to the given start condition state. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to *this. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>start condition state to transition to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9230120566cda8006cb8549daa53f61f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::start </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current start condition state. </p>
<dl class="section return"><dt>Returns</dt><dd>start condition (integer). </dd></dl>

</div>
</div>
<a class="anchor" id="a4adc8cccffbc846e0f8408ddadfed22f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::text </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns string with the text matched. </p>
<dl class="section return"><dt>Returns</dt><dd>matched text. </dd></dl>

</div>
</div>
<a class="anchor" id="ab3469ff468c7a2472af990876110b227"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::top_state </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the stack top start condition state. </p>
<dl class="section return"><dt>Returns</dt><dd>start condition (integer). </dd></dl>

</div>
</div>
<a class="anchor" id="ae77e2fac36ed991f62b1308557bfd146"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::wrap </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The default wrap operation at EOF: do not wrap input. </p>
<dl class="section return"><dt>Returns</dt><dd>1 (override to return 0 to indicate that new input is available after this invocation so that wrap after EOF is OK). </dd></dl>

</div>
</div>
<a class="anchor" id="a13cc5a6320d44382b1f1d825472749df"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::wsize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the matched text size in number of (wide) characters. </p>
<dl class="section return"><dt>Returns</dt><dd>number of (wide) characters matched. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a278b6ed6fdf565b2ef4592ac7372660e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::debug_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>1 if -d (&ndash;debug) 0 otherwise: </p>

</div>
</div>
<a class="anchor" id="a5476b6d021bcbb48aa1623f3a8338b5d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_input.html">Input</a> <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::in_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the input character sequence to scan </p>

</div>
</div>
<a class="anchor" id="a31804738641329190e2ab79c0429d805"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreflex_1_1_abstract_lexer_1_1_matcher.html">Matcher</a>* <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::matcher_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the matcher used for scanning </p>

</div>
</div>
<a class="anchor" id="a25646f2503ea4a20f5b73bc7da28545e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream* <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::os_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the output stream to echo text matches to </p>

</div>
</div>
<a class="anchor" id="a5c0b0705752b17d78302e4dae7d2b643"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::stack&lt;<a class="el" href="classreflex_1_1_abstract_lexer_1_1_matcher.html">Matcher</a>*&gt; <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::stack_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>a stack of pointers to matchers </p>

</div>
</div>
<a class="anchor" id="a588470b3af8d9c64437ea48f21f9e5fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::start_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the current start condition state </p>

</div>
</div>
<a class="anchor" id="acbffb98e8f214ace1a1c5a2c2b66243a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::stack&lt;int&gt; <a class="el" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt; M &gt;::state_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>a stack of start condition states </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="abslexer_8h.html">abslexer.h</a></li>
</ul>
</div><!-- contents -->
<hr class="footer">
<address class="footer"><small>
Converted on Sat Mar 4 2017 16:15:33 by <a target="_blank" href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.11</small></address>
<br>
<div style="height: 246px; background: #DBDBDB;">
</body>
</html>
