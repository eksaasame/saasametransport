<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<meta http-equiv="cache-control" content="no-cache">
<title>reflex::Input Class Reference</title>
<link href="doxygen_tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="doxygen_content.css" rel="stylesheet" type="text/css">
</head>
<body>
<div id="top">
 <div id="titlearea">
  <table height="72px" width="100%" cellspacing="0" cellpadding="0">
   <tbody>
    <tr>
     <td width="10%">&nbsp;</td>
     <td><a href="https://github.com/Genivia/RE-flex"><img src="reflex-logo.png"/></a></td>
     <td>
      <div style="float: right; font-size: 18px; font-weight: bold;">reflex::Input Class Reference</div>
      <br>
      <div style="float: right; font-size: 10px;">updated Sat Mar 4 2017 by Robert van Engelen</div>
     </td>
     <td width="10%">&nbsp;</td>
    </tr>
   </tbody>
  </table>
 </div>
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacereflex.html">reflex</a></li><li class="navelem"><a class="el" href="classreflex_1_1_input.html">Input</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classreflex_1_1_input-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">reflex::Input Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> character sequence class for unified access to sources of input text.  
 <a href="classreflex_1_1_input.html#details">More...</a></p>

<p><code>#include &lt;input.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreflex_1_1_input_1_1_const.html">Const</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common constants.  <a href="structreflex_1_1_input_1_1_const.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7c6455e576c90b478789928db6066267"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a7c6455e576c90b478789928db6066267">Input</a> (const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;input)</td></tr>
<tr class="memdesc:a7c6455e576c90b478789928db6066267"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor (with intended "move semantics" as internal state is shared, should not rely on using the rhs after copying).  <a href="#a7c6455e576c90b478789928db6066267">More...</a><br /></td></tr>
<tr class="separator:a7c6455e576c90b478789928db6066267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa61821e129865a4f58086529486815d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#aaa61821e129865a4f58086529486815d">Input</a> (void)</td></tr>
<tr class="memdesc:aaa61821e129865a4f58086529486815d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct empty input character sequence.  <a href="#aaa61821e129865a4f58086529486815d">More...</a><br /></td></tr>
<tr class="separator:aaa61821e129865a4f58086529486815d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09465211ad37559885e2e85e9fc18791"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a09465211ad37559885e2e85e9fc18791">Input</a> (const char *<a class="el" href="classreflex_1_1_input.html#a35426a06bf4b8928c8ee10b30de93c8b">cstring</a>)</td></tr>
<tr class="memdesc:a09465211ad37559885e2e85e9fc18791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct input character sequence from a NUL-terminated string.  <a href="#a09465211ad37559885e2e85e9fc18791">More...</a><br /></td></tr>
<tr class="separator:a09465211ad37559885e2e85e9fc18791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4d78f4c05c7e5ffdaa723bf58ffaea"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#aec4d78f4c05c7e5ffdaa723bf58ffaea">Input</a> (const std::string &amp;string)</td></tr>
<tr class="memdesc:aec4d78f4c05c7e5ffdaa723bf58ffaea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct input character sequence from a std::string.  <a href="#aec4d78f4c05c7e5ffdaa723bf58ffaea">More...</a><br /></td></tr>
<tr class="separator:aec4d78f4c05c7e5ffdaa723bf58ffaea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa309946c0340260b7213ff803544542b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#aa309946c0340260b7213ff803544542b">Input</a> (const std::string *string)</td></tr>
<tr class="memdesc:aa309946c0340260b7213ff803544542b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct input character sequence from a pointer to a std::string.  <a href="#aa309946c0340260b7213ff803544542b">More...</a><br /></td></tr>
<tr class="separator:aa309946c0340260b7213ff803544542b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a057e2908a65efbb3ba0c445b724fe100"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a057e2908a65efbb3ba0c445b724fe100">Input</a> (const wchar_t *<a class="el" href="classreflex_1_1_input.html#a0b1890722873d83bc651590c65fa87e3">wstring</a>)</td></tr>
<tr class="memdesc:a057e2908a65efbb3ba0c445b724fe100"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct input character sequence from a NUL-terminated wide character string.  <a href="#a057e2908a65efbb3ba0c445b724fe100">More...</a><br /></td></tr>
<tr class="separator:a057e2908a65efbb3ba0c445b724fe100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c0d90a9095c8af1a09e6baa04710bc4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a4c0d90a9095c8af1a09e6baa04710bc4">Input</a> (const std::wstring &amp;<a class="el" href="classreflex_1_1_input.html#a0b1890722873d83bc651590c65fa87e3">wstring</a>)</td></tr>
<tr class="memdesc:a4c0d90a9095c8af1a09e6baa04710bc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct input character sequence from a std::wstring (may contain UTF-16 surrogate pairs).  <a href="#a4c0d90a9095c8af1a09e6baa04710bc4">More...</a><br /></td></tr>
<tr class="separator:a4c0d90a9095c8af1a09e6baa04710bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c30dabe3972582d662517d42cf75a4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a02c30dabe3972582d662517d42cf75a4">Input</a> (const std::wstring *<a class="el" href="classreflex_1_1_input.html#a0b1890722873d83bc651590c65fa87e3">wstring</a>)</td></tr>
<tr class="memdesc:a02c30dabe3972582d662517d42cf75a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct input character sequence from a pointer to a std::wstring (may contain UTF-16 surrogate pairs).  <a href="#a02c30dabe3972582d662517d42cf75a4">More...</a><br /></td></tr>
<tr class="separator:a02c30dabe3972582d662517d42cf75a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13135ec6cf70ed5d16396ad2db5b0c7b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a13135ec6cf70ed5d16396ad2db5b0c7b">Input</a> (FILE *<a class="el" href="classreflex_1_1_input.html#ad96de320b73063857a6d8b84f300eaba">file</a>)</td></tr>
<tr class="memdesc:a13135ec6cf70ed5d16396ad2db5b0c7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct input character sequence from an open FILE* file descriptor, supports UTF-8 conversion from UTF-16 and UTF-32, use stdin if file == NULL.  <a href="#a13135ec6cf70ed5d16396ad2db5b0c7b">More...</a><br /></td></tr>
<tr class="separator:a13135ec6cf70ed5d16396ad2db5b0c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a25a1b7ebdda31f175e0139713212f1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a2a25a1b7ebdda31f175e0139713212f1">Input</a> (std::istream &amp;<a class="el" href="classreflex_1_1_input.html#add3aa2ba7a605bf45c5bdc3661f7cb55">istream</a>)</td></tr>
<tr class="memdesc:a2a25a1b7ebdda31f175e0139713212f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct input character sequence from a std::istream.  <a href="#a2a25a1b7ebdda31f175e0139713212f1">More...</a><br /></td></tr>
<tr class="separator:a2a25a1b7ebdda31f175e0139713212f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a96b263a02333550b1d7d6cd21d776"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#af5a96b263a02333550b1d7d6cd21d776">Input</a> (std::istream *<a class="el" href="classreflex_1_1_input.html#add3aa2ba7a605bf45c5bdc3661f7cb55">istream</a>)</td></tr>
<tr class="memdesc:af5a96b263a02333550b1d7d6cd21d776"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct input character sequence from a pointer to a std::istream, use stdin if istream == NULL.  <a href="#af5a96b263a02333550b1d7d6cd21d776">More...</a><br /></td></tr>
<tr class="separator:af5a96b263a02333550b1d7d6cd21d776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b104b28d7b9be8f7c43c7e79ffabb5e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a0b104b28d7b9be8f7c43c7e79ffabb5e">operator const char *</a> ()</td></tr>
<tr class="memdesc:a0b104b28d7b9be8f7c43c7e79ffabb5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast this <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> object to string.  <a href="#a0b104b28d7b9be8f7c43c7e79ffabb5e">More...</a><br /></td></tr>
<tr class="separator:a0b104b28d7b9be8f7c43c7e79ffabb5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a032935b6b8f2a5f44036971bda9a1cbd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a032935b6b8f2a5f44036971bda9a1cbd">operator const wchar_t *</a> ()</td></tr>
<tr class="memdesc:a032935b6b8f2a5f44036971bda9a1cbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast this <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> object to wide character string.  <a href="#a032935b6b8f2a5f44036971bda9a1cbd">More...</a><br /></td></tr>
<tr class="separator:a032935b6b8f2a5f44036971bda9a1cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f2c1835f263ded23d2f262fbdf85c1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a28f2c1835f263ded23d2f262fbdf85c1">operator FILE *</a> ()</td></tr>
<tr class="memdesc:a28f2c1835f263ded23d2f262fbdf85c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast this <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> object to file descriptor FILE*.  <a href="#a28f2c1835f263ded23d2f262fbdf85c1">More...</a><br /></td></tr>
<tr class="separator:a28f2c1835f263ded23d2f262fbdf85c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d8c4d8c5105aa81138d3ea6a60c11d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a88d8c4d8c5105aa81138d3ea6a60c11d">operator std::istream *</a> ()</td></tr>
<tr class="memdesc:a88d8c4d8c5105aa81138d3ea6a60c11d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast this <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> object to std::istream*.  <a href="#a88d8c4d8c5105aa81138d3ea6a60c11d">More...</a><br /></td></tr>
<tr class="separator:a88d8c4d8c5105aa81138d3ea6a60c11d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1911f432346e847695e868386ab6acbd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a1911f432346e847695e868386ab6acbd">operator bool</a> ()</td></tr>
<tr class="separator:a1911f432346e847695e868386ab6acbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35426a06bf4b8928c8ee10b30de93c8b"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a35426a06bf4b8928c8ee10b30de93c8b">cstring</a> (void)</td></tr>
<tr class="memdesc:a35426a06bf4b8928c8ee10b30de93c8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the remaining string of this <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> object.  <a href="#a35426a06bf4b8928c8ee10b30de93c8b">More...</a><br /></td></tr>
<tr class="separator:a35426a06bf4b8928c8ee10b30de93c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b1890722873d83bc651590c65fa87e3"><td class="memItemLeft" align="right" valign="top">const wchar_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a0b1890722873d83bc651590c65fa87e3">wstring</a> (void)</td></tr>
<tr class="memdesc:a0b1890722873d83bc651590c65fa87e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the remaining wide character string of this <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> object.  <a href="#a0b1890722873d83bc651590c65fa87e3">More...</a><br /></td></tr>
<tr class="separator:a0b1890722873d83bc651590c65fa87e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad96de320b73063857a6d8b84f300eaba"><td class="memItemLeft" align="right" valign="top">FILE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#ad96de320b73063857a6d8b84f300eaba">file</a> (void)</td></tr>
<tr class="memdesc:ad96de320b73063857a6d8b84f300eaba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the FILE* of this <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> object.  <a href="#ad96de320b73063857a6d8b84f300eaba">More...</a><br /></td></tr>
<tr class="separator:ad96de320b73063857a6d8b84f300eaba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add3aa2ba7a605bf45c5bdc3661f7cb55"><td class="memItemLeft" align="right" valign="top">std::istream *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#add3aa2ba7a605bf45c5bdc3661f7cb55">istream</a> (void)</td></tr>
<tr class="memdesc:add3aa2ba7a605bf45c5bdc3661f7cb55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the std::istream of this <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> object.  <a href="#add3aa2ba7a605bf45c5bdc3661f7cb55">More...</a><br /></td></tr>
<tr class="separator:add3aa2ba7a605bf45c5bdc3661f7cb55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7adcaddc90acd4be7e521f5362d230d3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a7adcaddc90acd4be7e521f5362d230d3">size</a> (void)</td></tr>
<tr class="memdesc:a7adcaddc90acd4be7e521f5362d230d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the input character sequence in number of ASCII/UTF-8 bytes (zero if size is not determinable from a <code>FILE*</code> or <code>std::istream</code> source).  <a href="#a7adcaddc90acd4be7e521f5362d230d3">More...</a><br /></td></tr>
<tr class="separator:a7adcaddc90acd4be7e521f5362d230d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbed78324e9deccb7c22df0559602864"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#adbed78324e9deccb7c22df0559602864">good</a> (void)</td></tr>
<tr class="memdesc:adbed78324e9deccb7c22df0559602864"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if input is available.  <a href="#adbed78324e9deccb7c22df0559602864">More...</a><br /></td></tr>
<tr class="separator:adbed78324e9deccb7c22df0559602864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc9bc1fa36ca6f4df73d724aa4892ad3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#adc9bc1fa36ca6f4df73d724aa4892ad3">eof</a> (void)</td></tr>
<tr class="memdesc:adc9bc1fa36ca6f4df73d724aa4892ad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if input reached EOF.  <a href="#adc9bc1fa36ca6f4df73d724aa4892ad3">More...</a><br /></td></tr>
<tr class="separator:adc9bc1fa36ca6f4df73d724aa4892ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a3830a022486d78670f01003b56d5e5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a3a3830a022486d78670f01003b56d5e5">get</a> (char *s, size_t n)</td></tr>
<tr class="memdesc:a3a3830a022486d78670f01003b56d5e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy character sequence data into buffer.  <a href="#a3a3830a022486d78670f01003b56d5e5">More...</a><br /></td></tr>
<tr class="separator:a3a3830a022486d78670f01003b56d5e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac522bcd8f822f9191f890ba6543b5f71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#ac522bcd8f822f9191f890ba6543b5f71">file_encoding</a> (short enc)</td></tr>
<tr class="memdesc:ac522bcd8f822f9191f890ba6543b5f71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set encoding for <code>FILE*</code> input to <a class="el" href="structreflex_1_1_input_1_1_const.html#a2a327de7ecbe34c421ebcb5f09058c49" title="plain ASCII/UTF-8 file_encoding ">Const::plain</a>, <a class="el" href="structreflex_1_1_input_1_1_const.html#a9b6f173e4e331684ef3202bf4d50cd00" title="UTF-16 big endian file_encoding. ">Const::utf16be</a>, <a class="el" href="structreflex_1_1_input_1_1_const.html#a8d02b5c499209ed24ec80bece8d73c3b" title="UTF-16 little endian file_encoding. ">Const::utf16le</a>, <a class="el" href="structreflex_1_1_input_1_1_const.html#a7ef046acca7113d23ff77dbfa1ded607" title="UTF-32 big endian file_encoding. ">Const::utf32be</a>, or <a class="el" href="structreflex_1_1_input_1_1_const.html#aad4ebc8336540986901531df517c619a" title="UTF-32 little endian file_encoding. ">Const::utf32le</a>. File encodings are automatically detected by the presence of a UTF BOM in the file. This function may be used when a BOM is not present and file encoding is known or to override the BOM.  <a href="#ac522bcd8f822f9191f890ba6543b5f71">More...</a><br /></td></tr>
<tr class="separator:ac522bcd8f822f9191f890ba6543b5f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ea80c0af7f4a0442a49a5ec9a58f40f"><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a0ea80c0af7f4a0442a49a5ec9a58f40f">file_encoding</a> (void) const </td></tr>
<tr class="memdesc:a0ea80c0af7f4a0442a49a5ec9a58f40f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get encoding of the current <code>FILE*</code> input, <a class="el" href="structreflex_1_1_input_1_1_const.html#a2a327de7ecbe34c421ebcb5f09058c49" title="plain ASCII/UTF-8 file_encoding ">Const::plain</a>, <a class="el" href="structreflex_1_1_input_1_1_const.html#a9b6f173e4e331684ef3202bf4d50cd00" title="UTF-16 big endian file_encoding. ">Const::utf16be</a>, <a class="el" href="structreflex_1_1_input_1_1_const.html#a8d02b5c499209ed24ec80bece8d73c3b" title="UTF-16 little endian file_encoding. ">Const::utf16le</a>, <a class="el" href="structreflex_1_1_input_1_1_const.html#a7ef046acca7113d23ff77dbfa1ded607" title="UTF-32 big endian file_encoding. ">Const::utf32be</a>, or <a class="el" href="structreflex_1_1_input_1_1_const.html#aad4ebc8336540986901531df517c619a" title="UTF-32 little endian file_encoding. ">Const::utf32le</a>.  <a href="#a0ea80c0af7f4a0442a49a5ec9a58f40f">More...</a><br /></td></tr>
<tr class="separator:a0ea80c0af7f4a0442a49a5ec9a58f40f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a5349be78e278fc166fa74dfd726c7d4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a5349be78e278fc166fa74dfd726c7d4a">init</a> (void)</td></tr>
<tr class="memdesc:a5349be78e278fc166fa74dfd726c7d4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the state after (re)setting the input source, auto-detects UTF BOM in FILE* input if the file size is known.  <a href="#a5349be78e278fc166fa74dfd726c7d4a">More...</a><br /></td></tr>
<tr class="separator:a5349be78e278fc166fa74dfd726c7d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0681f7b13d04de6ab9ed8050529147b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a0681f7b13d04de6ab9ed8050529147b2">file_init</a> (void)</td></tr>
<tr class="memdesc:a0681f7b13d04de6ab9ed8050529147b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classreflex_1_1_input.html#a5349be78e278fc166fa74dfd726c7d4a" title="Initialize the state after (re)setting the input source, auto-detects UTF BOM in FILE* input if the f...">init()</a> on a FILE*.  <a href="#a0681f7b13d04de6ab9ed8050529147b2">More...</a><br /></td></tr>
<tr class="separator:a0681f7b13d04de6ab9ed8050529147b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37dd7c46da3413a52866bee4bb060cc5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a37dd7c46da3413a52866bee4bb060cc5">file_get</a> (char *s, size_t n)</td></tr>
<tr class="memdesc:a37dd7c46da3413a52866bee4bb060cc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classreflex_1_1_input.html#a3a3830a022486d78670f01003b56d5e5" title="Copy character sequence data into buffer. ">get()</a> on a FILE*.  <a href="#a37dd7c46da3413a52866bee4bb060cc5">More...</a><br /></td></tr>
<tr class="separator:a37dd7c46da3413a52866bee4bb060cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e52b0c33bcfd629d441867152e028c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a2e52b0c33bcfd629d441867152e028c6">file_size</a> (void)</td></tr>
<tr class="memdesc:a2e52b0c33bcfd629d441867152e028c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classreflex_1_1_input.html#a7adcaddc90acd4be7e521f5362d230d3" title="Get the size of the input character sequence in number of ASCII/UTF-8 bytes (zero if size is not dete...">size()</a> on a FILE*.  <a href="#a2e52b0c33bcfd629d441867152e028c6">More...</a><br /></td></tr>
<tr class="separator:a2e52b0c33bcfd629d441867152e028c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a888c01c45af9d069ab3a59e36dcd9c50"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a888c01c45af9d069ab3a59e36dcd9c50">file_good</a> (void)</td></tr>
<tr class="memdesc:a888c01c45af9d069ab3a59e36dcd9c50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classreflex_1_1_input.html#adbed78324e9deccb7c22df0559602864" title="Check if input is available. ">good()</a> operation on a FILE*.  <a href="#a888c01c45af9d069ab3a59e36dcd9c50">More...</a><br /></td></tr>
<tr class="separator:a888c01c45af9d069ab3a59e36dcd9c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3671ad8d99495f403d4f18f311712679"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a3671ad8d99495f403d4f18f311712679">file_eof</a> (void)</td></tr>
<tr class="memdesc:a3671ad8d99495f403d4f18f311712679"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classreflex_1_1_input.html#adc9bc1fa36ca6f4df73d724aa4892ad3" title="Check if input reached EOF. ">eof()</a> on a FILE*.  <a href="#a3671ad8d99495f403d4f18f311712679">More...</a><br /></td></tr>
<tr class="separator:a3671ad8d99495f403d4f18f311712679"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ac621d556b409c90464780ea44b8d6570"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#ac621d556b409c90464780ea44b8d6570">cstring_</a></td></tr>
<tr class="memdesc:ac621d556b409c90464780ea44b8d6570"><td class="mdescLeft">&#160;</td><td class="mdescRight">NUL-terminated char string input (when non-null)  <a href="#ac621d556b409c90464780ea44b8d6570">More...</a><br /></td></tr>
<tr class="separator:ac621d556b409c90464780ea44b8d6570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6107c7aabf9c28a777c3942442c3b22f"><td class="memItemLeft" align="right" valign="top">const wchar_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a6107c7aabf9c28a777c3942442c3b22f">wstring_</a></td></tr>
<tr class="memdesc:a6107c7aabf9c28a777c3942442c3b22f"><td class="mdescLeft">&#160;</td><td class="mdescRight">NUL-terminated wide string input (when non-null)  <a href="#a6107c7aabf9c28a777c3942442c3b22f">More...</a><br /></td></tr>
<tr class="separator:a6107c7aabf9c28a777c3942442c3b22f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9eac97d0e608b436ab2c10620e68fb5"><td class="memItemLeft" align="right" valign="top">FILE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#ae9eac97d0e608b436ab2c10620e68fb5">file_</a></td></tr>
<tr class="memdesc:ae9eac97d0e608b436ab2c10620e68fb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">FILE* input (when non-null)  <a href="#ae9eac97d0e608b436ab2c10620e68fb5">More...</a><br /></td></tr>
<tr class="separator:ae9eac97d0e608b436ab2c10620e68fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5293a8f00869af77ce8036312d78591c"><td class="memItemLeft" align="right" valign="top">std::istream *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a5293a8f00869af77ce8036312d78591c">istream_</a></td></tr>
<tr class="memdesc:a5293a8f00869af77ce8036312d78591c"><td class="mdescLeft">&#160;</td><td class="mdescRight">stream input (when non-null)  <a href="#a5293a8f00869af77ce8036312d78591c">More...</a><br /></td></tr>
<tr class="separator:a5293a8f00869af77ce8036312d78591c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca4ea90ef6f28c106a6811ff21bcc2b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a4ca4ea90ef6f28c106a6811ff21bcc2b">size_</a></td></tr>
<tr class="memdesc:a4ca4ea90ef6f28c106a6811ff21bcc2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">size of the input in bytes, when known  <a href="#a4ca4ea90ef6f28c106a6811ff21bcc2b">More...</a><br /></td></tr>
<tr class="separator:a4ca4ea90ef6f28c106a6811ff21bcc2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb61be8907f3204e7b3583aaa5b72da"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a2fb61be8907f3204e7b3583aaa5b72da">utf8_</a> [8]</td></tr>
<tr class="memdesc:a2fb61be8907f3204e7b3583aaa5b72da"><td class="mdescLeft">&#160;</td><td class="mdescRight">UTF-8 conversion buffer.  <a href="#a2fb61be8907f3204e7b3583aaa5b72da">More...</a><br /></td></tr>
<tr class="separator:a2fb61be8907f3204e7b3583aaa5b72da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a371264ce1908a198cc11a7d6990ccbcc"><td class="memItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a371264ce1908a198cc11a7d6990ccbcc">uidx_</a></td></tr>
<tr class="memdesc:a371264ce1908a198cc11a7d6990ccbcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">index in utf8_[] or &gt;= 8 when unused  <a href="#a371264ce1908a198cc11a7d6990ccbcc">More...</a><br /></td></tr>
<tr class="separator:a371264ce1908a198cc11a7d6990ccbcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e560a30d77f8c4bf277e60998e3c7db"><td class="memItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreflex_1_1_input.html#a2e560a30d77f8c4bf277e60998e3c7db">utfx_</a></td></tr>
<tr class="memdesc:a2e560a30d77f8c4bf277e60998e3c7db"><td class="mdescLeft">&#160;</td><td class="mdescRight">0 = ASCII/UTF-8, 1 = UTF-16 BE, 2 = UTF-16 LE, 3 = UTF-32 BE, 4 = UTF-32 LE  <a href="#a2e560a30d77f8c4bf277e60998e3c7db">More...</a><br /></td></tr>
<tr class="separator:a2e560a30d77f8c4bf277e60998e3c7db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> character sequence class for unified access to sources of input text. </p>
<h2>Description </h2>
<p>The <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> class unifies access to a source of input text that constitutes a sequence of characters:</p>
<ul>
<li>An <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> object is instantiated and (re)assigned a (new) source input: either a <code>char*</code> string, a <code>wchar_t*</code> wide string, a <code>std::string</code>, a <code>std::wstring</code>, a <code>FILE*</code> descriptor, or a <code>std::istream</code> object.</li>
<li>When assigned a wide string source as input, the wide character content is automatically converted to an UTF-8 character sequence when reading with <a class="el" href="classreflex_1_1_input.html#a3a3830a022486d78670f01003b56d5e5" title="Copy character sequence data into buffer. ">get()</a>. Wide strings are UCS-2/UCS-4 and may contain UTF-16 surrogate pairs.</li>
<li>When assigned a <code>FILE*</code> source as input, the file is checked for the presence of a UTF-8 or a UTF-16 BOM (Byte Order Mark). A UTF-8 BOM is ignored and will not appear on the input character stream (and size is adjusted by 3 bytes). A UTF-16 BOM is intepreted, resulting in the conversion of the file content automatically to an UTF-8 character sequence when reading the file with <a class="el" href="classreflex_1_1_input.html#a3a3830a022486d78670f01003b56d5e5" title="Copy character sequence data into buffer. ">get()</a>. Also, <a class="el" href="classreflex_1_1_input.html#a7adcaddc90acd4be7e521f5362d230d3" title="Get the size of the input character sequence in number of ASCII/UTF-8 bytes (zero if size is not dete...">size()</a> gives the content size in the number of UTF-8 bytes.</li>
<li>An input object can be reassigned a new source of input for reading at any time.</li>
<li>An input object obeys move semantics. That is, after assigning an input object to another, the former can no longer be used to read input. This prevents adding the overhead and complexity of file and stream duplication.</li>
<li><code>size_t <a class="el" href="classreflex_1_1_input.html#a3a3830a022486d78670f01003b56d5e5" title="Copy character sequence data into buffer. ">Input::get(char *buf, size_t len)</a>;</code> reads source input and fills <code>buf</code> with up to <code>len</code> bytes, returning the number of bytes read or zero when a stream or file is bad or when EOF is reached.</li>
<li><code>size_t <a class="el" href="classreflex_1_1_input.html#a7adcaddc90acd4be7e521f5362d230d3" title="Get the size of the input character sequence in number of ASCII/UTF-8 bytes (zero if size is not dete...">Input::size(void)</a>;</code> returns the number of ASCII/UTF-8 bytes available to read from the source input or zero (zero is also returned when the size is not determinable). Use this function only before reading input with <a class="el" href="classreflex_1_1_input.html#a3a3830a022486d78670f01003b56d5e5" title="Copy character sequence data into buffer. ">get()</a>. Wide character strings and UTF-16 <code>FILE*</code> content is counted as the total number of UTF-8 bytes that will be produced by <a class="el" href="classreflex_1_1_input.html#a3a3830a022486d78670f01003b56d5e5" title="Copy character sequence data into buffer. ">get()</a>. The size of a <code>std::istream</code> cannot be determined.</li>
<li><code>bool <a class="el" href="classreflex_1_1_input.html#adbed78324e9deccb7c22df0559602864" title="Check if input is available. ">Input::good(void)</a>;</code> returns true if the input is readable and has no EOF or error state. Returns false on EOF or if an error condition is present.</li>
<li><code>bool <a class="el" href="classreflex_1_1_input.html#adc9bc1fa36ca6f4df73d724aa4892ad3" title="Check if input reached EOF. ">Input::eof(void)</a>;</code> returns true if the input reached EOF. Note that <a class="el" href="classreflex_1_1_input.html#adbed78324e9deccb7c22df0559602864" title="Check if input is available. ">good()</a> == ! <a class="el" href="classreflex_1_1_input.html#adc9bc1fa36ca6f4df73d724aa4892ad3" title="Check if input reached EOF. ">eof()</a> for string source input only, since files and streams may have error conditions that prevent reading. That is, for files and streams <a class="el" href="classreflex_1_1_input.html#adc9bc1fa36ca6f4df73d724aa4892ad3" title="Check if input reached EOF. ">eof()</a> implies <a class="el" href="classreflex_1_1_input.html#adbed78324e9deccb7c22df0559602864" title="Check if input is available. ">good()</a> == false, but not vice versa. Thus, an error is diagnosed when the condition <a class="el" href="classreflex_1_1_input.html#adbed78324e9deccb7c22df0559602864" title="Check if input is available. ">good()</a> == false &amp;&amp; <a class="el" href="classreflex_1_1_input.html#adc9bc1fa36ca6f4df73d724aa4892ad3" title="Check if input reached EOF. ">eof()</a> == false holds. Note that get(buf, len) == 0 &amp;&amp; len &gt; 0 implies <a class="el" href="classreflex_1_1_input.html#adbed78324e9deccb7c22df0559602864" title="Check if input is available. ">good()</a> == false.</li>
<li>Compile with <code>WITH_UTF8_UNRESTRICTED</code> to enable unrestricted UTF-8 beyond U+10FFFF, permitting lossless UTF-8 encoding of 32 bit words without limits.</li>
</ul>
<h2>Example </h2>
<p>The following example shows how to use the <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> class to read a character sequence in blocks from a <code>std::ifstream</code> to copy to stdout:</p>
<div class="fragment"><div class="line">std::ifstream ifs;</div><div class="line">ifs.open(<span class="stringliteral">&quot;input.h&quot;</span>, std::ifstream::in);</div><div class="line"><a class="code" href="classreflex_1_1_input.html">reflex::Input</a> input(ifs);</div><div class="line"><span class="keywordtype">char</span> buf[1024];</div><div class="line"><span class="keywordtype">size_t</span> len;</div><div class="line"><span class="keywordflow">while</span> ((len = input.get(buf, <span class="keyword">sizeof</span>(buf))) &gt; 0)</div><div class="line">  fwrite(buf, 1, len, stdout);</div><div class="line"><span class="keywordflow">if</span> (!input.eof())</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">&quot;An IO error occurred&quot;</span> &lt;&lt; std::endl;</div><div class="line">ifs.close();</div></div><!-- fragment --><h2>Example </h2>
<p>The following example shows how to use the <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> class to store the entire content of a file in a temporary buffer:</p>
<div class="fragment"><div class="line"><a class="code" href="classreflex_1_1_input.html">reflex::Input</a> input(fopen(<span class="stringliteral">&quot;input.h&quot;</span>, <span class="stringliteral">&quot;r&quot;</span>));</div><div class="line"><span class="keywordflow">if</span> (!input.file())</div><div class="line">  abort();</div><div class="line"><span class="keywordtype">size_t</span> len = input.size(); <span class="comment">// file size (minus any leading UTF BOM)</span></div><div class="line"><span class="keywordtype">char</span> *buf = <span class="keyword">new</span> <span class="keywordtype">char</span>[len];</div><div class="line">input.get(buf, len);</div><div class="line"><span class="keywordflow">if</span> (!input.eof())</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">&quot;An IO error occurred&quot;</span> &lt;&lt; std::endl;</div><div class="line">fwrite(buf, 1, len, stdout);</div><div class="line"><span class="keyword">delete</span>[] buf;</div><div class="line">fclose(input.file());</div></div><!-- fragment --><p>In the above, files with UTF-16 and UTF-32 content are converted to UTF-8 by <code>get(buf, len)</code>. Also, <code><a class="el" href="classreflex_1_1_input.html#a7adcaddc90acd4be7e521f5362d230d3" title="Get the size of the input character sequence in number of ASCII/UTF-8 bytes (zero if size is not dete...">size()</a></code> returns the total number of UTF-8 bytes to copy in the buffer by <code>get(buf, len)</code>. The size is computed depending on the UTF-8/16/32 file content encoding, i.e. given a leading UTF BOM in the file. This means that UTF-16/32 files are read twice, first internally with <code><a class="el" href="classreflex_1_1_input.html#a7adcaddc90acd4be7e521f5362d230d3" title="Get the size of the input character sequence in number of ASCII/UTF-8 bytes (zero if size is not dete...">size()</a></code> and then again with get(buf, len)`.</p>
<h2>Example </h2>
<p>The following example shows how to use the <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> class to read a character sequence in blocks from a file:</p>
<div class="fragment"><div class="line"><a class="code" href="classreflex_1_1_input.html">reflex::Input</a> input(fopen(<span class="stringliteral">&quot;input.h&quot;</span>, <span class="stringliteral">&quot;r&quot;</span>));</div><div class="line"><span class="keywordtype">char</span> buf[1024];</div><div class="line"><span class="keywordtype">size_t</span> len;</div><div class="line"><span class="keywordflow">while</span> ((len = input.get(buf, <span class="keyword">sizeof</span>(buf))) &gt; 0)</div><div class="line">  fwrite(buf, 1, len, stdout);</div><div class="line">fclose(input);</div></div><!-- fragment --><h2>Example </h2>
<p>The following example shows how to use the <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> class to echo characters one by one from stdin, e.g. reading input from a tty:</p>
<div class="fragment"><div class="line"><a class="code" href="classreflex_1_1_input.html">reflex::Input</a> input(stdin);</div><div class="line"><span class="keywordtype">char</span> c;</div><div class="line"><span class="keywordflow">while</span> (input.get(&amp;c, 1))</div><div class="line">  fputc(c, stdout);</div></div><!-- fragment --><h2>Example </h2>
<p>The following example shows how to use the <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> class to read a character sequence in blocks from a wide character string, converting it to UTF-8 to copy to stdout:</p>
<div class="fragment"><div class="line"><a class="code" href="classreflex_1_1_input.html">reflex::Input</a> input(L<span class="stringliteral">&quot;Copyright ©&quot;</span>); <span class="comment">// © is unicode U+00A9 and UTF-8 C2 A9</span></div><div class="line"><span class="keywordtype">char</span> buf[8];</div><div class="line"><span class="keywordtype">size_t</span> len;</div><div class="line"><span class="keywordflow">while</span> ((len = input.get(buf, <span class="keyword">sizeof</span>(buf))) &gt; 0)</div><div class="line">  fwrite(buf, 1, len, stdout);</div></div><!-- fragment --><h2>Example </h2>
<p>The following example shows how to use the <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> class to convert a wide character string to UTF-8:</p>
<div class="fragment"><div class="line"><a class="code" href="classreflex_1_1_input.html">reflex::Input</a> input(L<span class="stringliteral">&quot;Copyright ©&quot;</span>); <span class="comment">// © is unicode U+00A9 and UTF-8 C2 A9</span></div><div class="line"><span class="keywordtype">size_t</span> len = input.size(); <span class="comment">// size of UTF-8 string</span></div><div class="line"><span class="keywordtype">char</span> *buf = <span class="keyword">new</span> <span class="keywordtype">char</span>[len + 1];</div><div class="line">input.get(buf, len);</div><div class="line">buf[len] = <span class="charliteral">&#39;\0&#39;</span>; <span class="comment">// make \0-terminated</span></div></div><!-- fragment --><h2>Example </h2>
<p>The following example shows how to switch source inputs while reading input byte by byte (use a buffer as shown in other examples to improve efficiency):</p>
<div class="fragment"><div class="line"><a class="code" href="classreflex_1_1_input.html">reflex::Input</a> input = <span class="stringliteral">&quot;Hello&quot;</span>;</div><div class="line">std::string message;</div><div class="line"><span class="keywordtype">char</span> c;</div><div class="line"><span class="keywordflow">while</span> (input.<a class="code" href="classreflex_1_1_input.html#a3a3830a022486d78670f01003b56d5e5">get</a>(&amp;c, 1))</div><div class="line">  message.append(c);</div><div class="line">input = L<span class="stringliteral">&quot; world! To ∞ and beyond.&quot;</span>; <span class="comment">// switch input to a wide string</span></div><div class="line"><span class="keywordflow">while</span> (input.<a class="code" href="classreflex_1_1_input.html#a3a3830a022486d78670f01003b56d5e5">get</a>(&amp;c, 1))</div><div class="line">  message.append(c);</div></div><!-- fragment --> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a7c6455e576c90b478789928db6066267"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::Input::Input </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreflex_1_1_input.html">Input</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor (with intended "move semantics" as internal state is shared, should not rely on using the rhs after copying). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>an <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> object to share state with (undefined behavior results from using both objects at the same time) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaa61821e129865a4f58086529486815d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::Input::Input </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct empty input character sequence. </p>

</div>
</div>
<a class="anchor" id="a09465211ad37559885e2e85e9fc18791"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::Input::Input </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cstring</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct input character sequence from a NUL-terminated string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cstring</td><td>NUL-terminated char* string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aec4d78f4c05c7e5ffdaa723bf58ffaea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::Input::Input </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct input character sequence from a std::string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>input string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa309946c0340260b7213ff803544542b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::Input::Input </td>
          <td>(</td>
          <td class="paramtype">const std::string *&#160;</td>
          <td class="paramname"><em>string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct input character sequence from a pointer to a std::string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>input string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a057e2908a65efbb3ba0c445b724fe100"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::Input::Input </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>wstring</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct input character sequence from a NUL-terminated wide character string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wstring</td><td>NUL-terminated wchar_t* input string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4c0d90a9095c8af1a09e6baa04710bc4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::Input::Input </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>wstring</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct input character sequence from a std::wstring (may contain UTF-16 surrogate pairs). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wstring</td><td>input wide string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a02c30dabe3972582d662517d42cf75a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::Input::Input </td>
          <td>(</td>
          <td class="paramtype">const std::wstring *&#160;</td>
          <td class="paramname"><em>wstring</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct input character sequence from a pointer to a std::wstring (may contain UTF-16 surrogate pairs). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wstring</td><td>input wide string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a13135ec6cf70ed5d16396ad2db5b0c7b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::Input::Input </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct input character sequence from an open FILE* file descriptor, supports UTF-8 conversion from UTF-16 and UTF-32, use stdin if file == NULL. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>input file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2a25a1b7ebdda31f175e0139713212f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::Input::Input </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>istream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct input character sequence from a std::istream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">istream</td><td>input stream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af5a96b263a02333550b1d7d6cd21d776"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::Input::Input </td>
          <td>(</td>
          <td class="paramtype">std::istream *&#160;</td>
          <td class="paramname"><em>istream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct input character sequence from a pointer to a std::istream, use stdin if istream == NULL. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">istream</td><td>input stream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a35426a06bf4b8928c8ee10b30de93c8b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* reflex::Input::cstring </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the remaining string of this <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> object. </p>
<dl class="section return"><dt>Returns</dt><dd>remaining unbuffered part of the NUL-terminated string or NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="adc9bc1fa36ca6f4df73d724aa4892ad3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::Input::eof </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if input reached EOF. </p>
<dl class="section return"><dt>Returns</dt><dd>true if input is at EOF and no characters are available. </dd></dl>

</div>
</div>
<a class="anchor" id="ad96de320b73063857a6d8b84f300eaba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FILE* reflex::Input::file </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the FILE* of this <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> object. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to current file descriptor or NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="ac522bcd8f822f9191f890ba6543b5f71"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::Input::file_encoding </td>
          <td>(</td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>enc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set encoding for <code>FILE*</code> input to <a class="el" href="structreflex_1_1_input_1_1_const.html#a2a327de7ecbe34c421ebcb5f09058c49" title="plain ASCII/UTF-8 file_encoding ">Const::plain</a>, <a class="el" href="structreflex_1_1_input_1_1_const.html#a9b6f173e4e331684ef3202bf4d50cd00" title="UTF-16 big endian file_encoding. ">Const::utf16be</a>, <a class="el" href="structreflex_1_1_input_1_1_const.html#a8d02b5c499209ed24ec80bece8d73c3b" title="UTF-16 little endian file_encoding. ">Const::utf16le</a>, <a class="el" href="structreflex_1_1_input_1_1_const.html#a7ef046acca7113d23ff77dbfa1ded607" title="UTF-32 big endian file_encoding. ">Const::utf32be</a>, or <a class="el" href="structreflex_1_1_input_1_1_const.html#aad4ebc8336540986901531df517c619a" title="UTF-32 little endian file_encoding. ">Const::utf32le</a>. File encodings are automatically detected by the presence of a UTF BOM in the file. This function may be used when a BOM is not present and file encoding is known or to override the BOM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enc</td><td><a class="el" href="structreflex_1_1_input_1_1_const.html#a2a327de7ecbe34c421ebcb5f09058c49" title="plain ASCII/UTF-8 file_encoding ">Const::plain</a>, <a class="el" href="structreflex_1_1_input_1_1_const.html#a9b6f173e4e331684ef3202bf4d50cd00" title="UTF-16 big endian file_encoding. ">Const::utf16be</a>, <a class="el" href="structreflex_1_1_input_1_1_const.html#a8d02b5c499209ed24ec80bece8d73c3b" title="UTF-16 little endian file_encoding. ">Const::utf16le</a>, <a class="el" href="structreflex_1_1_input_1_1_const.html#a7ef046acca7113d23ff77dbfa1ded607" title="UTF-32 big endian file_encoding. ">Const::utf32be</a>, or <a class="el" href="structreflex_1_1_input_1_1_const.html#aad4ebc8336540986901531df517c619a" title="UTF-32 little endian file_encoding. ">Const::utf32le</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0ea80c0af7f4a0442a49a5ec9a58f40f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">short reflex::Input::file_encoding </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get encoding of the current <code>FILE*</code> input, <a class="el" href="structreflex_1_1_input_1_1_const.html#a2a327de7ecbe34c421ebcb5f09058c49" title="plain ASCII/UTF-8 file_encoding ">Const::plain</a>, <a class="el" href="structreflex_1_1_input_1_1_const.html#a9b6f173e4e331684ef3202bf4d50cd00" title="UTF-16 big endian file_encoding. ">Const::utf16be</a>, <a class="el" href="structreflex_1_1_input_1_1_const.html#a8d02b5c499209ed24ec80bece8d73c3b" title="UTF-16 little endian file_encoding. ">Const::utf16le</a>, <a class="el" href="structreflex_1_1_input_1_1_const.html#a7ef046acca7113d23ff77dbfa1ded607" title="UTF-32 big endian file_encoding. ">Const::utf32be</a>, or <a class="el" href="structreflex_1_1_input_1_1_const.html#aad4ebc8336540986901531df517c619a" title="UTF-32 little endian file_encoding. ">Const::utf32le</a>. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structreflex_1_1_input_1_1_const.html#a2a327de7ecbe34c421ebcb5f09058c49" title="plain ASCII/UTF-8 file_encoding ">Const::plain</a>, <a class="el" href="structreflex_1_1_input_1_1_const.html#a9b6f173e4e331684ef3202bf4d50cd00" title="UTF-16 big endian file_encoding. ">Const::utf16be</a>, <a class="el" href="structreflex_1_1_input_1_1_const.html#a8d02b5c499209ed24ec80bece8d73c3b" title="UTF-16 little endian file_encoding. ">Const::utf16le</a>, <a class="el" href="structreflex_1_1_input_1_1_const.html#a7ef046acca7113d23ff77dbfa1ded607" title="UTF-32 big endian file_encoding. ">Const::utf32be</a>, or <a class="el" href="structreflex_1_1_input_1_1_const.html#aad4ebc8336540986901531df517c619a" title="UTF-32 little endian file_encoding. ">Const::utf32le</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a3671ad8d99495f403d4f18f311712679"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::Input::file_eof </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classreflex_1_1_input.html#adc9bc1fa36ca6f4df73d724aa4892ad3" title="Check if input reached EOF. ">eof()</a> on a FILE*. </p>

</div>
</div>
<a class="anchor" id="a37dd7c46da3413a52866bee4bb060cc5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t reflex::Input::file_get </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classreflex_1_1_input.html#a3a3830a022486d78670f01003b56d5e5" title="Copy character sequence data into buffer. ">get()</a> on a FILE*. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>points to the string buffer to fill with input </td></tr>
    <tr><td class="paramname">n</td><td>size of buffer pointed to by s </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a888c01c45af9d069ab3a59e36dcd9c50"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::Input::file_good </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classreflex_1_1_input.html#adbed78324e9deccb7c22df0559602864" title="Check if input is available. ">good()</a> operation on a FILE*. </p>

</div>
</div>
<a class="anchor" id="a0681f7b13d04de6ab9ed8050529147b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::Input::file_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classreflex_1_1_input.html#a5349be78e278fc166fa74dfd726c7d4a" title="Initialize the state after (re)setting the input source, auto-detects UTF BOM in FILE* input if the f...">init()</a> on a FILE*. </p>

</div>
</div>
<a class="anchor" id="a2e52b0c33bcfd629d441867152e028c6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::Input::file_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classreflex_1_1_input.html#a7adcaddc90acd4be7e521f5362d230d3" title="Get the size of the input character sequence in number of ASCII/UTF-8 bytes (zero if size is not dete...">size()</a> on a FILE*. </p>

</div>
</div>
<a class="anchor" id="a3a3830a022486d78670f01003b56d5e5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t reflex::Input::get </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy character sequence data into buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>the nonzero number of (less or equal to n) 8-bit characters added to buffer s from the current input, or zero when EOF. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>points to the string buffer to fill with input </td></tr>
    <tr><td class="paramname">n</td><td>size of buffer pointed to by s </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adbed78324e9deccb7c22df0559602864"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reflex::Input::good </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if input is available. </p>
<dl class="section return"><dt>Returns</dt><dd>true if a non-empty sequence of characters is available to get. </dd></dl>

</div>
</div>
<a class="anchor" id="a5349be78e278fc166fa74dfd726c7d4a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reflex::Input::init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the state after (re)setting the input source, auto-detects UTF BOM in FILE* input if the file size is known. </p>

</div>
</div>
<a class="anchor" id="add3aa2ba7a605bf45c5bdc3661f7cb55"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream* reflex::Input::istream </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the std::istream of this <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> object. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to current std::istream or NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="a1911f432346e847695e868386ab6acbd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::Input::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if a non-empty sequence of characters is available to get. </dd></dl>

</div>
</div>
<a class="anchor" id="a0b104b28d7b9be8f7c43c7e79ffabb5e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::Input::operator const char * </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast this <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> object to string. </p>
<dl class="section return"><dt>Returns</dt><dd>remaining unbuffered part of the NUL-terminated string or NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="a032935b6b8f2a5f44036971bda9a1cbd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::Input::operator const wchar_t * </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast this <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> object to wide character string. </p>
<dl class="section return"><dt>Returns</dt><dd>remaining unbuffered part of the NUL-terminated wide character string or NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="a28f2c1835f263ded23d2f262fbdf85c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::Input::operator FILE * </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast this <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> object to file descriptor FILE*. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to current file descriptor or NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="a88d8c4d8c5105aa81138d3ea6a60c11d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reflex::Input::operator std::istream * </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast this <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> object to std::istream*. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to current std::istream or NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="a7adcaddc90acd4be7e521f5362d230d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t reflex::Input::size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of the input character sequence in number of ASCII/UTF-8 bytes (zero if size is not determinable from a <code>FILE*</code> or <code>std::istream</code> source). </p>
<dl class="section return"><dt>Returns</dt><dd>the nonzero number of ASCII/UTF-8 bytes available to read, or zero when source is empty or if size is not determinable. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function SHOULD NOT be used after <a class="el" href="classreflex_1_1_input.html#a3a3830a022486d78670f01003b56d5e5" title="Copy character sequence data into buffer. ">get()</a> as the "cursor" has moved it changes the result. </dd></dl>

</div>
</div>
<a class="anchor" id="a0b1890722873d83bc651590c65fa87e3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const wchar_t* reflex::Input::wstring </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the remaining wide character string of this <a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">Input</a> object. </p>
<dl class="section return"><dt>Returns</dt><dd>remaining unbuffered part of the NUL-terminated wide character string or NULL. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="ac621d556b409c90464780ea44b8d6570"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* reflex::Input::cstring_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>NUL-terminated char string input (when non-null) </p>

</div>
</div>
<a class="anchor" id="ae9eac97d0e608b436ab2c10620e68fb5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FILE* reflex::Input::file_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>FILE* input (when non-null) </p>

</div>
</div>
<a class="anchor" id="a5293a8f00869af77ce8036312d78591c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream* reflex::Input::istream_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>stream input (when non-null) </p>

</div>
</div>
<a class="anchor" id="a4ca4ea90ef6f28c106a6811ff21bcc2b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t reflex::Input::size_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>size of the input in bytes, when known </p>

</div>
</div>
<a class="anchor" id="a371264ce1908a198cc11a7d6990ccbcc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short reflex::Input::uidx_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>index in utf8_[] or &gt;= 8 when unused </p>

</div>
</div>
<a class="anchor" id="a2fb61be8907f3204e7b3583aaa5b72da"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char reflex::Input::utf8_[8]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>UTF-8 conversion buffer. </p>

</div>
</div>
<a class="anchor" id="a2e560a30d77f8c4bf277e60998e3c7db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short reflex::Input::utfx_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>0 = ASCII/UTF-8, 1 = UTF-16 BE, 2 = UTF-16 LE, 3 = UTF-32 BE, 4 = UTF-32 LE </p>

</div>
</div>
<a class="anchor" id="a6107c7aabf9c28a777c3942442c3b22f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const wchar_t* reflex::Input::wstring_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>NUL-terminated wide string input (when non-null) </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="input_8h.html">input.h</a></li>
</ul>
</div><!-- contents -->
<hr class="footer">
<address class="footer"><small>
Converted on Sat Mar 4 2017 16:15:33 by <a target="_blank" href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.11</small></address>
<br>
<div style="height: 246px; background: #DBDBDB;">
</body>
</html>
